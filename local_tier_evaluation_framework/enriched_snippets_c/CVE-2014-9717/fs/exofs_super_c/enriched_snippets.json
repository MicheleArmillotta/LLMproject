[
  {
    "function_name": "exit_exofs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "1037-1042",
    "snippet": "static void __exit exit_exofs(void)\n{\n\texofs_sysfs_uninit();\n\tunregister_filesystem(&exofs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type exofs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"exofs\",\n\t.mount          = exofs_mount,\n\t.kill_sb        = generic_shutdown_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "207-215",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(exofs_inode_cachep);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *exofs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *exofs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(exofs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&exofs_type"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_sysfs_uninit",
          "args": [],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_sysfs_uninit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/sys.c",
          "lines": "202-205",
          "snippet": "void exofs_sysfs_uninit(void)\n{\n\tkset_unregister(exofs_kset);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/device.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *exofs_kset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/device.h>\n#include <linux/kobject.h>\n\nstatic struct kset *exofs_kset;\n\nvoid exofs_sysfs_uninit(void)\n{\n\tkset_unregister(exofs_kset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct file_system_type exofs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"exofs\",\n\t.mount          = exofs_mount,\n\t.kill_sb        = generic_shutdown_super,\n};\n\nstatic void __exit exit_exofs(void)\n{\n\texofs_sysfs_uninit();\n\tunregister_filesystem(&exofs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_exofs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "1015-1035",
    "snippet": "static int __init init_exofs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out;\n\n\terr = register_filesystem(&exofs_type);\n\tif (err)\n\t\tgoto out_d;\n\n\t/* We don't fail if sysfs creation failed */\n\texofs_sysfs_init();\n\n\treturn 0;\nout_d:\n\tdestroy_inodecache();\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type exofs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"exofs\",\n\t.mount          = exofs_mount,\n\t.kill_sb        = generic_shutdown_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "207-215",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(exofs_inode_cachep);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *exofs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *exofs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(exofs_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_sysfs_init",
          "args": [],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/sys.c",
          "lines": "192-200",
          "snippet": "int exofs_sysfs_init(void)\n{\n\texofs_kset = kset_create_and_add(\"exofs\", NULL, fs_kobj);\n\tif (!exofs_kset) {\n\t\tEXOFS_ERR(\"ERROR: kset_create_and_add exofs failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/device.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *exofs_kset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/device.h>\n#include <linux/kobject.h>\n\nstatic struct kset *exofs_kset;\n\nint exofs_sysfs_init(void)\n{\n\texofs_kset = kset_create_and_add(\"exofs\", NULL, fs_kobj);\n\tif (!exofs_kset) {\n\t\tEXOFS_ERR(\"ERROR: kset_create_and_add exofs failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&exofs_type"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "193-202",
          "snippet": "static int init_inodecache(void)\n{\n\texofs_inode_cachep = kmem_cache_create(\"exofs_inode_cache\",\n\t\t\t\tsizeof(struct exofs_i_info), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\texofs_init_once);\n\tif (exofs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *exofs_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *exofs_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\texofs_inode_cachep = kmem_cache_create(\"exofs_inode_cache\",\n\t\t\t\tsizeof(struct exofs_i_info), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\texofs_init_once);\n\tif (exofs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct file_system_type exofs_type = {\n\t.owner          = THIS_MODULE,\n\t.name           = \"exofs\",\n\t.mount          = exofs_mount,\n\t.kill_sb        = generic_shutdown_super,\n};\n\nstatic int __init init_exofs(void)\n{\n\tint err;\n\n\terr = init_inodecache();\n\tif (err)\n\t\tgoto out;\n\n\terr = register_filesystem(&exofs_type);\n\tif (err)\n\t\tgoto out_d;\n\n\t/* We don't fail if sysfs creation failed */\n\texofs_sysfs_init();\n\n\treturn 0;\nout_d:\n\tdestroy_inodecache();\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "exofs_fh_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "987-992",
    "snippet": "static struct dentry *exofs_fh_to_parent(struct super_block *sb,\n\t\t\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    exofs_nfs_get_inode);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_parent",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "exofs_nfs_get_inode"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "906-923",
          "snippet": "struct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_parent(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len <= 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.parent_ino,\n\t\t\t\t  (fh_len > 3 ? fid->i32.parent_gen : 0));\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct dentry *exofs_fh_to_parent(struct super_block *sb,\n\t\t\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\treturn generic_fh_to_parent(sb, fid, fh_len, fh_type,\n\t\t\t\t    exofs_nfs_get_inode);\n}"
  },
  {
    "function_name": "exofs_fh_to_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "980-985",
    "snippet": "static struct dentry *exofs_fh_to_dentry(struct super_block *sb,\n\t\t\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    exofs_nfs_get_inode);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_fh_to_dentry",
          "args": [
            "sb",
            "fid",
            "fh_len",
            "fh_type",
            "exofs_nfs_get_inode"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fh_to_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "873-890",
          "snippet": "struct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstruct dentry *generic_fh_to_dentry(struct super_block *sb, struct fid *fid,\n\t\tint fh_len, int fh_type, struct inode *(*get_inode)\n\t\t\t(struct super_block *sb, u64 ino, u32 gen))\n{\n\tstruct inode *inode = NULL;\n\n\tif (fh_len < 2)\n\t\treturn NULL;\n\n\tswitch (fh_type) {\n\tcase FILEID_INO32_GEN:\n\tcase FILEID_INO32_GEN_PARENT:\n\t\tinode = get_inode(sb, fid->i32.ino, fid->i32.gen);\n\t\tbreak;\n\t}\n\n\treturn d_obtain_alias(inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct dentry *exofs_fh_to_dentry(struct super_block *sb,\n\t\t\t\tstruct fid *fid, int fh_len, int fh_type)\n{\n\treturn generic_fh_to_dentry(sb, fid, fh_len, fh_type,\n\t\t\t\t    exofs_nfs_get_inode);\n}"
  },
  {
    "function_name": "exofs_nfs_get_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "964-978",
    "snippet": "static struct inode *exofs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tinode = exofs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\t/* we didn't find the right inode.. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1159-1247",
          "snippet": "struct inode *exofs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct exofs_i_info *oi;\n\tstruct exofs_fcb fcb;\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\n\t/* read the inode from the osd */\n\tret = exofs_get_inode(sb, oi, &fcb);\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tset_obj_created(oi);\n\n\t/* copy stuff from on-disk struct to in-memory struct */\n\tinode->i_mode = le16_to_cpu(fcb.i_mode);\n\ti_uid_write(inode, le32_to_cpu(fcb.i_uid));\n\ti_gid_write(inode, le32_to_cpu(fcb.i_gid));\n\tset_nlink(inode, le16_to_cpu(fcb.i_links_count));\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\n\tinode->i_ctime.tv_nsec =\n\t\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\toi->i_commit_size = le64_to_cpu(fcb.i_size);\n\ti_size_write(inode, oi->i_commit_size);\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_generation = le32_to_cpu(fcb.i_generation);\n\n\toi->i_dir_start_lookup = 0;\n\n\tif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (fcb.i_data[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(fcb.i_data[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\n\t} else {\n\t\tmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &exofs_file_inode_operations;\n\t\tinode->i_fop = &exofs_file_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &exofs_dir_inode_operations;\n\t\tinode->i_fop = &exofs_dir_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (exofs_inode_is_fast_symlink(inode))\n\t\t\tinode->i_op = &exofs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &exofs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &exofs_special_inode_operations;\n\t\tif (fcb.i_data[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(fcb.i_data[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(fcb.i_data[1])));\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations exofs_aops = {\n\t.readpage\t= exofs_readpage,\n\t.readpages\t= exofs_readpages,\n\t.writepage\t= NULL,\n\t.writepages\t= exofs_writepages,\n\t.write_begin\t= exofs_write_begin_export,\n\t.write_end\t= exofs_write_end,\n\t.releasepage\t= exofs_releasepage,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.invalidatepage = exofs_invalidatepage,\n\n\t/* Not implemented Yet */\n\t.bmap\t\t= NULL, /* TODO: use osd's OSD_ACT_READ_MAP */\n\t.direct_IO\t= exofs_direct_IO,\n\n\t/* With these NULL has special meaning or default is not exported */\n\t.migratepage\t= NULL,\n\t.launder_page\t= NULL,\n\t.is_partially_uptodate = NULL,\n\t.error_remove_page = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nconst struct address_space_operations exofs_aops = {\n\t.readpage\t= exofs_readpage,\n\t.readpages\t= exofs_readpages,\n\t.writepage\t= NULL,\n\t.writepages\t= exofs_writepages,\n\t.write_begin\t= exofs_write_begin_export,\n\t.write_end\t= exofs_write_end,\n\t.releasepage\t= exofs_releasepage,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.invalidatepage = exofs_invalidatepage,\n\n\t/* Not implemented Yet */\n\t.bmap\t\t= NULL, /* TODO: use osd's OSD_ACT_READ_MAP */\n\t.direct_IO\t= exofs_direct_IO,\n\n\t/* With these NULL has special meaning or default is not exported */\n\t.migratepage\t= NULL,\n\t.launder_page\t= NULL,\n\t.is_partially_uptodate = NULL,\n\t.error_remove_page = NULL,\n};\n\nstruct inode *exofs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct exofs_i_info *oi;\n\tstruct exofs_fcb fcb;\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\n\t/* read the inode from the osd */\n\tret = exofs_get_inode(sb, oi, &fcb);\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tset_obj_created(oi);\n\n\t/* copy stuff from on-disk struct to in-memory struct */\n\tinode->i_mode = le16_to_cpu(fcb.i_mode);\n\ti_uid_write(inode, le32_to_cpu(fcb.i_uid));\n\ti_gid_write(inode, le32_to_cpu(fcb.i_gid));\n\tset_nlink(inode, le16_to_cpu(fcb.i_links_count));\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\n\tinode->i_ctime.tv_nsec =\n\t\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\toi->i_commit_size = le64_to_cpu(fcb.i_size);\n\ti_size_write(inode, oi->i_commit_size);\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_generation = le32_to_cpu(fcb.i_generation);\n\n\toi->i_dir_start_lookup = 0;\n\n\tif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (fcb.i_data[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(fcb.i_data[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\n\t} else {\n\t\tmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &exofs_file_inode_operations;\n\t\tinode->i_fop = &exofs_file_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &exofs_dir_inode_operations;\n\t\tinode->i_fop = &exofs_dir_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (exofs_inode_is_fast_symlink(inode))\n\t\t\tinode->i_op = &exofs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &exofs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &exofs_special_inode_operations;\n\t\tif (fcb.i_data[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(fcb.i_data[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(fcb.i_data[1])));\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct inode *exofs_nfs_get_inode(struct super_block *sb,\n\t\tu64 ino, u32 generation)\n{\n\tstruct inode *inode;\n\n\tinode = exofs_iget(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\tif (generation && inode->i_generation != generation) {\n\t\t/* we didn't find the right inode.. */\n\t\tiput(inode);\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\treturn inode;\n}"
  },
  {
    "function_name": "exofs_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "954-962",
    "snippet": "static struct dentry *exofs_get_parent(struct dentry *child)\n{\n\tunsigned long ino = exofs_parent_ino(child);\n\n\tif (!ino)\n\t\treturn ERR_PTR(-ESTALE);\n\n\treturn d_obtain_alias(exofs_iget(child->d_inode->i_sb, ino));\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_alias",
          "args": [
            "exofs_iget(child->d_inode->i_sb, ino)"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1977-1980",
          "snippet": "struct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_alias(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_iget",
          "args": [
            "child->d_inode->i_sb",
            "ino"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1159-1247",
          "snippet": "struct inode *exofs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct exofs_i_info *oi;\n\tstruct exofs_fcb fcb;\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\n\t/* read the inode from the osd */\n\tret = exofs_get_inode(sb, oi, &fcb);\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tset_obj_created(oi);\n\n\t/* copy stuff from on-disk struct to in-memory struct */\n\tinode->i_mode = le16_to_cpu(fcb.i_mode);\n\ti_uid_write(inode, le32_to_cpu(fcb.i_uid));\n\ti_gid_write(inode, le32_to_cpu(fcb.i_gid));\n\tset_nlink(inode, le16_to_cpu(fcb.i_links_count));\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\n\tinode->i_ctime.tv_nsec =\n\t\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\toi->i_commit_size = le64_to_cpu(fcb.i_size);\n\ti_size_write(inode, oi->i_commit_size);\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_generation = le32_to_cpu(fcb.i_generation);\n\n\toi->i_dir_start_lookup = 0;\n\n\tif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (fcb.i_data[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(fcb.i_data[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\n\t} else {\n\t\tmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &exofs_file_inode_operations;\n\t\tinode->i_fop = &exofs_file_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &exofs_dir_inode_operations;\n\t\tinode->i_fop = &exofs_dir_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (exofs_inode_is_fast_symlink(inode))\n\t\t\tinode->i_op = &exofs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &exofs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &exofs_special_inode_operations;\n\t\tif (fcb.i_data[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(fcb.i_data[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(fcb.i_data[1])));\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations exofs_aops = {\n\t.readpage\t= exofs_readpage,\n\t.readpages\t= exofs_readpages,\n\t.writepage\t= NULL,\n\t.writepages\t= exofs_writepages,\n\t.write_begin\t= exofs_write_begin_export,\n\t.write_end\t= exofs_write_end,\n\t.releasepage\t= exofs_releasepage,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.invalidatepage = exofs_invalidatepage,\n\n\t/* Not implemented Yet */\n\t.bmap\t\t= NULL, /* TODO: use osd's OSD_ACT_READ_MAP */\n\t.direct_IO\t= exofs_direct_IO,\n\n\t/* With these NULL has special meaning or default is not exported */\n\t.migratepage\t= NULL,\n\t.launder_page\t= NULL,\n\t.is_partially_uptodate = NULL,\n\t.error_remove_page = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nconst struct address_space_operations exofs_aops = {\n\t.readpage\t= exofs_readpage,\n\t.readpages\t= exofs_readpages,\n\t.writepage\t= NULL,\n\t.writepages\t= exofs_writepages,\n\t.write_begin\t= exofs_write_begin_export,\n\t.write_end\t= exofs_write_end,\n\t.releasepage\t= exofs_releasepage,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.invalidatepage = exofs_invalidatepage,\n\n\t/* Not implemented Yet */\n\t.bmap\t\t= NULL, /* TODO: use osd's OSD_ACT_READ_MAP */\n\t.direct_IO\t= exofs_direct_IO,\n\n\t/* With these NULL has special meaning or default is not exported */\n\t.migratepage\t= NULL,\n\t.launder_page\t= NULL,\n\t.is_partially_uptodate = NULL,\n\t.error_remove_page = NULL,\n};\n\nstruct inode *exofs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct exofs_i_info *oi;\n\tstruct exofs_fcb fcb;\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\n\t/* read the inode from the osd */\n\tret = exofs_get_inode(sb, oi, &fcb);\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tset_obj_created(oi);\n\n\t/* copy stuff from on-disk struct to in-memory struct */\n\tinode->i_mode = le16_to_cpu(fcb.i_mode);\n\ti_uid_write(inode, le32_to_cpu(fcb.i_uid));\n\ti_gid_write(inode, le32_to_cpu(fcb.i_gid));\n\tset_nlink(inode, le16_to_cpu(fcb.i_links_count));\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\n\tinode->i_ctime.tv_nsec =\n\t\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\toi->i_commit_size = le64_to_cpu(fcb.i_size);\n\ti_size_write(inode, oi->i_commit_size);\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_generation = le32_to_cpu(fcb.i_generation);\n\n\toi->i_dir_start_lookup = 0;\n\n\tif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (fcb.i_data[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(fcb.i_data[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\n\t} else {\n\t\tmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &exofs_file_inode_operations;\n\t\tinode->i_fop = &exofs_file_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &exofs_dir_inode_operations;\n\t\tinode->i_fop = &exofs_dir_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (exofs_inode_is_fast_symlink(inode))\n\t\t\tinode->i_op = &exofs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &exofs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &exofs_special_inode_operations;\n\t\tif (fcb.i_data[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(fcb.i_data[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(fcb.i_data[1])));\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_parent_ino",
          "args": [
            "child"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_parent_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "376-389",
          "snippet": "ino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct dentry *exofs_get_parent(struct dentry *child)\n{\n\tunsigned long ino = exofs_parent_ino(child);\n\n\tif (!ino)\n\t\treturn ERR_PTR(-ESTALE);\n\n\treturn d_obtain_alias(exofs_iget(child->d_inode->i_sb, ino));\n}"
  },
  {
    "function_name": "exofs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "883-938",
    "snippet": "static int exofs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct ore_io_state *ios;\n\tstruct osd_attr attrs[] = {\n\t\tATTR_DEF(OSD_APAGE_PARTITION_QUOTAS,\n\t\t\tOSD_ATTR_PQ_CAPACITY_QUOTA, sizeof(__be64)),\n\t\tATTR_DEF(OSD_APAGE_PARTITION_INFORMATION,\n\t\t\tOSD_ATTR_PI_USED_CAPACITY, sizeof(__be64)),\n\t};\n\tuint64_t capacity = ULLONG_MAX;\n\tuint64_t used = ULLONG_MAX;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (ret) {\n\t\tEXOFS_DBGMSG(\"ore_get_io_state failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (likely(!ret)) {\n\t\tcapacity = get_unaligned_be64(attrs[0].val_ptr);\n\t\tif (unlikely(!capacity))\n\t\t\tcapacity = ULLONG_MAX;\n\t} else\n\t\tEXOFS_DBGMSG(\"exofs_statfs: get capacity failed.\\n\");\n\n\tret = extract_attr_from_ios(ios, &attrs[1]);\n\tif (likely(!ret))\n\t\tused = get_unaligned_be64(attrs[1].val_ptr);\n\telse\n\t\tEXOFS_DBGMSG(\"exofs_statfs: get used-space failed.\\n\");\n\n\t/* fill in the stats buffer */\n\tbuf->f_type = EXOFS_SUPER_MAGIC;\n\tbuf->f_bsize = EXOFS_BLKSIZE;\n\tbuf->f_blocks = capacity >> 9;\n\tbuf->f_bfree = (capacity - used) >> 9;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = sbi->s_numfiles;\n\tbuf->f_ffree = EXOFS_MAX_ID - sbi->s_numfiles;\n\tbuf->f_namelen = EXOFS_NAME_LEN;\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"exofs_statfs: get used-space failed.\\n\""
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_be64",
          "args": [
            "attrs[1].val_ptr"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_attr_from_ios",
          "args": [
            "ios",
            "&attrs[1]"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"exofs_statfs: get capacity failed.\\n\""
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!capacity"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned_be64",
          "args": [
            "attrs[0].val_ptr"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ret"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_attr_from_ios",
          "args": [
            "ios",
            "&attrs[0]"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_read",
          "args": [
            "ios"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "attrs"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"ore_get_io_state failed.\\n\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_io_state",
          "args": [
            "&sbi->layout",
            "&sbi->oc",
            "&ios"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "311-315",
          "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ATTR_DEF",
          "args": [
            "OSD_APAGE_PARTITION_INFORMATION",
            "OSD_ATTR_PI_USED_CAPACITY",
            "sizeof(__be64)"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATTR_DEF",
          "args": [
            "OSD_APAGE_PARTITION_QUOTAS",
            "OSD_ATTR_PQ_CAPACITY_QUOTA",
            "sizeof(__be64)"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\tstruct ore_io_state *ios;\n\tstruct osd_attr attrs[] = {\n\t\tATTR_DEF(OSD_APAGE_PARTITION_QUOTAS,\n\t\t\tOSD_ATTR_PQ_CAPACITY_QUOTA, sizeof(__be64)),\n\t\tATTR_DEF(OSD_APAGE_PARTITION_INFORMATION,\n\t\t\tOSD_ATTR_PI_USED_CAPACITY, sizeof(__be64)),\n\t};\n\tuint64_t capacity = ULLONG_MAX;\n\tuint64_t used = ULLONG_MAX;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (ret) {\n\t\tEXOFS_DBGMSG(\"ore_get_io_state failed.\\n\");\n\t\treturn ret;\n\t}\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (likely(!ret)) {\n\t\tcapacity = get_unaligned_be64(attrs[0].val_ptr);\n\t\tif (unlikely(!capacity))\n\t\t\tcapacity = ULLONG_MAX;\n\t} else\n\t\tEXOFS_DBGMSG(\"exofs_statfs: get capacity failed.\\n\");\n\n\tret = extract_attr_from_ios(ios, &attrs[1]);\n\tif (likely(!ret))\n\t\tused = get_unaligned_be64(attrs[1].val_ptr);\n\telse\n\t\tEXOFS_DBGMSG(\"exofs_statfs: get used-space failed.\\n\");\n\n\t/* fill in the stats buffer */\n\tbuf->f_type = EXOFS_SUPER_MAGIC;\n\tbuf->f_bsize = EXOFS_BLKSIZE;\n\tbuf->f_blocks = capacity >> 9;\n\tbuf->f_bfree = (capacity - used) >> 9;\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = sbi->s_numfiles;\n\tbuf->f_ffree = EXOFS_MAX_ID - sbi->s_numfiles;\n\tbuf->f_namelen = EXOFS_NAME_LEN;\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "863-877",
    "snippet": "static struct dentry *exofs_mount(struct file_system_type *type,\n\t\t\t  int flags, const char *dev_name,\n\t\t\t  void *data)\n{\n\tstruct exofs_mountopt opts;\n\tint ret;\n\n\tret = parse_options(data, &opts);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!opts.dev_name)\n\t\topts.dev_name = dev_name;\n\treturn mount_nodev(type, flags, &opts, exofs_fill_super);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_nodev",
          "args": [
            "type",
            "flags",
            "&opts",
            "exofs_fill_super"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "data",
            "&opts"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "81-140",
          "snippet": "static int parse_options(char *options, struct exofs_mountopt *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tbool s_pid = false;\n\n\tEXOFS_DBGMSG(\"parse_options %s\\n\", options);\n\t/* defaults */\n\tmemset(opts, 0, sizeof(*opts));\n\topts->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tchar str[32];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_name:\n\t\t\topts->dev_name = match_strdup(&args[0]);\n\t\t\tif (unlikely(!opts->dev_name)) {\n\t\t\t\tEXOFS_ERR(\"Error allocating dev_name\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\topts->is_osdname = true;\n\t\t\tbreak;\n\t\tcase Opt_pid:\n\t\t\tif (0 == match_strlcpy(str, &args[0], sizeof(str)))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->pid = simple_strtoull(str, NULL, 0);\n\t\t\tif (opts->pid < EXOFS_MIN_PID) {\n\t\t\t\tEXOFS_ERR(\"Partition ID must be >= %u\",\n\t\t\t\t\t  EXOFS_MIN_PID);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ts_pid = 1;\n\t\t\tbreak;\n\t\tcase Opt_to:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (option <= 0) {\n\t\t\t\tEXOFS_ERR(\"Timout must be > 0\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\topts->timeout = option * HZ;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!s_pid) {\n\t\tEXOFS_ERR(\"Need to specify the following options:\\n\");\n\t\tEXOFS_ERR(\"    -o pid=pid_no_to_use\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static match_table_t tokens = {\n\t{Opt_name, \"osdname=%s\"},\n\t{Opt_pid, \"pid=%u\"},\n\t{Opt_to, \"to=%u\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic match_table_t tokens = {\n\t{Opt_name, \"osdname=%s\"},\n\t{Opt_pid, \"pid=%u\"},\n\t{Opt_to, \"to=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct exofs_mountopt *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tbool s_pid = false;\n\n\tEXOFS_DBGMSG(\"parse_options %s\\n\", options);\n\t/* defaults */\n\tmemset(opts, 0, sizeof(*opts));\n\topts->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tchar str[32];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_name:\n\t\t\topts->dev_name = match_strdup(&args[0]);\n\t\t\tif (unlikely(!opts->dev_name)) {\n\t\t\t\tEXOFS_ERR(\"Error allocating dev_name\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\topts->is_osdname = true;\n\t\t\tbreak;\n\t\tcase Opt_pid:\n\t\t\tif (0 == match_strlcpy(str, &args[0], sizeof(str)))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->pid = simple_strtoull(str, NULL, 0);\n\t\t\tif (opts->pid < EXOFS_MIN_PID) {\n\t\t\t\tEXOFS_ERR(\"Partition ID must be >= %u\",\n\t\t\t\t\t  EXOFS_MIN_PID);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ts_pid = 1;\n\t\t\tbreak;\n\t\tcase Opt_to:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (option <= 0) {\n\t\t\t\tEXOFS_ERR(\"Timout must be > 0\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\topts->timeout = option * HZ;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!s_pid) {\n\t\tEXOFS_ERR(\"Need to specify the following options:\\n\");\n\t\tEXOFS_ERR(\"    -o pid=pid_no_to_use\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct dentry *exofs_mount(struct file_system_type *type,\n\t\t\t  int flags, const char *dev_name,\n\t\t\t  void *data)\n{\n\tstruct exofs_mountopt opts;\n\tint ret;\n\n\tret = parse_options(data, &opts);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!opts.dev_name)\n\t\topts.dev_name = dev_name;\n\treturn mount_nodev(type, flags, &opts, exofs_fill_super);\n}"
  },
  {
    "function_name": "exofs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "705-858",
    "snippet": "static int exofs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *root;\n\tstruct exofs_mountopt *opts = data;\n\tstruct exofs_sb_info *sbi;\t/*extended info                  */\n\tstruct osd_dev *od;\t\t/* Master device                 */\n\tstruct exofs_fscb fscb;\t\t/*on-disk superblock info        */\n\tstruct ore_comp comp;\n\tunsigned table_count;\n\tint ret;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\t/* use mount options to fill superblock */\n\tif (opts->is_osdname) {\n\t\tstruct osd_dev_info odi = {.systemid_len = 0};\n\n\t\todi.osdname_len = strlen(opts->dev_name);\n\t\todi.osdname = (u8 *)opts->dev_name;\n\t\tod = osduld_info_lookup(&odi);\n\t\tkfree(opts->dev_name);\n\t\topts->dev_name = NULL;\n\t} else {\n\t\tod = osduld_path_lookup(opts->dev_name);\n\t}\n\tif (IS_ERR(od)) {\n\t\tret = -EINVAL;\n\t\tgoto free_sbi;\n\t}\n\n\t/* Default layout in case we do not have a device-table */\n\tsbi->layout.stripe_unit = PAGE_SIZE;\n\tsbi->layout.mirrors_p1 = 1;\n\tsbi->layout.group_width = 1;\n\tsbi->layout.group_depth = -1;\n\tsbi->layout.group_count = 1;\n\tsbi->s_timeout = opts->timeout;\n\n\tsbi->one_comp.obj.partition = opts->pid;\n\tsbi->one_comp.obj.id = 0;\n\texofs_make_credential(sbi->one_comp.cred, &sbi->one_comp.obj);\n\tsbi->oc.single_comp = EC_SINGLE_COMP;\n\tsbi->oc.comps = &sbi->one_comp;\n\n\t/* fill in some other data by hand */\n\tmemset(sb->s_id, 0, sizeof(sb->s_id));\n\tstrcpy(sb->s_id, \"exofs\");\n\tsb->s_blocksize = EXOFS_BLKSIZE;\n\tsb->s_blocksize_bits = EXOFS_BLKSHIFT;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_max_links = EXOFS_LINK_MAX;\n\tatomic_set(&sbi->s_curr_pending, 0);\n\tsb->s_bdev = NULL;\n\tsb->s_dev = 0;\n\n\tcomp.obj.partition = sbi->one_comp.obj.partition;\n\tcomp.obj.id = EXOFS_SUPER_ID;\n\texofs_make_credential(comp.cred, &comp.obj);\n\n\tret = exofs_read_kern(od, comp.cred, &comp.obj, 0, &fscb, sizeof(fscb));\n\tif (unlikely(ret))\n\t\tgoto free_sbi;\n\n\tsb->s_magic = le16_to_cpu(fscb.s_magic);\n\t/* NOTE: we read below to be backward compatible with old versions */\n\tsbi->s_nextid = le64_to_cpu(fscb.s_nextid);\n\tsbi->s_numfiles = le32_to_cpu(fscb.s_numfiles);\n\n\t/* make sure what we read from the object store is correct */\n\tif (sb->s_magic != EXOFS_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tEXOFS_ERR(\"ERROR: Bad magic value\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_sbi;\n\t}\n\tif (le32_to_cpu(fscb.s_version) > EXOFS_FSCB_VER) {\n\t\tEXOFS_ERR(\"ERROR: Bad FSCB version expected-%d got-%d\\n\",\n\t\t\t  EXOFS_FSCB_VER, le32_to_cpu(fscb.s_version));\n\t\tret = -EINVAL;\n\t\tgoto free_sbi;\n\t}\n\n\t/* start generation numbers from a random point */\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\ttable_count = le64_to_cpu(fscb.s_dev_table_count);\n\tif (table_count) {\n\t\tret = exofs_read_lookup_dev_table(sbi, od, table_count);\n\t\tif (unlikely(ret))\n\t\t\tgoto free_sbi;\n\t} else {\n\t\tstruct exofs_dev *eds;\n\n\t\tret = __alloc_dev_table(sbi, 1, &eds);\n\t\tif (unlikely(ret))\n\t\t\tgoto free_sbi;\n\n\t\tore_comp_set_dev(&sbi->oc, 0, od);\n\t\tsbi->oc.numdevs = 1;\n\t}\n\n\t__sbi_read_stats(sbi);\n\n\t/* set up operation vectors */\n\tsbi->bdi.ra_pages = __ra_pages(&sbi->layout);\n\tsb->s_bdi = &sbi->bdi;\n\tsb->s_fs_info = sbi;\n\tsb->s_op = &exofs_sops;\n\tsb->s_export_op = &exofs_export_ops;\n\troot = exofs_iget(sb, EXOFS_ROOT_ID - EXOFS_OBJ_OFF);\n\tif (IS_ERR(root)) {\n\t\tEXOFS_ERR(\"ERROR: exofs_iget failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto free_sbi;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tEXOFS_ERR(\"ERROR: get root inode failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_sbi;\n\t}\n\n\tif (!S_ISDIR(root->i_mode)) {\n\t\tdput(sb->s_root);\n\t\tsb->s_root = NULL;\n\t\tEXOFS_ERR(\"ERROR: corrupt root inode (mode = %hd)\\n\",\n\t\t       root->i_mode);\n\t\tret = -EINVAL;\n\t\tgoto free_sbi;\n\t}\n\n\tret = bdi_setup_and_register(&sbi->bdi, \"exofs\");\n\tif (ret) {\n\t\tEXOFS_DBGMSG(\"Failed to bdi_setup_and_register\\n\");\n\t\tdput(sb->s_root);\n\t\tsb->s_root = NULL;\n\t\tgoto free_sbi;\n\t}\n\n\texofs_sysfs_dbg_print();\n\t_exofs_print_device(\"Mounting\", opts->dev_name,\n\t\t\t    ore_comp_dev(&sbi->oc, 0),\n\t\t\t    sbi->one_comp.obj.partition);\n\treturn 0;\n\nfree_sbi:\n\tEXOFS_ERR(\"Unable to mount exofs on %s pid=0x%llx err=%d\\n\",\n\t\t  opts->dev_name, sbi->one_comp.obj.partition, ret);\n\texofs_free_sbi(sbi);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations exofs_sops;",
      "static const struct export_operations exofs_export_ops;",
      "static const struct super_operations exofs_sops = {\n\t.alloc_inode    = exofs_alloc_inode,\n\t.destroy_inode  = exofs_destroy_inode,\n\t.write_inode    = exofs_write_inode,\n\t.evict_inode    = exofs_evict_inode,\n\t.put_super      = exofs_put_super,\n\t.sync_fs\t= exofs_sync_fs,\n\t.statfs         = exofs_statfs,\n};",
      "static const struct export_operations exofs_export_ops = {\n\t.fh_to_dentry = exofs_fh_to_dentry,\n\t.fh_to_parent = exofs_fh_to_parent,\n\t.get_parent = exofs_get_parent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_free_sbi",
          "args": [
            "sbi"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_free_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "423-438",
          "snippet": "static void exofs_free_sbi(struct exofs_sb_info *sbi)\n{\n\tunsigned numdevs = sbi->oc.numdevs;\n\n\twhile (numdevs) {\n\t\tunsigned i = --numdevs;\n\t\tstruct osd_dev *od = ore_comp_dev(&sbi->oc, i);\n\n\t\tif (od) {\n\t\t\tore_comp_set_dev(&sbi->oc, i, NULL);\n\t\t\tosduld_put_device(od);\n\t\t}\n\t}\n\tkfree(sbi->oc.ods);\n\tkfree(sbi);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void exofs_free_sbi(struct exofs_sb_info *sbi)\n{\n\tunsigned numdevs = sbi->oc.numdevs;\n\n\twhile (numdevs) {\n\t\tunsigned i = --numdevs;\n\t\tstruct osd_dev *od = ore_comp_dev(&sbi->oc, i);\n\n\t\tif (od) {\n\t\t\tore_comp_set_dev(&sbi->oc, i, NULL);\n\t\t\tosduld_put_device(od);\n\t\t}\n\t}\n\tkfree(sbi->oc.ods);\n\tkfree(sbi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"Unable to mount exofs on %s pid=0x%llx err=%d\\n\"",
            "opts->dev_name",
            "sbi->one_comp.obj.partition",
            "ret"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exofs_print_device",
          "args": [
            "\"Mounting\"",
            "opts->dev_name",
            "ore_comp_dev(&sbi->oc, 0)",
            "sbi->one_comp.obj.partition"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "_exofs_print_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "414-421",
          "snippet": "static void _exofs_print_device(const char *msg, const char *dev_path,\n\t\t\t\tstruct osd_dev *od, u64 pid)\n{\n\tconst struct osd_dev_info *odi = osduld_device_info(od);\n\n\tprintk(KERN_NOTICE \"exofs: %s %s osd_name-%s pid-0x%llx\\n\",\n\t\tmsg, dev_path ?: \"\", odi->osdname, _LLU(pid));\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void _exofs_print_device(const char *msg, const char *dev_path,\n\t\t\t\tstruct osd_dev *od, u64 pid)\n{\n\tconst struct osd_dev_info *odi = osduld_device_info(od);\n\n\tprintk(KERN_NOTICE \"exofs: %s %s osd_name-%s pid-0x%llx\\n\",\n\t\tmsg, dev_path ?: \"\", odi->osdname, _LLU(pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_comp_dev",
          "args": [
            "&sbi->oc",
            "0"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_sysfs_dbg_print",
          "args": [],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_sysfs_dbg_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/sys.c",
          "lines": "117-128",
          "snippet": "void exofs_sysfs_dbg_print(void)\n{\n#ifdef CONFIG_EXOFS_DEBUG\n\tstruct kobject *k_name, *k_tmp;\n\n\tlist_for_each_entry_safe(k_name, k_tmp, &exofs_kset->list, entry) {\n\t\tprintk(KERN_INFO \"%s: name %s ref %d\\n\",\n\t\t\t__func__, kobject_name(k_name),\n\t\t\t(int)atomic_read(&k_name->kref.refcount));\n\t}\n#endif\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/device.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *exofs_kset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/device.h>\n#include <linux/kobject.h>\n\nstatic struct kset *exofs_kset;\n\nvoid exofs_sysfs_dbg_print(void)\n{\n#ifdef CONFIG_EXOFS_DEBUG\n\tstruct kobject *k_name, *k_tmp;\n\n\tlist_for_each_entry_safe(k_name, k_tmp, &exofs_kset->list, entry) {\n\t\tprintk(KERN_INFO \"%s: name %s ref %d\\n\",\n\t\t\t__func__, kobject_name(k_name),\n\t\t\t(int)atomic_read(&k_name->kref.refcount));\n\t}\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "sb->s_root"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"Failed to bdi_setup_and_register\\n\""
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_setup_and_register",
          "args": [
            "&sbi->bdi",
            "\"exofs\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: corrupt root inode (mode = %hd)\\n\"",
            "root->i_mode"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "root->i_mode"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: get root inode failed\\n\""
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: exofs_iget failed\\n\""
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_iget",
          "args": [
            "sb",
            "EXOFS_ROOT_ID - EXOFS_OBJ_OFF"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1159-1247",
          "snippet": "struct inode *exofs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct exofs_i_info *oi;\n\tstruct exofs_fcb fcb;\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\n\t/* read the inode from the osd */\n\tret = exofs_get_inode(sb, oi, &fcb);\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tset_obj_created(oi);\n\n\t/* copy stuff from on-disk struct to in-memory struct */\n\tinode->i_mode = le16_to_cpu(fcb.i_mode);\n\ti_uid_write(inode, le32_to_cpu(fcb.i_uid));\n\ti_gid_write(inode, le32_to_cpu(fcb.i_gid));\n\tset_nlink(inode, le16_to_cpu(fcb.i_links_count));\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\n\tinode->i_ctime.tv_nsec =\n\t\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\toi->i_commit_size = le64_to_cpu(fcb.i_size);\n\ti_size_write(inode, oi->i_commit_size);\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_generation = le32_to_cpu(fcb.i_generation);\n\n\toi->i_dir_start_lookup = 0;\n\n\tif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (fcb.i_data[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(fcb.i_data[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\n\t} else {\n\t\tmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &exofs_file_inode_operations;\n\t\tinode->i_fop = &exofs_file_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &exofs_dir_inode_operations;\n\t\tinode->i_fop = &exofs_dir_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (exofs_inode_is_fast_symlink(inode))\n\t\t\tinode->i_op = &exofs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &exofs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &exofs_special_inode_operations;\n\t\tif (fcb.i_data[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(fcb.i_data[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(fcb.i_data[1])));\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct address_space_operations exofs_aops = {\n\t.readpage\t= exofs_readpage,\n\t.readpages\t= exofs_readpages,\n\t.writepage\t= NULL,\n\t.writepages\t= exofs_writepages,\n\t.write_begin\t= exofs_write_begin_export,\n\t.write_end\t= exofs_write_end,\n\t.releasepage\t= exofs_releasepage,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.invalidatepage = exofs_invalidatepage,\n\n\t/* Not implemented Yet */\n\t.bmap\t\t= NULL, /* TODO: use osd's OSD_ACT_READ_MAP */\n\t.direct_IO\t= exofs_direct_IO,\n\n\t/* With these NULL has special meaning or default is not exported */\n\t.migratepage\t= NULL,\n\t.launder_page\t= NULL,\n\t.is_partially_uptodate = NULL,\n\t.error_remove_page = NULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nconst struct address_space_operations exofs_aops = {\n\t.readpage\t= exofs_readpage,\n\t.readpages\t= exofs_readpages,\n\t.writepage\t= NULL,\n\t.writepages\t= exofs_writepages,\n\t.write_begin\t= exofs_write_begin_export,\n\t.write_end\t= exofs_write_end,\n\t.releasepage\t= exofs_releasepage,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.invalidatepage = exofs_invalidatepage,\n\n\t/* Not implemented Yet */\n\t.bmap\t\t= NULL, /* TODO: use osd's OSD_ACT_READ_MAP */\n\t.direct_IO\t= exofs_direct_IO,\n\n\t/* With these NULL has special meaning or default is not exported */\n\t.migratepage\t= NULL,\n\t.launder_page\t= NULL,\n\t.is_partially_uptodate = NULL,\n\t.error_remove_page = NULL,\n};\n\nstruct inode *exofs_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct exofs_i_info *oi;\n\tstruct exofs_fcb fcb;\n\tstruct inode *inode;\n\tint ret;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\toi = exofs_i(inode);\n\t__oi_init(oi);\n\texofs_init_comps(&oi->oc, &oi->one_comp, sb->s_fs_info,\n\t\t\t exofs_oi_objno(oi));\n\n\t/* read the inode from the osd */\n\tret = exofs_get_inode(sb, oi, &fcb);\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tset_obj_created(oi);\n\n\t/* copy stuff from on-disk struct to in-memory struct */\n\tinode->i_mode = le16_to_cpu(fcb.i_mode);\n\ti_uid_write(inode, le32_to_cpu(fcb.i_uid));\n\ti_gid_write(inode, le32_to_cpu(fcb.i_gid));\n\tset_nlink(inode, le16_to_cpu(fcb.i_links_count));\n\tinode->i_ctime.tv_sec = (signed)le32_to_cpu(fcb.i_ctime);\n\tinode->i_atime.tv_sec = (signed)le32_to_cpu(fcb.i_atime);\n\tinode->i_mtime.tv_sec = (signed)le32_to_cpu(fcb.i_mtime);\n\tinode->i_ctime.tv_nsec =\n\t\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = 0;\n\toi->i_commit_size = le64_to_cpu(fcb.i_size);\n\ti_size_write(inode, oi->i_commit_size);\n\tinode->i_blkbits = EXOFS_BLKSHIFT;\n\tinode->i_generation = le32_to_cpu(fcb.i_generation);\n\n\toi->i_dir_start_lookup = 0;\n\n\tif ((inode->i_nlink == 0) && (inode->i_mode == 0)) {\n\t\tret = -ESTALE;\n\t\tgoto bad_inode;\n\t}\n\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (fcb.i_data[0])\n\t\t\tinode->i_rdev =\n\t\t\t\told_decode_dev(le32_to_cpu(fcb.i_data[0]));\n\t\telse\n\t\t\tinode->i_rdev =\n\t\t\t\tnew_decode_dev(le32_to_cpu(fcb.i_data[1]));\n\t} else {\n\t\tmemcpy(oi->i_data, fcb.i_data, sizeof(fcb.i_data));\n\t}\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &exofs_file_inode_operations;\n\t\tinode->i_fop = &exofs_file_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &exofs_dir_inode_operations;\n\t\tinode->i_fop = &exofs_dir_operations;\n\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (exofs_inode_is_fast_symlink(inode))\n\t\t\tinode->i_op = &exofs_fast_symlink_inode_operations;\n\t\telse {\n\t\t\tinode->i_op = &exofs_symlink_inode_operations;\n\t\t\tinode->i_mapping->a_ops = &exofs_aops;\n\t\t}\n\t} else {\n\t\tinode->i_op = &exofs_special_inode_operations;\n\t\tif (fcb.i_data[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(fcb.i_data[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(fcb.i_data[1])));\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ra_pages",
          "args": [
            "&sbi->layout"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "__ra_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "502-517",
          "snippet": "static unsigned __ra_pages(struct ore_layout *layout)\n{\n\tconst unsigned _MIN_RA = 32; /* min 128K read-ahead */\n\tunsigned ra_pages = layout->group_width * layout->stripe_unit /\n\t\t\t\tPAGE_SIZE;\n\tunsigned max_io_pages = exofs_max_io_pages(layout, ~0);\n\n\tra_pages *= 2; /* two stripes */\n\tif (ra_pages < _MIN_RA)\n\t\tra_pages = roundup(_MIN_RA, ra_pages / 2);\n\n\tif (ra_pages > max_io_pages)\n\t\tra_pages = max_io_pages;\n\n\treturn ra_pages;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic unsigned __ra_pages(struct ore_layout *layout)\n{\n\tconst unsigned _MIN_RA = 32; /* min 128K read-ahead */\n\tunsigned ra_pages = layout->group_width * layout->stripe_unit /\n\t\t\t\tPAGE_SIZE;\n\tunsigned max_io_pages = exofs_max_io_pages(layout, ~0);\n\n\tra_pages *= 2; /* two stripes */\n\tif (ra_pages < _MIN_RA)\n\t\tra_pages = roundup(_MIN_RA, ra_pages / 2);\n\n\tif (ra_pages > max_io_pages)\n\t\tra_pages = max_io_pages;\n\n\treturn ra_pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sbi_read_stats",
          "args": [
            "sbi"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "__sbi_read_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "266-312",
          "snippet": "static int __sbi_read_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"Error reading super_block stats => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr of sb_stats failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[0].len) {\n\t\tstruct exofs_sb_stats *ess;\n\n\t\tif (unlikely(attrs[0].len != sizeof(*ess))) {\n\t\t\tEXOFS_ERR(\"%s: Wrong version of exofs_sb_stats \"\n\t\t\t\t  \"size(%d) != expected(%zd)\\n\",\n\t\t\t\t  __func__, attrs[0].len, sizeof(*ess));\n\t\t\tgoto out;\n\t\t}\n\n\t\tess = attrs[0].val_ptr;\n\t\tsbi->s_nextid = le64_to_cpu(ess->s_nextid);\n\t\tsbi->s_numfiles = le32_to_cpu(ess->s_numfiles);\n\t}\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));\n\nstatic int __sbi_read_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"Error reading super_block stats => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr of sb_stats failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[0].len) {\n\t\tstruct exofs_sb_stats *ess;\n\n\t\tif (unlikely(attrs[0].len != sizeof(*ess))) {\n\t\t\tEXOFS_ERR(\"%s: Wrong version of exofs_sb_stats \"\n\t\t\t\t  \"size(%d) != expected(%zd)\\n\",\n\t\t\t\t  __func__, attrs[0].len, sizeof(*ess));\n\t\t\tgoto out;\n\t\t}\n\n\t\tess = attrs[0].val_ptr;\n\t\tsbi->s_nextid = le64_to_cpu(ess->s_nextid);\n\t\tsbi->s_numfiles = le32_to_cpu(ess->s_numfiles);\n\t}\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_comp_set_dev",
          "args": [
            "&sbi->oc",
            "0",
            "od"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_dev_table",
          "args": [
            "sbi",
            "1",
            "&eds"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_dev_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "546-571",
          "snippet": "static int __alloc_dev_table(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t      struct exofs_dev **peds)\n{\n\tstruct __alloc_ore_devs_and_exofs_devs {\n\t\t/* Twice bigger table: See exofs_init_comps() and comment at\n\t\t * exofs_read_lookup_dev_table()\n\t\t */\n\t\tstruct ore_dev *oreds[numdevs * 2 - 1];\n\t\tstruct exofs_dev eds[numdevs];\n\t} *aoded;\n\tstruct exofs_dev *eds;\n\tunsigned i;\n\n\taoded = kzalloc(sizeof(*aoded), GFP_KERNEL);\n\tif (unlikely(!aoded)) {\n\t\tEXOFS_ERR(\"ERROR: failed allocating Device array[%d]\\n\",\n\t\t\t  numdevs);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.ods = aoded->oreds;\n\t*peds = eds = aoded->eds;\n\tfor (i = 0; i < numdevs; ++i)\n\t\taoded->oreds[i] = &eds[i].ored;\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int __alloc_dev_table(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t      struct exofs_dev **peds)\n{\n\tstruct __alloc_ore_devs_and_exofs_devs {\n\t\t/* Twice bigger table: See exofs_init_comps() and comment at\n\t\t * exofs_read_lookup_dev_table()\n\t\t */\n\t\tstruct ore_dev *oreds[numdevs * 2 - 1];\n\t\tstruct exofs_dev eds[numdevs];\n\t} *aoded;\n\tstruct exofs_dev *eds;\n\tunsigned i;\n\n\taoded = kzalloc(sizeof(*aoded), GFP_KERNEL);\n\tif (unlikely(!aoded)) {\n\t\tEXOFS_ERR(\"ERROR: failed allocating Device array[%d]\\n\",\n\t\t\t  numdevs);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.ods = aoded->oreds;\n\t*peds = eds = aoded->eds;\n\tfor (i = 0; i < numdevs; ++i)\n\t\taoded->oreds[i] = &eds[i].ored;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_read_lookup_dev_table",
          "args": [
            "sbi",
            "od",
            "table_count"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_read_lookup_dev_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "573-700",
          "snippet": "static int exofs_read_lookup_dev_table(struct exofs_sb_info *sbi,\n\t\t\t\t       struct osd_dev *fscb_od,\n\t\t\t\t       unsigned table_count)\n{\n\tstruct ore_comp comp;\n\tstruct exofs_device_table *dt;\n\tstruct exofs_dev *eds;\n\tunsigned table_bytes = table_count * sizeof(dt->dt_dev_table[0]) +\n\t\t\t\t\t     sizeof(*dt);\n\tunsigned numdevs, i;\n\tint ret;\n\n\tdt = kmalloc(table_bytes, GFP_KERNEL);\n\tif (unlikely(!dt)) {\n\t\tEXOFS_ERR(\"ERROR: allocating %x bytes for device table\\n\",\n\t\t\t  table_bytes);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.numdevs = 0;\n\n\tcomp.obj.partition = sbi->one_comp.obj.partition;\n\tcomp.obj.id = EXOFS_DEVTABLE_ID;\n\texofs_make_credential(comp.cred, &comp.obj);\n\n\tret = exofs_read_kern(fscb_od, comp.cred, &comp.obj, 0, dt,\n\t\t\t      table_bytes);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"ERROR: reading device table\\n\");\n\t\tgoto out;\n\t}\n\n\tnumdevs = le64_to_cpu(dt->dt_num_devices);\n\tif (unlikely(!numdevs)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tWARN_ON(table_count != numdevs);\n\n\tret = _read_and_match_data_map(sbi, numdevs, dt);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = __alloc_dev_table(sbi, numdevs, &eds);\n\tif (unlikely(ret))\n\t\tgoto out;\n\t/* exofs round-robins the device table view according to inode\n\t * number. We hold a: twice bigger table hence inodes can point\n\t * to any device and have a sequential view of the table\n\t * starting at this device. See exofs_init_comps()\n\t */\n\tmemcpy(&sbi->oc.ods[numdevs], &sbi->oc.ods[0],\n\t\t(numdevs - 1) * sizeof(sbi->oc.ods[0]));\n\n\t/* create sysfs subdir under which we put the device table\n\t * And cluster layout. A Superblock is identified by the string:\n\t *\t\"dev[0].osdname\"_\"pid\"\n\t */\n\texofs_sysfs_sb_add(sbi, &dt->dt_dev_table[0]);\n\n\tfor (i = 0; i < numdevs; i++) {\n\t\tstruct exofs_fscb fscb;\n\t\tstruct osd_dev_info odi;\n\t\tstruct osd_dev *od;\n\n\t\tif (exofs_devs_2_odi(&dt->dt_dev_table[i], &odi)) {\n\t\t\tEXOFS_ERR(\"ERROR: Read all-zeros device entry\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprintk(KERN_NOTICE \"Add device[%d]: osd_name-%s\\n\",\n\t\t       i, odi.osdname);\n\n\t\t/* the exofs id is currently the table index */\n\t\teds[i].did = i;\n\n\t\t/* On all devices the device table is identical. The user can\n\t\t * specify any one of the participating devices on the command\n\t\t * line. We always keep them in device-table order.\n\t\t */\n\t\tif (fscb_od && osduld_device_same(fscb_od, &odi)) {\n\t\t\teds[i].ored.od = fscb_od;\n\t\t\t++sbi->oc.numdevs;\n\t\t\tfscb_od = NULL;\n\t\t\texofs_sysfs_odev_add(&eds[i], sbi);\n\t\t\tcontinue;\n\t\t}\n\n\t\tod = osduld_info_lookup(&odi);\n\t\tif (IS_ERR(od)) {\n\t\t\tret = PTR_ERR(od);\n\t\t\tEXOFS_ERR(\"ERROR: device requested is not found \"\n\t\t\t\t  \"osd_name-%s =>%d\\n\", odi.osdname, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teds[i].ored.od = od;\n\t\t++sbi->oc.numdevs;\n\n\t\t/* Read the fscb of the other devices to make sure the FS\n\t\t * partition is there.\n\t\t */\n\t\tret = exofs_read_kern(od, comp.cred, &comp.obj, 0, &fscb,\n\t\t\t\t      sizeof(fscb));\n\t\tif (unlikely(ret)) {\n\t\t\tEXOFS_ERR(\"ERROR: Malformed participating device \"\n\t\t\t\t  \"error reading fscb osd_name-%s\\n\",\n\t\t\t\t  odi.osdname);\n\t\t\tgoto out;\n\t\t}\n\t\texofs_sysfs_odev_add(&eds[i], sbi);\n\n\t\t/* TODO: verify other information is correct and FS-uuid\n\t\t *\t matches. Benny what did you say about device table\n\t\t *\t generation and old devices?\n\t\t */\n\t}\n\nout:\n\tkfree(dt);\n\tif (unlikely(fscb_od && !ret)) {\n\t\t\tEXOFS_ERR(\"ERROR: Bad device-table container device not present\\n\");\n\t\t\tosduld_put_device(fscb_od);\n\t\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_read_lookup_dev_table(struct exofs_sb_info *sbi,\n\t\t\t\t       struct osd_dev *fscb_od,\n\t\t\t\t       unsigned table_count)\n{\n\tstruct ore_comp comp;\n\tstruct exofs_device_table *dt;\n\tstruct exofs_dev *eds;\n\tunsigned table_bytes = table_count * sizeof(dt->dt_dev_table[0]) +\n\t\t\t\t\t     sizeof(*dt);\n\tunsigned numdevs, i;\n\tint ret;\n\n\tdt = kmalloc(table_bytes, GFP_KERNEL);\n\tif (unlikely(!dt)) {\n\t\tEXOFS_ERR(\"ERROR: allocating %x bytes for device table\\n\",\n\t\t\t  table_bytes);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.numdevs = 0;\n\n\tcomp.obj.partition = sbi->one_comp.obj.partition;\n\tcomp.obj.id = EXOFS_DEVTABLE_ID;\n\texofs_make_credential(comp.cred, &comp.obj);\n\n\tret = exofs_read_kern(fscb_od, comp.cred, &comp.obj, 0, dt,\n\t\t\t      table_bytes);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"ERROR: reading device table\\n\");\n\t\tgoto out;\n\t}\n\n\tnumdevs = le64_to_cpu(dt->dt_num_devices);\n\tif (unlikely(!numdevs)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tWARN_ON(table_count != numdevs);\n\n\tret = _read_and_match_data_map(sbi, numdevs, dt);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = __alloc_dev_table(sbi, numdevs, &eds);\n\tif (unlikely(ret))\n\t\tgoto out;\n\t/* exofs round-robins the device table view according to inode\n\t * number. We hold a: twice bigger table hence inodes can point\n\t * to any device and have a sequential view of the table\n\t * starting at this device. See exofs_init_comps()\n\t */\n\tmemcpy(&sbi->oc.ods[numdevs], &sbi->oc.ods[0],\n\t\t(numdevs - 1) * sizeof(sbi->oc.ods[0]));\n\n\t/* create sysfs subdir under which we put the device table\n\t * And cluster layout. A Superblock is identified by the string:\n\t *\t\"dev[0].osdname\"_\"pid\"\n\t */\n\texofs_sysfs_sb_add(sbi, &dt->dt_dev_table[0]);\n\n\tfor (i = 0; i < numdevs; i++) {\n\t\tstruct exofs_fscb fscb;\n\t\tstruct osd_dev_info odi;\n\t\tstruct osd_dev *od;\n\n\t\tif (exofs_devs_2_odi(&dt->dt_dev_table[i], &odi)) {\n\t\t\tEXOFS_ERR(\"ERROR: Read all-zeros device entry\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprintk(KERN_NOTICE \"Add device[%d]: osd_name-%s\\n\",\n\t\t       i, odi.osdname);\n\n\t\t/* the exofs id is currently the table index */\n\t\teds[i].did = i;\n\n\t\t/* On all devices the device table is identical. The user can\n\t\t * specify any one of the participating devices on the command\n\t\t * line. We always keep them in device-table order.\n\t\t */\n\t\tif (fscb_od && osduld_device_same(fscb_od, &odi)) {\n\t\t\teds[i].ored.od = fscb_od;\n\t\t\t++sbi->oc.numdevs;\n\t\t\tfscb_od = NULL;\n\t\t\texofs_sysfs_odev_add(&eds[i], sbi);\n\t\t\tcontinue;\n\t\t}\n\n\t\tod = osduld_info_lookup(&odi);\n\t\tif (IS_ERR(od)) {\n\t\t\tret = PTR_ERR(od);\n\t\t\tEXOFS_ERR(\"ERROR: device requested is not found \"\n\t\t\t\t  \"osd_name-%s =>%d\\n\", odi.osdname, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teds[i].ored.od = od;\n\t\t++sbi->oc.numdevs;\n\n\t\t/* Read the fscb of the other devices to make sure the FS\n\t\t * partition is there.\n\t\t */\n\t\tret = exofs_read_kern(od, comp.cred, &comp.obj, 0, &fscb,\n\t\t\t\t      sizeof(fscb));\n\t\tif (unlikely(ret)) {\n\t\t\tEXOFS_ERR(\"ERROR: Malformed participating device \"\n\t\t\t\t  \"error reading fscb osd_name-%s\\n\",\n\t\t\t\t  odi.osdname);\n\t\t\tgoto out;\n\t\t}\n\t\texofs_sysfs_odev_add(&eds[i], sbi);\n\n\t\t/* TODO: verify other information is correct and FS-uuid\n\t\t *\t matches. Benny what did you say about device table\n\t\t *\t generation and old devices?\n\t\t */\n\t}\n\nout:\n\tkfree(dt);\n\tif (unlikely(fscb_od && !ret)) {\n\t\t\tEXOFS_ERR(\"ERROR: Bad device-table container device not present\\n\");\n\t\t\tosduld_put_device(fscb_od);\n\t\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fscb.s_dev_table_count"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&sbi->s_next_gen_lock"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "&sbi->s_next_generation",
            "sizeof(u32)"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: Bad FSCB version expected-%d got-%d\\n\"",
            "EXOFS_FSCB_VER",
            "le32_to_cpu(fscb.s_version)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fscb.s_version"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: Bad magic value\\n\""
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fscb.s_magic"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_read_kern",
          "args": [
            "od",
            "comp.cred",
            "&comp.obj",
            "0",
            "&fscb",
            "sizeof(fscb)"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_read_kern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "225-259",
          "snippet": "static int exofs_read_kern(struct osd_dev *od, u8 *cred, struct osd_obj_id *obj,\n\t\t    u64 offset, void *p, unsigned length)\n{\n\tstruct osd_request *or = osd_start_request(od, GFP_KERNEL);\n/*\tstruct osd_sense_info osi = {.key = 0};*/\n\tint ret;\n\n\tif (unlikely(!or)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_start_request failed.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tret = osd_req_read_kern(or, obj, offset, p, length);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_req_read_kern failed.\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tret = osd_finalize_request(or, 0, cred, NULL);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = osd_execute_request(or);\n\tif (unlikely(ret))\n\t\tEXOFS_DBGMSG(\"osd_execute_request() => %d\\n\", ret);\n\t/* osd_req_decode_sense(or, ret); */\n\nout:\n\tosd_end_request(or);\n\tEXOFS_DBGMSG2(\"read_kern(0x%llx) offset=0x%llx \"\n\t\t      \"length=0x%llx dev=%p ret=>%d\\n\",\n\t\t      _LLU(obj->id), _LLU(offset), _LLU(length), od, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_read_kern(struct osd_dev *od, u8 *cred, struct osd_obj_id *obj,\n\t\t    u64 offset, void *p, unsigned length)\n{\n\tstruct osd_request *or = osd_start_request(od, GFP_KERNEL);\n/*\tstruct osd_sense_info osi = {.key = 0};*/\n\tint ret;\n\n\tif (unlikely(!or)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_start_request failed.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tret = osd_req_read_kern(or, obj, offset, p, length);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_req_read_kern failed.\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tret = osd_finalize_request(or, 0, cred, NULL);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = osd_execute_request(or);\n\tif (unlikely(ret))\n\t\tEXOFS_DBGMSG(\"osd_execute_request() => %d\\n\", ret);\n\t/* osd_req_decode_sense(or, ret); */\n\nout:\n\tosd_end_request(or);\n\tEXOFS_DBGMSG2(\"read_kern(0x%llx) offset=0x%llx \"\n\t\t      \"length=0x%llx dev=%p ret=>%d\\n\",\n\t\t      _LLU(obj->id), _LLU(offset), _LLU(length), od, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_make_credential",
          "args": [
            "comp.cred",
            "&comp.obj"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_make_credential",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "220-223",
          "snippet": "void exofs_make_credential(u8 cred_a[OSD_CAP_LEN], const struct osd_obj_id *obj)\n{\n\tosd_sec_init_nosec_doall_caps(cred_a, obj, false, true);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nvoid exofs_make_credential(u8 cred_a[OSD_CAP_LEN], const struct osd_obj_id *obj)\n{\n\tosd_sec_init_nosec_doall_caps(cred_a, obj, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sbi->s_curr_pending",
            "0"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "sb->s_id",
            "\"exofs\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sb->s_id",
            "0",
            "sizeof(sb->s_id)"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "od"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osduld_path_lookup",
          "args": [
            "opts->dev_name"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "opts->dev_name"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osduld_info_lookup",
          "args": [
            "&odi"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "opts->dev_name"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sbi)",
            "GFP_KERNEL"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic const struct super_operations exofs_sops;\nstatic const struct export_operations exofs_export_ops;\nstatic const struct super_operations exofs_sops = {\n\t.alloc_inode    = exofs_alloc_inode,\n\t.destroy_inode  = exofs_destroy_inode,\n\t.write_inode    = exofs_write_inode,\n\t.evict_inode    = exofs_evict_inode,\n\t.put_super      = exofs_put_super,\n\t.sync_fs\t= exofs_sync_fs,\n\t.statfs         = exofs_statfs,\n};\nstatic const struct export_operations exofs_export_ops = {\n\t.fh_to_dentry = exofs_fh_to_dentry,\n\t.fh_to_parent = exofs_fh_to_parent,\n\t.get_parent = exofs_get_parent,\n};\n\nstatic int exofs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct inode *root;\n\tstruct exofs_mountopt *opts = data;\n\tstruct exofs_sb_info *sbi;\t/*extended info                  */\n\tstruct osd_dev *od;\t\t/* Master device                 */\n\tstruct exofs_fscb fscb;\t\t/*on-disk superblock info        */\n\tstruct ore_comp comp;\n\tunsigned table_count;\n\tint ret;\n\n\tsbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\t/* use mount options to fill superblock */\n\tif (opts->is_osdname) {\n\t\tstruct osd_dev_info odi = {.systemid_len = 0};\n\n\t\todi.osdname_len = strlen(opts->dev_name);\n\t\todi.osdname = (u8 *)opts->dev_name;\n\t\tod = osduld_info_lookup(&odi);\n\t\tkfree(opts->dev_name);\n\t\topts->dev_name = NULL;\n\t} else {\n\t\tod = osduld_path_lookup(opts->dev_name);\n\t}\n\tif (IS_ERR(od)) {\n\t\tret = -EINVAL;\n\t\tgoto free_sbi;\n\t}\n\n\t/* Default layout in case we do not have a device-table */\n\tsbi->layout.stripe_unit = PAGE_SIZE;\n\tsbi->layout.mirrors_p1 = 1;\n\tsbi->layout.group_width = 1;\n\tsbi->layout.group_depth = -1;\n\tsbi->layout.group_count = 1;\n\tsbi->s_timeout = opts->timeout;\n\n\tsbi->one_comp.obj.partition = opts->pid;\n\tsbi->one_comp.obj.id = 0;\n\texofs_make_credential(sbi->one_comp.cred, &sbi->one_comp.obj);\n\tsbi->oc.single_comp = EC_SINGLE_COMP;\n\tsbi->oc.comps = &sbi->one_comp;\n\n\t/* fill in some other data by hand */\n\tmemset(sb->s_id, 0, sizeof(sb->s_id));\n\tstrcpy(sb->s_id, \"exofs\");\n\tsb->s_blocksize = EXOFS_BLKSIZE;\n\tsb->s_blocksize_bits = EXOFS_BLKSHIFT;\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_max_links = EXOFS_LINK_MAX;\n\tatomic_set(&sbi->s_curr_pending, 0);\n\tsb->s_bdev = NULL;\n\tsb->s_dev = 0;\n\n\tcomp.obj.partition = sbi->one_comp.obj.partition;\n\tcomp.obj.id = EXOFS_SUPER_ID;\n\texofs_make_credential(comp.cred, &comp.obj);\n\n\tret = exofs_read_kern(od, comp.cred, &comp.obj, 0, &fscb, sizeof(fscb));\n\tif (unlikely(ret))\n\t\tgoto free_sbi;\n\n\tsb->s_magic = le16_to_cpu(fscb.s_magic);\n\t/* NOTE: we read below to be backward compatible with old versions */\n\tsbi->s_nextid = le64_to_cpu(fscb.s_nextid);\n\tsbi->s_numfiles = le32_to_cpu(fscb.s_numfiles);\n\n\t/* make sure what we read from the object store is correct */\n\tif (sb->s_magic != EXOFS_SUPER_MAGIC) {\n\t\tif (!silent)\n\t\t\tEXOFS_ERR(\"ERROR: Bad magic value\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_sbi;\n\t}\n\tif (le32_to_cpu(fscb.s_version) > EXOFS_FSCB_VER) {\n\t\tEXOFS_ERR(\"ERROR: Bad FSCB version expected-%d got-%d\\n\",\n\t\t\t  EXOFS_FSCB_VER, le32_to_cpu(fscb.s_version));\n\t\tret = -EINVAL;\n\t\tgoto free_sbi;\n\t}\n\n\t/* start generation numbers from a random point */\n\tget_random_bytes(&sbi->s_next_generation, sizeof(u32));\n\tspin_lock_init(&sbi->s_next_gen_lock);\n\n\ttable_count = le64_to_cpu(fscb.s_dev_table_count);\n\tif (table_count) {\n\t\tret = exofs_read_lookup_dev_table(sbi, od, table_count);\n\t\tif (unlikely(ret))\n\t\t\tgoto free_sbi;\n\t} else {\n\t\tstruct exofs_dev *eds;\n\n\t\tret = __alloc_dev_table(sbi, 1, &eds);\n\t\tif (unlikely(ret))\n\t\t\tgoto free_sbi;\n\n\t\tore_comp_set_dev(&sbi->oc, 0, od);\n\t\tsbi->oc.numdevs = 1;\n\t}\n\n\t__sbi_read_stats(sbi);\n\n\t/* set up operation vectors */\n\tsbi->bdi.ra_pages = __ra_pages(&sbi->layout);\n\tsb->s_bdi = &sbi->bdi;\n\tsb->s_fs_info = sbi;\n\tsb->s_op = &exofs_sops;\n\tsb->s_export_op = &exofs_export_ops;\n\troot = exofs_iget(sb, EXOFS_ROOT_ID - EXOFS_OBJ_OFF);\n\tif (IS_ERR(root)) {\n\t\tEXOFS_ERR(\"ERROR: exofs_iget failed\\n\");\n\t\tret = PTR_ERR(root);\n\t\tgoto free_sbi;\n\t}\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root) {\n\t\tEXOFS_ERR(\"ERROR: get root inode failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_sbi;\n\t}\n\n\tif (!S_ISDIR(root->i_mode)) {\n\t\tdput(sb->s_root);\n\t\tsb->s_root = NULL;\n\t\tEXOFS_ERR(\"ERROR: corrupt root inode (mode = %hd)\\n\",\n\t\t       root->i_mode);\n\t\tret = -EINVAL;\n\t\tgoto free_sbi;\n\t}\n\n\tret = bdi_setup_and_register(&sbi->bdi, \"exofs\");\n\tif (ret) {\n\t\tEXOFS_DBGMSG(\"Failed to bdi_setup_and_register\\n\");\n\t\tdput(sb->s_root);\n\t\tsb->s_root = NULL;\n\t\tgoto free_sbi;\n\t}\n\n\texofs_sysfs_dbg_print();\n\t_exofs_print_device(\"Mounting\", opts->dev_name,\n\t\t\t    ore_comp_dev(&sbi->oc, 0),\n\t\t\t    sbi->one_comp.obj.partition);\n\treturn 0;\n\nfree_sbi:\n\tEXOFS_ERR(\"Unable to mount exofs on %s pid=0x%llx err=%d\\n\",\n\t\t  opts->dev_name, sbi->one_comp.obj.partition, ret);\n\texofs_free_sbi(sbi);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_read_lookup_dev_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "573-700",
    "snippet": "static int exofs_read_lookup_dev_table(struct exofs_sb_info *sbi,\n\t\t\t\t       struct osd_dev *fscb_od,\n\t\t\t\t       unsigned table_count)\n{\n\tstruct ore_comp comp;\n\tstruct exofs_device_table *dt;\n\tstruct exofs_dev *eds;\n\tunsigned table_bytes = table_count * sizeof(dt->dt_dev_table[0]) +\n\t\t\t\t\t     sizeof(*dt);\n\tunsigned numdevs, i;\n\tint ret;\n\n\tdt = kmalloc(table_bytes, GFP_KERNEL);\n\tif (unlikely(!dt)) {\n\t\tEXOFS_ERR(\"ERROR: allocating %x bytes for device table\\n\",\n\t\t\t  table_bytes);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.numdevs = 0;\n\n\tcomp.obj.partition = sbi->one_comp.obj.partition;\n\tcomp.obj.id = EXOFS_DEVTABLE_ID;\n\texofs_make_credential(comp.cred, &comp.obj);\n\n\tret = exofs_read_kern(fscb_od, comp.cred, &comp.obj, 0, dt,\n\t\t\t      table_bytes);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"ERROR: reading device table\\n\");\n\t\tgoto out;\n\t}\n\n\tnumdevs = le64_to_cpu(dt->dt_num_devices);\n\tif (unlikely(!numdevs)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tWARN_ON(table_count != numdevs);\n\n\tret = _read_and_match_data_map(sbi, numdevs, dt);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = __alloc_dev_table(sbi, numdevs, &eds);\n\tif (unlikely(ret))\n\t\tgoto out;\n\t/* exofs round-robins the device table view according to inode\n\t * number. We hold a: twice bigger table hence inodes can point\n\t * to any device and have a sequential view of the table\n\t * starting at this device. See exofs_init_comps()\n\t */\n\tmemcpy(&sbi->oc.ods[numdevs], &sbi->oc.ods[0],\n\t\t(numdevs - 1) * sizeof(sbi->oc.ods[0]));\n\n\t/* create sysfs subdir under which we put the device table\n\t * And cluster layout. A Superblock is identified by the string:\n\t *\t\"dev[0].osdname\"_\"pid\"\n\t */\n\texofs_sysfs_sb_add(sbi, &dt->dt_dev_table[0]);\n\n\tfor (i = 0; i < numdevs; i++) {\n\t\tstruct exofs_fscb fscb;\n\t\tstruct osd_dev_info odi;\n\t\tstruct osd_dev *od;\n\n\t\tif (exofs_devs_2_odi(&dt->dt_dev_table[i], &odi)) {\n\t\t\tEXOFS_ERR(\"ERROR: Read all-zeros device entry\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprintk(KERN_NOTICE \"Add device[%d]: osd_name-%s\\n\",\n\t\t       i, odi.osdname);\n\n\t\t/* the exofs id is currently the table index */\n\t\teds[i].did = i;\n\n\t\t/* On all devices the device table is identical. The user can\n\t\t * specify any one of the participating devices on the command\n\t\t * line. We always keep them in device-table order.\n\t\t */\n\t\tif (fscb_od && osduld_device_same(fscb_od, &odi)) {\n\t\t\teds[i].ored.od = fscb_od;\n\t\t\t++sbi->oc.numdevs;\n\t\t\tfscb_od = NULL;\n\t\t\texofs_sysfs_odev_add(&eds[i], sbi);\n\t\t\tcontinue;\n\t\t}\n\n\t\tod = osduld_info_lookup(&odi);\n\t\tif (IS_ERR(od)) {\n\t\t\tret = PTR_ERR(od);\n\t\t\tEXOFS_ERR(\"ERROR: device requested is not found \"\n\t\t\t\t  \"osd_name-%s =>%d\\n\", odi.osdname, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teds[i].ored.od = od;\n\t\t++sbi->oc.numdevs;\n\n\t\t/* Read the fscb of the other devices to make sure the FS\n\t\t * partition is there.\n\t\t */\n\t\tret = exofs_read_kern(od, comp.cred, &comp.obj, 0, &fscb,\n\t\t\t\t      sizeof(fscb));\n\t\tif (unlikely(ret)) {\n\t\t\tEXOFS_ERR(\"ERROR: Malformed participating device \"\n\t\t\t\t  \"error reading fscb osd_name-%s\\n\",\n\t\t\t\t  odi.osdname);\n\t\t\tgoto out;\n\t\t}\n\t\texofs_sysfs_odev_add(&eds[i], sbi);\n\n\t\t/* TODO: verify other information is correct and FS-uuid\n\t\t *\t matches. Benny what did you say about device table\n\t\t *\t generation and old devices?\n\t\t */\n\t}\n\nout:\n\tkfree(dt);\n\tif (unlikely(fscb_od && !ret)) {\n\t\t\tEXOFS_ERR(\"ERROR: Bad device-table container device not present\\n\");\n\t\t\tosduld_put_device(fscb_od);\n\t\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osduld_put_device",
          "args": [
            "fscb_od"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: Bad device-table container device not present\\n\""
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fscb_od && !ret"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dt"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_sysfs_odev_add",
          "args": [
            "&eds[i]",
            "sbi"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_sysfs_odev_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/sys.c",
          "lines": "172-190",
          "snippet": "int exofs_sysfs_odev_add(struct exofs_dev *edev, struct exofs_sb_info *sbi)\n{\n\tstruct kobject *d_kobj;\n\tint retval = 0;\n\n\t/* create osd device group which contains following attributes\n\t * osdname, systemid & uri\n\t */\n\td_kobj = &edev->ed_kobj;\n\td_kobj->kset = exofs_kset;\n\tretval = kobject_init_and_add(d_kobj, &odev_ktype,\n\t\t\t&sbi->s_kobj, \"dev%u\", edev->did);\n\tif (retval) {\n\t\tEXOFS_ERR(\"ERROR: Failed to create sysfs entry for \"\n\t\t\t\t\"device dev%u\\n\", edev->did);\n\t\treturn retval;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/device.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *exofs_kset;",
            "static struct kobj_type odev_ktype = {\n\t.default_attrs\t= odev_attrs,\n\t.sysfs_ops\t= &odev_attr_ops,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/device.h>\n#include <linux/kobject.h>\n\nstatic struct kset *exofs_kset;\nstatic struct kobj_type odev_ktype = {\n\t.default_attrs\t= odev_attrs,\n\t.sysfs_ops\t= &odev_attr_ops,\n};\n\nint exofs_sysfs_odev_add(struct exofs_dev *edev, struct exofs_sb_info *sbi)\n{\n\tstruct kobject *d_kobj;\n\tint retval = 0;\n\n\t/* create osd device group which contains following attributes\n\t * osdname, systemid & uri\n\t */\n\td_kobj = &edev->ed_kobj;\n\td_kobj->kset = exofs_kset;\n\tretval = kobject_init_and_add(d_kobj, &odev_ktype,\n\t\t\t&sbi->s_kobj, \"dev%u\", edev->did);\n\tif (retval) {\n\t\tEXOFS_ERR(\"ERROR: Failed to create sysfs entry for \"\n\t\t\t\t\"device dev%u\\n\", edev->did);\n\t\treturn retval;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: Malformed participating device \"\n\t\t\t\t  \"error reading fscb osd_name-%s\\n\"",
            "odi.osdname"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_read_kern",
          "args": [
            "od",
            "comp.cred",
            "&comp.obj",
            "0",
            "&fscb",
            "sizeof(fscb)"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_read_kern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "225-259",
          "snippet": "static int exofs_read_kern(struct osd_dev *od, u8 *cred, struct osd_obj_id *obj,\n\t\t    u64 offset, void *p, unsigned length)\n{\n\tstruct osd_request *or = osd_start_request(od, GFP_KERNEL);\n/*\tstruct osd_sense_info osi = {.key = 0};*/\n\tint ret;\n\n\tif (unlikely(!or)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_start_request failed.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tret = osd_req_read_kern(or, obj, offset, p, length);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_req_read_kern failed.\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tret = osd_finalize_request(or, 0, cred, NULL);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = osd_execute_request(or);\n\tif (unlikely(ret))\n\t\tEXOFS_DBGMSG(\"osd_execute_request() => %d\\n\", ret);\n\t/* osd_req_decode_sense(or, ret); */\n\nout:\n\tosd_end_request(or);\n\tEXOFS_DBGMSG2(\"read_kern(0x%llx) offset=0x%llx \"\n\t\t      \"length=0x%llx dev=%p ret=>%d\\n\",\n\t\t      _LLU(obj->id), _LLU(offset), _LLU(length), od, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_read_kern(struct osd_dev *od, u8 *cred, struct osd_obj_id *obj,\n\t\t    u64 offset, void *p, unsigned length)\n{\n\tstruct osd_request *or = osd_start_request(od, GFP_KERNEL);\n/*\tstruct osd_sense_info osi = {.key = 0};*/\n\tint ret;\n\n\tif (unlikely(!or)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_start_request failed.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tret = osd_req_read_kern(or, obj, offset, p, length);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_req_read_kern failed.\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tret = osd_finalize_request(or, 0, cred, NULL);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = osd_execute_request(or);\n\tif (unlikely(ret))\n\t\tEXOFS_DBGMSG(\"osd_execute_request() => %d\\n\", ret);\n\t/* osd_req_decode_sense(or, ret); */\n\nout:\n\tosd_end_request(or);\n\tEXOFS_DBGMSG2(\"read_kern(0x%llx) offset=0x%llx \"\n\t\t      \"length=0x%llx dev=%p ret=>%d\\n\",\n\t\t      _LLU(obj->id), _LLU(offset), _LLU(length), od, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: device requested is not found \"\n\t\t\t\t  \"osd_name-%s =>%d\\n\"",
            "odi.osdname",
            "ret"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "od"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "od"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osduld_info_lookup",
          "args": [
            "&odi"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osduld_device_same",
          "args": [
            "fscb_od",
            "&odi"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"Add device[%d]: osd_name-%s\\n\"",
            "i",
            "odi.osdname"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: Read all-zeros device entry\\n\""
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_devs_2_odi",
          "args": [
            "&dt->dt_dev_table[i]",
            "&odi"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_devs_2_odi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "520-544",
          "snippet": "static int exofs_devs_2_odi(struct exofs_dt_device_info *dt_dev,\n\t\t\t     struct osd_dev_info *odi)\n{\n\todi->systemid_len = le32_to_cpu(dt_dev->systemid_len);\n\tif (likely(odi->systemid_len))\n\t\tmemcpy(odi->systemid, dt_dev->systemid, OSD_SYSTEMID_LEN);\n\n\todi->osdname_len = le32_to_cpu(dt_dev->osdname_len);\n\todi->osdname = dt_dev->osdname;\n\n\t/* FIXME support long names. Will need a _put function */\n\tif (dt_dev->long_name_offset)\n\t\treturn -EINVAL;\n\n\t/* Make sure osdname is printable!\n\t * mkexofs should give us space for a null-terminator else the\n\t * device-table is invalid.\n\t */\n\tif (unlikely(odi->osdname_len >= sizeof(dt_dev->osdname)))\n\t\todi->osdname_len = sizeof(dt_dev->osdname) - 1;\n\tdt_dev->osdname[odi->osdname_len] = 0;\n\n\t/* If it's all zeros something is bad we read past end-of-obj */\n\treturn !(odi->systemid_len || odi->osdname_len);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_devs_2_odi(struct exofs_dt_device_info *dt_dev,\n\t\t\t     struct osd_dev_info *odi)\n{\n\todi->systemid_len = le32_to_cpu(dt_dev->systemid_len);\n\tif (likely(odi->systemid_len))\n\t\tmemcpy(odi->systemid, dt_dev->systemid, OSD_SYSTEMID_LEN);\n\n\todi->osdname_len = le32_to_cpu(dt_dev->osdname_len);\n\todi->osdname = dt_dev->osdname;\n\n\t/* FIXME support long names. Will need a _put function */\n\tif (dt_dev->long_name_offset)\n\t\treturn -EINVAL;\n\n\t/* Make sure osdname is printable!\n\t * mkexofs should give us space for a null-terminator else the\n\t * device-table is invalid.\n\t */\n\tif (unlikely(odi->osdname_len >= sizeof(dt_dev->osdname)))\n\t\todi->osdname_len = sizeof(dt_dev->osdname) - 1;\n\tdt_dev->osdname[odi->osdname_len] = 0;\n\n\t/* If it's all zeros something is bad we read past end-of-obj */\n\treturn !(odi->systemid_len || odi->osdname_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_sysfs_sb_add",
          "args": [
            "sbi",
            "&dt->dt_dev_table[0]"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_sysfs_sb_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/sys.c",
          "lines": "152-170",
          "snippet": "int exofs_sysfs_sb_add(struct exofs_sb_info *sbi,\n\t\t       struct exofs_dt_device_info *dt_dev)\n{\n\tstruct kobject *s_kobj;\n\tint retval = 0;\n\tuint64_t pid = sbi->one_comp.obj.partition;\n\n\t/* allocate new uuid dirent */\n\ts_kobj = &sbi->s_kobj;\n\ts_kobj->kset = exofs_kset;\n\tretval = kobject_init_and_add(s_kobj, &uuid_ktype,\n\t\t\t&exofs_kset->kobj,  \"%s_%llx\", dt_dev->osdname, pid);\n\tif (retval) {\n\t\tEXOFS_ERR(\"ERROR: Failed to create sysfs entry for \"\n\t\t\t  \"uuid-%s_%llx => %d\\n\", dt_dev->osdname, pid, retval);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/device.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *exofs_kset;",
            "static struct kobj_type uuid_ktype = {\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/device.h>\n#include <linux/kobject.h>\n\nstatic struct kset *exofs_kset;\nstatic struct kobj_type uuid_ktype = {\n};\n\nint exofs_sysfs_sb_add(struct exofs_sb_info *sbi,\n\t\t       struct exofs_dt_device_info *dt_dev)\n{\n\tstruct kobject *s_kobj;\n\tint retval = 0;\n\tuint64_t pid = sbi->one_comp.obj.partition;\n\n\t/* allocate new uuid dirent */\n\ts_kobj = &sbi->s_kobj;\n\ts_kobj->kset = exofs_kset;\n\tretval = kobject_init_and_add(s_kobj, &uuid_ktype,\n\t\t\t&exofs_kset->kobj,  \"%s_%llx\", dt_dev->osdname, pid);\n\tif (retval) {\n\t\tEXOFS_ERR(\"ERROR: Failed to create sysfs entry for \"\n\t\t\t  \"uuid-%s_%llx => %d\\n\", dt_dev->osdname, pid, retval);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&sbi->oc.ods[numdevs]",
            "&sbi->oc.ods[0]",
            "(numdevs - 1) * sizeof(sbi->oc.ods[0])"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_dev_table",
          "args": [
            "sbi",
            "numdevs",
            "&eds"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "__alloc_dev_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "546-571",
          "snippet": "static int __alloc_dev_table(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t      struct exofs_dev **peds)\n{\n\tstruct __alloc_ore_devs_and_exofs_devs {\n\t\t/* Twice bigger table: See exofs_init_comps() and comment at\n\t\t * exofs_read_lookup_dev_table()\n\t\t */\n\t\tstruct ore_dev *oreds[numdevs * 2 - 1];\n\t\tstruct exofs_dev eds[numdevs];\n\t} *aoded;\n\tstruct exofs_dev *eds;\n\tunsigned i;\n\n\taoded = kzalloc(sizeof(*aoded), GFP_KERNEL);\n\tif (unlikely(!aoded)) {\n\t\tEXOFS_ERR(\"ERROR: failed allocating Device array[%d]\\n\",\n\t\t\t  numdevs);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.ods = aoded->oreds;\n\t*peds = eds = aoded->eds;\n\tfor (i = 0; i < numdevs; ++i)\n\t\taoded->oreds[i] = &eds[i].ored;\n\treturn 0;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int __alloc_dev_table(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t      struct exofs_dev **peds)\n{\n\tstruct __alloc_ore_devs_and_exofs_devs {\n\t\t/* Twice bigger table: See exofs_init_comps() and comment at\n\t\t * exofs_read_lookup_dev_table()\n\t\t */\n\t\tstruct ore_dev *oreds[numdevs * 2 - 1];\n\t\tstruct exofs_dev eds[numdevs];\n\t} *aoded;\n\tstruct exofs_dev *eds;\n\tunsigned i;\n\n\taoded = kzalloc(sizeof(*aoded), GFP_KERNEL);\n\tif (unlikely(!aoded)) {\n\t\tEXOFS_ERR(\"ERROR: failed allocating Device array[%d]\\n\",\n\t\t\t  numdevs);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.ods = aoded->oreds;\n\t*peds = eds = aoded->eds;\n\tfor (i = 0; i < numdevs; ++i)\n\t\taoded->oreds[i] = &eds[i].ored;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_read_and_match_data_map",
          "args": [
            "sbi",
            "numdevs",
            "dt"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "_read_and_match_data_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "472-500",
          "snippet": "static int _read_and_match_data_map(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t\t\t    struct exofs_device_table *dt)\n{\n\tint ret;\n\n\tsbi->layout.stripe_unit =\n\t\t\t\tle64_to_cpu(dt->dt_data_map.cb_stripe_unit);\n\tsbi->layout.group_width =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_group_width);\n\tsbi->layout.group_depth =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_group_depth);\n\tsbi->layout.mirrors_p1  =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_mirror_cnt) + 1;\n\tsbi->layout.raid_algorithm  =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_raid_algorithm);\n\n\tret = ore_verify_layout(numdevs, &sbi->layout);\n\n\tEXOFS_DBGMSG(\"exofs: layout: \"\n\t\t\"num_comps=%u stripe_unit=0x%x group_width=%u \"\n\t\t\"group_depth=0x%llx mirrors_p1=%u raid_algorithm=%u\\n\",\n\t\tnumdevs,\n\t\tsbi->layout.stripe_unit,\n\t\tsbi->layout.group_width,\n\t\t_LLU(sbi->layout.group_depth),\n\t\tsbi->layout.mirrors_p1,\n\t\tsbi->layout.raid_algorithm);\n\treturn ret;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int _read_and_match_data_map(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t\t\t    struct exofs_device_table *dt)\n{\n\tint ret;\n\n\tsbi->layout.stripe_unit =\n\t\t\t\tle64_to_cpu(dt->dt_data_map.cb_stripe_unit);\n\tsbi->layout.group_width =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_group_width);\n\tsbi->layout.group_depth =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_group_depth);\n\tsbi->layout.mirrors_p1  =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_mirror_cnt) + 1;\n\tsbi->layout.raid_algorithm  =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_raid_algorithm);\n\n\tret = ore_verify_layout(numdevs, &sbi->layout);\n\n\tEXOFS_DBGMSG(\"exofs: layout: \"\n\t\t\"num_comps=%u stripe_unit=0x%x group_width=%u \"\n\t\t\"group_depth=0x%llx mirrors_p1=%u raid_algorithm=%u\\n\",\n\t\tnumdevs,\n\t\tsbi->layout.stripe_unit,\n\t\tsbi->layout.group_width,\n\t\t_LLU(sbi->layout.group_depth),\n\t\tsbi->layout.mirrors_p1,\n\t\tsbi->layout.raid_algorithm);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "table_count != numdevs"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!numdevs"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dt->dt_num_devices"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: reading device table\\n\""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_make_credential",
          "args": [
            "comp.cred",
            "&comp.obj"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_make_credential",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "220-223",
          "snippet": "void exofs_make_credential(u8 cred_a[OSD_CAP_LEN], const struct osd_obj_id *obj)\n{\n\tosd_sec_init_nosec_doall_caps(cred_a, obj, false, true);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nvoid exofs_make_credential(u8 cred_a[OSD_CAP_LEN], const struct osd_obj_id *obj)\n{\n\tosd_sec_init_nosec_doall_caps(cred_a, obj, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: allocating %x bytes for device table\\n\"",
            "table_bytes"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dt"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "table_bytes",
            "GFP_KERNEL"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_read_lookup_dev_table(struct exofs_sb_info *sbi,\n\t\t\t\t       struct osd_dev *fscb_od,\n\t\t\t\t       unsigned table_count)\n{\n\tstruct ore_comp comp;\n\tstruct exofs_device_table *dt;\n\tstruct exofs_dev *eds;\n\tunsigned table_bytes = table_count * sizeof(dt->dt_dev_table[0]) +\n\t\t\t\t\t     sizeof(*dt);\n\tunsigned numdevs, i;\n\tint ret;\n\n\tdt = kmalloc(table_bytes, GFP_KERNEL);\n\tif (unlikely(!dt)) {\n\t\tEXOFS_ERR(\"ERROR: allocating %x bytes for device table\\n\",\n\t\t\t  table_bytes);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.numdevs = 0;\n\n\tcomp.obj.partition = sbi->one_comp.obj.partition;\n\tcomp.obj.id = EXOFS_DEVTABLE_ID;\n\texofs_make_credential(comp.cred, &comp.obj);\n\n\tret = exofs_read_kern(fscb_od, comp.cred, &comp.obj, 0, dt,\n\t\t\t      table_bytes);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"ERROR: reading device table\\n\");\n\t\tgoto out;\n\t}\n\n\tnumdevs = le64_to_cpu(dt->dt_num_devices);\n\tif (unlikely(!numdevs)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tWARN_ON(table_count != numdevs);\n\n\tret = _read_and_match_data_map(sbi, numdevs, dt);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tret = __alloc_dev_table(sbi, numdevs, &eds);\n\tif (unlikely(ret))\n\t\tgoto out;\n\t/* exofs round-robins the device table view according to inode\n\t * number. We hold a: twice bigger table hence inodes can point\n\t * to any device and have a sequential view of the table\n\t * starting at this device. See exofs_init_comps()\n\t */\n\tmemcpy(&sbi->oc.ods[numdevs], &sbi->oc.ods[0],\n\t\t(numdevs - 1) * sizeof(sbi->oc.ods[0]));\n\n\t/* create sysfs subdir under which we put the device table\n\t * And cluster layout. A Superblock is identified by the string:\n\t *\t\"dev[0].osdname\"_\"pid\"\n\t */\n\texofs_sysfs_sb_add(sbi, &dt->dt_dev_table[0]);\n\n\tfor (i = 0; i < numdevs; i++) {\n\t\tstruct exofs_fscb fscb;\n\t\tstruct osd_dev_info odi;\n\t\tstruct osd_dev *od;\n\n\t\tif (exofs_devs_2_odi(&dt->dt_dev_table[i], &odi)) {\n\t\t\tEXOFS_ERR(\"ERROR: Read all-zeros device entry\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprintk(KERN_NOTICE \"Add device[%d]: osd_name-%s\\n\",\n\t\t       i, odi.osdname);\n\n\t\t/* the exofs id is currently the table index */\n\t\teds[i].did = i;\n\n\t\t/* On all devices the device table is identical. The user can\n\t\t * specify any one of the participating devices on the command\n\t\t * line. We always keep them in device-table order.\n\t\t */\n\t\tif (fscb_od && osduld_device_same(fscb_od, &odi)) {\n\t\t\teds[i].ored.od = fscb_od;\n\t\t\t++sbi->oc.numdevs;\n\t\t\tfscb_od = NULL;\n\t\t\texofs_sysfs_odev_add(&eds[i], sbi);\n\t\t\tcontinue;\n\t\t}\n\n\t\tod = osduld_info_lookup(&odi);\n\t\tif (IS_ERR(od)) {\n\t\t\tret = PTR_ERR(od);\n\t\t\tEXOFS_ERR(\"ERROR: device requested is not found \"\n\t\t\t\t  \"osd_name-%s =>%d\\n\", odi.osdname, ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teds[i].ored.od = od;\n\t\t++sbi->oc.numdevs;\n\n\t\t/* Read the fscb of the other devices to make sure the FS\n\t\t * partition is there.\n\t\t */\n\t\tret = exofs_read_kern(od, comp.cred, &comp.obj, 0, &fscb,\n\t\t\t\t      sizeof(fscb));\n\t\tif (unlikely(ret)) {\n\t\t\tEXOFS_ERR(\"ERROR: Malformed participating device \"\n\t\t\t\t  \"error reading fscb osd_name-%s\\n\",\n\t\t\t\t  odi.osdname);\n\t\t\tgoto out;\n\t\t}\n\t\texofs_sysfs_odev_add(&eds[i], sbi);\n\n\t\t/* TODO: verify other information is correct and FS-uuid\n\t\t *\t matches. Benny what did you say about device table\n\t\t *\t generation and old devices?\n\t\t */\n\t}\n\nout:\n\tkfree(dt);\n\tif (unlikely(fscb_od && !ret)) {\n\t\t\tEXOFS_ERR(\"ERROR: Bad device-table container device not present\\n\");\n\t\t\tosduld_put_device(fscb_od);\n\t\t\treturn -EINVAL;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__alloc_dev_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "546-571",
    "snippet": "static int __alloc_dev_table(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t      struct exofs_dev **peds)\n{\n\tstruct __alloc_ore_devs_and_exofs_devs {\n\t\t/* Twice bigger table: See exofs_init_comps() and comment at\n\t\t * exofs_read_lookup_dev_table()\n\t\t */\n\t\tstruct ore_dev *oreds[numdevs * 2 - 1];\n\t\tstruct exofs_dev eds[numdevs];\n\t} *aoded;\n\tstruct exofs_dev *eds;\n\tunsigned i;\n\n\taoded = kzalloc(sizeof(*aoded), GFP_KERNEL);\n\tif (unlikely(!aoded)) {\n\t\tEXOFS_ERR(\"ERROR: failed allocating Device array[%d]\\n\",\n\t\t\t  numdevs);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.ods = aoded->oreds;\n\t*peds = eds = aoded->eds;\n\tfor (i = 0; i < numdevs; ++i)\n\t\taoded->oreds[i] = &eds[i].ored;\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: failed allocating Device array[%d]\\n\"",
            "numdevs"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!aoded"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*aoded)",
            "GFP_KERNEL"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int __alloc_dev_table(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t      struct exofs_dev **peds)\n{\n\tstruct __alloc_ore_devs_and_exofs_devs {\n\t\t/* Twice bigger table: See exofs_init_comps() and comment at\n\t\t * exofs_read_lookup_dev_table()\n\t\t */\n\t\tstruct ore_dev *oreds[numdevs * 2 - 1];\n\t\tstruct exofs_dev eds[numdevs];\n\t} *aoded;\n\tstruct exofs_dev *eds;\n\tunsigned i;\n\n\taoded = kzalloc(sizeof(*aoded), GFP_KERNEL);\n\tif (unlikely(!aoded)) {\n\t\tEXOFS_ERR(\"ERROR: failed allocating Device array[%d]\\n\",\n\t\t\t  numdevs);\n\t\treturn -ENOMEM;\n\t}\n\n\tsbi->oc.ods = aoded->oreds;\n\t*peds = eds = aoded->eds;\n\tfor (i = 0; i < numdevs; ++i)\n\t\taoded->oreds[i] = &eds[i].ored;\n\treturn 0;\n}"
  },
  {
    "function_name": "exofs_devs_2_odi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "520-544",
    "snippet": "static int exofs_devs_2_odi(struct exofs_dt_device_info *dt_dev,\n\t\t\t     struct osd_dev_info *odi)\n{\n\todi->systemid_len = le32_to_cpu(dt_dev->systemid_len);\n\tif (likely(odi->systemid_len))\n\t\tmemcpy(odi->systemid, dt_dev->systemid, OSD_SYSTEMID_LEN);\n\n\todi->osdname_len = le32_to_cpu(dt_dev->osdname_len);\n\todi->osdname = dt_dev->osdname;\n\n\t/* FIXME support long names. Will need a _put function */\n\tif (dt_dev->long_name_offset)\n\t\treturn -EINVAL;\n\n\t/* Make sure osdname is printable!\n\t * mkexofs should give us space for a null-terminator else the\n\t * device-table is invalid.\n\t */\n\tif (unlikely(odi->osdname_len >= sizeof(dt_dev->osdname)))\n\t\todi->osdname_len = sizeof(dt_dev->osdname) - 1;\n\tdt_dev->osdname[odi->osdname_len] = 0;\n\n\t/* If it's all zeros something is bad we read past end-of-obj */\n\treturn !(odi->systemid_len || odi->osdname_len);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "odi->osdname_len >= sizeof(dt_dev->osdname)"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dt_dev->osdname_len"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "odi->systemid",
            "dt_dev->systemid",
            "OSD_SYSTEMID_LEN"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "odi->systemid_len"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_devs_2_odi(struct exofs_dt_device_info *dt_dev,\n\t\t\t     struct osd_dev_info *odi)\n{\n\todi->systemid_len = le32_to_cpu(dt_dev->systemid_len);\n\tif (likely(odi->systemid_len))\n\t\tmemcpy(odi->systemid, dt_dev->systemid, OSD_SYSTEMID_LEN);\n\n\todi->osdname_len = le32_to_cpu(dt_dev->osdname_len);\n\todi->osdname = dt_dev->osdname;\n\n\t/* FIXME support long names. Will need a _put function */\n\tif (dt_dev->long_name_offset)\n\t\treturn -EINVAL;\n\n\t/* Make sure osdname is printable!\n\t * mkexofs should give us space for a null-terminator else the\n\t * device-table is invalid.\n\t */\n\tif (unlikely(odi->osdname_len >= sizeof(dt_dev->osdname)))\n\t\todi->osdname_len = sizeof(dt_dev->osdname) - 1;\n\tdt_dev->osdname[odi->osdname_len] = 0;\n\n\t/* If it's all zeros something is bad we read past end-of-obj */\n\treturn !(odi->systemid_len || odi->osdname_len);\n}"
  },
  {
    "function_name": "__ra_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "502-517",
    "snippet": "static unsigned __ra_pages(struct ore_layout *layout)\n{\n\tconst unsigned _MIN_RA = 32; /* min 128K read-ahead */\n\tunsigned ra_pages = layout->group_width * layout->stripe_unit /\n\t\t\t\tPAGE_SIZE;\n\tunsigned max_io_pages = exofs_max_io_pages(layout, ~0);\n\n\tra_pages *= 2; /* two stripes */\n\tif (ra_pages < _MIN_RA)\n\t\tra_pages = roundup(_MIN_RA, ra_pages / 2);\n\n\tif (ra_pages > max_io_pages)\n\t\tra_pages = max_io_pages;\n\n\treturn ra_pages;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "_MIN_RA",
            "ra_pages / 2"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_max_io_pages",
          "args": [
            "layout",
            "~0"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_max_io_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "40-47",
          "snippet": "unsigned exofs_max_io_pages(struct ore_layout *layout,\n\t\t\t    unsigned expected_pages)\n{\n\tunsigned pages = min_t(unsigned, expected_pages,\n\t\t\t       layout->max_io_length / PAGE_SIZE);\n\n\treturn pages;\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nunsigned exofs_max_io_pages(struct ore_layout *layout,\n\t\t\t    unsigned expected_pages)\n{\n\tunsigned pages = min_t(unsigned, expected_pages,\n\t\t\t       layout->max_io_length / PAGE_SIZE);\n\n\treturn pages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic unsigned __ra_pages(struct ore_layout *layout)\n{\n\tconst unsigned _MIN_RA = 32; /* min 128K read-ahead */\n\tunsigned ra_pages = layout->group_width * layout->stripe_unit /\n\t\t\t\tPAGE_SIZE;\n\tunsigned max_io_pages = exofs_max_io_pages(layout, ~0);\n\n\tra_pages *= 2; /* two stripes */\n\tif (ra_pages < _MIN_RA)\n\t\tra_pages = roundup(_MIN_RA, ra_pages / 2);\n\n\tif (ra_pages > max_io_pages)\n\t\tra_pages = max_io_pages;\n\n\treturn ra_pages;\n}"
  },
  {
    "function_name": "_read_and_match_data_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "472-500",
    "snippet": "static int _read_and_match_data_map(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t\t\t    struct exofs_device_table *dt)\n{\n\tint ret;\n\n\tsbi->layout.stripe_unit =\n\t\t\t\tle64_to_cpu(dt->dt_data_map.cb_stripe_unit);\n\tsbi->layout.group_width =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_group_width);\n\tsbi->layout.group_depth =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_group_depth);\n\tsbi->layout.mirrors_p1  =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_mirror_cnt) + 1;\n\tsbi->layout.raid_algorithm  =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_raid_algorithm);\n\n\tret = ore_verify_layout(numdevs, &sbi->layout);\n\n\tEXOFS_DBGMSG(\"exofs: layout: \"\n\t\t\"num_comps=%u stripe_unit=0x%x group_width=%u \"\n\t\t\"group_depth=0x%llx mirrors_p1=%u raid_algorithm=%u\\n\",\n\t\tnumdevs,\n\t\tsbi->layout.stripe_unit,\n\t\tsbi->layout.group_width,\n\t\t_LLU(sbi->layout.group_depth),\n\t\tsbi->layout.mirrors_p1,\n\t\tsbi->layout.raid_algorithm);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"exofs: layout: \"\n\t\t\"num_comps=%u stripe_unit=0x%x group_width=%u \"\n\t\t\"group_depth=0x%llx mirrors_p1=%u raid_algorithm=%u\\n\"",
            "numdevs",
            "sbi->layout.stripe_unit",
            "sbi->layout.group_width",
            "_LLU(sbi->layout.group_depth)",
            "sbi->layout.mirrors_p1",
            "sbi->layout.raid_algorithm"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "sbi->layout.group_depth"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_verify_layout",
          "args": [
            "numdevs",
            "&sbi->layout"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "ore_verify_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "49-121",
          "snippet": "int ore_verify_layout(unsigned total_comps, struct ore_layout *layout)\n{\n\tu64 stripe_length;\n\n\tswitch (layout->raid_algorithm) {\n\tcase PNFS_OSD_RAID_0:\n\t\tlayout->parity = 0;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_5:\n\t\tlayout->parity = 1;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_PQ:\n\t\tlayout->parity = 2;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_4:\n\tdefault:\n\t\tORE_ERR(\"Only RAID_0/5/6 for now received-enum=%d\\n\",\n\t\t\tlayout->raid_algorithm);\n\t\treturn -EINVAL;\n\t}\n\tif (0 != (layout->stripe_unit & ~PAGE_MASK)) {\n\t\tORE_ERR(\"Stripe Unit(0x%llx)\"\n\t\t\t  \" must be Multples of PAGE_SIZE(0x%lx)\\n\",\n\t\t\t  _LLU(layout->stripe_unit), PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\tif (layout->group_width) {\n\t\tif (!layout->group_depth) {\n\t\t\tORE_ERR(\"group_depth == 0 && group_width != 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total_comps < (layout->group_width * layout->mirrors_p1)) {\n\t\t\tORE_ERR(\"Data Map wrong, \"\n\t\t\t\t\"numdevs=%d < group_width=%d * mirrors=%d\\n\",\n\t\t\t\ttotal_comps, layout->group_width,\n\t\t\t\tlayout->mirrors_p1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlayout->group_count = total_comps / layout->mirrors_p1 /\n\t\t\t\t\t\tlayout->group_width;\n\t} else {\n\t\tif (layout->group_depth) {\n\t\t\tprintk(KERN_NOTICE \"Warning: group_depth ignored \"\n\t\t\t\t\"group_width == 0 && group_depth == %lld\\n\",\n\t\t\t\t_LLU(layout->group_depth));\n\t\t}\n\t\tlayout->group_width = total_comps / layout->mirrors_p1;\n\t\tlayout->group_depth = -1;\n\t\tlayout->group_count = 1;\n\t}\n\n\tstripe_length = (u64)layout->group_width * layout->stripe_unit;\n\tif (stripe_length >= (1ULL << 32)) {\n\t\tORE_ERR(\"Stripe_length(0x%llx) >= 32bit is not supported\\n\",\n\t\t\t_LLU(stripe_length));\n\t\treturn -EINVAL;\n\t}\n\n\tlayout->max_io_length =\n\t\t(BIO_MAX_PAGES_KMALLOC * PAGE_SIZE - layout->stripe_unit) *\n\t\t\t\t\t(layout->group_width - layout->parity);\n\tif (layout->parity) {\n\t\tunsigned stripe_length =\n\t\t\t\t(layout->group_width - layout->parity) *\n\t\t\t\tlayout->stripe_unit;\n\n\t\tlayout->max_io_length /= stripe_length;\n\t\tlayout->max_io_length *= stripe_length;\n\t}\n\tORE_DBGMSG(\"max_io_length=0x%lx\\n\", layout->max_io_length);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint ore_verify_layout(unsigned total_comps, struct ore_layout *layout)\n{\n\tu64 stripe_length;\n\n\tswitch (layout->raid_algorithm) {\n\tcase PNFS_OSD_RAID_0:\n\t\tlayout->parity = 0;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_5:\n\t\tlayout->parity = 1;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_PQ:\n\t\tlayout->parity = 2;\n\t\tbreak;\n\tcase PNFS_OSD_RAID_4:\n\tdefault:\n\t\tORE_ERR(\"Only RAID_0/5/6 for now received-enum=%d\\n\",\n\t\t\tlayout->raid_algorithm);\n\t\treturn -EINVAL;\n\t}\n\tif (0 != (layout->stripe_unit & ~PAGE_MASK)) {\n\t\tORE_ERR(\"Stripe Unit(0x%llx)\"\n\t\t\t  \" must be Multples of PAGE_SIZE(0x%lx)\\n\",\n\t\t\t  _LLU(layout->stripe_unit), PAGE_SIZE);\n\t\treturn -EINVAL;\n\t}\n\tif (layout->group_width) {\n\t\tif (!layout->group_depth) {\n\t\t\tORE_ERR(\"group_depth == 0 && group_width != 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (total_comps < (layout->group_width * layout->mirrors_p1)) {\n\t\t\tORE_ERR(\"Data Map wrong, \"\n\t\t\t\t\"numdevs=%d < group_width=%d * mirrors=%d\\n\",\n\t\t\t\ttotal_comps, layout->group_width,\n\t\t\t\tlayout->mirrors_p1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlayout->group_count = total_comps / layout->mirrors_p1 /\n\t\t\t\t\t\tlayout->group_width;\n\t} else {\n\t\tif (layout->group_depth) {\n\t\t\tprintk(KERN_NOTICE \"Warning: group_depth ignored \"\n\t\t\t\t\"group_width == 0 && group_depth == %lld\\n\",\n\t\t\t\t_LLU(layout->group_depth));\n\t\t}\n\t\tlayout->group_width = total_comps / layout->mirrors_p1;\n\t\tlayout->group_depth = -1;\n\t\tlayout->group_count = 1;\n\t}\n\n\tstripe_length = (u64)layout->group_width * layout->stripe_unit;\n\tif (stripe_length >= (1ULL << 32)) {\n\t\tORE_ERR(\"Stripe_length(0x%llx) >= 32bit is not supported\\n\",\n\t\t\t_LLU(stripe_length));\n\t\treturn -EINVAL;\n\t}\n\n\tlayout->max_io_length =\n\t\t(BIO_MAX_PAGES_KMALLOC * PAGE_SIZE - layout->stripe_unit) *\n\t\t\t\t\t(layout->group_width - layout->parity);\n\tif (layout->parity) {\n\t\tunsigned stripe_length =\n\t\t\t\t(layout->group_width - layout->parity) *\n\t\t\t\tlayout->stripe_unit;\n\n\t\tlayout->max_io_length /= stripe_length;\n\t\tlayout->max_io_length *= stripe_length;\n\t}\n\tORE_DBGMSG(\"max_io_length=0x%lx\\n\", layout->max_io_length);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "dt->dt_data_map.cb_raid_algorithm"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "dt->dt_data_map.cb_stripe_unit"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int _read_and_match_data_map(struct exofs_sb_info *sbi, unsigned numdevs,\n\t\t\t\t    struct exofs_device_table *dt)\n{\n\tint ret;\n\n\tsbi->layout.stripe_unit =\n\t\t\t\tle64_to_cpu(dt->dt_data_map.cb_stripe_unit);\n\tsbi->layout.group_width =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_group_width);\n\tsbi->layout.group_depth =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_group_depth);\n\tsbi->layout.mirrors_p1  =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_mirror_cnt) + 1;\n\tsbi->layout.raid_algorithm  =\n\t\t\t\tle32_to_cpu(dt->dt_data_map.cb_raid_algorithm);\n\n\tret = ore_verify_layout(numdevs, &sbi->layout);\n\n\tEXOFS_DBGMSG(\"exofs: layout: \"\n\t\t\"num_comps=%u stripe_unit=0x%x group_width=%u \"\n\t\t\"group_depth=0x%llx mirrors_p1=%u raid_algorithm=%u\\n\",\n\t\tnumdevs,\n\t\tsbi->layout.stripe_unit,\n\t\tsbi->layout.group_width,\n\t\t_LLU(sbi->layout.group_depth),\n\t\tsbi->layout.mirrors_p1,\n\t\tsbi->layout.raid_algorithm);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "444-470",
    "snippet": "static void exofs_put_super(struct super_block *sb)\n{\n\tint num_pend;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\n\t/* make sure there are no pending commands */\n\tfor (num_pend = atomic_read(&sbi->s_curr_pending); num_pend > 0;\n\t     num_pend = atomic_read(&sbi->s_curr_pending)) {\n\t\twait_queue_head_t wq;\n\n\t\tprintk(KERN_NOTICE \"%s: !!Pending operations in flight. \"\n\t\t       \"This is a BUG. please report to osd-dev@open-osd.org\\n\",\n\t\t       __func__);\n\t\tinit_waitqueue_head(&wq);\n\t\twait_event_timeout(wq,\n\t\t\t\t  (atomic_read(&sbi->s_curr_pending) == 0),\n\t\t\t\t  msecs_to_jiffies(100));\n\t}\n\n\t_exofs_print_device(\"Unmounting\", NULL, ore_comp_dev(&sbi->oc, 0),\n\t\t\t    sbi->one_comp.obj.partition);\n\n\texofs_sysfs_sb_del(sbi);\n\tbdi_destroy(&sbi->bdi);\n\texofs_free_sbi(sbi);\n\tsb->s_fs_info = NULL;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_free_sbi",
          "args": [
            "sbi"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_free_sbi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "423-438",
          "snippet": "static void exofs_free_sbi(struct exofs_sb_info *sbi)\n{\n\tunsigned numdevs = sbi->oc.numdevs;\n\n\twhile (numdevs) {\n\t\tunsigned i = --numdevs;\n\t\tstruct osd_dev *od = ore_comp_dev(&sbi->oc, i);\n\n\t\tif (od) {\n\t\t\tore_comp_set_dev(&sbi->oc, i, NULL);\n\t\t\tosduld_put_device(od);\n\t\t}\n\t}\n\tkfree(sbi->oc.ods);\n\tkfree(sbi);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void exofs_free_sbi(struct exofs_sb_info *sbi)\n{\n\tunsigned numdevs = sbi->oc.numdevs;\n\n\twhile (numdevs) {\n\t\tunsigned i = --numdevs;\n\t\tstruct osd_dev *od = ore_comp_dev(&sbi->oc, i);\n\n\t\tif (od) {\n\t\t\tore_comp_set_dev(&sbi->oc, i, NULL);\n\t\t\tosduld_put_device(od);\n\t\t}\n\t}\n\tkfree(sbi->oc.ods);\n\tkfree(sbi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&sbi->bdi"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_sysfs_sb_del",
          "args": [
            "sbi"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_sysfs_sb_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/sys.c",
          "lines": "134-145",
          "snippet": "void exofs_sysfs_sb_del(struct exofs_sb_info *sbi)\n{\n\tstruct kobject *k_name, *k_tmp;\n\tstruct kobject *s_kobj = &sbi->s_kobj;\n\n\tlist_for_each_entry_safe(k_name, k_tmp, &exofs_kset->list, entry) {\n\t\t/* Remove all that are children of this SBI */\n\t\tif (k_name->parent == s_kobj)\n\t\t\tkobject_put(k_name);\n\t}\n\tkobject_put(s_kobj);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/device.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *exofs_kset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/device.h>\n#include <linux/kobject.h>\n\nstatic struct kset *exofs_kset;\n\nvoid exofs_sysfs_sb_del(struct exofs_sb_info *sbi)\n{\n\tstruct kobject *k_name, *k_tmp;\n\tstruct kobject *s_kobj = &sbi->s_kobj;\n\n\tlist_for_each_entry_safe(k_name, k_tmp, &exofs_kset->list, entry) {\n\t\t/* Remove all that are children of this SBI */\n\t\tif (k_name->parent == s_kobj)\n\t\t\tkobject_put(k_name);\n\t}\n\tkobject_put(s_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_exofs_print_device",
          "args": [
            "\"Unmounting\"",
            "NULL",
            "ore_comp_dev(&sbi->oc, 0)",
            "sbi->one_comp.obj.partition"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "_exofs_print_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "414-421",
          "snippet": "static void _exofs_print_device(const char *msg, const char *dev_path,\n\t\t\t\tstruct osd_dev *od, u64 pid)\n{\n\tconst struct osd_dev_info *odi = osduld_device_info(od);\n\n\tprintk(KERN_NOTICE \"exofs: %s %s osd_name-%s pid-0x%llx\\n\",\n\t\tmsg, dev_path ?: \"\", odi->osdname, _LLU(pid));\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void _exofs_print_device(const char *msg, const char *dev_path,\n\t\t\t\tstruct osd_dev *od, u64 pid)\n{\n\tconst struct osd_dev_info *odi = osduld_device_info(od);\n\n\tprintk(KERN_NOTICE \"exofs: %s %s osd_name-%s pid-0x%llx\\n\",\n\t\tmsg, dev_path ?: \"\", odi->osdname, _LLU(pid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ore_comp_dev",
          "args": [
            "&sbi->oc",
            "0"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "wq",
            "(atomic_read(&sbi->s_curr_pending) == 0)",
            "msecs_to_jiffies(100)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "100"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_curr_pending"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&wq"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"%s: !!Pending operations in flight. \"\n\t\t       \"This is a BUG. please report to osd-dev@open-osd.org\\n\"",
            "__func__"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_curr_pending"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sbi->s_curr_pending"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void exofs_put_super(struct super_block *sb)\n{\n\tint num_pend;\n\tstruct exofs_sb_info *sbi = sb->s_fs_info;\n\n\t/* make sure there are no pending commands */\n\tfor (num_pend = atomic_read(&sbi->s_curr_pending); num_pend > 0;\n\t     num_pend = atomic_read(&sbi->s_curr_pending)) {\n\t\twait_queue_head_t wq;\n\n\t\tprintk(KERN_NOTICE \"%s: !!Pending operations in flight. \"\n\t\t       \"This is a BUG. please report to osd-dev@open-osd.org\\n\",\n\t\t       __func__);\n\t\tinit_waitqueue_head(&wq);\n\t\twait_event_timeout(wq,\n\t\t\t\t  (atomic_read(&sbi->s_curr_pending) == 0),\n\t\t\t\t  msecs_to_jiffies(100));\n\t}\n\n\t_exofs_print_device(\"Unmounting\", NULL, ore_comp_dev(&sbi->oc, 0),\n\t\t\t    sbi->one_comp.obj.partition);\n\n\texofs_sysfs_sb_del(sbi);\n\tbdi_destroy(&sbi->bdi);\n\texofs_free_sbi(sbi);\n\tsb->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "exofs_free_sbi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "423-438",
    "snippet": "static void exofs_free_sbi(struct exofs_sb_info *sbi)\n{\n\tunsigned numdevs = sbi->oc.numdevs;\n\n\twhile (numdevs) {\n\t\tunsigned i = --numdevs;\n\t\tstruct osd_dev *od = ore_comp_dev(&sbi->oc, i);\n\n\t\tif (od) {\n\t\t\tore_comp_set_dev(&sbi->oc, i, NULL);\n\t\t\tosduld_put_device(od);\n\t\t}\n\t}\n\tkfree(sbi->oc.ods);\n\tkfree(sbi);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->oc.ods"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osduld_put_device",
          "args": [
            "od"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_comp_set_dev",
          "args": [
            "&sbi->oc",
            "i",
            "NULL"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_comp_dev",
          "args": [
            "&sbi->oc",
            "i"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void exofs_free_sbi(struct exofs_sb_info *sbi)\n{\n\tunsigned numdevs = sbi->oc.numdevs;\n\n\twhile (numdevs) {\n\t\tunsigned i = --numdevs;\n\t\tstruct osd_dev *od = ore_comp_dev(&sbi->oc, i);\n\n\t\tif (od) {\n\t\t\tore_comp_set_dev(&sbi->oc, i, NULL);\n\t\t\tosduld_put_device(od);\n\t\t}\n\t}\n\tkfree(sbi->oc.ods);\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "_exofs_print_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "414-421",
    "snippet": "static void _exofs_print_device(const char *msg, const char *dev_path,\n\t\t\t\tstruct osd_dev *od, u64 pid)\n{\n\tconst struct osd_dev_info *odi = osduld_device_info(od);\n\n\tprintk(KERN_NOTICE \"exofs: %s %s osd_name-%s pid-0x%llx\\n\",\n\t\tmsg, dev_path ?: \"\", odi->osdname, _LLU(pid));\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"exofs: %s %s osd_name-%s pid-0x%llx\\n\"",
            "msg",
            "dev_path ?: \"\"",
            "odi->osdname",
            "_LLU(pid)"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "pid"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osduld_device_info",
          "args": [
            "od"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void _exofs_print_device(const char *msg, const char *dev_path,\n\t\t\t\tstruct osd_dev *od, u64 pid)\n{\n\tconst struct osd_dev_info *odi = osduld_device_info(od);\n\n\tprintk(KERN_NOTICE \"exofs: %s %s osd_name-%s pid-0x%llx\\n\",\n\t\tmsg, dev_path ?: \"\", odi->osdname, _LLU(pid));\n}"
  },
  {
    "function_name": "exofs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "363-412",
    "snippet": "static int exofs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct exofs_sb_info *sbi;\n\tstruct exofs_fscb *fscb;\n\tstruct ore_comp one_comp;\n\tstruct ore_components oc;\n\tstruct ore_io_state *ios;\n\tint ret = -ENOMEM;\n\n\tfscb = kmalloc(sizeof(*fscb), GFP_KERNEL);\n\tif (unlikely(!fscb))\n\t\treturn -ENOMEM;\n\n\tsbi = sb->s_fs_info;\n\n\t/* NOTE: We no longer dirty the super_block anywhere in exofs. The\n\t * reason we write the fscb here on unmount is so we can stay backwards\n\t * compatible with fscb->s_version == 1. (What we are not compatible\n\t * with is if a new version FS crashed and then we try to mount an old\n\t * version). Otherwise the exofs_fscb is read-only from mkfs time. All\n\t * the writeable info is set in exofs_sbi_write_stats() above.\n\t */\n\n\texofs_init_comps(&oc, &one_comp, sbi, EXOFS_SUPER_ID);\n\n\tret = ore_get_io_state(&sbi->layout, &oc, &ios);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tios->length = offsetof(struct exofs_fscb, s_dev_table_oid);\n\tmemset(fscb, 0, ios->length);\n\tfscb->s_nextid = cpu_to_le64(sbi->s_nextid);\n\tfscb->s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tfscb->s_magic = cpu_to_le16(sb->s_magic);\n\tfscb->s_newfs = 0;\n\tfscb->s_version = EXOFS_FSCB_VER;\n\n\tios->offset = 0;\n\tios->kern_buff = fscb;\n\n\tret = ore_write(ios);\n\tif (unlikely(ret))\n\t\tEXOFS_ERR(\"%s: ore_write failed.\\n\", __func__);\n\nout:\n\tEXOFS_DBGMSG(\"s_nextid=0x%llx ret=%d\\n\", _LLU(sbi->s_nextid), ret);\n\tore_put_io_state(ios);\n\tkfree(fscb);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fscb"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"s_nextid=0x%llx ret=%d\\n\"",
            "_LLU(sbi->s_nextid)",
            "ret"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "sbi->s_nextid"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: ore_write failed.\\n\"",
            "__func__"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_write",
          "args": [
            "ios"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "sb->s_magic"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "sbi->s_numfiles"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "sbi->s_nextid"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "fscb",
            "0",
            "ios->length"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_io_state",
          "args": [
            "&sbi->layout",
            "&oc",
            "&ios"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "311-315",
          "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_init_comps",
          "args": [
            "&oc",
            "&one_comp",
            "sbi",
            "EXOFS_SUPER_ID"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_init_comps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/exofs.h",
          "lines": "224-243",
          "snippet": "static inline void exofs_init_comps(struct ore_components *oc,\n\t\t\t\t    struct ore_comp *one_comp,\n\t\t\t\t    struct exofs_sb_info *sbi, osd_id oid)\n{\n\tunsigned dev_mod = (unsigned)oid, first_dev;\n\n\tone_comp->obj.partition = sbi->one_comp.obj.partition;\n\tone_comp->obj.id = oid;\n\texofs_make_credential(one_comp->cred, &one_comp->obj);\n\n\toc->first_dev = 0;\n\toc->numdevs = sbi->layout.group_width * sbi->layout.mirrors_p1 *\n\t\t\t\t\t\t\tsbi->layout.group_count;\n\toc->single_comp = EC_SINGLE_COMP;\n\toc->comps = one_comp;\n\n\t/* Round robin device view of the table */\n\tfirst_dev = (dev_mod * sbi->layout.mirrors_p1) % sbi->oc.numdevs;\n\toc->ods = &sbi->oc.ods[first_dev];\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <scsi/osd_ore.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <scsi/osd_ore.h>\n#include <linux/backing-dev.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstatic inline void exofs_init_comps(struct ore_components *oc,\n\t\t\t\t    struct ore_comp *one_comp,\n\t\t\t\t    struct exofs_sb_info *sbi, osd_id oid)\n{\n\tunsigned dev_mod = (unsigned)oid, first_dev;\n\n\tone_comp->obj.partition = sbi->one_comp.obj.partition;\n\tone_comp->obj.id = oid;\n\texofs_make_credential(one_comp->cred, &one_comp->obj);\n\n\toc->first_dev = 0;\n\toc->numdevs = sbi->layout.group_width * sbi->layout.mirrors_p1 *\n\t\t\t\t\t\t\tsbi->layout.group_count;\n\toc->single_comp = EC_SINGLE_COMP;\n\toc->comps = one_comp;\n\n\t/* Round robin device view of the table */\n\tfirst_dev = (dev_mod * sbi->layout.mirrors_p1) % sbi->oc.numdevs;\n\toc->ods = &sbi->oc.ods[first_dev];\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fscb"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*fscb)",
            "GFP_KERNEL"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct exofs_sb_info *sbi;\n\tstruct exofs_fscb *fscb;\n\tstruct ore_comp one_comp;\n\tstruct ore_components oc;\n\tstruct ore_io_state *ios;\n\tint ret = -ENOMEM;\n\n\tfscb = kmalloc(sizeof(*fscb), GFP_KERNEL);\n\tif (unlikely(!fscb))\n\t\treturn -ENOMEM;\n\n\tsbi = sb->s_fs_info;\n\n\t/* NOTE: We no longer dirty the super_block anywhere in exofs. The\n\t * reason we write the fscb here on unmount is so we can stay backwards\n\t * compatible with fscb->s_version == 1. (What we are not compatible\n\t * with is if a new version FS crashed and then we try to mount an old\n\t * version). Otherwise the exofs_fscb is read-only from mkfs time. All\n\t * the writeable info is set in exofs_sbi_write_stats() above.\n\t */\n\n\texofs_init_comps(&oc, &one_comp, sbi, EXOFS_SUPER_ID);\n\n\tret = ore_get_io_state(&sbi->layout, &oc, &ios);\n\tif (unlikely(ret))\n\t\tgoto out;\n\n\tios->length = offsetof(struct exofs_fscb, s_dev_table_oid);\n\tmemset(fscb, 0, ios->length);\n\tfscb->s_nextid = cpu_to_le64(sbi->s_nextid);\n\tfscb->s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tfscb->s_magic = cpu_to_le16(sb->s_magic);\n\tfscb->s_newfs = 0;\n\tfscb->s_version = EXOFS_FSCB_VER;\n\n\tios->offset = 0;\n\tios->kern_buff = fscb;\n\n\tret = ore_write(ios);\n\tif (unlikely(ret))\n\t\tEXOFS_ERR(\"%s: ore_write failed.\\n\", __func__);\n\nout:\n\tEXOFS_DBGMSG(\"s_nextid=0x%llx ret=%d\\n\", _LLU(sbi->s_nextid), ret);\n\tore_put_io_state(ios);\n\tkfree(fscb);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_sbi_write_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "321-352",
    "snippet": "int exofs_sbi_write_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsbi->s_ess.s_nextid   = cpu_to_le64(sbi->s_nextid);\n\tsbi->s_ess.s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tattrs[0].val_ptr = &sbi->s_ess;\n\n\n\tios->done = stats_done;\n\tios->private = sbi;\n\tios->out_attr = attrs;\n\tios->out_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_write failed.\\n\", __func__);\n\t\tore_put_io_state(ios);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: ore_write failed.\\n\"",
            "__func__"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_write",
          "args": [
            "ios"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "attrs"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "sbi->s_numfiles"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "sbi->s_nextid"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: ore_get_io_state failed.\\n\"",
            "__func__"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_io_state",
          "args": [
            "&sbi->layout",
            "&sbi->oc",
            "&ios"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "311-315",
          "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));\n\nint exofs_sbi_write_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsbi->s_ess.s_nextid   = cpu_to_le64(sbi->s_nextid);\n\tsbi->s_ess.s_numfiles = cpu_to_le64(sbi->s_numfiles);\n\tattrs[0].val_ptr = &sbi->s_ess;\n\n\n\tios->done = stats_done;\n\tios->private = sbi;\n\tios->out_attr = attrs;\n\tios->out_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_write(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_write failed.\\n\", __func__);\n\t\tore_put_io_state(ios);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "stats_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "314-318",
    "snippet": "static void stats_done(struct ore_io_state *ios, void *p)\n{\n\tore_put_io_state(ios);\n\t/* Good thanks nothing to do anymore */\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void stats_done(struct ore_io_state *ios, void *p)\n{\n\tore_put_io_state(ios);\n\t/* Good thanks nothing to do anymore */\n}"
  },
  {
    "function_name": "__sbi_read_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "266-312",
    "snippet": "static int __sbi_read_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"Error reading super_block stats => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr of sb_stats failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[0].len) {\n\t\tstruct exofs_sb_stats *ess;\n\n\t\tif (unlikely(attrs[0].len != sizeof(*ess))) {\n\t\t\tEXOFS_ERR(\"%s: Wrong version of exofs_sb_stats \"\n\t\t\t\t  \"size(%d) != expected(%zd)\\n\",\n\t\t\t\t  __func__, attrs[0].len, sizeof(*ess));\n\t\t\tgoto out;\n\t\t}\n\n\t\tess = attrs[0].val_ptr;\n\t\tsbi->s_nextid = le64_to_cpu(ess->s_nextid);\n\t\tsbi->s_numfiles = le32_to_cpu(ess->s_numfiles);\n\t}\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ore_put_io_state",
          "args": [
            "ios"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ore_put_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "318-335",
          "snippet": "void ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nvoid ore_put_io_state(struct ore_io_state *ios)\n{\n\tif (ios) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ios->numdevs; i++) {\n\t\t\tstruct ore_per_dev_state *per_dev = &ios->per_dev[i];\n\n\t\t\tif (per_dev->or)\n\t\t\t\tosd_end_request(per_dev->or);\n\t\t\tif (per_dev->bio)\n\t\t\t\tbio_put(per_dev->bio);\n\t\t}\n\n\t\t_ore_free_raid_stuff(ios);\n\t\tkfree(ios);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ess->s_numfiles"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "ess->s_nextid"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: Wrong version of exofs_sb_stats \"\n\t\t\t\t  \"size(%d) != expected(%zd)\\n\"",
            "__func__",
            "attrs[0].len",
            "sizeof(*ess)"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "attrs[0].len != sizeof(*ess)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: extract_attr of sb_stats failed\\n\"",
            "__func__"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extract_attr_from_ios",
          "args": [
            "ios",
            "&attrs[0]"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"Error reading super_block stats => %d\\n\"",
            "ret"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_read",
          "args": [
            "ios"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "attrs"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"%s: ore_get_io_state failed.\\n\"",
            "__func__"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ore_get_io_state",
          "args": [
            "&sbi->layout",
            "&sbi->oc",
            "&ios"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ore_get_io_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/ore.c",
          "lines": "311-315",
          "snippet": "int  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}",
          "includes": [
            "#include \"ore_raid.h\"",
            "#include <linux/lcm.h>",
            "#include <asm/div64.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ore_raid.h\"\n#include <linux/lcm.h>\n#include <asm/div64.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint  ore_get_io_state(struct ore_layout *layout, struct ore_components *oc,\n\t\t      struct ore_io_state **pios)\n{\n\treturn _ore_get_io_state(layout, oc, oc->numdevs, 0, 0, pios);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic const struct osd_attr g_attr_sb_stats = ATTR_DEF(\n\tEXOFS_APAGE_SB_DATA,\n\tEXOFS_ATTR_SB_STATS,\n\tsizeof(struct exofs_sb_stats));\n\nstatic int __sbi_read_stats(struct exofs_sb_info *sbi)\n{\n\tstruct osd_attr attrs[] = {\n\t\t[0] = g_attr_sb_stats,\n\t};\n\tstruct ore_io_state *ios;\n\tint ret;\n\n\tret = ore_get_io_state(&sbi->layout, &sbi->oc, &ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"%s: ore_get_io_state failed.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tios->in_attr = attrs;\n\tios->in_attr_len = ARRAY_SIZE(attrs);\n\n\tret = ore_read(ios);\n\tif (unlikely(ret)) {\n\t\tEXOFS_ERR(\"Error reading super_block stats => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = extract_attr_from_ios(ios, &attrs[0]);\n\tif (ret) {\n\t\tEXOFS_ERR(\"%s: extract_attr of sb_stats failed\\n\", __func__);\n\t\tgoto out;\n\t}\n\tif (attrs[0].len) {\n\t\tstruct exofs_sb_stats *ess;\n\n\t\tif (unlikely(attrs[0].len != sizeof(*ess))) {\n\t\t\tEXOFS_ERR(\"%s: Wrong version of exofs_sb_stats \"\n\t\t\t\t  \"size(%d) != expected(%zd)\\n\",\n\t\t\t\t  __func__, attrs[0].len, sizeof(*ess));\n\t\t\tgoto out;\n\t\t}\n\n\t\tess = attrs[0].val_ptr;\n\t\tsbi->s_nextid = le64_to_cpu(ess->s_nextid);\n\t\tsbi->s_numfiles = le32_to_cpu(ess->s_numfiles);\n\t}\n\nout:\n\tore_put_io_state(ios);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_read_kern",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "225-259",
    "snippet": "static int exofs_read_kern(struct osd_dev *od, u8 *cred, struct osd_obj_id *obj,\n\t\t    u64 offset, void *p, unsigned length)\n{\n\tstruct osd_request *or = osd_start_request(od, GFP_KERNEL);\n/*\tstruct osd_sense_info osi = {.key = 0};*/\n\tint ret;\n\n\tif (unlikely(!or)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_start_request failed.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tret = osd_req_read_kern(or, obj, offset, p, length);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_req_read_kern failed.\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tret = osd_finalize_request(or, 0, cred, NULL);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = osd_execute_request(or);\n\tif (unlikely(ret))\n\t\tEXOFS_DBGMSG(\"osd_execute_request() => %d\\n\", ret);\n\t/* osd_req_decode_sense(or, ret); */\n\nout:\n\tosd_end_request(or);\n\tEXOFS_DBGMSG2(\"read_kern(0x%llx) offset=0x%llx \"\n\t\t      \"length=0x%llx dev=%p ret=>%d\\n\",\n\t\t      _LLU(obj->id), _LLU(offset), _LLU(length), od, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG2",
          "args": [
            "\"read_kern(0x%llx) offset=0x%llx \"\n\t\t      \"length=0x%llx dev=%p ret=>%d\\n\"",
            "_LLU(obj->id)",
            "_LLU(offset)",
            "_LLU(length)",
            "od",
            "ret"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "length"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "offset"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "obj->id"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_end_request",
          "args": [
            "or"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"osd_execute_request() => %d\\n\"",
            "ret"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_execute_request",
          "args": [
            "or"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"Failed to osd_finalize_request() => %d\\n\"",
            "ret"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_finalize_request",
          "args": [
            "or",
            "0",
            "cred",
            "NULL"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"%s: osd_req_read_kern failed.\\n\"",
            "__func__"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_req_read_kern",
          "args": [
            "or",
            "obj",
            "offset",
            "p",
            "length"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"%s: osd_start_request failed.\\n\"",
            "__func__"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!or"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osd_start_request",
          "args": [
            "od",
            "GFP_KERNEL"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic int exofs_read_kern(struct osd_dev *od, u8 *cred, struct osd_obj_id *obj,\n\t\t    u64 offset, void *p, unsigned length)\n{\n\tstruct osd_request *or = osd_start_request(od, GFP_KERNEL);\n/*\tstruct osd_sense_info osi = {.key = 0};*/\n\tint ret;\n\n\tif (unlikely(!or)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_start_request failed.\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tret = osd_req_read_kern(or, obj, offset, p, length);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"%s: osd_req_read_kern failed.\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tret = osd_finalize_request(or, 0, cred, NULL);\n\tif (unlikely(ret)) {\n\t\tEXOFS_DBGMSG(\"Failed to osd_finalize_request() => %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = osd_execute_request(or);\n\tif (unlikely(ret))\n\t\tEXOFS_DBGMSG(\"osd_execute_request() => %d\\n\", ret);\n\t/* osd_req_decode_sense(or, ret); */\n\nout:\n\tosd_end_request(or);\n\tEXOFS_DBGMSG2(\"read_kern(0x%llx) offset=0x%llx \"\n\t\t      \"length=0x%llx dev=%p ret=>%d\\n\",\n\t\t      _LLU(obj->id), _LLU(offset), _LLU(length), od, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "exofs_make_credential",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "220-223",
    "snippet": "void exofs_make_credential(u8 cred_a[OSD_CAP_LEN], const struct osd_obj_id *obj)\n{\n\tosd_sec_init_nosec_doall_caps(cred_a, obj, false, true);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osd_sec_init_nosec_doall_caps",
          "args": [
            "cred_a",
            "obj",
            "false",
            "true"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nvoid exofs_make_credential(u8 cred_a[OSD_CAP_LEN], const struct osd_obj_id *obj)\n{\n\tosd_sec_init_nosec_doall_caps(cred_a, obj, false, true);\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "207-215",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(exofs_inode_cachep);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *exofs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "exofs_inode_cachep"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *exofs_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(exofs_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "193-202",
    "snippet": "static int init_inodecache(void)\n{\n\texofs_inode_cachep = kmem_cache_create(\"exofs_inode_cache\",\n\t\t\t\tsizeof(struct exofs_i_info), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\texofs_init_once);\n\tif (exofs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *exofs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"exofs_inode_cache\"",
            "sizeof(struct exofs_i_info)",
            "0",
            "SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD",
            "exofs_init_once"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *exofs_inode_cachep;\n\nstatic int init_inodecache(void)\n{\n\texofs_inode_cachep = kmem_cache_create(\"exofs_inode_cache\",\n\t\t\t\tsizeof(struct exofs_i_info), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\texofs_init_once);\n\tif (exofs_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "exofs_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "183-188",
    "snippet": "static void exofs_init_once(void *foo)\n{\n\tstruct exofs_i_info *oi = foo;\n\n\tinode_init_once(&oi->vfs_inode);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&oi->vfs_inode"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "1725-1755",
          "snippet": "static void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int ocfs2_remount(struct super_block *sb, int *flags, char *data);\n\nstatic void ocfs2_inode_init_once(void *data)\n{\n\tstruct ocfs2_inode_info *oi = data;\n\n\toi->ip_flags = 0;\n\toi->ip_open_count = 0;\n\tspin_lock_init(&oi->ip_lock);\n\tocfs2_extent_map_init(&oi->vfs_inode);\n\tINIT_LIST_HEAD(&oi->ip_io_markers);\n\toi->ip_dir_start_lookup = 0;\n\tmutex_init(&oi->ip_unaligned_aio);\n\tinit_rwsem(&oi->ip_alloc_sem);\n\tinit_rwsem(&oi->ip_xattr_sem);\n\tmutex_init(&oi->ip_io_mutex);\n\n\toi->ip_blkno = 0ULL;\n\toi->ip_clusters = 0;\n\n\tocfs2_resv_init_once(&oi->ip_la_data_resv);\n\n\tocfs2_lock_res_init_once(&oi->ip_rw_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_inode_lockres);\n\tocfs2_lock_res_init_once(&oi->ip_open_lockres);\n\n\tinit_waitqueue_head(&oi->append_dio_wq);\n\n\tocfs2_metadata_cache_init(INODE_CACHE(&oi->vfs_inode),\n\t\t\t\t  &ocfs2_inode_caching_ops);\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void exofs_init_once(void *foo)\n{\n\tstruct exofs_i_info *oi = foo;\n\n\tinode_init_once(&oi->vfs_inode);\n}"
  },
  {
    "function_name": "exofs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "175-178",
    "snippet": "static void exofs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, exofs_i_callback);\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "exofs_i_callback"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void exofs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, exofs_i_callback);\n}"
  },
  {
    "function_name": "exofs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "166-170",
    "snippet": "static void exofs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(exofs_inode_cachep, exofs_i(inode));\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *exofs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "exofs_inode_cachep",
            "exofs_i(inode)"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "inode"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
          "lines": "183-188",
          "snippet": "static void exofs_init_once(void *foo)\n{\n\tstruct exofs_i_info *oi = foo;\n\n\tinode_init_once(&oi->vfs_inode);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/random.h>",
            "#include <linux/vfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic void exofs_init_once(void *foo)\n{\n\tstruct exofs_i_info *oi = foo;\n\n\tinode_init_once(&oi->vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *exofs_inode_cachep;\n\nstatic void exofs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(exofs_inode_cachep, exofs_i(inode));\n}"
  },
  {
    "function_name": "exofs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "154-164",
    "snippet": "static struct inode *exofs_alloc_inode(struct super_block *sb)\n{\n\tstruct exofs_i_info *oi;\n\n\toi = kmem_cache_alloc(exofs_inode_cachep, GFP_KERNEL);\n\tif (!oi)\n\t\treturn NULL;\n\n\toi->vfs_inode.i_version = 1;\n\treturn &oi->vfs_inode;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *exofs_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "exofs_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic struct kmem_cache *exofs_inode_cachep;\n\nstatic struct inode *exofs_alloc_inode(struct super_block *sb)\n{\n\tstruct exofs_i_info *oi;\n\n\toi = kmem_cache_alloc(exofs_inode_cachep, GFP_KERNEL);\n\tif (!oi)\n\t\treturn NULL;\n\n\toi->vfs_inode.i_version = 1;\n\treturn &oi->vfs_inode;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/super.c",
    "lines": "81-140",
    "snippet": "static int parse_options(char *options, struct exofs_mountopt *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tbool s_pid = false;\n\n\tEXOFS_DBGMSG(\"parse_options %s\\n\", options);\n\t/* defaults */\n\tmemset(opts, 0, sizeof(*opts));\n\topts->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tchar str[32];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_name:\n\t\t\topts->dev_name = match_strdup(&args[0]);\n\t\t\tif (unlikely(!opts->dev_name)) {\n\t\t\t\tEXOFS_ERR(\"Error allocating dev_name\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\topts->is_osdname = true;\n\t\t\tbreak;\n\t\tcase Opt_pid:\n\t\t\tif (0 == match_strlcpy(str, &args[0], sizeof(str)))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->pid = simple_strtoull(str, NULL, 0);\n\t\t\tif (opts->pid < EXOFS_MIN_PID) {\n\t\t\t\tEXOFS_ERR(\"Partition ID must be >= %u\",\n\t\t\t\t\t  EXOFS_MIN_PID);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ts_pid = 1;\n\t\t\tbreak;\n\t\tcase Opt_to:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (option <= 0) {\n\t\t\t\tEXOFS_ERR(\"Timout must be > 0\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\topts->timeout = option * HZ;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!s_pid) {\n\t\tEXOFS_ERR(\"Need to specify the following options:\\n\");\n\t\tEXOFS_ERR(\"    -o pid=pid_no_to_use\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\"",
      "#include <linux/slab.h>",
      "#include <linux/exportfs.h>",
      "#include <linux/module.h>",
      "#include <linux/random.h>",
      "#include <linux/vfs.h>",
      "#include <linux/parser.h>",
      "#include <linux/string.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static match_table_t tokens = {\n\t{Opt_name, \"osdname=%s\"},\n\t{Opt_pid, \"pid=%u\"},\n\t{Opt_to, \"to=%u\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"    -o pid=pid_no_to_use\\n\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"Need to specify the following options:\\n\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"Timout must be > 0\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"Partition ID must be >= %u\"",
            "EXOFS_MIN_PID"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "str",
            "NULL",
            "0"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strlcpy",
          "args": [
            "str",
            "&args[0]",
            "sizeof(str)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"Error allocating dev_name\""
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!opts->dev_name"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "opts",
            "0",
            "sizeof(*opts)"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DBGMSG",
          "args": [
            "\"parse_options %s\\n\"",
            "options"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/random.h>\n#include <linux/vfs.h>\n#include <linux/parser.h>\n#include <linux/string.h>\n\nstatic match_table_t tokens = {\n\t{Opt_name, \"osdname=%s\"},\n\t{Opt_pid, \"pid=%u\"},\n\t{Opt_to, \"to=%u\"},\n\t{Opt_err, NULL}\n};\n\nstatic int parse_options(char *options, struct exofs_mountopt *opts)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\tbool s_pid = false;\n\n\tEXOFS_DBGMSG(\"parse_options %s\\n\", options);\n\t/* defaults */\n\tmemset(opts, 0, sizeof(*opts));\n\topts->timeout = BLK_DEFAULT_SG_TIMEOUT;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tchar str[32];\n\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_name:\n\t\t\topts->dev_name = match_strdup(&args[0]);\n\t\t\tif (unlikely(!opts->dev_name)) {\n\t\t\t\tEXOFS_ERR(\"Error allocating dev_name\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\topts->is_osdname = true;\n\t\t\tbreak;\n\t\tcase Opt_pid:\n\t\t\tif (0 == match_strlcpy(str, &args[0], sizeof(str)))\n\t\t\t\treturn -EINVAL;\n\t\t\topts->pid = simple_strtoull(str, NULL, 0);\n\t\t\tif (opts->pid < EXOFS_MIN_PID) {\n\t\t\t\tEXOFS_ERR(\"Partition ID must be >= %u\",\n\t\t\t\t\t  EXOFS_MIN_PID);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\ts_pid = 1;\n\t\t\tbreak;\n\t\tcase Opt_to:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (option <= 0) {\n\t\t\t\tEXOFS_ERR(\"Timout must be > 0\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\topts->timeout = option * HZ;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!s_pid) {\n\t\tEXOFS_ERR(\"Need to specify the following options:\\n\");\n\t\tEXOFS_ERR(\"    -o pid=pid_no_to_use\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  }
]