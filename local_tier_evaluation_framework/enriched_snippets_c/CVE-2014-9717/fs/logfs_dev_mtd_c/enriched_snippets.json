[
  {
    "function_name": "logfs_get_sb_mtd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "264-274",
    "snippet": "int logfs_get_sb_mtd(struct logfs_super *s, int mtdnr)\n{\n\tstruct mtd_info *mtd = get_mtd_device(NULL, mtdnr);\n\tif (IS_ERR(mtd))\n\t\treturn PTR_ERR(mtd);\n\n\ts->s_bdev = NULL;\n\ts->s_mtd = mtd;\n\ts->s_devops = &mtd_devops;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct logfs_device_ops mtd_devops = {\n\t.find_first_sb\t= logfs_mtd_find_first_sb,\n\t.find_last_sb\t= logfs_mtd_find_last_sb,\n\t.readpage\t= logfs_mtd_readpage,\n\t.writeseg\t= logfs_mtd_writeseg,\n\t.erase\t\t= logfs_mtd_erase,\n\t.can_write_buf\t= logfs_mtd_can_write_buf,\n\t.sync\t\t= logfs_mtd_sync,\n\t.put_device\t= logfs_mtd_put_device,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mtd"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mtd"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mtd_device",
          "args": [
            "NULL",
            "mtdnr"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic const struct logfs_device_ops mtd_devops = {\n\t.find_first_sb\t= logfs_mtd_find_first_sb,\n\t.find_last_sb\t= logfs_mtd_find_last_sb,\n\t.readpage\t= logfs_mtd_readpage,\n\t.writeseg\t= logfs_mtd_writeseg,\n\t.erase\t\t= logfs_mtd_erase,\n\t.can_write_buf\t= logfs_mtd_can_write_buf,\n\t.sync\t\t= logfs_mtd_sync,\n\t.put_device\t= logfs_mtd_put_device,\n};\n\nint logfs_get_sb_mtd(struct logfs_super *s, int mtdnr)\n{\n\tstruct mtd_info *mtd = get_mtd_device(NULL, mtdnr);\n\tif (IS_ERR(mtd))\n\t\treturn PTR_ERR(mtd);\n\n\ts->s_bdev = NULL;\n\ts->s_mtd = mtd;\n\ts->s_devops = &mtd_devops;\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_mtd_can_write_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "234-251",
    "snippet": "static int logfs_mtd_can_write_buf(struct super_block *sb, u64 ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tvoid *buf;\n\tint err;\n\n\tbuf = kmalloc(super->s_writesize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = logfs_mtd_read(sb, ofs, super->s_writesize, buf);\n\tif (err)\n\t\tgoto out;\n\tif (memchr_inv(buf, 0xff, super->s_writesize))\n\t\terr = -EIO;\n\tkfree(buf);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "buf",
            "0xff",
            "super->s_writesize"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_mtd_read",
          "args": [
            "sb",
            "ofs",
            "super->s_writesize",
            "buf"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mtd_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "16-33",
          "snippet": "static int logfs_mtd_read(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\tsize_t retlen;\n\tint ret;\n\n\tret = mtd_read(mtd, ofs, len, &retlen, buf);\n\tBUG_ON(ret == -EINVAL);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Not sure if we should loop instead. */\n\tif (retlen != len)\n\t\treturn -EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/completion.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int logfs_mtd_read(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\tsize_t retlen;\n\tint ret;\n\n\tret = mtd_read(mtd, ofs, len, &retlen, buf);\n\tBUG_ON(ret == -EINVAL);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Not sure if we should loop instead. */\n\tif (retlen != len)\n\t\treturn -EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "super->s_writesize",
            "GFP_KERNEL"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int logfs_mtd_can_write_buf(struct super_block *sb, u64 ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tvoid *buf;\n\tint err;\n\n\tbuf = kmalloc(super->s_writesize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\terr = logfs_mtd_read(sb, ofs, super->s_writesize, buf);\n\tif (err)\n\t\tgoto out;\n\tif (memchr_inv(buf, 0xff, super->s_writesize))\n\t\terr = -EIO;\n\tkfree(buf);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "logfs_mtd_put_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "229-232",
    "snippet": "static void logfs_mtd_put_device(struct logfs_super *s)\n{\n\tput_mtd_device(s->s_mtd);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_mtd_device",
          "args": [
            "s->s_mtd"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic void logfs_mtd_put_device(struct logfs_super *s)\n{\n\tput_mtd_device(s->s_mtd);\n}"
  },
  {
    "function_name": "logfs_mtd_writeseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "205-227",
    "snippet": "static void logfs_mtd_writeseg(struct super_block *sb, u64 ofs, size_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint head;\n\n\tif (super->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn;\n\n\tif (len == 0) {\n\t\t/* This can happen when the object fit perfectly into a\n\t\t * segment, the segment gets written per sync and subsequently\n\t\t * closed.\n\t\t */\n\t\treturn;\n\t}\n\thead = ofs & (PAGE_SIZE - 1);\n\tif (head) {\n\t\tofs -= head;\n\t\tlen += head;\n\t}\n\tlen = PAGE_ALIGN(len);\n\t__logfs_mtd_writeseg(sb, ofs, ofs >> PAGE_SHIFT, len >> PAGE_SHIFT);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_mtd_writeseg",
          "args": [
            "sb",
            "ofs",
            "ofs >> PAGE_SHIFT",
            "len >> PAGE_SHIFT"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_mtd_writeseg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "183-203",
          "snippet": "static int __logfs_mtd_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tint i, err;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = find_lock_page(mapping, index + i);\n\t\tBUG_ON(!page);\n\n\t\terr = loffs_mtd_write(sb, page->index << PAGE_SHIFT, PAGE_SIZE,\n\t\t\t\t\tpage_address(page));\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/completion.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int __logfs_mtd_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tint i, err;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = find_lock_page(mapping, index + i);\n\t\tBUG_ON(!page);\n\n\t\terr = loffs_mtd_write(sb, page->index << PAGE_SHIFT, PAGE_SIZE,\n\t\t\t\t\tpage_address(page));\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "len"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic void logfs_mtd_writeseg(struct super_block *sb, u64 ofs, size_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tint head;\n\n\tif (super->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn;\n\n\tif (len == 0) {\n\t\t/* This can happen when the object fit perfectly into a\n\t\t * segment, the segment gets written per sync and subsequently\n\t\t * closed.\n\t\t */\n\t\treturn;\n\t}\n\thead = ofs & (PAGE_SIZE - 1);\n\tif (head) {\n\t\tofs -= head;\n\t\tlen += head;\n\t}\n\tlen = PAGE_ALIGN(len);\n\t__logfs_mtd_writeseg(sb, ofs, ofs >> PAGE_SHIFT, len >> PAGE_SHIFT);\n}"
  },
  {
    "function_name": "__logfs_mtd_writeseg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "183-203",
    "snippet": "static int __logfs_mtd_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tint i, err;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = find_lock_page(mapping, index + i);\n\t\tBUG_ON(!page);\n\n\t\terr = loffs_mtd_write(sb, page->index << PAGE_SHIFT, PAGE_SIZE,\n\t\t\t\t\tpage_address(page));\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loffs_mtd_write",
          "args": [
            "sb",
            "page->index << PAGE_SHIFT",
            "PAGE_SIZE",
            "page_address(page)"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "loffs_mtd_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "35-57",
          "snippet": "static int loffs_mtd_write(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct mtd_info *mtd = super->s_mtd;\n\tsize_t retlen;\n\tloff_t page_start, page_end;\n\tint ret;\n\n\tif (super->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn -EROFS;\n\n\tBUG_ON((ofs >= mtd->size) || (len > mtd->size - ofs));\n\tBUG_ON(ofs != (ofs >> super->s_writeshift) << super->s_writeshift);\n\tBUG_ON(len > PAGE_CACHE_SIZE);\n\tpage_start = ofs & PAGE_CACHE_MASK;\n\tpage_end = PAGE_CACHE_ALIGN(ofs + len) - 1;\n\tret = mtd_write(mtd, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len))\n\t\treturn -EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/completion.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int loffs_mtd_write(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct mtd_info *mtd = super->s_mtd;\n\tsize_t retlen;\n\tloff_t page_start, page_end;\n\tint ret;\n\n\tif (super->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn -EROFS;\n\n\tBUG_ON((ofs >= mtd->size) || (len > mtd->size - ofs));\n\tBUG_ON(ofs != (ofs >> super->s_writeshift) << super->s_writeshift);\n\tBUG_ON(len > PAGE_CACHE_SIZE);\n\tpage_start = ofs & PAGE_CACHE_MASK;\n\tpage_end = PAGE_CACHE_ALIGN(ofs + len) - 1;\n\tret = mtd_write(mtd, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len))\n\t\treturn -EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "index + i"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int __logfs_mtd_writeseg(struct super_block *sb, u64 ofs, pgoff_t index,\n\t\tsize_t nr_pages)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tint i, err;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\tpage = find_lock_page(mapping, index + i);\n\t\tBUG_ON(!page);\n\n\t\terr = loffs_mtd_write(sb, page->index << PAGE_SHIFT, PAGE_SIZE,\n\t\t\t\t\tpage_address(page));\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_mtd_find_last_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "165-181",
    "snippet": "static struct page *logfs_mtd_find_last_sb(struct super_block *sb, u64 *ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = logfs_mtd_readpage;\n\tstruct mtd_info *mtd = super->s_mtd;\n\n\t*ofs = mtd->size - mtd->erasesize;\n\twhile (mtd_block_isbad(mtd, *ofs)) {\n\t\t*ofs -= mtd->erasesize;\n\t\tif (*ofs <= 0)\n\t\t\treturn NULL;\n\t}\n\t*ofs = *ofs + mtd->erasesize - 0x1000;\n\tBUG_ON(*ofs & ~PAGE_MASK);\n\treturn read_cache_page(mapping, *ofs >> PAGE_SHIFT, filler, sb);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "mapping",
            "*ofs >> PAGE_SHIFT",
            "filler",
            "sb"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*ofs & ~PAGE_MASK"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtd_block_isbad",
          "args": [
            "mtd",
            "*ofs"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_mtd_find_last_sb(struct super_block *sb, u64 *ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = logfs_mtd_readpage;\n\tstruct mtd_info *mtd = super->s_mtd;\n\n\t*ofs = mtd->size - mtd->erasesize;\n\twhile (mtd_block_isbad(mtd, *ofs)) {\n\t\t*ofs -= mtd->erasesize;\n\t\tif (*ofs <= 0)\n\t\t\treturn NULL;\n\t}\n\t*ofs = *ofs + mtd->erasesize - 0x1000;\n\tBUG_ON(*ofs & ~PAGE_MASK);\n\treturn read_cache_page(mapping, *ofs >> PAGE_SHIFT, filler, sb);\n}"
  },
  {
    "function_name": "logfs_mtd_find_first_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "148-163",
    "snippet": "static struct page *logfs_mtd_find_first_sb(struct super_block *sb, u64 *ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = logfs_mtd_readpage;\n\tstruct mtd_info *mtd = super->s_mtd;\n\n\t*ofs = 0;\n\twhile (mtd_block_isbad(mtd, *ofs)) {\n\t\t*ofs += mtd->erasesize;\n\t\tif (*ofs >= mtd->size)\n\t\t\treturn NULL;\n\t}\n\tBUG_ON(*ofs & ~PAGE_MASK);\n\treturn read_cache_page(mapping, *ofs >> PAGE_SHIFT, filler, sb);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "mapping",
            "*ofs >> PAGE_SHIFT",
            "filler",
            "sb"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "*ofs & ~PAGE_MASK"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtd_block_isbad",
          "args": [
            "mtd",
            "*ofs"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic struct page *logfs_mtd_find_first_sb(struct super_block *sb, u64 *ofs)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tfiller_t *filler = logfs_mtd_readpage;\n\tstruct mtd_info *mtd = super->s_mtd;\n\n\t*ofs = 0;\n\twhile (mtd_block_isbad(mtd, *ofs)) {\n\t\t*ofs += mtd->erasesize;\n\t\tif (*ofs >= mtd->size)\n\t\t\treturn NULL;\n\t}\n\tBUG_ON(*ofs & ~PAGE_MASK);\n\treturn read_cache_page(mapping, *ofs >> PAGE_SHIFT, filler, sb);\n}"
  },
  {
    "function_name": "logfs_mtd_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "125-146",
    "snippet": "static int logfs_mtd_readpage(void *_sb, struct page *page)\n{\n\tstruct super_block *sb = _sb;\n\tint err;\n\n\terr = logfs_mtd_read(sb, page->index << PAGE_SHIFT, PAGE_SIZE,\n\t\t\tpage_address(page));\n\tif (err == -EUCLEAN || err == -EBADMSG) {\n\t\t/* -EBADMSG happens regularly on power failures */\n\t\terr = 0;\n\t\t/* FIXME: force GC this segment */\n\t}\n\tif (err) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ClearPageError",
          "args": [
            "page"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ClearPageUptodate",
          "args": [
            "page"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_mtd_read",
          "args": [
            "sb",
            "page->index << PAGE_SHIFT",
            "PAGE_SIZE",
            "page_address(page)"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mtd_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "16-33",
          "snippet": "static int logfs_mtd_read(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\tsize_t retlen;\n\tint ret;\n\n\tret = mtd_read(mtd, ofs, len, &retlen, buf);\n\tBUG_ON(ret == -EINVAL);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Not sure if we should loop instead. */\n\tif (retlen != len)\n\t\treturn -EIO;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/completion.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int logfs_mtd_read(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\tsize_t retlen;\n\tint ret;\n\n\tret = mtd_read(mtd, ofs, len, &retlen, buf);\n\tBUG_ON(ret == -EINVAL);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Not sure if we should loop instead. */\n\tif (retlen != len)\n\t\treturn -EIO;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int logfs_mtd_readpage(void *_sb, struct page *page)\n{\n\tstruct super_block *sb = _sb;\n\tint err;\n\n\terr = logfs_mtd_read(sb, page->index << PAGE_SHIFT, PAGE_SIZE,\n\t\t\tpage_address(page));\n\tif (err == -EUCLEAN || err == -EBADMSG) {\n\t\t/* -EBADMSG happens regularly on power failures */\n\t\terr = 0;\n\t\t/* FIXME: force GC this segment */\n\t}\n\tif (err) {\n\t\tClearPageUptodate(page);\n\t\tSetPageError(page);\n\t} else {\n\t\tSetPageUptodate(page);\n\t\tClearPageError(page);\n\t}\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "logfs_mtd_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "118-123",
    "snippet": "static void logfs_mtd_sync(struct super_block *sb)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\n\tmtd_sync(mtd);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtd_sync",
          "args": [
            "mtd"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mtd_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "118-123",
          "snippet": "static void logfs_mtd_sync(struct super_block *sb)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\n\tmtd_sync(mtd);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic void logfs_mtd_sync(struct super_block *sb)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\n\tmtd_sync(mtd);\n}"
  },
  {
    "function_name": "logfs_mtd_erase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "90-116",
    "snippet": "static int logfs_mtd_erase(struct super_block *sb, loff_t ofs, size_t len,\n\t\tint ensure_write)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\tstruct erase_info ei;\n\tDECLARE_COMPLETION_ONSTACK(complete);\n\tint ret;\n\n\tBUG_ON(len % mtd->erasesize);\n\tif (logfs_super(sb)->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn -EROFS;\n\n\tmemset(&ei, 0, sizeof(ei));\n\tei.mtd = mtd;\n\tei.addr = ofs;\n\tei.len = len;\n\tei.callback = logfs_erase_callback;\n\tei.priv = (long)&complete;\n\tret = mtd_erase(mtd, &ei);\n\tif (ret)\n\t\treturn -EIO;\n\n\twait_for_completion(&complete);\n\tif (ei.state != MTD_ERASE_DONE)\n\t\treturn -EIO;\n\treturn logfs_mtd_erase_mapping(sb, ofs, len);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_mtd_erase_mapping",
          "args": [
            "sb",
            "ofs",
            "len"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_mtd_erase_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
          "lines": "72-88",
          "snippet": "static int logfs_mtd_erase_mapping(struct super_block *sb, loff_t ofs,\n\t\t\t\tsize_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\n\tfor (index = ofs >> PAGE_SHIFT; index < (ofs + len) >> PAGE_SHIFT; index++) {\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tmemset(page_address(page), 0xFF, PAGE_SIZE);\n\t\tpage_cache_release(page);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/completion.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int logfs_mtd_erase_mapping(struct super_block *sb, loff_t ofs,\n\t\t\t\tsize_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\n\tfor (index = ofs >> PAGE_SHIFT; index < (ofs + len) >> PAGE_SHIFT; index++) {\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tmemset(page_address(page), 0xFF, PAGE_SIZE);\n\t\tpage_cache_release(page);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&complete"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mtd_erase",
          "args": [
            "mtd",
            "&ei"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ei",
            "0",
            "sizeof(ei)"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len % mtd->erasesize"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_COMPLETION_ONSTACK",
          "args": [
            "complete"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int logfs_mtd_erase(struct super_block *sb, loff_t ofs, size_t len,\n\t\tint ensure_write)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\tstruct erase_info ei;\n\tDECLARE_COMPLETION_ONSTACK(complete);\n\tint ret;\n\n\tBUG_ON(len % mtd->erasesize);\n\tif (logfs_super(sb)->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn -EROFS;\n\n\tmemset(&ei, 0, sizeof(ei));\n\tei.mtd = mtd;\n\tei.addr = ofs;\n\tei.len = len;\n\tei.callback = logfs_erase_callback;\n\tei.priv = (long)&complete;\n\tret = mtd_erase(mtd, &ei);\n\tif (ret)\n\t\treturn -EIO;\n\n\twait_for_completion(&complete);\n\tif (ei.state != MTD_ERASE_DONE)\n\t\treturn -EIO;\n\treturn logfs_mtd_erase_mapping(sb, ofs, len);\n}"
  },
  {
    "function_name": "logfs_mtd_erase_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "72-88",
    "snippet": "static int logfs_mtd_erase_mapping(struct super_block *sb, loff_t ofs,\n\t\t\t\tsize_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\n\tfor (index = ofs >> PAGE_SHIFT; index < (ofs + len) >> PAGE_SHIFT; index++) {\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tmemset(page_address(page), 0xFF, PAGE_SIZE);\n\t\tpage_cache_release(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "page_address(page)",
            "0xFF",
            "PAGE_SIZE"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int logfs_mtd_erase_mapping(struct super_block *sb, loff_t ofs,\n\t\t\t\tsize_t len)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct address_space *mapping = super->s_mapping_inode->i_mapping;\n\tstruct page *page;\n\tpgoff_t index = ofs >> PAGE_SHIFT;\n\n\tfor (index = ofs >> PAGE_SHIFT; index < (ofs + len) >> PAGE_SHIFT; index++) {\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page)\n\t\t\tcontinue;\n\t\tmemset(page_address(page), 0xFF, PAGE_SIZE);\n\t\tpage_cache_release(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_erase_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "67-70",
    "snippet": "static void logfs_erase_callback(struct erase_info *ei)\n{\n\tcomplete((struct completion *)ei->priv);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "(struct completion *)ei->priv"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic void logfs_erase_callback(struct erase_info *ei)\n{\n\tcomplete((struct completion *)ei->priv);\n}"
  },
  {
    "function_name": "loffs_mtd_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "35-57",
    "snippet": "static int loffs_mtd_write(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct mtd_info *mtd = super->s_mtd;\n\tsize_t retlen;\n\tloff_t page_start, page_end;\n\tint ret;\n\n\tif (super->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn -EROFS;\n\n\tBUG_ON((ofs >= mtd->size) || (len > mtd->size - ofs));\n\tBUG_ON(ofs != (ofs >> super->s_writeshift) << super->s_writeshift);\n\tBUG_ON(len > PAGE_CACHE_SIZE);\n\tpage_start = ofs & PAGE_CACHE_MASK;\n\tpage_end = PAGE_CACHE_ALIGN(ofs + len) - 1;\n\tret = mtd_write(mtd, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len))\n\t\treturn -EIO;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mtd_write",
          "args": [
            "mtd",
            "ofs",
            "len",
            "&retlen",
            "buf"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_CACHE_ALIGN",
          "args": [
            "ofs + len"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "len > PAGE_CACHE_SIZE"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ofs != (ofs >> super->s_writeshift) << super->s_writeshift"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(ofs >= mtd->size) || (len > mtd->size - ofs)"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int loffs_mtd_write(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct mtd_info *mtd = super->s_mtd;\n\tsize_t retlen;\n\tloff_t page_start, page_end;\n\tint ret;\n\n\tif (super->s_flags & LOGFS_SB_FLAG_RO)\n\t\treturn -EROFS;\n\n\tBUG_ON((ofs >= mtd->size) || (len > mtd->size - ofs));\n\tBUG_ON(ofs != (ofs >> super->s_writeshift) << super->s_writeshift);\n\tBUG_ON(len > PAGE_CACHE_SIZE);\n\tpage_start = ofs & PAGE_CACHE_MASK;\n\tpage_end = PAGE_CACHE_ALIGN(ofs + len) - 1;\n\tret = mtd_write(mtd, ofs, len, &retlen, buf);\n\tif (ret || (retlen != len))\n\t\treturn -EIO;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_mtd_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/dev_mtd.c",
    "lines": "16-33",
    "snippet": "static int logfs_mtd_read(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\tsize_t retlen;\n\tint ret;\n\n\tret = mtd_read(mtd, ofs, len, &retlen, buf);\n\tBUG_ON(ret == -EINVAL);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Not sure if we should loop instead. */\n\tif (retlen != len)\n\t\treturn -EIO;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/mount.h>",
      "#include <linux/completion.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ret == -EINVAL"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mtd_read",
          "args": [
            "mtd",
            "ofs",
            "len",
            "&retlen",
            "buf"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 19
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/completion.h>\n#include \"logfs.h\"\n\nstatic int logfs_mtd_read(struct super_block *sb, loff_t ofs, size_t len,\n\t\t\tvoid *buf)\n{\n\tstruct mtd_info *mtd = logfs_super(sb)->s_mtd;\n\tsize_t retlen;\n\tint ret;\n\n\tret = mtd_read(mtd, ofs, len, &retlen, buf);\n\tBUG_ON(ret == -EINVAL);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Not sure if we should loop instead. */\n\tif (retlen != len)\n\t\treturn -EIO;\n\n\treturn 0;\n}"
  }
]