[
  {
    "function_name": "xfs_trans_roll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "995-1055",
    "snippet": "int\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "trans",
            "dp",
            "0"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "trans",
            "&tres",
            "0",
            "0"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_put",
          "args": [
            "trans->t_ticket"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3496-3503",
          "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "trans",
            "0"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_dup",
          "args": [
            "trans"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "116-152",
          "snippet": "xfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_trans_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "trans",
            "dp",
            "XFS_ILOG_CORE"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_roll(\n\tstruct xfs_trans\t**tpp,\n\tstruct xfs_inode\t*dp)\n{\n\tstruct xfs_trans\t*trans;\n\tstruct xfs_trans_res\ttres;\n\tint\t\t\terror;\n\n\t/*\n\t * Ensure that the inode is always logged.\n\t */\n\ttrans = *tpp;\n\txfs_trans_log_inode(trans, dp, XFS_ILOG_CORE);\n\n\t/*\n\t * Copy the critical parameters from one trans to the next.\n\t */\n\ttres.tr_logres = trans->t_log_res;\n\ttres.tr_logcount = trans->t_log_count;\n\t*tpp = xfs_trans_dup(trans);\n\n\t/*\n\t * Commit the current transaction.\n\t * If this commit failed, then it'd just unlock those items that\n\t * are not marked ihold. That also means that a filesystem shutdown\n\t * is in progress. The caller takes the responsibility to cancel\n\t * the duplicate transaction that gets returned.\n\t */\n\terror = xfs_trans_commit(trans, 0);\n\tif (error)\n\t\treturn error;\n\n\ttrans = *tpp;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(trans->t_ticket);\n\n\n\t/*\n\t * Reserve space in the log for th next transaction.\n\t * This also pushes items in the \"AIL\", the list of logged items,\n\t * out to disk if they are taking up space at the tail of the log\n\t * that we want to use.  This requires that either nothing be locked\n\t * across this call, or that anything that is locked be logged in\n\t * the prior and the next transactions.\n\t */\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\terror = xfs_trans_reserve(trans, &tres, 0, 0);\n\t/*\n\t *  Ensure that the inode is in the new transaction and locked.\n\t */\n\tif (error)\n\t\treturn error;\n\n\txfs_trans_ijoin(trans, dp, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_trans_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "937-986",
    "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_free",
          "args": [
            "tp"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_item_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "670-676",
          "snippet": "STATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nSTATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_free_items",
          "args": [
            "tp",
            "NULLCOMMITLSN",
            "flags"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "693-714",
          "snippet": "void\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xfs_log_item_desc *lidp, *next;\n\n\tlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\tlip->li_desc = NULL;\n\n\t\tif (commit_lsn != NULLCOMMITLSN)\n\t\t\tlip->li_ops->iop_committing(lip, commit_lsn);\n\t\tif (flags & XFS_TRANS_ABORT)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\tlip->li_ops->iop_unlock(lip);\n\n\t\txfs_trans_free_item_desc(lidp);\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xfs_log_item_desc *lidp, *next;\n\n\tlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\tlip->li_desc = NULL;\n\n\t\tif (commit_lsn != NULLCOMMITLSN)\n\t\t\tlip->li_ops->iop_committing(lip, commit_lsn);\n\t\tif (flags & XFS_TRANS_ABORT)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\tlip->li_ops->iop_unlock(lip);\n\n\t\txfs_trans_free_item_desc(lidp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_restore_flags_nested",
          "args": [
            "&tp->t_pflags",
            "PF_FSTRANS"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_done",
          "args": [
            "mp",
            "tp->t_ticket",
            "NULL",
            "log_flags"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "511-557",
          "snippet": "xfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_flags & XFS_TRANS_PERM_LOG_RES"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_unreserve_and_mod_dquots",
          "args": [
            "tp"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_unreserve_and_mod_dquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "504-561",
          "snippet": "void\nxfs_trans_unreserve_and_mod_dquots(\n\txfs_trans_t\t\t*tp)\n{\n\tint\t\t\ti, j;\n\txfs_dquot_t\t\t*dqp;\n\txfs_dqtrx_t\t\t*qtrx, *qa;\n\tbool                    locked;\n\n\tif (!tp->t_dqinfo || !(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * We assume that the array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Unreserve the original reservation. We don't care\n\t\t\t * about the number of blocks used field, or deltas.\n\t\t\t * Also we don't bother to zero the fields.\n\t\t\t */\n\t\t\tlocked = false;\n\t\t\tif (qtrx->qt_blk_res) {\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tlocked = true;\n\t\t\t\tdqp->q_res_bcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_blk_res;\n\t\t\t}\n\t\t\tif (qtrx->qt_ino_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_icount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_ino_res;\n\t\t\t}\n\n\t\t\tif (qtrx->qt_rtblk_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_rtbcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_rtblk_res;\n\t\t\t}\n\t\t\tif (locked)\n\t\t\t\txfs_dqunlock(dqp);\n\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_unreserve_and_mod_dquots(\n\txfs_trans_t\t\t*tp)\n{\n\tint\t\t\ti, j;\n\txfs_dquot_t\t\t*dqp;\n\txfs_dqtrx_t\t\t*qtrx, *qa;\n\tbool                    locked;\n\n\tif (!tp->t_dqinfo || !(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * We assume that the array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Unreserve the original reservation. We don't care\n\t\t\t * about the number of blocks used field, or deltas.\n\t\t\t * Also we don't bother to zero the fields.\n\t\t\t */\n\t\t\tlocked = false;\n\t\t\tif (qtrx->qt_blk_res) {\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tlocked = true;\n\t\t\t\tdqp->q_res_bcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_blk_res;\n\t\t\t}\n\t\t\tif (qtrx->qt_ino_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_icount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_ino_res;\n\t\t\t}\n\n\t\t\tif (qtrx->qt_rtblk_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_rtbcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_rtblk_res;\n\t\t\t}\n\t\t\tif (locked)\n\t\t\t\txfs_dqunlock(dqp);\n\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_unreserve_and_mod_sb",
          "args": [
            "tp"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_unreserve_and_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "510-644",
          "snippet": "void\nxfs_trans_unreserve_and_mod_sb(\n\txfs_trans_t\t*tp)\n{\n\txfs_mod_sb_t\tmsb[9];\t/* If you add cases, add entries */\n\txfs_mod_sb_t\t*msbp;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\t/* REFERENCED */\n\tint\t\terror;\n\tint\t\trsvd;\n\tint64_t\t\tblkdelta = 0;\n\tint64_t\t\trtxdelta = 0;\n\tint64_t\t\tidelta = 0;\n\tint64_t\t\tifreedelta = 0;\n\n\tmsbp = msb;\n\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* calculate deltas */\n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t/* apply the per-cpu counters */\n\tif (blkdelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t blkdelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (idelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT,\n\t\t\t\t\t\t idelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_fdblocks;\n\t}\n\n\tif (ifreedelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,\n\t\t\t\t\t\t ifreedelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_icount;\n\t}\n\n\t/* apply remaining deltas */\n\tif (rtxdelta != 0) {\n\t\tmsbp->msb_field = XFS_SBS_FREXTENTS;\n\t\tmsbp->msb_delta = rtxdelta;\n\t\tmsbp++;\n\t}\n\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY) {\n\t\tif (tp->t_dblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_DBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_dblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_agcount_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_AGCOUNT;\n\t\t\tmsbp->msb_delta = tp->t_agcount_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_imaxpct_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_IMAX_PCT;\n\t\t\tmsbp->msb_delta = tp->t_imaxpct_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextsize_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSIZE;\n\t\t\tmsbp->msb_delta = tp->t_rextsize_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rbmblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBMBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rbmblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextents_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTENTS;\n\t\t\tmsbp->msb_delta = tp->t_rextents_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextslog_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSLOG;\n\t\t\tmsbp->msb_delta = tp->t_rextslog_delta;\n\t\t\tmsbp++;\n\t\t}\n\t}\n\n\t/*\n\t * If we need to change anything, do it.\n\t */\n\tif (msbp > msb) {\n\t\terror = xfs_mod_incore_sb_batch(tp->t_mountp, msb,\n\t\t\t(uint)(msbp - msb), rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_ifreecount;\n\t}\n\n\treturn;\n\nout_undo_ifreecount:\n\tif (ifreedelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);\nout_undo_icount:\n\tif (idelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);\nout_undo_fdblocks:\n\tif (blkdelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, -blkdelta, rsvd);\nout:\n\tASSERT(error == 0);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_unreserve_and_mod_sb(\n\txfs_trans_t\t*tp)\n{\n\txfs_mod_sb_t\tmsb[9];\t/* If you add cases, add entries */\n\txfs_mod_sb_t\t*msbp;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\t/* REFERENCED */\n\tint\t\terror;\n\tint\t\trsvd;\n\tint64_t\t\tblkdelta = 0;\n\tint64_t\t\trtxdelta = 0;\n\tint64_t\t\tidelta = 0;\n\tint64_t\t\tifreedelta = 0;\n\n\tmsbp = msb;\n\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* calculate deltas */\n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t/* apply the per-cpu counters */\n\tif (blkdelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t blkdelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (idelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT,\n\t\t\t\t\t\t idelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_fdblocks;\n\t}\n\n\tif (ifreedelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,\n\t\t\t\t\t\t ifreedelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_icount;\n\t}\n\n\t/* apply remaining deltas */\n\tif (rtxdelta != 0) {\n\t\tmsbp->msb_field = XFS_SBS_FREXTENTS;\n\t\tmsbp->msb_delta = rtxdelta;\n\t\tmsbp++;\n\t}\n\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY) {\n\t\tif (tp->t_dblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_DBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_dblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_agcount_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_AGCOUNT;\n\t\t\tmsbp->msb_delta = tp->t_agcount_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_imaxpct_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_IMAX_PCT;\n\t\t\tmsbp->msb_delta = tp->t_imaxpct_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextsize_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSIZE;\n\t\t\tmsbp->msb_delta = tp->t_rextsize_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rbmblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBMBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rbmblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextents_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTENTS;\n\t\t\tmsbp->msb_delta = tp->t_rextents_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextslog_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSLOG;\n\t\t\tmsbp->msb_delta = tp->t_rextslog_delta;\n\t\t\tmsbp++;\n\t\t}\n\t}\n\n\t/*\n\t * If we need to change anything, do it.\n\t */\n\tif (msbp > msb) {\n\t\terror = xfs_mod_incore_sb_batch(tp->t_mountp, msb,\n\t\t\t(uint)(msbp - msb), rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_ifreecount;\n\t}\n\n\treturn;\n\nout_undo_ifreecount:\n\tif (ifreedelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);\nout_undo_icount:\n\tif (idelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);\nout_undo_fdblocks:\n\tif (blkdelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, -blkdelta, rsvd);\nout:\n\tASSERT(error == 0);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(lidp->lid_item->li_type == XFS_LI_EFD)"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lidp",
            "&tp->t_items",
            "lid_trans"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_force_shutdown",
          "args": [
            "mp",
            "SHUTDOWN_CORRUPT_INCORE"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_trans_cancel\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
  },
  {
    "function_name": "xfs_trans_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "845-927",
    "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_trans_empty"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_free",
          "args": [
            "tp"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_item_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "670-676",
          "snippet": "STATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nSTATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_free_items",
          "args": [
            "tp",
            "NULLCOMMITLSN",
            "error ? XFS_TRANS_ABORT : 0"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "693-714",
          "snippet": "void\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xfs_log_item_desc *lidp, *next;\n\n\tlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\tlip->li_desc = NULL;\n\n\t\tif (commit_lsn != NULLCOMMITLSN)\n\t\t\tlip->li_ops->iop_committing(lip, commit_lsn);\n\t\tif (flags & XFS_TRANS_ABORT)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\tlip->li_ops->iop_unlock(lip);\n\n\t\txfs_trans_free_item_desc(lidp);\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xfs_log_item_desc *lidp, *next;\n\n\tlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\tlip->li_desc = NULL;\n\n\t\tif (commit_lsn != NULLCOMMITLSN)\n\t\t\tlip->li_ops->iop_committing(lip, commit_lsn);\n\t\tif (flags & XFS_TRANS_ABORT)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\tlip->li_ops->iop_unlock(lip);\n\n\t\txfs_trans_free_item_desc(lidp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_restore_flags_nested",
          "args": [
            "&tp->t_pflags",
            "PF_FSTRANS"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_done",
          "args": [
            "mp",
            "tp->t_ticket",
            "NULL",
            "log_flags"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "511-557",
          "snippet": "xfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_unreserve_and_mod_dquots",
          "args": [
            "tp"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_unreserve_and_mod_dquots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "504-561",
          "snippet": "void\nxfs_trans_unreserve_and_mod_dquots(\n\txfs_trans_t\t\t*tp)\n{\n\tint\t\t\ti, j;\n\txfs_dquot_t\t\t*dqp;\n\txfs_dqtrx_t\t\t*qtrx, *qa;\n\tbool                    locked;\n\n\tif (!tp->t_dqinfo || !(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * We assume that the array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Unreserve the original reservation. We don't care\n\t\t\t * about the number of blocks used field, or deltas.\n\t\t\t * Also we don't bother to zero the fields.\n\t\t\t */\n\t\t\tlocked = false;\n\t\t\tif (qtrx->qt_blk_res) {\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tlocked = true;\n\t\t\t\tdqp->q_res_bcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_blk_res;\n\t\t\t}\n\t\t\tif (qtrx->qt_ino_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_icount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_ino_res;\n\t\t\t}\n\n\t\t\tif (qtrx->qt_rtblk_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_rtbcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_rtblk_res;\n\t\t\t}\n\t\t\tif (locked)\n\t\t\t\txfs_dqunlock(dqp);\n\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_unreserve_and_mod_dquots(\n\txfs_trans_t\t\t*tp)\n{\n\tint\t\t\ti, j;\n\txfs_dquot_t\t\t*dqp;\n\txfs_dqtrx_t\t\t*qtrx, *qa;\n\tbool                    locked;\n\n\tif (!tp->t_dqinfo || !(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * We assume that the array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * Unreserve the original reservation. We don't care\n\t\t\t * about the number of blocks used field, or deltas.\n\t\t\t * Also we don't bother to zero the fields.\n\t\t\t */\n\t\t\tlocked = false;\n\t\t\tif (qtrx->qt_blk_res) {\n\t\t\t\txfs_dqlock(dqp);\n\t\t\t\tlocked = true;\n\t\t\t\tdqp->q_res_bcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_blk_res;\n\t\t\t}\n\t\t\tif (qtrx->qt_ino_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_icount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_ino_res;\n\t\t\t}\n\n\t\t\tif (qtrx->qt_rtblk_res) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\txfs_dqlock(dqp);\n\t\t\t\t\tlocked = true;\n\t\t\t\t}\n\t\t\t\tdqp->q_res_rtbcount -=\n\t\t\t\t\t(xfs_qcnt_t)qtrx->qt_rtblk_res;\n\t\t\t}\n\t\t\tif (locked)\n\t\t\t\txfs_dqunlock(dqp);\n\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_unreserve_and_mod_sb",
          "args": [
            "tp"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_unreserve_and_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "510-644",
          "snippet": "void\nxfs_trans_unreserve_and_mod_sb(\n\txfs_trans_t\t*tp)\n{\n\txfs_mod_sb_t\tmsb[9];\t/* If you add cases, add entries */\n\txfs_mod_sb_t\t*msbp;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\t/* REFERENCED */\n\tint\t\terror;\n\tint\t\trsvd;\n\tint64_t\t\tblkdelta = 0;\n\tint64_t\t\trtxdelta = 0;\n\tint64_t\t\tidelta = 0;\n\tint64_t\t\tifreedelta = 0;\n\n\tmsbp = msb;\n\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* calculate deltas */\n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t/* apply the per-cpu counters */\n\tif (blkdelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t blkdelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (idelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT,\n\t\t\t\t\t\t idelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_fdblocks;\n\t}\n\n\tif (ifreedelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,\n\t\t\t\t\t\t ifreedelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_icount;\n\t}\n\n\t/* apply remaining deltas */\n\tif (rtxdelta != 0) {\n\t\tmsbp->msb_field = XFS_SBS_FREXTENTS;\n\t\tmsbp->msb_delta = rtxdelta;\n\t\tmsbp++;\n\t}\n\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY) {\n\t\tif (tp->t_dblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_DBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_dblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_agcount_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_AGCOUNT;\n\t\t\tmsbp->msb_delta = tp->t_agcount_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_imaxpct_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_IMAX_PCT;\n\t\t\tmsbp->msb_delta = tp->t_imaxpct_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextsize_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSIZE;\n\t\t\tmsbp->msb_delta = tp->t_rextsize_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rbmblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBMBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rbmblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextents_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTENTS;\n\t\t\tmsbp->msb_delta = tp->t_rextents_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextslog_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSLOG;\n\t\t\tmsbp->msb_delta = tp->t_rextslog_delta;\n\t\t\tmsbp++;\n\t\t}\n\t}\n\n\t/*\n\t * If we need to change anything, do it.\n\t */\n\tif (msbp > msb) {\n\t\terror = xfs_mod_incore_sb_batch(tp->t_mountp, msb,\n\t\t\t(uint)(msbp - msb), rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_ifreecount;\n\t}\n\n\treturn;\n\nout_undo_ifreecount:\n\tif (ifreedelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);\nout_undo_icount:\n\tif (idelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);\nout_undo_fdblocks:\n\tif (blkdelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, -blkdelta, rsvd);\nout:\n\tASSERT(error == 0);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_unreserve_and_mod_sb(\n\txfs_trans_t\t*tp)\n{\n\txfs_mod_sb_t\tmsb[9];\t/* If you add cases, add entries */\n\txfs_mod_sb_t\t*msbp;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\t/* REFERENCED */\n\tint\t\terror;\n\tint\t\trsvd;\n\tint64_t\t\tblkdelta = 0;\n\tint64_t\t\trtxdelta = 0;\n\tint64_t\t\tidelta = 0;\n\tint64_t\t\tifreedelta = 0;\n\n\tmsbp = msb;\n\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* calculate deltas */\n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t/* apply the per-cpu counters */\n\tif (blkdelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t blkdelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (idelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT,\n\t\t\t\t\t\t idelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_fdblocks;\n\t}\n\n\tif (ifreedelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,\n\t\t\t\t\t\t ifreedelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_icount;\n\t}\n\n\t/* apply remaining deltas */\n\tif (rtxdelta != 0) {\n\t\tmsbp->msb_field = XFS_SBS_FREXTENTS;\n\t\tmsbp->msb_delta = rtxdelta;\n\t\tmsbp++;\n\t}\n\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY) {\n\t\tif (tp->t_dblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_DBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_dblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_agcount_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_AGCOUNT;\n\t\t\tmsbp->msb_delta = tp->t_agcount_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_imaxpct_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_IMAX_PCT;\n\t\t\tmsbp->msb_delta = tp->t_imaxpct_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextsize_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSIZE;\n\t\t\tmsbp->msb_delta = tp->t_rextsize_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rbmblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBMBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rbmblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextents_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTENTS;\n\t\t\tmsbp->msb_delta = tp->t_rextents_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextslog_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSLOG;\n\t\t\tmsbp->msb_delta = tp->t_rextslog_delta;\n\t\t\tmsbp++;\n\t\t}\n\t}\n\n\t/*\n\t * If we need to change anything, do it.\n\t */\n\tif (msbp > msb) {\n\t\terror = xfs_mod_incore_sb_batch(tp->t_mountp, msb,\n\t\t\t(uint)(msbp - msb), rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_ifreecount;\n\t}\n\n\treturn;\n\nout_undo_ifreecount:\n\tif (ifreedelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);\nout_undo_icount:\n\tif (idelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);\nout_undo_fdblocks:\n\tif (blkdelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, -blkdelta, rsvd);\nout:\n\tASSERT(error == 0);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_trans_async"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_trans_sync"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_log_force_lsn",
          "args": [
            "mp",
            "commit_lsn",
            "XFS_LOG_SYNC",
            "NULL"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_log_force_lsn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3332-3445",
          "snippet": "int\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\n_xfs_log_force_lsn(\n\tstruct xfs_mount\t*mp,\n\txfs_lsn_t\t\tlsn,\n\tuint\t\t\tflags,\n\tint\t\t\t*log_flushed)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_in_core\t*iclog;\n\tint\t\t\talready_slept = 0;\n\n\tASSERT(lsn != 0);\n\n\tXFS_STATS_INC(xs_log_force);\n\n\tlsn = xlog_cil_force_lsn(log, lsn);\n\tif (lsn == NULLCOMMITLSN)\n\t\treturn 0;\n\ntry_again:\n\tspin_lock(&log->l_icloglock);\n\ticlog = log->l_iclog;\n\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\tspin_unlock(&log->l_icloglock);\n\t\treturn -EIO;\n\t}\n\n\tdo {\n\t\tif (be64_to_cpu(iclog->ic_header.h_lsn) != lsn) {\n\t\t\ticlog = iclog->ic_next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_DIRTY) {\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (iclog->ic_state == XLOG_STATE_ACTIVE) {\n\t\t\t/*\n\t\t\t * We sleep here if we haven't already slept (e.g.\n\t\t\t * this is the first time we've looked at the correct\n\t\t\t * iclog buf) and the buffer before us is going to\n\t\t\t * be sync'ed. The reason for this is that if we\n\t\t\t * are doing sync transactions here, by waiting for\n\t\t\t * the previous I/O to complete, we can allow a few\n\t\t\t * more transactions into this iclog before we close\n\t\t\t * it down.\n\t\t\t *\n\t\t\t * Otherwise, we mark the buffer WANT_SYNC, and bump\n\t\t\t * up the refcnt so we can release the log (which\n\t\t\t * drops the ref count).  The state switch keeps new\n\t\t\t * transaction commits from using this buffer.  When\n\t\t\t * the current commits finish writing into the buffer,\n\t\t\t * the refcount will drop to zero and the buffer will\n\t\t\t * go out then.\n\t\t\t */\n\t\t\tif (!already_slept &&\n\t\t\t    (iclog->ic_prev->ic_state &\n\t\t\t     (XLOG_STATE_WANT_SYNC | XLOG_STATE_SYNCING))) {\n\t\t\t\tASSERT(!(iclog->ic_state & XLOG_STATE_IOERROR));\n\n\t\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\n\t\t\t\txlog_wait(&iclog->ic_prev->ic_write_wait,\n\t\t\t\t\t\t\t&log->l_icloglock);\n\t\t\t\tif (log_flushed)\n\t\t\t\t\t*log_flushed = 1;\n\t\t\t\talready_slept = 1;\n\t\t\t\tgoto try_again;\n\t\t\t}\n\t\t\tatomic_inc(&iclog->ic_refcnt);\n\t\t\txlog_state_switch_iclogs(log, iclog, 0);\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\tif (xlog_state_release_iclog(log, iclog))\n\t\t\t\treturn -EIO;\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t\tspin_lock(&log->l_icloglock);\n\t\t}\n\n\t\tif ((flags & XFS_LOG_SYNC) && /* sleep */\n\t\t    !(iclog->ic_state &\n\t\t      (XLOG_STATE_ACTIVE | XLOG_STATE_DIRTY))) {\n\t\t\t/*\n\t\t\t * Don't wait on completion if we know that we've\n\t\t\t * gotten a log write error.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR) {\n\t\t\t\tspin_unlock(&log->l_icloglock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tXFS_STATS_INC(xs_log_force_sleep);\n\t\t\txlog_wait(&iclog->ic_force_wait, &log->l_icloglock);\n\t\t\t/*\n\t\t\t * No need to grab the log lock here since we're\n\t\t\t * only deciding whether or not to return EIO\n\t\t\t * and the memory read should be atomic.\n\t\t\t */\n\t\t\tif (iclog->ic_state & XLOG_STATE_IOERROR)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (log_flushed)\n\t\t\t\t*log_flushed = 1;\n\t\t} else {\t\t/* just return */\n\t\t\tspin_unlock(&log->l_icloglock);\n\t\t}\n\n\t\treturn 0;\n\t} while (iclog != log->l_iclog);\n\n\tspin_unlock(&log->l_icloglock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_restore_flags_nested",
          "args": [
            "&tp->t_pflags",
            "PF_FSTRANS"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_commit_cil",
          "args": [
            "mp",
            "tp",
            "&commit_lsn",
            "flags"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_commit_cil",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "771-817",
          "snippet": "void\nxfs_log_commit_cil(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\t*commit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tint\t\t\tlog_flags = 0;\n\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES)\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\n\t/* lock out background commit */\n\tdown_read(&cil->xc_ctx_lock);\n\n\txlog_cil_insert_items(log, tp);\n\n\t/* check we didn't blow the reservation */\n\tif (tp->t_ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(mp, tp->t_ticket);\n\n\ttp->t_commit_lsn = cil->xc_ctx->sequence;\n\tif (commit_lsn)\n\t\t*commit_lsn = tp->t_commit_lsn;\n\n\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * Once all the items of the transaction have been copied to the CIL,\n\t * the items can be unlocked and freed.\n\t *\n\t * This needs to be done before we drop the CIL context lock because we\n\t * have to update state in the log items and unlock them before they go\n\t * to disk. If we don't, then the CIL checkpoint can race with us and\n\t * we can run checkpoint completion before we've updated and unlocked\n\t * the log items. This affects (at least) processing of stale buffers,\n\t * inodes and EFIs.\n\t */\n\txfs_trans_free_items(tp, tp->t_commit_lsn, 0);\n\n\txlog_cil_push_background(log);\n\n\tup_read(&cil->xc_ctx_lock);\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_commit_cil(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\t*commit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tint\t\t\tlog_flags = 0;\n\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES)\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\n\t/* lock out background commit */\n\tdown_read(&cil->xc_ctx_lock);\n\n\txlog_cil_insert_items(log, tp);\n\n\t/* check we didn't blow the reservation */\n\tif (tp->t_ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(mp, tp->t_ticket);\n\n\ttp->t_commit_lsn = cil->xc_ctx->sequence;\n\tif (commit_lsn)\n\t\t*commit_lsn = tp->t_commit_lsn;\n\n\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * Once all the items of the transaction have been copied to the CIL,\n\t * the items can be unlocked and freed.\n\t *\n\t * This needs to be done before we drop the CIL context lock because we\n\t * have to update state in the log items and unlock them before they go\n\t * to disk. If we don't, then the CIL checkpoint can race with us and\n\t * we can run checkpoint completion before we've updated and unlocked\n\t * the log items. This affects (at least) processing of stale buffers,\n\t * inodes and EFIs.\n\t */\n\txfs_trans_free_items(tp, tp->t_commit_lsn, 0);\n\n\txlog_cil_push_background(log);\n\n\tup_read(&cil->xc_ctx_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_apply_dquot_deltas",
          "args": [
            "tp"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_apply_dquot_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "325-495",
          "snippet": "void\nxfs_trans_apply_dquot_deltas(\n\tstruct xfs_trans\t*tp)\n{\n\tint\t\t\ti, j;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_dqtrx\t*qtrx, *qa;\n\tstruct xfs_disk_dquot\t*d;\n\tlong\t\t\ttotalbdelta;\n\tlong\t\t\ttotalrtbdelta;\n\n\tif (!(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tASSERT(tp->t_dqinfo);\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\t\tif (qa[0].qt_dquot == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Lock all of the dquots and join them to the transaction.\n\t\t */\n\t\txfs_trans_dqlockedjoin(tp, qa);\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * The array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\t\t\tASSERT(dqp->q_transp == tp);\n\n\t\t\t/*\n\t\t\t * adjust the actual number of blocks used\n\t\t\t */\n\t\t\td = &dqp->q_core;\n\n\t\t\t/*\n\t\t\t * The issue here is - sometimes we don't make a blkquota\n\t\t\t * reservation intentionally to be fair to users\n\t\t\t * (when the amount is small). On the other hand,\n\t\t\t * delayed allocs do make reservations, but that's\n\t\t\t * outside of a transaction, so we have no\n\t\t\t * idea how much was really reserved.\n\t\t\t * So, here we've accumulated delayed allocation blks and\n\t\t\t * non-delay blks. The assumption is that the\n\t\t\t * delayed ones are always reserved (outside of a\n\t\t\t * transaction), and the others may or may not have\n\t\t\t * quota reservations.\n\t\t\t */\n\t\t\ttotalbdelta = qtrx->qt_bcount_delta +\n\t\t\t\tqtrx->qt_delbcnt_delta;\n\t\t\ttotalrtbdelta = qtrx->qt_rtbcount_delta +\n\t\t\t\tqtrx->qt_delrtb_delta;\n#ifdef DEBUG\n\t\t\tif (totalbdelta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_bcount) >=\n\t\t\t\t       -totalbdelta);\n\n\t\t\tif (totalrtbdelta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_rtbcount) >=\n\t\t\t\t       -totalrtbdelta);\n\n\t\t\tif (qtrx->qt_icount_delta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_icount) >=\n\t\t\t\t       -qtrx->qt_icount_delta);\n#endif\n\t\t\tif (totalbdelta)\n\t\t\t\tbe64_add_cpu(&d->d_bcount, (xfs_qcnt_t)totalbdelta);\n\n\t\t\tif (qtrx->qt_icount_delta)\n\t\t\t\tbe64_add_cpu(&d->d_icount, (xfs_qcnt_t)qtrx->qt_icount_delta);\n\n\t\t\tif (totalrtbdelta)\n\t\t\t\tbe64_add_cpu(&d->d_rtbcount, (xfs_qcnt_t)totalrtbdelta);\n\n\t\t\t/*\n\t\t\t * Get any default limits in use.\n\t\t\t * Start/reset the timer(s) if needed.\n\t\t\t */\n\t\t\tif (d->d_id) {\n\t\t\t\txfs_qm_adjust_dqlimits(tp->t_mountp, dqp);\n\t\t\t\txfs_qm_adjust_dqtimers(tp->t_mountp, d);\n\t\t\t}\n\n\t\t\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\t\t\t/*\n\t\t\t * add this to the list of items to get logged\n\t\t\t */\n\t\t\txfs_trans_log_dquot(tp, dqp);\n\t\t\t/*\n\t\t\t * Take off what's left of the original reservation.\n\t\t\t * In case of delayed allocations, there's no\n\t\t\t * reservation that a transaction structure knows of.\n\t\t\t */\n\t\t\tif (qtrx->qt_blk_res != 0) {\n\t\t\t\tif (qtrx->qt_blk_res != qtrx->qt_blk_res_used) {\n\t\t\t\t\tif (qtrx->qt_blk_res >\n\t\t\t\t\t    qtrx->qt_blk_res_used)\n\t\t\t\t\t\tdqp->q_res_bcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t\t(qtrx->qt_blk_res -\n\t\t\t\t\t\t\t qtrx->qt_blk_res_used);\n\t\t\t\t\telse\n\t\t\t\t\t\tdqp->q_res_bcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t\t(qtrx->qt_blk_res_used -\n\t\t\t\t\t\t\t qtrx->qt_blk_res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * These blks were never reserved, either inside\n\t\t\t\t * a transaction or outside one (in a delayed\n\t\t\t\t * allocation). Also, this isn't always a\n\t\t\t\t * negative number since we sometimes\n\t\t\t\t * deliberately skip quota reservations.\n\t\t\t\t */\n\t\t\t\tif (qtrx->qt_bcount_delta) {\n\t\t\t\t\tdqp->q_res_bcount +=\n\t\t\t\t\t      (xfs_qcnt_t)qtrx->qt_bcount_delta;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Adjust the RT reservation.\n\t\t\t */\n\t\t\tif (qtrx->qt_rtblk_res != 0) {\n\t\t\t\tif (qtrx->qt_rtblk_res != qtrx->qt_rtblk_res_used) {\n\t\t\t\t\tif (qtrx->qt_rtblk_res >\n\t\t\t\t\t    qtrx->qt_rtblk_res_used)\n\t\t\t\t\t       dqp->q_res_rtbcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t       (qtrx->qt_rtblk_res -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res_used);\n\t\t\t\t\telse\n\t\t\t\t\t       dqp->q_res_rtbcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t       (qtrx->qt_rtblk_res_used -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (qtrx->qt_rtbcount_delta)\n\t\t\t\t\tdqp->q_res_rtbcount +=\n\t\t\t\t\t    (xfs_qcnt_t)qtrx->qt_rtbcount_delta;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Adjust the inode reservation.\n\t\t\t */\n\t\t\tif (qtrx->qt_ino_res != 0) {\n\t\t\t\tASSERT(qtrx->qt_ino_res >=\n\t\t\t\t       qtrx->qt_ino_res_used);\n\t\t\t\tif (qtrx->qt_ino_res > qtrx->qt_ino_res_used)\n\t\t\t\t\tdqp->q_res_icount -= (xfs_qcnt_t)\n\t\t\t\t\t\t(qtrx->qt_ino_res -\n\t\t\t\t\t\t qtrx->qt_ino_res_used);\n\t\t\t} else {\n\t\t\t\tif (qtrx->qt_icount_delta)\n\t\t\t\t\tdqp->q_res_icount +=\n\t\t\t\t\t    (xfs_qcnt_t)qtrx->qt_icount_delta;\n\t\t\t}\n\n\t\t\tASSERT(dqp->q_res_bcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_bcount));\n\t\t\tASSERT(dqp->q_res_icount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_icount));\n\t\t\tASSERT(dqp->q_res_rtbcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_rtbcount));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_apply_dquot_deltas(\n\tstruct xfs_trans\t*tp)\n{\n\tint\t\t\ti, j;\n\tstruct xfs_dquot\t*dqp;\n\tstruct xfs_dqtrx\t*qtrx, *qa;\n\tstruct xfs_disk_dquot\t*d;\n\tlong\t\t\ttotalbdelta;\n\tlong\t\t\ttotalrtbdelta;\n\n\tif (!(tp->t_flags & XFS_TRANS_DQ_DIRTY))\n\t\treturn;\n\n\tASSERT(tp->t_dqinfo);\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\tqa = tp->t_dqinfo->dqs[j];\n\t\tif (qa[0].qt_dquot == NULL)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Lock all of the dquots and join them to the transaction.\n\t\t */\n\t\txfs_trans_dqlockedjoin(tp, qa);\n\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tqtrx = &qa[i];\n\t\t\t/*\n\t\t\t * The array of dquots is filled\n\t\t\t * sequentially, not sparsely.\n\t\t\t */\n\t\t\tif ((dqp = qtrx->qt_dquot) == NULL)\n\t\t\t\tbreak;\n\n\t\t\tASSERT(XFS_DQ_IS_LOCKED(dqp));\n\t\t\tASSERT(dqp->q_transp == tp);\n\n\t\t\t/*\n\t\t\t * adjust the actual number of blocks used\n\t\t\t */\n\t\t\td = &dqp->q_core;\n\n\t\t\t/*\n\t\t\t * The issue here is - sometimes we don't make a blkquota\n\t\t\t * reservation intentionally to be fair to users\n\t\t\t * (when the amount is small). On the other hand,\n\t\t\t * delayed allocs do make reservations, but that's\n\t\t\t * outside of a transaction, so we have no\n\t\t\t * idea how much was really reserved.\n\t\t\t * So, here we've accumulated delayed allocation blks and\n\t\t\t * non-delay blks. The assumption is that the\n\t\t\t * delayed ones are always reserved (outside of a\n\t\t\t * transaction), and the others may or may not have\n\t\t\t * quota reservations.\n\t\t\t */\n\t\t\ttotalbdelta = qtrx->qt_bcount_delta +\n\t\t\t\tqtrx->qt_delbcnt_delta;\n\t\t\ttotalrtbdelta = qtrx->qt_rtbcount_delta +\n\t\t\t\tqtrx->qt_delrtb_delta;\n#ifdef DEBUG\n\t\t\tif (totalbdelta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_bcount) >=\n\t\t\t\t       -totalbdelta);\n\n\t\t\tif (totalrtbdelta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_rtbcount) >=\n\t\t\t\t       -totalrtbdelta);\n\n\t\t\tif (qtrx->qt_icount_delta < 0)\n\t\t\t\tASSERT(be64_to_cpu(d->d_icount) >=\n\t\t\t\t       -qtrx->qt_icount_delta);\n#endif\n\t\t\tif (totalbdelta)\n\t\t\t\tbe64_add_cpu(&d->d_bcount, (xfs_qcnt_t)totalbdelta);\n\n\t\t\tif (qtrx->qt_icount_delta)\n\t\t\t\tbe64_add_cpu(&d->d_icount, (xfs_qcnt_t)qtrx->qt_icount_delta);\n\n\t\t\tif (totalrtbdelta)\n\t\t\t\tbe64_add_cpu(&d->d_rtbcount, (xfs_qcnt_t)totalrtbdelta);\n\n\t\t\t/*\n\t\t\t * Get any default limits in use.\n\t\t\t * Start/reset the timer(s) if needed.\n\t\t\t */\n\t\t\tif (d->d_id) {\n\t\t\t\txfs_qm_adjust_dqlimits(tp->t_mountp, dqp);\n\t\t\t\txfs_qm_adjust_dqtimers(tp->t_mountp, d);\n\t\t\t}\n\n\t\t\tdqp->dq_flags |= XFS_DQ_DIRTY;\n\t\t\t/*\n\t\t\t * add this to the list of items to get logged\n\t\t\t */\n\t\t\txfs_trans_log_dquot(tp, dqp);\n\t\t\t/*\n\t\t\t * Take off what's left of the original reservation.\n\t\t\t * In case of delayed allocations, there's no\n\t\t\t * reservation that a transaction structure knows of.\n\t\t\t */\n\t\t\tif (qtrx->qt_blk_res != 0) {\n\t\t\t\tif (qtrx->qt_blk_res != qtrx->qt_blk_res_used) {\n\t\t\t\t\tif (qtrx->qt_blk_res >\n\t\t\t\t\t    qtrx->qt_blk_res_used)\n\t\t\t\t\t\tdqp->q_res_bcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t\t(qtrx->qt_blk_res -\n\t\t\t\t\t\t\t qtrx->qt_blk_res_used);\n\t\t\t\t\telse\n\t\t\t\t\t\tdqp->q_res_bcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t\t(qtrx->qt_blk_res_used -\n\t\t\t\t\t\t\t qtrx->qt_blk_res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * These blks were never reserved, either inside\n\t\t\t\t * a transaction or outside one (in a delayed\n\t\t\t\t * allocation). Also, this isn't always a\n\t\t\t\t * negative number since we sometimes\n\t\t\t\t * deliberately skip quota reservations.\n\t\t\t\t */\n\t\t\t\tif (qtrx->qt_bcount_delta) {\n\t\t\t\t\tdqp->q_res_bcount +=\n\t\t\t\t\t      (xfs_qcnt_t)qtrx->qt_bcount_delta;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\t * Adjust the RT reservation.\n\t\t\t */\n\t\t\tif (qtrx->qt_rtblk_res != 0) {\n\t\t\t\tif (qtrx->qt_rtblk_res != qtrx->qt_rtblk_res_used) {\n\t\t\t\t\tif (qtrx->qt_rtblk_res >\n\t\t\t\t\t    qtrx->qt_rtblk_res_used)\n\t\t\t\t\t       dqp->q_res_rtbcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t       (qtrx->qt_rtblk_res -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res_used);\n\t\t\t\t\telse\n\t\t\t\t\t       dqp->q_res_rtbcount -= (xfs_qcnt_t)\n\t\t\t\t\t\t       (qtrx->qt_rtblk_res_used -\n\t\t\t\t\t\t\tqtrx->qt_rtblk_res);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (qtrx->qt_rtbcount_delta)\n\t\t\t\t\tdqp->q_res_rtbcount +=\n\t\t\t\t\t    (xfs_qcnt_t)qtrx->qt_rtbcount_delta;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Adjust the inode reservation.\n\t\t\t */\n\t\t\tif (qtrx->qt_ino_res != 0) {\n\t\t\t\tASSERT(qtrx->qt_ino_res >=\n\t\t\t\t       qtrx->qt_ino_res_used);\n\t\t\t\tif (qtrx->qt_ino_res > qtrx->qt_ino_res_used)\n\t\t\t\t\tdqp->q_res_icount -= (xfs_qcnt_t)\n\t\t\t\t\t\t(qtrx->qt_ino_res -\n\t\t\t\t\t\t qtrx->qt_ino_res_used);\n\t\t\t} else {\n\t\t\t\tif (qtrx->qt_icount_delta)\n\t\t\t\t\tdqp->q_res_icount +=\n\t\t\t\t\t    (xfs_qcnt_t)qtrx->qt_icount_delta;\n\t\t\t}\n\n\t\t\tASSERT(dqp->q_res_bcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_bcount));\n\t\t\tASSERT(dqp->q_res_icount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_icount));\n\t\t\tASSERT(dqp->q_res_rtbcount >=\n\t\t\t\tbe64_to_cpu(dqp->q_core.d_rtbcount));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_apply_sb_deltas",
          "args": [
            "tp"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_apply_sb_deltas",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "405-489",
          "snippet": "STATIC void\nxfs_trans_apply_sb_deltas(\n\txfs_trans_t\t*tp)\n{\n\txfs_dsb_t\t*sbp;\n\txfs_buf_t\t*bp;\n\tint\t\twhole = 0;\n\n\tbp = xfs_trans_getsb(tp, tp->t_mountp, 0);\n\tsbp = XFS_BUF_TO_SBP(bp);\n\n\t/*\n\t * Check that superblock mods match the mods made to AGF counters.\n\t */\n\tASSERT((tp->t_fdblocks_delta + tp->t_res_fdblocks_delta) ==\n\t       (tp->t_ag_freeblks_delta + tp->t_ag_flist_delta +\n\t\ttp->t_ag_btree_delta));\n\n\t/*\n\t * Only update the superblock counters if we are logging them\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&(tp->t_mountp->m_sb))) {\n\t\tif (tp->t_icount_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_icount, tp->t_icount_delta);\n\t\tif (tp->t_ifree_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_ifree, tp->t_ifree_delta);\n\t\tif (tp->t_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_fdblocks_delta);\n\t\tif (tp->t_res_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_res_fdblocks_delta);\n\t}\n\n\tif (tp->t_frextents_delta)\n\t\tbe64_add_cpu(&sbp->sb_frextents, tp->t_frextents_delta);\n\tif (tp->t_res_frextents_delta)\n\t\tbe64_add_cpu(&sbp->sb_frextents, tp->t_res_frextents_delta);\n\n\tif (tp->t_dblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_dblocks, tp->t_dblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_agcount_delta) {\n\t\tbe32_add_cpu(&sbp->sb_agcount, tp->t_agcount_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_imaxpct_delta) {\n\t\tsbp->sb_imax_pct += tp->t_imaxpct_delta;\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextsize_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rextsize, tp->t_rextsize_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rbmblocks_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rbmblocks, tp->t_rbmblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rblocks, tp->t_rblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextents_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rextents, tp->t_rextents_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextslog_delta) {\n\t\tsbp->sb_rextslog += tp->t_rextslog_delta;\n\t\twhole = 1;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\tif (whole)\n\t\t/*\n\t\t * Log the whole thing, the fields are noncontiguous.\n\t\t */\n\t\txfs_trans_log_buf(tp, bp, 0, sizeof(xfs_dsb_t) - 1);\n\telse\n\t\t/*\n\t\t * Since all the modifiable fields are contiguous, we\n\t\t * can get away with this.\n\t\t */\n\t\txfs_trans_log_buf(tp, bp, offsetof(xfs_dsb_t, sb_icount),\n\t\t\t\t  offsetof(xfs_dsb_t, sb_frextents) +\n\t\t\t\t  sizeof(sbp->sb_frextents) - 1);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_trans_apply_sb_deltas(\n\txfs_trans_t\t*tp)\n{\n\txfs_dsb_t\t*sbp;\n\txfs_buf_t\t*bp;\n\tint\t\twhole = 0;\n\n\tbp = xfs_trans_getsb(tp, tp->t_mountp, 0);\n\tsbp = XFS_BUF_TO_SBP(bp);\n\n\t/*\n\t * Check that superblock mods match the mods made to AGF counters.\n\t */\n\tASSERT((tp->t_fdblocks_delta + tp->t_res_fdblocks_delta) ==\n\t       (tp->t_ag_freeblks_delta + tp->t_ag_flist_delta +\n\t\ttp->t_ag_btree_delta));\n\n\t/*\n\t * Only update the superblock counters if we are logging them\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&(tp->t_mountp->m_sb))) {\n\t\tif (tp->t_icount_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_icount, tp->t_icount_delta);\n\t\tif (tp->t_ifree_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_ifree, tp->t_ifree_delta);\n\t\tif (tp->t_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_fdblocks_delta);\n\t\tif (tp->t_res_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_res_fdblocks_delta);\n\t}\n\n\tif (tp->t_frextents_delta)\n\t\tbe64_add_cpu(&sbp->sb_frextents, tp->t_frextents_delta);\n\tif (tp->t_res_frextents_delta)\n\t\tbe64_add_cpu(&sbp->sb_frextents, tp->t_res_frextents_delta);\n\n\tif (tp->t_dblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_dblocks, tp->t_dblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_agcount_delta) {\n\t\tbe32_add_cpu(&sbp->sb_agcount, tp->t_agcount_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_imaxpct_delta) {\n\t\tsbp->sb_imax_pct += tp->t_imaxpct_delta;\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextsize_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rextsize, tp->t_rextsize_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rbmblocks_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rbmblocks, tp->t_rbmblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rblocks, tp->t_rblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextents_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rextents, tp->t_rextents_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextslog_delta) {\n\t\tsbp->sb_rextslog += tp->t_rextslog_delta;\n\t\twhole = 1;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\tif (whole)\n\t\t/*\n\t\t * Log the whole thing, the fields are noncontiguous.\n\t\t */\n\t\txfs_trans_log_buf(tp, bp, 0, sizeof(xfs_dsb_t) - 1);\n\telse\n\t\t/*\n\t\t * Since all the modifiable fields are contiguous, we\n\t\t * can get away with this.\n\t\t */\n\t\txfs_trans_log_buf(tp, bp, offsetof(xfs_dsb_t, sb_icount),\n\t\t\t\t  offsetof(xfs_dsb_t, sb_frextents) +\n\t\t\t\t  sizeof(sbp->sb_frextents) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_ticket != NULL"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_flags & XFS_TRANS_PERM_LOG_RES"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_trans_committed_bulk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "757-831",
    "snippet": "void\nxfs_trans_committed_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_vec\t*log_vector,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\taborted)\n{\n#define LOG_ITEM_BATCH_SIZE\t32\n\tstruct xfs_log_item\t*log_items[LOG_ITEM_BATCH_SIZE];\n\tstruct xfs_log_vec\t*lv;\n\tstruct xfs_ail_cursor\tcur;\n\tint\t\t\ti = 0;\n\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_cursor_last(ailp, &cur, commit_lsn);\n\tspin_unlock(&ailp->xa_lock);\n\n\t/* unpin all the log items */\n\tfor (lv = log_vector; lv; lv = lv->lv_next ) {\n\t\tstruct xfs_log_item\t*lip = lv->lv_item;\n\t\txfs_lsn_t\t\titem_lsn;\n\n\t\tif (aborted)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\titem_lsn = lip->li_ops->iop_committed(lip, commit_lsn);\n\n\t\t/* item_lsn of -1 means the item needs no further processing */\n\t\tif (XFS_LSN_CMP(item_lsn, (xfs_lsn_t)-1) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if we are aborting the operation, no point in inserting the\n\t\t * object into the AIL as we are in a shutdown situation.\n\t\t */\n\t\tif (aborted) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(ailp->xa_mount));\n\t\t\tlip->li_ops->iop_unpin(lip, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (item_lsn != commit_lsn) {\n\n\t\t\t/*\n\t\t\t * Not a bulk update option due to unusual item_lsn.\n\t\t\t * Push into AIL immediately, rechecking the lsn once\n\t\t\t * we have the ail lock. Then unpin the item. This does\n\t\t\t * not affect the AIL cursor the bulk insert path is\n\t\t\t * using.\n\t\t\t */\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (XFS_LSN_CMP(item_lsn, lip->li_lsn) > 0)\n\t\t\t\txfs_trans_ail_update(ailp, lip, item_lsn);\n\t\t\telse\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tlip->li_ops->iop_unpin(lip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Item is a candidate for bulk AIL insert.  */\n\t\tlog_items[i++] = lv->lv_item;\n\t\tif (i >= LOG_ITEM_BATCH_SIZE) {\n\t\t\txfs_log_item_batch_insert(ailp, &cur, log_items,\n\t\t\t\t\tLOG_ITEM_BATCH_SIZE, commit_lsn);\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\t/* make sure we insert the remainder! */\n\tif (i)\n\t\txfs_log_item_batch_insert(ailp, &cur, log_items, i, commit_lsn);\n\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define LOG_ITEM_BATCH_SIZE\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_done",
          "args": [
            "&cur"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "173-179",
          "snippet": "void\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_cursor_done(\n\tstruct xfs_ail_cursor\t*cur)\n{\n\tcur->item = NULL;\n\tlist_del_init(&cur->list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_item_batch_insert",
          "args": [
            "ailp",
            "&cur",
            "log_items",
            "i",
            "commit_lsn"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_item_batch_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "716-735",
          "snippet": "static inline void\nxfs_log_item_batch_insert(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n\tint\ti;\n\n\tspin_lock(&ailp->xa_lock);\n\t/* xfs_trans_ail_update_bulk drops ailp->xa_lock */\n\txfs_trans_ail_update_bulk(ailp, cur, log_items, nr_items, commit_lsn);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\n\t\tlip->li_ops->iop_unpin(lip, 0);\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_log_item_batch_insert(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n\tint\ti;\n\n\tspin_lock(&ailp->xa_lock);\n\t/* xfs_trans_ail_update_bulk drops ailp->xa_lock */\n\txfs_trans_ail_update_bulk(ailp, cur, log_items, nr_items, commit_lsn);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\n\t\tlip->li_ops->iop_unpin(lip, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lip->li_ops->iop_unpin",
          "args": [
            "lip",
            "0"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_update",
          "args": [
            "ailp",
            "lip",
            "item_lsn"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_priv.h",
          "lines": "100-107",
          "snippet": "static inline void\nxfs_trans_ail_update(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_update_bulk(ailp, NULL, &lip, 1, lsn);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nxfs_trans_ail_update(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_item\t*lip,\n\txfs_lsn_t\t\tlsn) __releases(ailp->xa_lock)\n{\n\txfs_trans_ail_update_bulk(ailp, NULL, &lip, 1, lsn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "item_lsn",
            "lip->li_lsn"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lip->li_ops->iop_unpin",
          "args": [
            "lip",
            "1"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FORCED_SHUTDOWN(ailp->xa_mount)"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "ailp->xa_mount"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "item_lsn",
            "(xfs_lsn_t)-1"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lip->li_ops->iop_committed",
          "args": [
            "lip",
            "commit_lsn"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_cursor_last",
          "args": [
            "ailp",
            "&cur",
            "commit_lsn"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_cursor_last",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "256-265",
          "snippet": "struct xfs_log_item *\nxfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_trans_ail_cursor_init(ailp, cur);\n\tcur->item = __xfs_trans_ail_cursor_last(ailp, lsn);\n\treturn cur->item;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_log_item *\nxfs_trans_ail_cursor_last(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\txfs_lsn_t\t\tlsn)\n{\n\txfs_trans_ail_cursor_init(ailp, cur);\n\tcur->item = __xfs_trans_ail_cursor_last(ailp, lsn);\n\treturn cur->item;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define LOG_ITEM_BATCH_SIZE\t32\n\nvoid\nxfs_trans_committed_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_vec\t*log_vector,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\taborted)\n{\n#define LOG_ITEM_BATCH_SIZE\t32\n\tstruct xfs_log_item\t*log_items[LOG_ITEM_BATCH_SIZE];\n\tstruct xfs_log_vec\t*lv;\n\tstruct xfs_ail_cursor\tcur;\n\tint\t\t\ti = 0;\n\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_cursor_last(ailp, &cur, commit_lsn);\n\tspin_unlock(&ailp->xa_lock);\n\n\t/* unpin all the log items */\n\tfor (lv = log_vector; lv; lv = lv->lv_next ) {\n\t\tstruct xfs_log_item\t*lip = lv->lv_item;\n\t\txfs_lsn_t\t\titem_lsn;\n\n\t\tif (aborted)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\titem_lsn = lip->li_ops->iop_committed(lip, commit_lsn);\n\n\t\t/* item_lsn of -1 means the item needs no further processing */\n\t\tif (XFS_LSN_CMP(item_lsn, (xfs_lsn_t)-1) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if we are aborting the operation, no point in inserting the\n\t\t * object into the AIL as we are in a shutdown situation.\n\t\t */\n\t\tif (aborted) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(ailp->xa_mount));\n\t\t\tlip->li_ops->iop_unpin(lip, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (item_lsn != commit_lsn) {\n\n\t\t\t/*\n\t\t\t * Not a bulk update option due to unusual item_lsn.\n\t\t\t * Push into AIL immediately, rechecking the lsn once\n\t\t\t * we have the ail lock. Then unpin the item. This does\n\t\t\t * not affect the AIL cursor the bulk insert path is\n\t\t\t * using.\n\t\t\t */\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (XFS_LSN_CMP(item_lsn, lip->li_lsn) > 0)\n\t\t\t\txfs_trans_ail_update(ailp, lip, item_lsn);\n\t\t\telse\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tlip->li_ops->iop_unpin(lip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Item is a candidate for bulk AIL insert.  */\n\t\tlog_items[i++] = lv->lv_item;\n\t\tif (i >= LOG_ITEM_BATCH_SIZE) {\n\t\t\txfs_log_item_batch_insert(ailp, &cur, log_items,\n\t\t\t\t\tLOG_ITEM_BATCH_SIZE, commit_lsn);\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\t/* make sure we insert the remainder! */\n\tif (i)\n\t\txfs_log_item_batch_insert(ailp, &cur, log_items, i, commit_lsn);\n\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n}"
  },
  {
    "function_name": "xfs_log_item_batch_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "716-735",
    "snippet": "static inline void\nxfs_log_item_batch_insert(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n\tint\ti;\n\n\tspin_lock(&ailp->xa_lock);\n\t/* xfs_trans_ail_update_bulk drops ailp->xa_lock */\n\txfs_trans_ail_update_bulk(ailp, cur, log_items, nr_items, commit_lsn);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\n\t\tlip->li_ops->iop_unpin(lip, 0);\n\t}\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lip->li_ops->iop_unpin",
          "args": [
            "lip",
            "0"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ail_update_bulk",
          "args": [
            "ailp",
            "cur",
            "log_items",
            "nr_items",
            "commit_lsn"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ail_update_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_ail.c",
          "lines": "637-684",
          "snippet": "void\nxfs_trans_ail_update_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tlsn) __releases(ailp->xa_lock)\n{\n\txfs_log_item_t\t\t*mlip;\n\tint\t\t\tmlip_changed = 0;\n\tint\t\t\ti;\n\tLIST_HEAD(tmp);\n\n\tASSERT(nr_items > 0);\t\t/* Not required, but true. */\n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (lip->li_flags & XFS_LI_IN_AIL) {\n\t\t\t/* check if we really need to move the item */\n\t\t\tif (XFS_LSN_CMP(lsn, lip->li_lsn) <= 0)\n\t\t\t\tcontinue;\n\n\t\t\ttrace_xfs_ail_move(lip, lip->li_lsn, lsn);\n\t\t\txfs_ail_delete(ailp, lip);\n\t\t\tif (mlip == lip)\n\t\t\t\tmlip_changed = 1;\n\t\t} else {\n\t\t\tlip->li_flags |= XFS_LI_IN_AIL;\n\t\t\ttrace_xfs_ail_insert(lip, 0, lsn);\n\t\t}\n\t\tlip->li_lsn = lsn;\n\t\tlist_add(&lip->li_ail, &tmp);\n\t}\n\n\tif (!list_empty(&tmp))\n\t\txfs_ail_splice(ailp, cur, &tmp, lsn);\n\n\tif (mlip_changed) {\n\t\tif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\n\t\t\txlog_assign_tail_lsn_locked(ailp->xa_mount);\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\txfs_log_space_wake(ailp->xa_mount);\n\t} else {\n\t\tspin_unlock(&ailp->xa_lock);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ail_update_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tlsn) __releases(ailp->xa_lock)\n{\n\txfs_log_item_t\t\t*mlip;\n\tint\t\t\tmlip_changed = 0;\n\tint\t\t\ti;\n\tLIST_HEAD(tmp);\n\n\tASSERT(nr_items > 0);\t\t/* Not required, but true. */\n\tmlip = xfs_ail_min(ailp);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\t\tif (lip->li_flags & XFS_LI_IN_AIL) {\n\t\t\t/* check if we really need to move the item */\n\t\t\tif (XFS_LSN_CMP(lsn, lip->li_lsn) <= 0)\n\t\t\t\tcontinue;\n\n\t\t\ttrace_xfs_ail_move(lip, lip->li_lsn, lsn);\n\t\t\txfs_ail_delete(ailp, lip);\n\t\t\tif (mlip == lip)\n\t\t\t\tmlip_changed = 1;\n\t\t} else {\n\t\t\tlip->li_flags |= XFS_LI_IN_AIL;\n\t\t\ttrace_xfs_ail_insert(lip, 0, lsn);\n\t\t}\n\t\tlip->li_lsn = lsn;\n\t\tlist_add(&lip->li_ail, &tmp);\n\t}\n\n\tif (!list_empty(&tmp))\n\t\txfs_ail_splice(ailp, cur, &tmp, lsn);\n\n\tif (mlip_changed) {\n\t\tif (!XFS_FORCED_SHUTDOWN(ailp->xa_mount))\n\t\t\txlog_assign_tail_lsn_locked(ailp->xa_mount);\n\t\tspin_unlock(&ailp->xa_lock);\n\n\t\txfs_log_space_wake(ailp->xa_mount);\n\t} else {\n\t\tspin_unlock(&ailp->xa_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ailp->xa_lock"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline void\nxfs_log_item_batch_insert(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_ail_cursor\t*cur,\n\tstruct xfs_log_item\t**log_items,\n\tint\t\t\tnr_items,\n\txfs_lsn_t\t\tcommit_lsn)\n{\n\tint\ti;\n\n\tspin_lock(&ailp->xa_lock);\n\t/* xfs_trans_ail_update_bulk drops ailp->xa_lock */\n\txfs_trans_ail_update_bulk(ailp, cur, log_items, nr_items, commit_lsn);\n\n\tfor (i = 0; i < nr_items; i++) {\n\t\tstruct xfs_log_item *lip = log_items[i];\n\n\t\tlip->li_ops->iop_unpin(lip, 0);\n\t}\n}"
  },
  {
    "function_name": "xfs_trans_free_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "693-714",
    "snippet": "void\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xfs_log_item_desc *lidp, *next;\n\n\tlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\tlip->li_desc = NULL;\n\n\t\tif (commit_lsn != NULLCOMMITLSN)\n\t\t\tlip->li_ops->iop_committing(lip, commit_lsn);\n\t\tif (flags & XFS_TRANS_ABORT)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\tlip->li_ops->iop_unlock(lip);\n\n\t\txfs_trans_free_item_desc(lidp);\n\t}\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_free_item_desc",
          "args": [
            "lidp"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_item_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "670-676",
          "snippet": "STATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nSTATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lip->li_ops->iop_unlock",
          "args": [
            "lip"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lip->li_ops->iop_committing",
          "args": [
            "lip",
            "commit_lsn"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "lidp",
            "next",
            "&tp->t_items",
            "lid_trans"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xfs_log_item_desc *lidp, *next;\n\n\tlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\tlip->li_desc = NULL;\n\n\t\tif (commit_lsn != NULLCOMMITLSN)\n\t\t\tlip->li_ops->iop_committing(lip, commit_lsn);\n\t\tif (flags & XFS_TRANS_ABORT)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\tlip->li_ops->iop_unlock(lip);\n\n\t\txfs_trans_free_item_desc(lidp);\n\t}\n}"
  },
  {
    "function_name": "xfs_trans_del_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "681-687",
    "snippet": "void\nxfs_trans_del_item(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_trans_free_item_desc(lip->li_desc);\n\tlip->li_desc = NULL;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_free_item_desc",
          "args": [
            "lip->li_desc"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_item_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "670-676",
          "snippet": "STATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_item_desc_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nSTATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_del_item(\n\tstruct xfs_log_item\t*lip)\n{\n\txfs_trans_free_item_desc(lip->li_desc);\n\tlip->li_desc = NULL;\n}"
  },
  {
    "function_name": "xfs_trans_free_item_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "670-676",
    "snippet": "STATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_log_item_desc_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_log_item_desc_zone",
            "lidp"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lidp->lid_trans"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nSTATIC void\nxfs_trans_free_item_desc(\n\tstruct xfs_log_item_desc *lidp)\n{\n\tlist_del_init(&lidp->lid_trans);\n\tkmem_zone_free(xfs_log_item_desc_zone, lidp);\n}"
  },
  {
    "function_name": "xfs_trans_add_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "651-668",
    "snippet": "void\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_log_item_desc_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lidp->lid_trans",
            "&tp->t_items"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_log_item_desc_zone",
            "KM_SLEEP | KM_NOFS"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lip->li_ailp == tp->t_mountp->m_ail"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lip->li_mountp == tp->t_mountp"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_item_desc_zone;\n\nvoid\nxfs_trans_add_item(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_log_item\t*lip)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\tASSERT(lip->li_mountp == tp->t_mountp);\n\tASSERT(lip->li_ailp == tp->t_mountp->m_ail);\n\n\tlidp = kmem_zone_zalloc(xfs_log_item_desc_zone, KM_SLEEP | KM_NOFS);\n\n\tlidp->lid_item = lip;\n\tlidp->lid_flags = 0;\n\tlist_add_tail(&lidp->lid_trans, &tp->t_items);\n\n\tlip->li_desc = lidp;\n}"
  },
  {
    "function_name": "xfs_trans_unreserve_and_mod_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "510-644",
    "snippet": "void\nxfs_trans_unreserve_and_mod_sb(\n\txfs_trans_t\t*tp)\n{\n\txfs_mod_sb_t\tmsb[9];\t/* If you add cases, add entries */\n\txfs_mod_sb_t\t*msbp;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\t/* REFERENCED */\n\tint\t\terror;\n\tint\t\trsvd;\n\tint64_t\t\tblkdelta = 0;\n\tint64_t\t\trtxdelta = 0;\n\tint64_t\t\tidelta = 0;\n\tint64_t\t\tifreedelta = 0;\n\n\tmsbp = msb;\n\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* calculate deltas */\n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t/* apply the per-cpu counters */\n\tif (blkdelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t blkdelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (idelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT,\n\t\t\t\t\t\t idelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_fdblocks;\n\t}\n\n\tif (ifreedelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,\n\t\t\t\t\t\t ifreedelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_icount;\n\t}\n\n\t/* apply remaining deltas */\n\tif (rtxdelta != 0) {\n\t\tmsbp->msb_field = XFS_SBS_FREXTENTS;\n\t\tmsbp->msb_delta = rtxdelta;\n\t\tmsbp++;\n\t}\n\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY) {\n\t\tif (tp->t_dblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_DBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_dblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_agcount_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_AGCOUNT;\n\t\t\tmsbp->msb_delta = tp->t_agcount_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_imaxpct_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_IMAX_PCT;\n\t\t\tmsbp->msb_delta = tp->t_imaxpct_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextsize_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSIZE;\n\t\t\tmsbp->msb_delta = tp->t_rextsize_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rbmblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBMBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rbmblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextents_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTENTS;\n\t\t\tmsbp->msb_delta = tp->t_rextents_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextslog_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSLOG;\n\t\t\tmsbp->msb_delta = tp->t_rextslog_delta;\n\t\t\tmsbp++;\n\t\t}\n\t}\n\n\t/*\n\t * If we need to change anything, do it.\n\t */\n\tif (msbp > msb) {\n\t\terror = xfs_mod_incore_sb_batch(tp->t_mountp, msb,\n\t\t\t(uint)(msbp - msb), rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_ifreecount;\n\t}\n\n\treturn;\n\nout_undo_ifreecount:\n\tif (ifreedelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);\nout_undo_icount:\n\tif (idelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);\nout_undo_fdblocks:\n\tif (blkdelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, -blkdelta, rsvd);\nout:\n\tASSERT(error == 0);\n\treturn;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "error == 0"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_modify_counters",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS",
            "-blkdelta",
            "rsvd"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_modify_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1846-1977",
          "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mod_incore_sb_batch",
          "args": [
            "tp->t_mountp",
            "msb",
            "(uint)(msbp - msb)",
            "rsvd"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mod_incore_sb_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1312-1349",
          "snippet": "int\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "msbp - msb"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslazysbcount",
          "args": [
            "&mp->m_sb"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslazysbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "441-446",
          "snippet": "static inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_unreserve_and_mod_sb(\n\txfs_trans_t\t*tp)\n{\n\txfs_mod_sb_t\tmsb[9];\t/* If you add cases, add entries */\n\txfs_mod_sb_t\t*msbp;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\t/* REFERENCED */\n\tint\t\terror;\n\tint\t\trsvd;\n\tint64_t\t\tblkdelta = 0;\n\tint64_t\t\trtxdelta = 0;\n\tint64_t\t\tidelta = 0;\n\tint64_t\t\tifreedelta = 0;\n\n\tmsbp = msb;\n\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* calculate deltas */\n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t/* apply the per-cpu counters */\n\tif (blkdelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t blkdelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (idelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT,\n\t\t\t\t\t\t idelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_fdblocks;\n\t}\n\n\tif (ifreedelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,\n\t\t\t\t\t\t ifreedelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_icount;\n\t}\n\n\t/* apply remaining deltas */\n\tif (rtxdelta != 0) {\n\t\tmsbp->msb_field = XFS_SBS_FREXTENTS;\n\t\tmsbp->msb_delta = rtxdelta;\n\t\tmsbp++;\n\t}\n\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY) {\n\t\tif (tp->t_dblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_DBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_dblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_agcount_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_AGCOUNT;\n\t\t\tmsbp->msb_delta = tp->t_agcount_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_imaxpct_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_IMAX_PCT;\n\t\t\tmsbp->msb_delta = tp->t_imaxpct_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextsize_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSIZE;\n\t\t\tmsbp->msb_delta = tp->t_rextsize_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rbmblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBMBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rbmblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextents_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTENTS;\n\t\t\tmsbp->msb_delta = tp->t_rextents_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextslog_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSLOG;\n\t\t\tmsbp->msb_delta = tp->t_rextslog_delta;\n\t\t\tmsbp++;\n\t\t}\n\t}\n\n\t/*\n\t * If we need to change anything, do it.\n\t */\n\tif (msbp > msb) {\n\t\terror = xfs_mod_incore_sb_batch(tp->t_mountp, msb,\n\t\t\t(uint)(msbp - msb), rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_ifreecount;\n\t}\n\n\treturn;\n\nout_undo_ifreecount:\n\tif (ifreedelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);\nout_undo_icount:\n\tif (idelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);\nout_undo_fdblocks:\n\tif (blkdelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, -blkdelta, rsvd);\nout:\n\tASSERT(error == 0);\n\treturn;\n}"
  },
  {
    "function_name": "xfs_trans_apply_sb_deltas",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "405-489",
    "snippet": "STATIC void\nxfs_trans_apply_sb_deltas(\n\txfs_trans_t\t*tp)\n{\n\txfs_dsb_t\t*sbp;\n\txfs_buf_t\t*bp;\n\tint\t\twhole = 0;\n\n\tbp = xfs_trans_getsb(tp, tp->t_mountp, 0);\n\tsbp = XFS_BUF_TO_SBP(bp);\n\n\t/*\n\t * Check that superblock mods match the mods made to AGF counters.\n\t */\n\tASSERT((tp->t_fdblocks_delta + tp->t_res_fdblocks_delta) ==\n\t       (tp->t_ag_freeblks_delta + tp->t_ag_flist_delta +\n\t\ttp->t_ag_btree_delta));\n\n\t/*\n\t * Only update the superblock counters if we are logging them\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&(tp->t_mountp->m_sb))) {\n\t\tif (tp->t_icount_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_icount, tp->t_icount_delta);\n\t\tif (tp->t_ifree_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_ifree, tp->t_ifree_delta);\n\t\tif (tp->t_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_fdblocks_delta);\n\t\tif (tp->t_res_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_res_fdblocks_delta);\n\t}\n\n\tif (tp->t_frextents_delta)\n\t\tbe64_add_cpu(&sbp->sb_frextents, tp->t_frextents_delta);\n\tif (tp->t_res_frextents_delta)\n\t\tbe64_add_cpu(&sbp->sb_frextents, tp->t_res_frextents_delta);\n\n\tif (tp->t_dblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_dblocks, tp->t_dblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_agcount_delta) {\n\t\tbe32_add_cpu(&sbp->sb_agcount, tp->t_agcount_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_imaxpct_delta) {\n\t\tsbp->sb_imax_pct += tp->t_imaxpct_delta;\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextsize_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rextsize, tp->t_rextsize_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rbmblocks_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rbmblocks, tp->t_rbmblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rblocks, tp->t_rblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextents_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rextents, tp->t_rextents_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextslog_delta) {\n\t\tsbp->sb_rextslog += tp->t_rextslog_delta;\n\t\twhole = 1;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\tif (whole)\n\t\t/*\n\t\t * Log the whole thing, the fields are noncontiguous.\n\t\t */\n\t\txfs_trans_log_buf(tp, bp, 0, sizeof(xfs_dsb_t) - 1);\n\telse\n\t\t/*\n\t\t * Since all the modifiable fields are contiguous, we\n\t\t * can get away with this.\n\t\t */\n\t\txfs_trans_log_buf(tp, bp, offsetof(xfs_dsb_t, sb_icount),\n\t\t\t\t  offsetof(xfs_dsb_t, sb_frextents) +\n\t\t\t\t  sizeof(sbp->sb_frextents) - 1);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "offsetof(xfs_dsb_t, sb_icount)",
            "offsetof(xfs_dsb_t, sb_frextents) +\n\t\t\t\t  sizeof(sbp->sb_frextents) - 1"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_SB_BUF"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_rextents",
            "tp->t_rextents_delta"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_rblocks",
            "tp->t_rblocks_delta"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&sbp->sb_rbmblocks",
            "tp->t_rbmblocks_delta"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&sbp->sb_rextsize",
            "tp->t_rextsize_delta"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&sbp->sb_agcount",
            "tp->t_agcount_delta"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_dblocks",
            "tp->t_dblocks_delta"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_frextents",
            "tp->t_res_frextents_delta"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_frextents",
            "tp->t_frextents_delta"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_fdblocks",
            "tp->t_res_fdblocks_delta"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_fdblocks",
            "tp->t_fdblocks_delta"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_ifree",
            "tp->t_ifree_delta"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_add_cpu",
          "args": [
            "&sbp->sb_icount",
            "tp->t_icount_delta"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslazysbcount",
          "args": [
            "&(tp->t_mountp->m_sb)"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslazysbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "441-446",
          "snippet": "static inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(tp->t_fdblocks_delta + tp->t_res_fdblocks_delta) ==\n\t       (tp->t_ag_freeblks_delta + tp->t_ag_flist_delta +\n\t\ttp->t_ag_btree_delta)"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_getsb",
          "args": [
            "tp",
            "tp->t_mountp",
            "0"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_getsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "190-228",
          "snippet": "xfs_buf_t *\nxfs_trans_getsb(xfs_trans_t\t*tp,\n\t\tstruct xfs_mount *mp,\n\t\tint\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to just trying to lock the superblock buffer\n\t * if tp is NULL.\n\t */\n\tif (tp == NULL)\n\t\treturn xfs_getsb(mp, flags);\n\n\t/*\n\t * If the superblock buffer already has this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = mp->m_sb_bp;\n\tif (bp->b_transp == tp) {\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_getsb_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_getsb(mp, flags);\n\tif (bp == NULL)\n\t\treturn NULL;\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_getsb(bp->b_fspriv);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_buf_t *\nxfs_trans_getsb(xfs_trans_t\t*tp,\n\t\tstruct xfs_mount *mp,\n\t\tint\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to just trying to lock the superblock buffer\n\t * if tp is NULL.\n\t */\n\tif (tp == NULL)\n\t\treturn xfs_getsb(mp, flags);\n\n\t/*\n\t * If the superblock buffer already has this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = mp->m_sb_bp;\n\tif (bp->b_transp == tp) {\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_getsb_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_getsb(mp, flags);\n\tif (bp == NULL)\n\t\treturn NULL;\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_getsb(bp->b_fspriv);\n\treturn bp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_trans_apply_sb_deltas(\n\txfs_trans_t\t*tp)\n{\n\txfs_dsb_t\t*sbp;\n\txfs_buf_t\t*bp;\n\tint\t\twhole = 0;\n\n\tbp = xfs_trans_getsb(tp, tp->t_mountp, 0);\n\tsbp = XFS_BUF_TO_SBP(bp);\n\n\t/*\n\t * Check that superblock mods match the mods made to AGF counters.\n\t */\n\tASSERT((tp->t_fdblocks_delta + tp->t_res_fdblocks_delta) ==\n\t       (tp->t_ag_freeblks_delta + tp->t_ag_flist_delta +\n\t\ttp->t_ag_btree_delta));\n\n\t/*\n\t * Only update the superblock counters if we are logging them\n\t */\n\tif (!xfs_sb_version_haslazysbcount(&(tp->t_mountp->m_sb))) {\n\t\tif (tp->t_icount_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_icount, tp->t_icount_delta);\n\t\tif (tp->t_ifree_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_ifree, tp->t_ifree_delta);\n\t\tif (tp->t_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_fdblocks_delta);\n\t\tif (tp->t_res_fdblocks_delta)\n\t\t\tbe64_add_cpu(&sbp->sb_fdblocks, tp->t_res_fdblocks_delta);\n\t}\n\n\tif (tp->t_frextents_delta)\n\t\tbe64_add_cpu(&sbp->sb_frextents, tp->t_frextents_delta);\n\tif (tp->t_res_frextents_delta)\n\t\tbe64_add_cpu(&sbp->sb_frextents, tp->t_res_frextents_delta);\n\n\tif (tp->t_dblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_dblocks, tp->t_dblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_agcount_delta) {\n\t\tbe32_add_cpu(&sbp->sb_agcount, tp->t_agcount_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_imaxpct_delta) {\n\t\tsbp->sb_imax_pct += tp->t_imaxpct_delta;\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextsize_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rextsize, tp->t_rextsize_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rbmblocks_delta) {\n\t\tbe32_add_cpu(&sbp->sb_rbmblocks, tp->t_rbmblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rblocks_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rblocks, tp->t_rblocks_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextents_delta) {\n\t\tbe64_add_cpu(&sbp->sb_rextents, tp->t_rextents_delta);\n\t\twhole = 1;\n\t}\n\tif (tp->t_rextslog_delta) {\n\t\tsbp->sb_rextslog += tp->t_rextslog_delta;\n\t\twhole = 1;\n\t}\n\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\tif (whole)\n\t\t/*\n\t\t * Log the whole thing, the fields are noncontiguous.\n\t\t */\n\t\txfs_trans_log_buf(tp, bp, 0, sizeof(xfs_dsb_t) - 1);\n\telse\n\t\t/*\n\t\t * Since all the modifiable fields are contiguous, we\n\t\t * can get away with this.\n\t\t */\n\t\txfs_trans_log_buf(tp, bp, offsetof(xfs_dsb_t, sb_icount),\n\t\t\t\t  offsetof(xfs_dsb_t, sb_frextents) +\n\t\t\t\t  sizeof(sbp->sb_frextents) - 1);\n}"
  },
  {
    "function_name": "xfs_trans_mod_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "297-395",
    "snippet": "void\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "delta > 0"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "delta > 0"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "delta < 0"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_rtx_res_used <= tp->t_rtx_res"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_haslazysbcount",
          "args": [
            "&mp->m_sb"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_haslazysbcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "441-446",
          "snippet": "static inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_LAZYSBCOUNTBIT\t0x00000002\t/* Superblk counters */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_haslazysbcount(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_LAZYSBCOUNTBIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "delta < 0"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_blk_res_used <= tp->t_blk_res"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_mod_sb(\n\txfs_trans_t\t*tp,\n\tuint\t\tfield,\n\tint64_t\t\tdelta)\n{\n\tuint32_t\tflags = (XFS_TRANS_DIRTY|XFS_TRANS_SB_DIRTY);\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tswitch (field) {\n\tcase XFS_TRANS_SB_ICOUNT:\n\t\ttp->t_icount_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IFREE:\n\t\ttp->t_ifree_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FDBLOCKS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_blk_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_blk_res_used <= tp->t_blk_res);\n\t\t}\n\t\ttp->t_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FDBLOCKS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_fdblocks_delta += delta;\n\t\tif (xfs_sb_version_haslazysbcount(&mp->m_sb))\n\t\t\tflags &= ~XFS_TRANS_SB_DIRTY;\n\t\tbreak;\n\tcase XFS_TRANS_SB_FREXTENTS:\n\t\t/*\n\t\t * Track the number of blocks allocated in the\n\t\t * transaction.  Make sure it does not exceed the\n\t\t * number reserved.\n\t\t */\n\t\tif (delta < 0) {\n\t\t\ttp->t_rtx_res_used += (uint)-delta;\n\t\t\tASSERT(tp->t_rtx_res_used <= tp->t_rtx_res);\n\t\t}\n\t\ttp->t_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RES_FREXTENTS:\n\t\t/*\n\t\t * The allocation has already been applied to the\n\t\t * in-core superblock's counter.  This should only\n\t\t * be applied to the on-disk superblock.\n\t\t */\n\t\tASSERT(delta < 0);\n\t\ttp->t_res_frextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_DBLOCKS:\n\t\tASSERT(delta > 0);\n\t\ttp->t_dblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_AGCOUNT:\n\t\tASSERT(delta > 0);\n\t\ttp->t_agcount_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_IMAXPCT:\n\t\ttp->t_imaxpct_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSIZE:\n\t\ttp->t_rextsize_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBMBLOCKS:\n\t\ttp->t_rbmblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_RBLOCKS:\n\t\ttp->t_rblocks_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTENTS:\n\t\ttp->t_rextents_delta += delta;\n\t\tbreak;\n\tcase XFS_TRANS_SB_REXTSLOG:\n\t\ttp->t_rextslog_delta += delta;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\ttp->t_flags |= flags;\n}"
  },
  {
    "function_name": "xfs_trans_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "168-279",
    "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_restore_flags_nested",
          "args": [
            "&tp->t_pflags",
            "PF_FSTRANS"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_modify_counters",
          "args": [
            "tp->t_mountp",
            "XFS_SBS_FDBLOCKS",
            "(int64_t)blocks",
            "rsvd"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_modify_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1846-1977",
          "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_done",
          "args": [
            "tp->t_mountp",
            "tp->t_ticket",
            "NULL",
            "log_flags"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "511-557",
          "snippet": "xfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mod_incore_sb",
          "args": [
            "tp->t_mountp",
            "XFS_SBS_FREXTENTS",
            "-((int64_t)rtextents)",
            "rsvd"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mod_incore_sb_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1312-1349",
          "snippet": "int\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_reserve",
          "args": [
            "tp->t_mountp",
            "resp->tr_logres",
            "resp->tr_logcount",
            "&tp->t_ticket",
            "XFS_TRANSACTION",
            "permanent",
            "tp->t_type"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "431-487",
          "snippet": "int\nxfs_log_reserve(\n\tstruct xfs_mount\t*mp,\n\tint\t\t \tunit_bytes,\n\tint\t\t \tcnt,\n\tstruct xlog_ticket\t**ticp,\n\t__uint8_t\t \tclient,\n\tbool\t\t\tpermanent,\n\tuint\t\t \tt_type)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(client == XFS_TRANSACTION || client == XFS_LOG);\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\tASSERT(*ticp == NULL);\n\ttic = xlog_ticket_alloc(log, unit_bytes, cnt, client, permanent,\n\t\t\t\tKM_SLEEP | KM_MAYFAIL);\n\tif (!tic)\n\t\treturn -ENOMEM;\n\n\ttic->t_trans_type = t_type;\n\t*ticp = tic;\n\n\txlog_grant_push_ail(log, tic->t_cnt ? tic->t_unit_res * tic->t_cnt\n\t\t\t\t\t    : tic->t_unit_res);\n\n\ttrace_xfs_log_reserve(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_reserve_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, need_bytes);\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_reserve_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_reserve(\n\tstruct xfs_mount\t*mp,\n\tint\t\t \tunit_bytes,\n\tint\t\t \tcnt,\n\tstruct xlog_ticket\t**ticp,\n\t__uint8_t\t \tclient,\n\tbool\t\t\tpermanent,\n\tuint\t\t \tt_type)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tASSERT(client == XFS_TRANSACTION || client == XFS_LOG);\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\tASSERT(*ticp == NULL);\n\ttic = xlog_ticket_alloc(log, unit_bytes, cnt, client, permanent,\n\t\t\t\tKM_SLEEP | KM_MAYFAIL);\n\tif (!tic)\n\t\treturn -ENOMEM;\n\n\ttic->t_trans_type = t_type;\n\t*ticp = tic;\n\n\txlog_grant_push_ail(log, tic->t_cnt ? tic->t_unit_res * tic->t_cnt\n\t\t\t\t\t    : tic->t_unit_res);\n\n\ttrace_xfs_log_reserve(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_reserve_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_reserve_head.grant, need_bytes);\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_reserve_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_regrant",
          "args": [
            "tp->t_mountp",
            "tp->t_ticket"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_regrant",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "370-421",
          "snippet": "int\nxfs_log_regrant(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*tic)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\t/*\n\t * This is a new transaction on the ticket, so we need to change the\n\t * transaction ID so that the next transaction has a different TID in\n\t * the log. Just add one to the existing tid so that we can see chains\n\t * of rolling transactions in the log easily.\n\t */\n\ttic->t_tid++;\n\n\txlog_grant_push_ail(log, tic->t_unit_res);\n\n\ttic->t_curr_res = tic->t_unit_res;\n\txlog_tic_reset_res(tic);\n\n\tif (tic->t_cnt > 0)\n\t\treturn 0;\n\n\ttrace_xfs_log_regrant(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_write_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_regrant_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void\nxlog_grant_push_ail(\n\tstruct xlog\t\t*log,\n\tint\t\t\tneed_bytes);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxfs_log_regrant(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*tic)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tint\t\t\tneed_bytes;\n\tint\t\t\terror = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_try_logspace);\n\n\t/*\n\t * This is a new transaction on the ticket, so we need to change the\n\t * transaction ID so that the next transaction has a different TID in\n\t * the log. Just add one to the existing tid so that we can see chains\n\t * of rolling transactions in the log easily.\n\t */\n\ttic->t_tid++;\n\n\txlog_grant_push_ail(log, tic->t_unit_res);\n\n\ttic->t_curr_res = tic->t_unit_res;\n\txlog_tic_reset_res(tic);\n\n\tif (tic->t_cnt > 0)\n\t\treturn 0;\n\n\ttrace_xfs_log_regrant(log, tic);\n\n\terror = xlog_grant_head_check(log, &log->l_write_head, tic,\n\t\t\t\t      &need_bytes);\n\tif (error)\n\t\tgoto out_error;\n\n\txlog_grant_add_space(log, &log->l_write_head.grant, need_bytes);\n\ttrace_xfs_log_regrant_exit(log, tic);\n\txlog_verify_grant_tail(log);\n\treturn 0;\n\nout_error:\n\t/*\n\t * If we are failing, make sure the ticket doesn't have any current\n\t * reservations.  We don't want to add this back when the ticket/\n\t * transaction gets cancelled.\n\t */\n\ttic->t_curr_res = 0;\n\ttic->t_cnt = 0;\t/* ungrant will give back unit_res * t_cnt. */\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "resp->tr_logflags & XFS_TRANS_PERM_LOG_RES"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(tp->t_flags & XFS_TRANS_PERM_LOG_RES)"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_ticket == NULL"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_restore_flags_nested",
          "args": [
            "&tp->t_pflags",
            "PF_FSTRANS"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_set_flags_nested",
          "args": [
            "&tp->t_pflags",
            "PF_FSTRANS"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_trans_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "116-152",
    "snippet": "xfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_trans_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&tp->t_mountp->m_active_trans"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_dup_dqinfo",
          "args": [
            "tp",
            "ntp"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_dup_dqinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "87-136",
          "snippet": "void\nxfs_trans_dup_dqinfo(\n\txfs_trans_t\t*otp,\n\txfs_trans_t\t*ntp)\n{\n\txfs_dqtrx_t\t*oq, *nq;\n\tint\t\ti,j;\n\txfs_dqtrx_t\t*oqa, *nqa;\n\n\tif (!otp->t_dqinfo)\n\t\treturn;\n\n\txfs_trans_alloc_dqinfo(ntp);\n\n\t/*\n\t * Because the quota blk reservation is carried forward,\n\t * it is also necessary to carry forward the DQ_DIRTY flag.\n\t */\n\tif(otp->t_flags & XFS_TRANS_DQ_DIRTY)\n\t\tntp->t_flags |= XFS_TRANS_DQ_DIRTY;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\toqa = otp->t_dqinfo->dqs[j];\n\t\tnqa = ntp->t_dqinfo->dqs[j];\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tif (oqa[i].qt_dquot == NULL)\n\t\t\t\tbreak;\n\t\t\toq = &oqa[i];\n\t\t\tnq = &nqa[i];\n\n\t\t\tnq->qt_dquot = oq->qt_dquot;\n\t\t\tnq->qt_bcount_delta = nq->qt_icount_delta = 0;\n\t\t\tnq->qt_rtbcount_delta = 0;\n\n\t\t\t/*\n\t\t\t * Transfer whatever is left of the reservations.\n\t\t\t */\n\t\t\tnq->qt_blk_res = oq->qt_blk_res - oq->qt_blk_res_used;\n\t\t\toq->qt_blk_res = oq->qt_blk_res_used;\n\n\t\t\tnq->qt_rtblk_res = oq->qt_rtblk_res -\n\t\t\t\toq->qt_rtblk_res_used;\n\t\t\toq->qt_rtblk_res = oq->qt_rtblk_res_used;\n\n\t\t\tnq->qt_ino_res = oq->qt_ino_res - oq->qt_ino_res_used;\n\t\t\toq->qt_ino_res = oq->qt_ino_res_used;\n\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_dup_dqinfo(\n\txfs_trans_t\t*otp,\n\txfs_trans_t\t*ntp)\n{\n\txfs_dqtrx_t\t*oq, *nq;\n\tint\t\ti,j;\n\txfs_dqtrx_t\t*oqa, *nqa;\n\n\tif (!otp->t_dqinfo)\n\t\treturn;\n\n\txfs_trans_alloc_dqinfo(ntp);\n\n\t/*\n\t * Because the quota blk reservation is carried forward,\n\t * it is also necessary to carry forward the DQ_DIRTY flag.\n\t */\n\tif(otp->t_flags & XFS_TRANS_DQ_DIRTY)\n\t\tntp->t_flags |= XFS_TRANS_DQ_DIRTY;\n\n\tfor (j = 0; j < XFS_QM_TRANS_DQTYPES; j++) {\n\t\toqa = otp->t_dqinfo->dqs[j];\n\t\tnqa = ntp->t_dqinfo->dqs[j];\n\t\tfor (i = 0; i < XFS_QM_TRANS_MAXDQS; i++) {\n\t\t\tif (oqa[i].qt_dquot == NULL)\n\t\t\t\tbreak;\n\t\t\toq = &oqa[i];\n\t\t\tnq = &nqa[i];\n\n\t\t\tnq->qt_dquot = oq->qt_dquot;\n\t\t\tnq->qt_bcount_delta = nq->qt_icount_delta = 0;\n\t\t\tnq->qt_rtbcount_delta = 0;\n\n\t\t\t/*\n\t\t\t * Transfer whatever is left of the reservations.\n\t\t\t */\n\t\t\tnq->qt_blk_res = oq->qt_blk_res - oq->qt_blk_res_used;\n\t\t\toq->qt_blk_res = oq->qt_blk_res_used;\n\n\t\t\tnq->qt_rtblk_res = oq->qt_rtblk_res -\n\t\t\t\toq->qt_rtblk_res_used;\n\t\t\toq->qt_rtblk_res = oq->qt_rtblk_res_used;\n\n\t\t\tnq->qt_ino_res = oq->qt_ino_res - oq->qt_ino_res_used;\n\t\t\toq->qt_ino_res = oq->qt_ino_res_used;\n\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_get",
          "args": [
            "tp->t_ticket"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3505-3512",
          "snippet": "xlog_ticket_t *\nxfs_log_ticket_get(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tatomic_inc(&ticket->t_ref);\n\treturn ticket;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nxlog_ticket_t *\nxfs_log_ticket_get(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tatomic_inc(&ticket->t_ref);\n\treturn ticket;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_ticket != NULL"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_flags & XFS_TRANS_PERM_LOG_RES"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ntp->t_busy"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ntp->t_items"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_trans_zone",
            "KM_SLEEP"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\nxfs_trans_dup(\n\txfs_trans_t\t*tp)\n{\n\txfs_trans_t\t*ntp;\n\n\tntp = kmem_zone_zalloc(xfs_trans_zone, KM_SLEEP);\n\n\t/*\n\t * Initialize the new transaction structure.\n\t */\n\tntp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\tntp->t_type = tp->t_type;\n\tntp->t_mountp = tp->t_mountp;\n\tINIT_LIST_HEAD(&ntp->t_items);\n\tINIT_LIST_HEAD(&ntp->t_busy);\n\n\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tASSERT(tp->t_ticket != NULL);\n\n\tntp->t_flags = XFS_TRANS_PERM_LOG_RES |\n\t\t       (tp->t_flags & XFS_TRANS_RESERVE) |\n\t\t       (tp->t_flags & XFS_TRANS_FREEZE_PROT);\n\t/* We gave our writer reference to the new transaction */\n\ttp->t_flags &= ~XFS_TRANS_FREEZE_PROT;\n\tntp->t_ticket = xfs_log_ticket_get(tp->t_ticket);\n\tntp->t_blk_res = tp->t_blk_res - tp->t_blk_res_used;\n\ttp->t_blk_res = tp->t_blk_res_used;\n\tntp->t_rtx_res = tp->t_rtx_res - tp->t_rtx_res_used;\n\ttp->t_rtx_res = tp->t_rtx_res_used;\n\tntp->t_pflags = tp->t_pflags;\n\n\txfs_trans_dup_dqinfo(tp, ntp);\n\n\tatomic_inc(&tp->t_mountp->m_active_trans);\n\treturn ntp;\n}"
  },
  {
    "function_name": "xfs_trans_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "94-106",
    "snippet": "STATIC void\nxfs_trans_free(\n\tstruct xfs_trans\t*tp)\n{\n\txfs_extent_busy_sort(&tp->t_busy);\n\txfs_extent_busy_clear(tp->t_mountp, &tp->t_busy, false);\n\n\tatomic_dec(&tp->t_mountp->m_active_trans);\n\tif (tp->t_flags & XFS_TRANS_FREEZE_PROT)\n\t\tsb_end_intwrite(tp->t_mountp->m_super);\n\txfs_trans_free_dqinfo(tp);\n\tkmem_zone_free(xfs_trans_zone, tp);\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_trans_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_trans_zone",
            "tp"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_free_dqinfo",
          "args": [
            "tp"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_dqinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "879-887",
          "snippet": "void\nxfs_trans_free_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\tif (!tp->t_dqinfo)\n\t\treturn;\n\tkmem_zone_free(xfs_qm_dqtrxzone, tp->t_dqinfo);\n\ttp->t_dqinfo = NULL;\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_free_dqinfo(\n\txfs_trans_t\t*tp)\n{\n\tif (!tp->t_dqinfo)\n\t\treturn;\n\tkmem_zone_free(xfs_qm_dqtrxzone, tp->t_dqinfo);\n\ttp->t_dqinfo = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_end_intwrite",
          "args": [
            "tp->t_mountp->m_super"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&tp->t_mountp->m_active_trans"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_clear",
          "args": [
            "tp->t_mountp",
            "&tp->t_busy",
            "false"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "559-591",
          "snippet": "void\nxfs_extent_busy_clear(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list,\n\tbool\t\t\tdo_discard)\n{\n\tstruct xfs_extent_busy\t*busyp, *n;\n\tstruct xfs_perag\t*pag = NULL;\n\txfs_agnumber_t\t\tagno = NULLAGNUMBER;\n\n\tlist_for_each_entry_safe(busyp, n, list, list) {\n\t\tif (busyp->agno != agno) {\n\t\t\tif (pag) {\n\t\t\t\tspin_unlock(&pag->pagb_lock);\n\t\t\t\txfs_perag_put(pag);\n\t\t\t}\n\t\t\tpag = xfs_perag_get(mp, busyp->agno);\n\t\t\tspin_lock(&pag->pagb_lock);\n\t\t\tagno = busyp->agno;\n\t\t}\n\n\t\tif (do_discard && busyp->length &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD))\n\t\t\tbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\n\t\telse\n\t\t\txfs_extent_busy_clear_one(mp, pag, busyp);\n\t}\n\n\tif (pag) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\txfs_perag_put(pag);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_clear(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list,\n\tbool\t\t\tdo_discard)\n{\n\tstruct xfs_extent_busy\t*busyp, *n;\n\tstruct xfs_perag\t*pag = NULL;\n\txfs_agnumber_t\t\tagno = NULLAGNUMBER;\n\n\tlist_for_each_entry_safe(busyp, n, list, list) {\n\t\tif (busyp->agno != agno) {\n\t\t\tif (pag) {\n\t\t\t\tspin_unlock(&pag->pagb_lock);\n\t\t\t\txfs_perag_put(pag);\n\t\t\t}\n\t\t\tpag = xfs_perag_get(mp, busyp->agno);\n\t\t\tspin_lock(&pag->pagb_lock);\n\t\t\tagno = busyp->agno;\n\t\t}\n\n\t\tif (do_discard && busyp->length &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD))\n\t\t\tbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\n\t\telse\n\t\t\txfs_extent_busy_clear_one(mp, pag, busyp);\n\t}\n\n\tif (pag) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\txfs_perag_put(pag);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_sort",
          "args": [
            "&tp->t_busy"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.h",
          "lines": "68-71",
          "snippet": "static inline void xfs_extent_busy_sort(struct list_head *list)\n{\n\tlist_sort(NULL, list, xfs_extent_busy_ag_cmp);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_extent_busy_sort(struct list_head *list)\n{\n\tlist_sort(NULL, list, xfs_extent_busy_ag_cmp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nSTATIC void\nxfs_trans_free(\n\tstruct xfs_trans\t*tp)\n{\n\txfs_extent_busy_sort(&tp->t_busy);\n\txfs_extent_busy_clear(tp->t_mountp, &tp->t_busy, false);\n\n\tatomic_dec(&tp->t_mountp->m_active_trans);\n\tif (tp->t_flags & XFS_TRANS_FREEZE_PROT)\n\t\tsb_end_intwrite(tp->t_mountp->m_super);\n\txfs_trans_free_dqinfo(tp);\n\tkmem_zone_free(xfs_trans_zone, tp);\n}"
  },
  {
    "function_name": "_xfs_trans_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "70-88",
    "snippet": "xfs_trans_t *\n_xfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype,\n\txfs_km_flags_t\tmemflags)\n{\n\txfs_trans_t\t*tp;\n\n\tWARN_ON(mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tatomic_inc(&mp->m_active_trans);\n\n\ttp = kmem_zone_zalloc(xfs_trans_zone, memflags);\n\ttp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\ttp->t_type = type;\n\ttp->t_mountp = mp;\n\tINIT_LIST_HEAD(&tp->t_items);\n\tINIT_LIST_HEAD(&tp->t_busy);\n\treturn tp;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t*xfs_trans_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tp->t_busy"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tp->t_items"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_trans_zone",
            "memflags"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&mp->m_active_trans"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\n_xfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype,\n\txfs_km_flags_t\tmemflags)\n{\n\txfs_trans_t\t*tp;\n\n\tWARN_ON(mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tatomic_inc(&mp->m_active_trans);\n\n\ttp = kmem_zone_zalloc(xfs_trans_zone, memflags);\n\ttp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\ttp->t_type = type;\n\ttp->t_mountp = mp;\n\tINIT_LIST_HEAD(&tp->t_items);\n\tINIT_LIST_HEAD(&tp->t_busy);\n\treturn tp;\n}"
  },
  {
    "function_name": "xfs_trans_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "57-68",
    "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_xfs_trans_alloc",
          "args": [
            "mp",
            "type",
            "KM_SLEEP"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "70-88",
          "snippet": "xfs_trans_t *\n_xfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype,\n\txfs_km_flags_t\tmemflags)\n{\n\txfs_trans_t\t*tp;\n\n\tWARN_ON(mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tatomic_inc(&mp->m_active_trans);\n\n\ttp = kmem_zone_zalloc(xfs_trans_zone, memflags);\n\ttp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\ttp->t_type = type;\n\ttp->t_mountp = mp;\n\tINIT_LIST_HEAD(&tp->t_items);\n\tINIT_LIST_HEAD(&tp->t_busy);\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_trans_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\n_xfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype,\n\txfs_km_flags_t\tmemflags)\n{\n\txfs_trans_t\t*tp;\n\n\tWARN_ON(mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tatomic_inc(&mp->m_active_trans);\n\n\ttp = kmem_zone_zalloc(xfs_trans_zone, memflags);\n\ttp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\ttp->t_type = type;\n\ttp->t_mountp = mp;\n\tINIT_LIST_HEAD(&tp->t_items);\n\tINIT_LIST_HEAD(&tp->t_busy);\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_intwrite",
          "args": [
            "mp->m_super"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
  },
  {
    "function_name": "xfs_trans_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
    "lines": "42-47",
    "snippet": "void\nxfs_trans_init(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_trans_resv_calc(mp, M_RES(mp));\n}",
    "includes": [
      "#include \"xfs_error.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_resv_calc",
          "args": [
            "mp",
            "M_RES(mp)"
          ],
          "line": 46
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_resv_calc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_trans_resv.c",
          "lines": "778-878",
          "snippet": "void\nxfs_trans_resv_calc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_resv\t*resp)\n{\n\t/*\n\t * The following transactions are logged in physical format and\n\t * require a permanent reservation on space.\n\t */\n\tresp->tr_write.tr_logres = xfs_calc_write_reservation(mp);\n\tresp->tr_write.tr_logcount = XFS_WRITE_LOG_COUNT;\n\tresp->tr_write.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_itruncate.tr_logres = xfs_calc_itruncate_reservation(mp);\n\tresp->tr_itruncate.tr_logcount = XFS_ITRUNCATE_LOG_COUNT;\n\tresp->tr_itruncate.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_rename.tr_logres = xfs_calc_rename_reservation(mp);\n\tresp->tr_rename.tr_logcount = XFS_RENAME_LOG_COUNT;\n\tresp->tr_rename.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_link.tr_logres = xfs_calc_link_reservation(mp);\n\tresp->tr_link.tr_logcount = XFS_LINK_LOG_COUNT;\n\tresp->tr_link.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_remove.tr_logres = xfs_calc_remove_reservation(mp);\n\tresp->tr_remove.tr_logcount = XFS_REMOVE_LOG_COUNT;\n\tresp->tr_remove.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_symlink.tr_logres = xfs_calc_symlink_reservation(mp);\n\tresp->tr_symlink.tr_logcount = XFS_SYMLINK_LOG_COUNT;\n\tresp->tr_symlink.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_create.tr_logres = xfs_calc_create_reservation(mp);\n\tresp->tr_create.tr_logcount = XFS_CREATE_LOG_COUNT;\n\tresp->tr_create.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_create_tmpfile.tr_logres =\n\t\t\txfs_calc_create_tmpfile_reservation(mp);\n\tresp->tr_create_tmpfile.tr_logcount = XFS_CREATE_TMPFILE_LOG_COUNT;\n\tresp->tr_create_tmpfile.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_mkdir.tr_logres = xfs_calc_mkdir_reservation(mp);\n\tresp->tr_mkdir.tr_logcount = XFS_MKDIR_LOG_COUNT;\n\tresp->tr_mkdir.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_ifree.tr_logres = xfs_calc_ifree_reservation(mp);\n\tresp->tr_ifree.tr_logcount = XFS_INACTIVE_LOG_COUNT;\n\tresp->tr_ifree.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_addafork.tr_logres = xfs_calc_addafork_reservation(mp);\n\tresp->tr_addafork.tr_logcount = XFS_ADDAFORK_LOG_COUNT;\n\tresp->tr_addafork.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_attrinval.tr_logres = xfs_calc_attrinval_reservation(mp);\n\tresp->tr_attrinval.tr_logcount = XFS_ATTRINVAL_LOG_COUNT;\n\tresp->tr_attrinval.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_attrsetm.tr_logres = xfs_calc_attrsetm_reservation(mp);\n\tresp->tr_attrsetm.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\tresp->tr_attrsetm.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_attrrm.tr_logres = xfs_calc_attrrm_reservation(mp);\n\tresp->tr_attrrm.tr_logcount = XFS_ATTRRM_LOG_COUNT;\n\tresp->tr_attrrm.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_growrtalloc.tr_logres = xfs_calc_growrtalloc_reservation(mp);\n\tresp->tr_growrtalloc.tr_logcount = XFS_DEFAULT_PERM_LOG_COUNT;\n\tresp->tr_growrtalloc.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_qm_dqalloc.tr_logres = xfs_calc_qm_dqalloc_reservation(mp);\n\tresp->tr_qm_dqalloc.tr_logcount = XFS_WRITE_LOG_COUNT;\n\tresp->tr_qm_dqalloc.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\t/*\n\t * The following transactions are logged in logical format with\n\t * a default log count.\n\t */\n\tresp->tr_qm_setqlim.tr_logres = xfs_calc_qm_setqlim_reservation(mp);\n\tresp->tr_qm_setqlim.tr_logcount = XFS_DEFAULT_LOG_COUNT;\n\n\tresp->tr_qm_quotaoff.tr_logres = xfs_calc_qm_quotaoff_reservation(mp);\n\tresp->tr_qm_quotaoff.tr_logcount = XFS_DEFAULT_LOG_COUNT;\n\n\tresp->tr_qm_equotaoff.tr_logres =\n\t\txfs_calc_qm_quotaoff_end_reservation(mp);\n\tresp->tr_qm_equotaoff.tr_logcount = XFS_DEFAULT_LOG_COUNT;\n\n\tresp->tr_sb.tr_logres = xfs_calc_sb_reservation(mp);\n\tresp->tr_sb.tr_logcount = XFS_DEFAULT_LOG_COUNT;\n\n\t/* The following transaction are logged in logical format */\n\tresp->tr_ichange.tr_logres = xfs_calc_ichange_reservation(mp);\n\tresp->tr_growdata.tr_logres = xfs_calc_growdata_reservation(mp);\n\tresp->tr_fsyncts.tr_logres = xfs_calc_swrite_reservation(mp);\n\tresp->tr_writeid.tr_logres = xfs_calc_writeid_reservation(mp);\n\tresp->tr_attrsetrt.tr_logres = xfs_calc_attrsetrt_reservation(mp);\n\tresp->tr_clearagi.tr_logres = xfs_calc_clear_agi_bucket_reservation(mp);\n\tresp->tr_growrtzero.tr_logres = xfs_calc_growrtzero_reservation(mp);\n\tresp->tr_growrtfree.tr_logres = xfs_calc_growrtfree_reservation(mp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_qm.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_qm.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_resv_calc(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans_resv\t*resp)\n{\n\t/*\n\t * The following transactions are logged in physical format and\n\t * require a permanent reservation on space.\n\t */\n\tresp->tr_write.tr_logres = xfs_calc_write_reservation(mp);\n\tresp->tr_write.tr_logcount = XFS_WRITE_LOG_COUNT;\n\tresp->tr_write.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_itruncate.tr_logres = xfs_calc_itruncate_reservation(mp);\n\tresp->tr_itruncate.tr_logcount = XFS_ITRUNCATE_LOG_COUNT;\n\tresp->tr_itruncate.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_rename.tr_logres = xfs_calc_rename_reservation(mp);\n\tresp->tr_rename.tr_logcount = XFS_RENAME_LOG_COUNT;\n\tresp->tr_rename.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_link.tr_logres = xfs_calc_link_reservation(mp);\n\tresp->tr_link.tr_logcount = XFS_LINK_LOG_COUNT;\n\tresp->tr_link.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_remove.tr_logres = xfs_calc_remove_reservation(mp);\n\tresp->tr_remove.tr_logcount = XFS_REMOVE_LOG_COUNT;\n\tresp->tr_remove.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_symlink.tr_logres = xfs_calc_symlink_reservation(mp);\n\tresp->tr_symlink.tr_logcount = XFS_SYMLINK_LOG_COUNT;\n\tresp->tr_symlink.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_create.tr_logres = xfs_calc_create_reservation(mp);\n\tresp->tr_create.tr_logcount = XFS_CREATE_LOG_COUNT;\n\tresp->tr_create.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_create_tmpfile.tr_logres =\n\t\t\txfs_calc_create_tmpfile_reservation(mp);\n\tresp->tr_create_tmpfile.tr_logcount = XFS_CREATE_TMPFILE_LOG_COUNT;\n\tresp->tr_create_tmpfile.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_mkdir.tr_logres = xfs_calc_mkdir_reservation(mp);\n\tresp->tr_mkdir.tr_logcount = XFS_MKDIR_LOG_COUNT;\n\tresp->tr_mkdir.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_ifree.tr_logres = xfs_calc_ifree_reservation(mp);\n\tresp->tr_ifree.tr_logcount = XFS_INACTIVE_LOG_COUNT;\n\tresp->tr_ifree.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_addafork.tr_logres = xfs_calc_addafork_reservation(mp);\n\tresp->tr_addafork.tr_logcount = XFS_ADDAFORK_LOG_COUNT;\n\tresp->tr_addafork.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_attrinval.tr_logres = xfs_calc_attrinval_reservation(mp);\n\tresp->tr_attrinval.tr_logcount = XFS_ATTRINVAL_LOG_COUNT;\n\tresp->tr_attrinval.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_attrsetm.tr_logres = xfs_calc_attrsetm_reservation(mp);\n\tresp->tr_attrsetm.tr_logcount = XFS_ATTRSET_LOG_COUNT;\n\tresp->tr_attrsetm.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_attrrm.tr_logres = xfs_calc_attrrm_reservation(mp);\n\tresp->tr_attrrm.tr_logcount = XFS_ATTRRM_LOG_COUNT;\n\tresp->tr_attrrm.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_growrtalloc.tr_logres = xfs_calc_growrtalloc_reservation(mp);\n\tresp->tr_growrtalloc.tr_logcount = XFS_DEFAULT_PERM_LOG_COUNT;\n\tresp->tr_growrtalloc.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\tresp->tr_qm_dqalloc.tr_logres = xfs_calc_qm_dqalloc_reservation(mp);\n\tresp->tr_qm_dqalloc.tr_logcount = XFS_WRITE_LOG_COUNT;\n\tresp->tr_qm_dqalloc.tr_logflags |= XFS_TRANS_PERM_LOG_RES;\n\n\t/*\n\t * The following transactions are logged in logical format with\n\t * a default log count.\n\t */\n\tresp->tr_qm_setqlim.tr_logres = xfs_calc_qm_setqlim_reservation(mp);\n\tresp->tr_qm_setqlim.tr_logcount = XFS_DEFAULT_LOG_COUNT;\n\n\tresp->tr_qm_quotaoff.tr_logres = xfs_calc_qm_quotaoff_reservation(mp);\n\tresp->tr_qm_quotaoff.tr_logcount = XFS_DEFAULT_LOG_COUNT;\n\n\tresp->tr_qm_equotaoff.tr_logres =\n\t\txfs_calc_qm_quotaoff_end_reservation(mp);\n\tresp->tr_qm_equotaoff.tr_logcount = XFS_DEFAULT_LOG_COUNT;\n\n\tresp->tr_sb.tr_logres = xfs_calc_sb_reservation(mp);\n\tresp->tr_sb.tr_logcount = XFS_DEFAULT_LOG_COUNT;\n\n\t/* The following transaction are logged in logical format */\n\tresp->tr_ichange.tr_logres = xfs_calc_ichange_reservation(mp);\n\tresp->tr_growdata.tr_logres = xfs_calc_growdata_reservation(mp);\n\tresp->tr_fsyncts.tr_logres = xfs_calc_swrite_reservation(mp);\n\tresp->tr_writeid.tr_logres = xfs_calc_writeid_reservation(mp);\n\tresp->tr_attrsetrt.tr_logres = xfs_calc_attrsetrt_reservation(mp);\n\tresp->tr_clearagi.tr_logres = xfs_calc_clear_agi_bucket_reservation(mp);\n\tresp->tr_growrtzero.tr_logres = xfs_calc_growrtzero_reservation(mp);\n\tresp->tr_growrtfree.tr_logres = xfs_calc_growrtfree_reservation(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_init(\n\tstruct xfs_mount\t*mp)\n{\n\txfs_trans_resv_calc(mp, M_RES(mp));\n}"
  }
]