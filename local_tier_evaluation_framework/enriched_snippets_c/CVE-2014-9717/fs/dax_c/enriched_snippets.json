[
  {
    "function_name": "dax_truncate_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "529-533",
    "snippet": "int dax_truncate_page(struct inode *inode, loff_t from, get_block_t get_block)\n{\n\tunsigned length = PAGE_CACHE_ALIGN(from) - from;\n\treturn dax_zero_page_range(inode, from, length, get_block);\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dax_zero_page_range",
          "args": [
            "inode",
            "from",
            "length",
            "get_block"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "dax_zero_page_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "484-511",
          "snippet": "int dax_zero_page_range(struct inode *inode, loff_t from, unsigned length,\n\t\t\t\t\t\t\tget_block_t get_block)\n{\n\tstruct buffer_head bh;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tint err;\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\tBUG_ON((offset + length) > PAGE_CACHE_SIZE);\n\n\tmemset(&bh, 0, sizeof(bh));\n\tbh.b_size = PAGE_CACHE_SIZE;\n\terr = get_block(inode, index, &bh, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (buffer_written(&bh)) {\n\t\tvoid *addr;\n\t\terr = dax_get_addr(&bh, &addr, inode->i_blkbits);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(addr + offset, 0, length);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_zero_page_range(struct inode *inode, loff_t from, unsigned length,\n\t\t\t\t\t\t\tget_block_t get_block)\n{\n\tstruct buffer_head bh;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tint err;\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\tBUG_ON((offset + length) > PAGE_CACHE_SIZE);\n\n\tmemset(&bh, 0, sizeof(bh));\n\tbh.b_size = PAGE_CACHE_SIZE;\n\terr = get_block(inode, index, &bh, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (buffer_written(&bh)) {\n\t\tvoid *addr;\n\t\terr = dax_get_addr(&bh, &addr, inode->i_blkbits);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(addr + offset, 0, length);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_CACHE_ALIGN",
          "args": [
            "from"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_truncate_page(struct inode *inode, loff_t from, get_block_t get_block)\n{\n\tunsigned length = PAGE_CACHE_ALIGN(from) - from;\n\treturn dax_zero_page_range(inode, from, length, get_block);\n}"
  },
  {
    "function_name": "dax_zero_page_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "484-511",
    "snippet": "int dax_zero_page_range(struct inode *inode, loff_t from, unsigned length,\n\t\t\t\t\t\t\tget_block_t get_block)\n{\n\tstruct buffer_head bh;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tint err;\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\tBUG_ON((offset + length) > PAGE_CACHE_SIZE);\n\n\tmemset(&bh, 0, sizeof(bh));\n\tbh.b_size = PAGE_CACHE_SIZE;\n\terr = get_block(inode, index, &bh, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (buffer_written(&bh)) {\n\t\tvoid *addr;\n\t\terr = dax_get_addr(&bh, &addr, inode->i_blkbits);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(addr + offset, 0, length);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr + offset",
            "0",
            "length"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_get_addr",
          "args": [
            "&bh",
            "&addr",
            "inode->i_blkbits"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "dax_get_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "66-71",
          "snippet": "static long dax_get_addr(struct buffer_head *bh, void **addr, unsigned blkbits)\n{\n\tunsigned long pfn;\n\tsector_t sector = bh->b_blocknr << (blkbits - 9);\n\treturn bdev_direct_access(bh->b_bdev, sector, addr, &pfn, bh->b_size);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic long dax_get_addr(struct buffer_head *bh, void **addr, unsigned blkbits)\n{\n\tunsigned long pfn;\n\tsector_t sector = bh->b_blocknr << (blkbits - 9);\n\treturn bdev_direct_access(bh->b_bdev, sector, addr, &pfn, bh->b_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_written",
          "args": [
            "&bh"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "84-87",
          "snippet": "static bool buffer_written(struct buffer_head *bh)\n{\n\treturn buffer_mapped(bh) && !buffer_unwritten(bh);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool buffer_written(struct buffer_head *bh)\n{\n\treturn buffer_mapped(bh) && !buffer_unwritten(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "index",
            "&bh",
            "0"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&bh",
            "0",
            "sizeof(bh)"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(offset + length) > PAGE_CACHE_SIZE"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_zero_page_range(struct inode *inode, loff_t from, unsigned length,\n\t\t\t\t\t\t\tget_block_t get_block)\n{\n\tstruct buffer_head bh;\n\tpgoff_t index = from >> PAGE_CACHE_SHIFT;\n\tunsigned offset = from & (PAGE_CACHE_SIZE-1);\n\tint err;\n\n\t/* Block boundary? Nothing to do */\n\tif (!length)\n\t\treturn 0;\n\tBUG_ON((offset + length) > PAGE_CACHE_SIZE);\n\n\tmemset(&bh, 0, sizeof(bh));\n\tbh.b_size = PAGE_CACHE_SIZE;\n\terr = get_block(inode, index, &bh, 0);\n\tif (err < 0)\n\t\treturn err;\n\tif (buffer_written(&bh)) {\n\t\tvoid *addr;\n\t\terr = dax_get_addr(&bh, &addr, inode->i_blkbits);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tmemset(addr + offset, 0, length);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dax_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "448-463",
    "snippet": "int dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\tget_block_t get_block)\n{\n\tint result;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t}\n\tresult = do_dax_fault(vma, vmf, get_block);\n\tif (vmf->flags & FAULT_FLAG_WRITE)\n\t\tsb_end_pagefault(sb);\n\n\treturn result;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_end_pagefault",
          "args": [
            "sb"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_dax_fault",
          "args": [
            "vma",
            "vmf",
            "get_block"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "do_dax_fault",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "319-437",
          "snippet": "static int do_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\tget_block_t get_block)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head bh;\n\tunsigned long vaddr = (unsigned long)vmf->virtual_address;\n\tunsigned blkbits = inode->i_blkbits;\n\tsector_t block;\n\tpgoff_t size;\n\tint error;\n\tint major = 0;\n\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tmemset(&bh, 0, sizeof(bh));\n\tblock = (sector_t)vmf->pgoff << (PAGE_SHIFT - blkbits);\n\tbh.b_size = PAGE_SIZE;\n\n repeat:\n\tpage = find_get_page(mapping, vmf->pgoff);\n\tif (page) {\n\t\tif (!lock_page_or_retry(page, vma->vm_mm, vmf->flags)) {\n\t\t\tpage_cache_release(page);\n\t\t\treturn VM_FAULT_RETRY;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (unlikely(vmf->pgoff >= size)) {\n\t\t\t/*\n\t\t\t * We have a struct page covering a hole in the file\n\t\t\t * from a read fault and we've raced with a truncate\n\t\t\t */\n\t\t\terror = -EIO;\n\t\t\tgoto unlock_page;\n\t\t}\n\t}\n\n\terror = get_block(inode, block, &bh, 0);\n\tif (!error && (bh.b_size < PAGE_SIZE))\n\t\terror = -EIO;\t\t/* fs corruption? */\n\tif (error)\n\t\tgoto unlock_page;\n\n\tif (!buffer_mapped(&bh) && !buffer_unwritten(&bh) && !vmf->cow_page) {\n\t\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\t\terror = get_block(inode, block, &bh, 1);\n\t\t\tcount_vm_event(PGMAJFAULT);\n\t\t\tmem_cgroup_count_vm_event(vma->vm_mm, PGMAJFAULT);\n\t\t\tmajor = VM_FAULT_MAJOR;\n\t\t\tif (!error && (bh.b_size < PAGE_SIZE))\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto unlock_page;\n\t\t} else {\n\t\t\treturn dax_load_hole(mapping, page, vmf);\n\t\t}\n\t}\n\n\tif (vmf->cow_page) {\n\t\tstruct page *new_page = vmf->cow_page;\n\t\tif (buffer_written(&bh))\n\t\t\terror = copy_user_bh(new_page, &bh, blkbits, vaddr);\n\t\telse\n\t\t\tclear_user_highpage(new_page, vaddr);\n\t\tif (error)\n\t\t\tgoto unlock_page;\n\t\tvmf->page = page;\n\t\tif (!page) {\n\t\t\ti_mmap_lock_read(mapping);\n\t\t\t/* Check we didn't race with truncate */\n\t\t\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >>\n\t\t\t\t\t\t\t\tPAGE_SHIFT;\n\t\t\tif (vmf->pgoff >= size) {\n\t\t\t\ti_mmap_unlock_read(mapping);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\treturn VM_FAULT_LOCKED;\n\t}\n\n\t/* Check we didn't race with a read fault installing a new page */\n\tif (!page && major)\n\t\tpage = find_lock_page(mapping, vmf->pgoff);\n\n\tif (page) {\n\t\tunmap_mapping_range(mapping, vmf->pgoff << PAGE_SHIFT,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE, 0);\n\t\tdelete_from_page_cache(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\terror = dax_insert_mapping(inode, &bh, vma, vmf);\n\n out:\n\tif (error == -ENOMEM)\n\t\treturn VM_FAULT_OOM | major;\n\t/* -EBUSY is fine, somebody else faulted on the same PTE */\n\tif ((error < 0) && (error != -EBUSY))\n\t\treturn VM_FAULT_SIGBUS | major;\n\treturn VM_FAULT_NOPAGE | major;\n\n unlock_page:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tgoto out;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int do_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\tget_block_t get_block)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head bh;\n\tunsigned long vaddr = (unsigned long)vmf->virtual_address;\n\tunsigned blkbits = inode->i_blkbits;\n\tsector_t block;\n\tpgoff_t size;\n\tint error;\n\tint major = 0;\n\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tmemset(&bh, 0, sizeof(bh));\n\tblock = (sector_t)vmf->pgoff << (PAGE_SHIFT - blkbits);\n\tbh.b_size = PAGE_SIZE;\n\n repeat:\n\tpage = find_get_page(mapping, vmf->pgoff);\n\tif (page) {\n\t\tif (!lock_page_or_retry(page, vma->vm_mm, vmf->flags)) {\n\t\t\tpage_cache_release(page);\n\t\t\treturn VM_FAULT_RETRY;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (unlikely(vmf->pgoff >= size)) {\n\t\t\t/*\n\t\t\t * We have a struct page covering a hole in the file\n\t\t\t * from a read fault and we've raced with a truncate\n\t\t\t */\n\t\t\terror = -EIO;\n\t\t\tgoto unlock_page;\n\t\t}\n\t}\n\n\terror = get_block(inode, block, &bh, 0);\n\tif (!error && (bh.b_size < PAGE_SIZE))\n\t\terror = -EIO;\t\t/* fs corruption? */\n\tif (error)\n\t\tgoto unlock_page;\n\n\tif (!buffer_mapped(&bh) && !buffer_unwritten(&bh) && !vmf->cow_page) {\n\t\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\t\terror = get_block(inode, block, &bh, 1);\n\t\t\tcount_vm_event(PGMAJFAULT);\n\t\t\tmem_cgroup_count_vm_event(vma->vm_mm, PGMAJFAULT);\n\t\t\tmajor = VM_FAULT_MAJOR;\n\t\t\tif (!error && (bh.b_size < PAGE_SIZE))\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto unlock_page;\n\t\t} else {\n\t\t\treturn dax_load_hole(mapping, page, vmf);\n\t\t}\n\t}\n\n\tif (vmf->cow_page) {\n\t\tstruct page *new_page = vmf->cow_page;\n\t\tif (buffer_written(&bh))\n\t\t\terror = copy_user_bh(new_page, &bh, blkbits, vaddr);\n\t\telse\n\t\t\tclear_user_highpage(new_page, vaddr);\n\t\tif (error)\n\t\t\tgoto unlock_page;\n\t\tvmf->page = page;\n\t\tif (!page) {\n\t\t\ti_mmap_lock_read(mapping);\n\t\t\t/* Check we didn't race with truncate */\n\t\t\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >>\n\t\t\t\t\t\t\t\tPAGE_SHIFT;\n\t\t\tif (vmf->pgoff >= size) {\n\t\t\t\ti_mmap_unlock_read(mapping);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\treturn VM_FAULT_LOCKED;\n\t}\n\n\t/* Check we didn't race with a read fault installing a new page */\n\tif (!page && major)\n\t\tpage = find_lock_page(mapping, vmf->pgoff);\n\n\tif (page) {\n\t\tunmap_mapping_range(mapping, vmf->pgoff << PAGE_SHIFT,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE, 0);\n\t\tdelete_from_page_cache(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\terror = dax_insert_mapping(inode, &bh, vma, vmf);\n\n out:\n\tif (error == -ENOMEM)\n\t\treturn VM_FAULT_OOM | major;\n\t/* -EBUSY is fine, somebody else faulted on the same PTE */\n\tif ((error < 0) && (error != -EBUSY))\n\t\treturn VM_FAULT_SIGBUS | major;\n\treturn VM_FAULT_NOPAGE | major;\n\n unlock_page:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_update_time",
          "args": [
            "vma->vm_file"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "file_update_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1716-1748",
          "snippet": "int file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nint file_update_time(struct file *file)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct timespec now;\n\tint sync_it = 0;\n\tint ret;\n\n\t/* First try to exhaust all avenues to not sync */\n\tif (IS_NOCMTIME(inode))\n\t\treturn 0;\n\n\tnow = current_fs_time(inode->i_sb);\n\tif (!timespec_equal(&inode->i_mtime, &now))\n\t\tsync_it = S_MTIME;\n\n\tif (!timespec_equal(&inode->i_ctime, &now))\n\t\tsync_it |= S_CTIME;\n\n\tif (IS_I_VERSION(inode))\n\t\tsync_it |= S_VERSION;\n\n\tif (!sync_it)\n\t\treturn 0;\n\n\t/* Finally allowed to write? Takes lock. */\n\tif (__mnt_want_write_file(file))\n\t\treturn 0;\n\n\tret = update_time(inode, &now, sync_it);\n\t__mnt_drop_write_file(file);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_start_pagefault",
          "args": [
            "sb"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "vma->vm_file"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\tget_block_t get_block)\n{\n\tint result;\n\tstruct super_block *sb = file_inode(vma->vm_file)->i_sb;\n\n\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\tsb_start_pagefault(sb);\n\t\tfile_update_time(vma->vm_file);\n\t}\n\tresult = do_dax_fault(vma, vmf, get_block);\n\tif (vmf->flags & FAULT_FLAG_WRITE)\n\t\tsb_end_pagefault(sb);\n\n\treturn result;\n}"
  },
  {
    "function_name": "do_dax_fault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "319-437",
    "snippet": "static int do_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\tget_block_t get_block)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head bh;\n\tunsigned long vaddr = (unsigned long)vmf->virtual_address;\n\tunsigned blkbits = inode->i_blkbits;\n\tsector_t block;\n\tpgoff_t size;\n\tint error;\n\tint major = 0;\n\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tmemset(&bh, 0, sizeof(bh));\n\tblock = (sector_t)vmf->pgoff << (PAGE_SHIFT - blkbits);\n\tbh.b_size = PAGE_SIZE;\n\n repeat:\n\tpage = find_get_page(mapping, vmf->pgoff);\n\tif (page) {\n\t\tif (!lock_page_or_retry(page, vma->vm_mm, vmf->flags)) {\n\t\t\tpage_cache_release(page);\n\t\t\treturn VM_FAULT_RETRY;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (unlikely(vmf->pgoff >= size)) {\n\t\t\t/*\n\t\t\t * We have a struct page covering a hole in the file\n\t\t\t * from a read fault and we've raced with a truncate\n\t\t\t */\n\t\t\terror = -EIO;\n\t\t\tgoto unlock_page;\n\t\t}\n\t}\n\n\terror = get_block(inode, block, &bh, 0);\n\tif (!error && (bh.b_size < PAGE_SIZE))\n\t\terror = -EIO;\t\t/* fs corruption? */\n\tif (error)\n\t\tgoto unlock_page;\n\n\tif (!buffer_mapped(&bh) && !buffer_unwritten(&bh) && !vmf->cow_page) {\n\t\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\t\terror = get_block(inode, block, &bh, 1);\n\t\t\tcount_vm_event(PGMAJFAULT);\n\t\t\tmem_cgroup_count_vm_event(vma->vm_mm, PGMAJFAULT);\n\t\t\tmajor = VM_FAULT_MAJOR;\n\t\t\tif (!error && (bh.b_size < PAGE_SIZE))\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto unlock_page;\n\t\t} else {\n\t\t\treturn dax_load_hole(mapping, page, vmf);\n\t\t}\n\t}\n\n\tif (vmf->cow_page) {\n\t\tstruct page *new_page = vmf->cow_page;\n\t\tif (buffer_written(&bh))\n\t\t\terror = copy_user_bh(new_page, &bh, blkbits, vaddr);\n\t\telse\n\t\t\tclear_user_highpage(new_page, vaddr);\n\t\tif (error)\n\t\t\tgoto unlock_page;\n\t\tvmf->page = page;\n\t\tif (!page) {\n\t\t\ti_mmap_lock_read(mapping);\n\t\t\t/* Check we didn't race with truncate */\n\t\t\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >>\n\t\t\t\t\t\t\t\tPAGE_SHIFT;\n\t\t\tif (vmf->pgoff >= size) {\n\t\t\t\ti_mmap_unlock_read(mapping);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\treturn VM_FAULT_LOCKED;\n\t}\n\n\t/* Check we didn't race with a read fault installing a new page */\n\tif (!page && major)\n\t\tpage = find_lock_page(mapping, vmf->pgoff);\n\n\tif (page) {\n\t\tunmap_mapping_range(mapping, vmf->pgoff << PAGE_SHIFT,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE, 0);\n\t\tdelete_from_page_cache(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\terror = dax_insert_mapping(inode, &bh, vma, vmf);\n\n out:\n\tif (error == -ENOMEM)\n\t\treturn VM_FAULT_OOM | major;\n\t/* -EBUSY is fine, somebody else faulted on the same PTE */\n\tif ((error < 0) && (error != -EBUSY))\n\t\treturn VM_FAULT_SIGBUS | major;\n\treturn VM_FAULT_NOPAGE | major;\n\n unlock_page:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tgoto out;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_insert_mapping",
          "args": [
            "inode",
            "&bh",
            "vma",
            "vmf"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "dax_insert_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "271-317",
          "snippet": "static int dax_insert_mapping(struct inode *inode, struct buffer_head *bh,\n\t\t\tstruct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tsector_t sector = bh->b_blocknr << (inode->i_blkbits - 9);\n\tunsigned long vaddr = (unsigned long)vmf->virtual_address;\n\tvoid *addr;\n\tunsigned long pfn;\n\tpgoff_t size;\n\tint error;\n\n\ti_mmap_lock_read(mapping);\n\n\t/*\n\t * Check truncate didn't happen while we were allocating a block.\n\t * If it did, this block may or may not be still allocated to the\n\t * file.  We can't tell the filesystem to free it because we can't\n\t * take i_mutex here.  In the worst case, the file still has blocks\n\t * allocated past the end of the file.\n\t */\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (unlikely(vmf->pgoff >= size)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\terror = bdev_direct_access(bh->b_bdev, sector, &addr, &pfn, bh->b_size);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error < PAGE_SIZE) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (buffer_unwritten(bh) || buffer_new(bh))\n\t\tclear_page(addr);\n\n\terror = vm_insert_mixed(vma, vaddr, pfn);\n\n out:\n\ti_mmap_unlock_read(mapping);\n\n\tif (bh->b_end_io)\n\t\tbh->b_end_io(bh, 1);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_insert_mapping(struct inode *inode, struct buffer_head *bh,\n\t\t\tstruct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tsector_t sector = bh->b_blocknr << (inode->i_blkbits - 9);\n\tunsigned long vaddr = (unsigned long)vmf->virtual_address;\n\tvoid *addr;\n\tunsigned long pfn;\n\tpgoff_t size;\n\tint error;\n\n\ti_mmap_lock_read(mapping);\n\n\t/*\n\t * Check truncate didn't happen while we were allocating a block.\n\t * If it did, this block may or may not be still allocated to the\n\t * file.  We can't tell the filesystem to free it because we can't\n\t * take i_mutex here.  In the worst case, the file still has blocks\n\t * allocated past the end of the file.\n\t */\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (unlikely(vmf->pgoff >= size)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\terror = bdev_direct_access(bh->b_bdev, sector, &addr, &pfn, bh->b_size);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error < PAGE_SIZE) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (buffer_unwritten(bh) || buffer_new(bh))\n\t\tclear_page(addr);\n\n\terror = vm_insert_mixed(vma, vaddr, pfn);\n\n out:\n\ti_mmap_unlock_read(mapping);\n\n\tif (bh->b_end_io)\n\t\tbh->b_end_io(bh, 1);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delete_from_page_cache",
          "args": [
            "page"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unmap_mapping_range",
          "args": [
            "mapping",
            "vmf->pgoff << PAGE_SHIFT",
            "PAGE_CACHE_SIZE",
            "0"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_page",
          "args": [
            "mapping",
            "vmf->pgoff"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_read",
          "args": [
            "mapping"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_read",
          "args": [
            "mapping"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_user_highpage",
          "args": [
            "new_page",
            "vaddr"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_bh",
          "args": [
            "new_page",
            "&bh",
            "blkbits",
            "vaddr"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "copy_user_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "259-269",
          "snippet": "static int copy_user_bh(struct page *to, struct buffer_head *bh,\n\t\t\tunsigned blkbits, unsigned long vaddr)\n{\n\tvoid *vfrom, *vto;\n\tif (dax_get_addr(bh, &vfrom, blkbits) < 0)\n\t\treturn -EIO;\n\tvto = kmap_atomic(to);\n\tcopy_user_page(vto, vfrom, vaddr, to);\n\tkunmap_atomic(vto);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int copy_user_bh(struct page *to, struct buffer_head *bh,\n\t\t\tunsigned blkbits, unsigned long vaddr)\n{\n\tvoid *vfrom, *vto;\n\tif (dax_get_addr(bh, &vfrom, blkbits) < 0)\n\t\treturn -EIO;\n\tvto = kmap_atomic(to);\n\tcopy_user_page(vto, vfrom, vaddr, to);\n\tkunmap_atomic(vto);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_written",
          "args": [
            "&bh"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "84-87",
          "snippet": "static bool buffer_written(struct buffer_head *bh)\n{\n\treturn buffer_mapped(bh) && !buffer_unwritten(bh);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool buffer_written(struct buffer_head *bh)\n{\n\treturn buffer_mapped(bh) && !buffer_unwritten(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_load_hole",
          "args": [
            "mapping",
            "page",
            "vmf"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "dax_load_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "237-257",
          "snippet": "static int dax_load_hole(struct address_space *mapping, struct page *page,\n\t\t\t\t\t\t\tstruct vm_fault *vmf)\n{\n\tunsigned long size;\n\tstruct inode *inode = mapping->host;\n\tif (!page)\n\t\tpage = find_or_create_page(mapping, vmf->pgoff,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\treturn VM_FAULT_OOM;\n\t/* Recheck i_size under page lock to avoid truncate race */\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tvmf->page = page;\n\treturn VM_FAULT_LOCKED;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_load_hole(struct address_space *mapping, struct page *page,\n\t\t\t\t\t\t\tstruct vm_fault *vmf)\n{\n\tunsigned long size;\n\tstruct inode *inode = mapping->host;\n\tif (!page)\n\t\tpage = find_or_create_page(mapping, vmf->pgoff,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\treturn VM_FAULT_OOM;\n\t/* Recheck i_size under page lock to avoid truncate race */\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tvmf->page = page;\n\treturn VM_FAULT_LOCKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mem_cgroup_count_vm_event",
          "args": [
            "vma->vm_mm",
            "PGMAJFAULT"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_vm_event",
          "args": [
            "PGMAJFAULT"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block",
            "&bh",
            "1"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "&bh"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "&bh"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vmf->pgoff >= size"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "page->mapping != mapping"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_page_or_retry",
          "args": [
            "page",
            "vma->vm_mm",
            "vmf->flags"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "vmf->pgoff"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&bh",
            "0",
            "sizeof(bh)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int do_dax_fault(struct vm_area_struct *vma, struct vm_fault *vmf,\n\t\t\tget_block_t get_block)\n{\n\tstruct file *file = vma->vm_file;\n\tstruct address_space *mapping = file->f_mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct page *page;\n\tstruct buffer_head bh;\n\tunsigned long vaddr = (unsigned long)vmf->virtual_address;\n\tunsigned blkbits = inode->i_blkbits;\n\tsector_t block;\n\tpgoff_t size;\n\tint error;\n\tint major = 0;\n\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tmemset(&bh, 0, sizeof(bh));\n\tblock = (sector_t)vmf->pgoff << (PAGE_SHIFT - blkbits);\n\tbh.b_size = PAGE_SIZE;\n\n repeat:\n\tpage = find_get_page(mapping, vmf->pgoff);\n\tif (page) {\n\t\tif (!lock_page_or_retry(page, vma->vm_mm, vmf->flags)) {\n\t\t\tpage_cache_release(page);\n\t\t\treturn VM_FAULT_RETRY;\n\t\t}\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tgoto repeat;\n\t\t}\n\t\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (unlikely(vmf->pgoff >= size)) {\n\t\t\t/*\n\t\t\t * We have a struct page covering a hole in the file\n\t\t\t * from a read fault and we've raced with a truncate\n\t\t\t */\n\t\t\terror = -EIO;\n\t\t\tgoto unlock_page;\n\t\t}\n\t}\n\n\terror = get_block(inode, block, &bh, 0);\n\tif (!error && (bh.b_size < PAGE_SIZE))\n\t\terror = -EIO;\t\t/* fs corruption? */\n\tif (error)\n\t\tgoto unlock_page;\n\n\tif (!buffer_mapped(&bh) && !buffer_unwritten(&bh) && !vmf->cow_page) {\n\t\tif (vmf->flags & FAULT_FLAG_WRITE) {\n\t\t\terror = get_block(inode, block, &bh, 1);\n\t\t\tcount_vm_event(PGMAJFAULT);\n\t\t\tmem_cgroup_count_vm_event(vma->vm_mm, PGMAJFAULT);\n\t\t\tmajor = VM_FAULT_MAJOR;\n\t\t\tif (!error && (bh.b_size < PAGE_SIZE))\n\t\t\t\terror = -EIO;\n\t\t\tif (error)\n\t\t\t\tgoto unlock_page;\n\t\t} else {\n\t\t\treturn dax_load_hole(mapping, page, vmf);\n\t\t}\n\t}\n\n\tif (vmf->cow_page) {\n\t\tstruct page *new_page = vmf->cow_page;\n\t\tif (buffer_written(&bh))\n\t\t\terror = copy_user_bh(new_page, &bh, blkbits, vaddr);\n\t\telse\n\t\t\tclear_user_highpage(new_page, vaddr);\n\t\tif (error)\n\t\t\tgoto unlock_page;\n\t\tvmf->page = page;\n\t\tif (!page) {\n\t\t\ti_mmap_lock_read(mapping);\n\t\t\t/* Check we didn't race with truncate */\n\t\t\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >>\n\t\t\t\t\t\t\t\tPAGE_SHIFT;\n\t\t\tif (vmf->pgoff >= size) {\n\t\t\t\ti_mmap_unlock_read(mapping);\n\t\t\t\terror = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\treturn VM_FAULT_LOCKED;\n\t}\n\n\t/* Check we didn't race with a read fault installing a new page */\n\tif (!page && major)\n\t\tpage = find_lock_page(mapping, vmf->pgoff);\n\n\tif (page) {\n\t\tunmap_mapping_range(mapping, vmf->pgoff << PAGE_SHIFT,\n\t\t\t\t\t\t\tPAGE_CACHE_SIZE, 0);\n\t\tdelete_from_page_cache(page);\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\n\terror = dax_insert_mapping(inode, &bh, vma, vmf);\n\n out:\n\tif (error == -ENOMEM)\n\t\treturn VM_FAULT_OOM | major;\n\t/* -EBUSY is fine, somebody else faulted on the same PTE */\n\tif ((error < 0) && (error != -EBUSY))\n\t\treturn VM_FAULT_SIGBUS | major;\n\treturn VM_FAULT_NOPAGE | major;\n\n unlock_page:\n\tif (page) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t}\n\tgoto out;\n}"
  },
  {
    "function_name": "dax_insert_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "271-317",
    "snippet": "static int dax_insert_mapping(struct inode *inode, struct buffer_head *bh,\n\t\t\tstruct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tsector_t sector = bh->b_blocknr << (inode->i_blkbits - 9);\n\tunsigned long vaddr = (unsigned long)vmf->virtual_address;\n\tvoid *addr;\n\tunsigned long pfn;\n\tpgoff_t size;\n\tint error;\n\n\ti_mmap_lock_read(mapping);\n\n\t/*\n\t * Check truncate didn't happen while we were allocating a block.\n\t * If it did, this block may or may not be still allocated to the\n\t * file.  We can't tell the filesystem to free it because we can't\n\t * take i_mutex here.  In the worst case, the file still has blocks\n\t * allocated past the end of the file.\n\t */\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (unlikely(vmf->pgoff >= size)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\terror = bdev_direct_access(bh->b_bdev, sector, &addr, &pfn, bh->b_size);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error < PAGE_SIZE) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (buffer_unwritten(bh) || buffer_new(bh))\n\t\tclear_page(addr);\n\n\terror = vm_insert_mixed(vma, vaddr, pfn);\n\n out:\n\ti_mmap_unlock_read(mapping);\n\n\tif (bh->b_end_io)\n\t\tbh->b_end_io(bh, 1);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bh->b_end_io",
          "args": [
            "bh",
            "1"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_unlock_read",
          "args": [
            "mapping"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_insert_mixed",
          "args": [
            "vma",
            "vaddr",
            "pfn"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "addr"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_direct_access",
          "args": [
            "bh->b_bdev",
            "sector",
            "&addr",
            "&pfn",
            "bh->b_size"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_direct_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "441-461",
          "snippet": "long bdev_direct_access(struct block_device *bdev, sector_t sector,\n\t\t\tvoid **addr, unsigned long *pfn, long size)\n{\n\tlong avail;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (size < 0)\n\t\treturn size;\n\tif (!ops->direct_access)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector + DIV_ROUND_UP(size, 512)) >\n\t\t\t\t\tpart_nr_sects_read(bdev->bd_part))\n\t\treturn -ERANGE;\n\tsector += get_start_sect(bdev);\n\tif (sector % (PAGE_SIZE / 512))\n\t\treturn -EINVAL;\n\tavail = ops->direct_access(bdev, sector, addr, pfn, size);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nlong bdev_direct_access(struct block_device *bdev, sector_t sector,\n\t\t\tvoid **addr, unsigned long *pfn, long size)\n{\n\tlong avail;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (size < 0)\n\t\treturn size;\n\tif (!ops->direct_access)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector + DIV_ROUND_UP(size, 512)) >\n\t\t\t\t\tpart_nr_sects_read(bdev->bd_part))\n\t\treturn -ERANGE;\n\tsector += get_start_sect(bdev);\n\tif (sector % (PAGE_SIZE / 512))\n\t\treturn -EINVAL;\n\tavail = ops->direct_access(bdev, sector, addr, pfn, size);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vmf->pgoff >= size"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_mmap_lock_read",
          "args": [
            "mapping"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_insert_mapping(struct inode *inode, struct buffer_head *bh,\n\t\t\tstruct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tsector_t sector = bh->b_blocknr << (inode->i_blkbits - 9);\n\tunsigned long vaddr = (unsigned long)vmf->virtual_address;\n\tvoid *addr;\n\tunsigned long pfn;\n\tpgoff_t size;\n\tint error;\n\n\ti_mmap_lock_read(mapping);\n\n\t/*\n\t * Check truncate didn't happen while we were allocating a block.\n\t * If it did, this block may or may not be still allocated to the\n\t * file.  We can't tell the filesystem to free it because we can't\n\t * take i_mutex here.  In the worst case, the file still has blocks\n\t * allocated past the end of the file.\n\t */\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (unlikely(vmf->pgoff >= size)) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\terror = bdev_direct_access(bh->b_bdev, sector, &addr, &pfn, bh->b_size);\n\tif (error < 0)\n\t\tgoto out;\n\tif (error < PAGE_SIZE) {\n\t\terror = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (buffer_unwritten(bh) || buffer_new(bh))\n\t\tclear_page(addr);\n\n\terror = vm_insert_mixed(vma, vaddr, pfn);\n\n out:\n\ti_mmap_unlock_read(mapping);\n\n\tif (bh->b_end_io)\n\t\tbh->b_end_io(bh, 1);\n\n\treturn error;\n}"
  },
  {
    "function_name": "copy_user_bh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "259-269",
    "snippet": "static int copy_user_bh(struct page *to, struct buffer_head *bh,\n\t\t\tunsigned blkbits, unsigned long vaddr)\n{\n\tvoid *vfrom, *vto;\n\tif (dax_get_addr(bh, &vfrom, blkbits) < 0)\n\t\treturn -EIO;\n\tvto = kmap_atomic(to);\n\tcopy_user_page(vto, vfrom, vaddr, to);\n\tkunmap_atomic(vto);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "vto"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_user_page",
          "args": [
            "vto",
            "vfrom",
            "vaddr",
            "to"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "to"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_get_addr",
          "args": [
            "bh",
            "&vfrom",
            "blkbits"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "dax_get_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "66-71",
          "snippet": "static long dax_get_addr(struct buffer_head *bh, void **addr, unsigned blkbits)\n{\n\tunsigned long pfn;\n\tsector_t sector = bh->b_blocknr << (blkbits - 9);\n\treturn bdev_direct_access(bh->b_bdev, sector, addr, &pfn, bh->b_size);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic long dax_get_addr(struct buffer_head *bh, void **addr, unsigned blkbits)\n{\n\tunsigned long pfn;\n\tsector_t sector = bh->b_blocknr << (blkbits - 9);\n\treturn bdev_direct_access(bh->b_bdev, sector, addr, &pfn, bh->b_size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int copy_user_bh(struct page *to, struct buffer_head *bh,\n\t\t\tunsigned blkbits, unsigned long vaddr)\n{\n\tvoid *vfrom, *vto;\n\tif (dax_get_addr(bh, &vfrom, blkbits) < 0)\n\t\treturn -EIO;\n\tvto = kmap_atomic(to);\n\tcopy_user_page(vto, vfrom, vaddr, to);\n\tkunmap_atomic(vto);\n\treturn 0;\n}"
  },
  {
    "function_name": "dax_load_hole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "237-257",
    "snippet": "static int dax_load_hole(struct address_space *mapping, struct page *page,\n\t\t\t\t\t\t\tstruct vm_fault *vmf)\n{\n\tunsigned long size;\n\tstruct inode *inode = mapping->host;\n\tif (!page)\n\t\tpage = find_or_create_page(mapping, vmf->pgoff,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\treturn VM_FAULT_OOM;\n\t/* Recheck i_size under page lock to avoid truncate race */\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tvmf->page = page;\n\treturn VM_FAULT_LOCKED;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "vmf->pgoff",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic int dax_load_hole(struct address_space *mapping, struct page *page,\n\t\t\t\t\t\t\tstruct vm_fault *vmf)\n{\n\tunsigned long size;\n\tstruct inode *inode = mapping->host;\n\tif (!page)\n\t\tpage = find_or_create_page(mapping, vmf->pgoff,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!page)\n\t\treturn VM_FAULT_OOM;\n\t/* Recheck i_size under page lock to avoid truncate race */\n\tsize = (i_size_read(inode) + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\tif (vmf->pgoff >= size) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\treturn VM_FAULT_SIGBUS;\n\t}\n\n\tvmf->page = page;\n\treturn VM_FAULT_LOCKED;\n}"
  },
  {
    "function_name": "dax_do_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "192-226",
    "snippet": "ssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,\n\t\t\tstruct iov_iter *iter, loff_t pos,\n\t\t\tget_block_t get_block, dio_iodone_t end_io, int flags)\n{\n\tstruct buffer_head bh;\n\tssize_t retval = -EINVAL;\n\tloff_t end = pos + iov_iter_count(iter);\n\n\tmemset(&bh, 0, sizeof(bh));\n\n\tif ((flags & DIO_LOCKING) && (rw == READ)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tretval = filemap_write_and_wait_range(mapping, pos, end - 1);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Protects against truncate */\n\tatomic_inc(&inode->i_dio_count);\n\n\tretval = dax_io(rw, inode, iter, pos, end, get_block, &bh);\n\n\tif ((flags & DIO_LOCKING) && (rw == READ))\n\t\tmutex_unlock(&inode->i_mutex);\n\n\tif ((retval > 0) && end_io)\n\t\tend_io(iocb, pos, retval, bh.b_private);\n\n\tinode_dio_done(inode);\n out:\n\treturn retval;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_dio_done",
          "args": [
            "inode"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "inode_dio_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1955-1959",
          "snippet": "void inode_dio_done(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_dio_done(struct inode *inode)\n{\n\tif (atomic_dec_and_test(&inode->i_dio_count))\n\t\twake_up_bit(&inode->i_state, __I_DIO_WAKEUP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "end_io",
          "args": [
            "iocb",
            "pos",
            "retval",
            "bh.b_private"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dio_end_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "610-634",
          "snippet": "static void ocfs2_dio_end_io(struct kiocb *iocb,\n\t\t\t     loff_t offset,\n\t\t\t     ssize_t bytes,\n\t\t\t     void *private)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tint level;\n\n\t/* this io's submitter should not have unlocked this before we could */\n\tBUG_ON(!ocfs2_iocb_is_rw_locked(iocb));\n\n\tif (ocfs2_iocb_is_sem_locked(iocb))\n\t\tocfs2_iocb_clear_sem_locked(iocb);\n\n\tif (ocfs2_iocb_is_unaligned_aio(iocb)) {\n\t\tocfs2_iocb_clear_unaligned_aio(iocb);\n\n\t\tmutex_unlock(&OCFS2_I(inode)->ip_unaligned_aio);\n\t}\n\n\tocfs2_iocb_clear_rw_locked(iocb);\n\n\tlevel = ocfs2_iocb_rw_locked_level(iocb);\n\tocfs2_rw_unlock(inode, level);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dio_end_io(struct kiocb *iocb,\n\t\t\t     loff_t offset,\n\t\t\t     ssize_t bytes,\n\t\t\t     void *private)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp);\n\tint level;\n\n\t/* this io's submitter should not have unlocked this before we could */\n\tBUG_ON(!ocfs2_iocb_is_rw_locked(iocb));\n\n\tif (ocfs2_iocb_is_sem_locked(iocb))\n\t\tocfs2_iocb_clear_sem_locked(iocb);\n\n\tif (ocfs2_iocb_is_unaligned_aio(iocb)) {\n\t\tocfs2_iocb_clear_unaligned_aio(iocb);\n\n\t\tmutex_unlock(&OCFS2_I(inode)->ip_unaligned_aio);\n\t}\n\n\tocfs2_iocb_clear_rw_locked(iocb);\n\n\tlevel = ocfs2_iocb_rw_locked_level(iocb);\n\tocfs2_rw_unlock(inode, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_io",
          "args": [
            "rw",
            "inode",
            "iter",
            "pos",
            "end",
            "get_block",
            "&bh"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "dax_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "101-172",
          "snippet": "static ssize_t dax_io(int rw, struct inode *inode, struct iov_iter *iter,\n\t\t\tloff_t start, loff_t end, get_block_t get_block,\n\t\t\tstruct buffer_head *bh)\n{\n\tssize_t retval = 0;\n\tloff_t pos = start;\n\tloff_t max = start;\n\tloff_t bh_max = start;\n\tvoid *addr;\n\tbool hole = false;\n\n\tif (rw != WRITE)\n\t\tend = min(end, i_size_read(inode));\n\n\twhile (pos < end) {\n\t\tunsigned len;\n\t\tif (pos == max) {\n\t\t\tunsigned blkbits = inode->i_blkbits;\n\t\t\tsector_t block = pos >> blkbits;\n\t\t\tunsigned first = pos - (block << blkbits);\n\t\t\tlong size;\n\n\t\t\tif (pos == bh_max) {\n\t\t\t\tbh->b_size = PAGE_ALIGN(end - pos);\n\t\t\t\tbh->b_state = 0;\n\t\t\t\tretval = get_block(inode, block, bh,\n\t\t\t\t\t\t\t\trw == WRITE);\n\t\t\t\tif (retval)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!buffer_size_valid(bh))\n\t\t\t\t\tbh->b_size = 1 << blkbits;\n\t\t\t\tbh_max = pos - first + bh->b_size;\n\t\t\t} else {\n\t\t\t\tunsigned done = bh->b_size -\n\t\t\t\t\t\t(bh_max - (pos - first));\n\t\t\t\tbh->b_blocknr += done >> blkbits;\n\t\t\t\tbh->b_size -= done;\n\t\t\t}\n\n\t\t\thole = (rw != WRITE) && !buffer_written(bh);\n\t\t\tif (hole) {\n\t\t\t\taddr = NULL;\n\t\t\t\tsize = bh->b_size - first;\n\t\t\t} else {\n\t\t\t\tretval = dax_get_addr(bh, &addr, blkbits);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (buffer_unwritten(bh) || buffer_new(bh))\n\t\t\t\t\tdax_new_buf(addr, retval, first, pos,\n\t\t\t\t\t\t\t\t\tend);\n\t\t\t\taddr += first;\n\t\t\t\tsize = retval - first;\n\t\t\t}\n\t\t\tmax = min(pos + size, end);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tlen = copy_from_iter(addr, max - pos, iter);\n\t\telse if (!hole)\n\t\t\tlen = copy_to_iter(addr, max - pos, iter);\n\t\telse\n\t\t\tlen = iov_iter_zero(max - pos, iter);\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tpos += len;\n\t\taddr += len;\n\t}\n\n\treturn (pos == start) ? retval : pos - start;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic ssize_t dax_io(int rw, struct inode *inode, struct iov_iter *iter,\n\t\t\tloff_t start, loff_t end, get_block_t get_block,\n\t\t\tstruct buffer_head *bh)\n{\n\tssize_t retval = 0;\n\tloff_t pos = start;\n\tloff_t max = start;\n\tloff_t bh_max = start;\n\tvoid *addr;\n\tbool hole = false;\n\n\tif (rw != WRITE)\n\t\tend = min(end, i_size_read(inode));\n\n\twhile (pos < end) {\n\t\tunsigned len;\n\t\tif (pos == max) {\n\t\t\tunsigned blkbits = inode->i_blkbits;\n\t\t\tsector_t block = pos >> blkbits;\n\t\t\tunsigned first = pos - (block << blkbits);\n\t\t\tlong size;\n\n\t\t\tif (pos == bh_max) {\n\t\t\t\tbh->b_size = PAGE_ALIGN(end - pos);\n\t\t\t\tbh->b_state = 0;\n\t\t\t\tretval = get_block(inode, block, bh,\n\t\t\t\t\t\t\t\trw == WRITE);\n\t\t\t\tif (retval)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!buffer_size_valid(bh))\n\t\t\t\t\tbh->b_size = 1 << blkbits;\n\t\t\t\tbh_max = pos - first + bh->b_size;\n\t\t\t} else {\n\t\t\t\tunsigned done = bh->b_size -\n\t\t\t\t\t\t(bh_max - (pos - first));\n\t\t\t\tbh->b_blocknr += done >> blkbits;\n\t\t\t\tbh->b_size -= done;\n\t\t\t}\n\n\t\t\thole = (rw != WRITE) && !buffer_written(bh);\n\t\t\tif (hole) {\n\t\t\t\taddr = NULL;\n\t\t\t\tsize = bh->b_size - first;\n\t\t\t} else {\n\t\t\t\tretval = dax_get_addr(bh, &addr, blkbits);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (buffer_unwritten(bh) || buffer_new(bh))\n\t\t\t\t\tdax_new_buf(addr, retval, first, pos,\n\t\t\t\t\t\t\t\t\tend);\n\t\t\t\taddr += first;\n\t\t\t\tsize = retval - first;\n\t\t\t}\n\t\t\tmax = min(pos + size, end);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tlen = copy_from_iter(addr, max - pos, iter);\n\t\telse if (!hole)\n\t\t\tlen = copy_to_iter(addr, max - pos, iter);\n\t\telse\n\t\t\tlen = iov_iter_zero(max - pos, iter);\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tpos += len;\n\t\taddr += len;\n\t}\n\n\treturn (pos == start) ? retval : pos - start;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&inode->i_dio_count"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_write_and_wait_range",
          "args": [
            "mapping",
            "pos",
            "end - 1"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&bh",
            "0",
            "sizeof(bh)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "iter"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nssize_t dax_do_io(int rw, struct kiocb *iocb, struct inode *inode,\n\t\t\tstruct iov_iter *iter, loff_t pos,\n\t\t\tget_block_t get_block, dio_iodone_t end_io, int flags)\n{\n\tstruct buffer_head bh;\n\tssize_t retval = -EINVAL;\n\tloff_t end = pos + iov_iter_count(iter);\n\n\tmemset(&bh, 0, sizeof(bh));\n\n\tif ((flags & DIO_LOCKING) && (rw == READ)) {\n\t\tstruct address_space *mapping = inode->i_mapping;\n\t\tmutex_lock(&inode->i_mutex);\n\t\tretval = filemap_write_and_wait_range(mapping, pos, end - 1);\n\t\tif (retval) {\n\t\t\tmutex_unlock(&inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Protects against truncate */\n\tatomic_inc(&inode->i_dio_count);\n\n\tretval = dax_io(rw, inode, iter, pos, end, get_block, &bh);\n\n\tif ((flags & DIO_LOCKING) && (rw == READ))\n\t\tmutex_unlock(&inode->i_mutex);\n\n\tif ((retval > 0) && end_io)\n\t\tend_io(iocb, pos, retval, bh.b_private);\n\n\tinode_dio_done(inode);\n out:\n\treturn retval;\n}"
  },
  {
    "function_name": "dax_io",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "101-172",
    "snippet": "static ssize_t dax_io(int rw, struct inode *inode, struct iov_iter *iter,\n\t\t\tloff_t start, loff_t end, get_block_t get_block,\n\t\t\tstruct buffer_head *bh)\n{\n\tssize_t retval = 0;\n\tloff_t pos = start;\n\tloff_t max = start;\n\tloff_t bh_max = start;\n\tvoid *addr;\n\tbool hole = false;\n\n\tif (rw != WRITE)\n\t\tend = min(end, i_size_read(inode));\n\n\twhile (pos < end) {\n\t\tunsigned len;\n\t\tif (pos == max) {\n\t\t\tunsigned blkbits = inode->i_blkbits;\n\t\t\tsector_t block = pos >> blkbits;\n\t\t\tunsigned first = pos - (block << blkbits);\n\t\t\tlong size;\n\n\t\t\tif (pos == bh_max) {\n\t\t\t\tbh->b_size = PAGE_ALIGN(end - pos);\n\t\t\t\tbh->b_state = 0;\n\t\t\t\tretval = get_block(inode, block, bh,\n\t\t\t\t\t\t\t\trw == WRITE);\n\t\t\t\tif (retval)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!buffer_size_valid(bh))\n\t\t\t\t\tbh->b_size = 1 << blkbits;\n\t\t\t\tbh_max = pos - first + bh->b_size;\n\t\t\t} else {\n\t\t\t\tunsigned done = bh->b_size -\n\t\t\t\t\t\t(bh_max - (pos - first));\n\t\t\t\tbh->b_blocknr += done >> blkbits;\n\t\t\t\tbh->b_size -= done;\n\t\t\t}\n\n\t\t\thole = (rw != WRITE) && !buffer_written(bh);\n\t\t\tif (hole) {\n\t\t\t\taddr = NULL;\n\t\t\t\tsize = bh->b_size - first;\n\t\t\t} else {\n\t\t\t\tretval = dax_get_addr(bh, &addr, blkbits);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (buffer_unwritten(bh) || buffer_new(bh))\n\t\t\t\t\tdax_new_buf(addr, retval, first, pos,\n\t\t\t\t\t\t\t\t\tend);\n\t\t\t\taddr += first;\n\t\t\t\tsize = retval - first;\n\t\t\t}\n\t\t\tmax = min(pos + size, end);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tlen = copy_from_iter(addr, max - pos, iter);\n\t\telse if (!hole)\n\t\t\tlen = copy_to_iter(addr, max - pos, iter);\n\t\telse\n\t\t\tlen = iov_iter_zero(max - pos, iter);\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tpos += len;\n\t\taddr += len;\n\t}\n\n\treturn (pos == start) ? retval : pos - start;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iov_iter_zero",
          "args": [
            "max - pos",
            "iter"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_iter",
          "args": [
            "addr",
            "max - pos",
            "iter"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_iter",
          "args": [
            "addr",
            "max - pos",
            "iter"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "pos + size",
            "end"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dax_new_buf",
          "args": [
            "addr",
            "retval",
            "first",
            "pos",
            "end"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "dax_new_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "73-82",
          "snippet": "static void dax_new_buf(void *addr, unsigned size, unsigned first, loff_t pos,\n\t\t\tloff_t end)\n{\n\tloff_t final = end - pos + first; /* The final byte of the buffer */\n\n\tif (first > 0)\n\t\tmemset(addr, 0, first);\n\tif (final < size)\n\t\tmemset(addr + final, 0, size - final);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_new_buf(void *addr, unsigned size, unsigned first, loff_t pos,\n\t\t\tloff_t end)\n{\n\tloff_t final = end - pos + first; /* The final byte of the buffer */\n\n\tif (first > 0)\n\t\tmemset(addr, 0, first);\n\tif (final < size)\n\t\tmemset(addr + final, 0, size - final);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_new",
          "args": [
            "bh"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dax_get_addr",
          "args": [
            "bh",
            "&addr",
            "blkbits"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "dax_get_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "66-71",
          "snippet": "static long dax_get_addr(struct buffer_head *bh, void **addr, unsigned blkbits)\n{\n\tunsigned long pfn;\n\tsector_t sector = bh->b_blocknr << (blkbits - 9);\n\treturn bdev_direct_access(bh->b_bdev, sector, addr, &pfn, bh->b_size);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic long dax_get_addr(struct buffer_head *bh, void **addr, unsigned blkbits)\n{\n\tunsigned long pfn;\n\tsector_t sector = bh->b_blocknr << (blkbits - 9);\n\treturn bdev_direct_access(bh->b_bdev, sector, addr, &pfn, bh->b_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_written",
          "args": [
            "bh"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_written",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "84-87",
          "snippet": "static bool buffer_written(struct buffer_head *bh)\n{\n\treturn buffer_mapped(bh) && !buffer_unwritten(bh);\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool buffer_written(struct buffer_head *bh)\n{\n\treturn buffer_mapped(bh) && !buffer_unwritten(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_size_valid",
          "args": [
            "bh"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "buffer_size_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
          "lines": "96-99",
          "snippet": "static bool buffer_size_valid(struct buffer_head *bh)\n{\n\treturn bh->b_state != 0;\n}",
          "includes": [
            "#include <linux/vmstat.h>",
            "#include <linux/uio.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mm.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/highmem.h>",
            "#include <linux/genhd.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool buffer_size_valid(struct buffer_head *bh)\n{\n\treturn bh->b_state != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_block",
          "args": [
            "inode",
            "block",
            "bh",
            "rw == WRITE"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "139-147",
          "snippet": "static int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic int\nblkdev_get_block(struct inode *inode, sector_t iblock,\n\t\tstruct buffer_head *bh, int create)\n{\n\tbh->b_bdev = I_BDEV(inode);\n\tbh->b_blocknr = iblock;\n\tset_buffer_mapped(bh);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "end - pos"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic ssize_t dax_io(int rw, struct inode *inode, struct iov_iter *iter,\n\t\t\tloff_t start, loff_t end, get_block_t get_block,\n\t\t\tstruct buffer_head *bh)\n{\n\tssize_t retval = 0;\n\tloff_t pos = start;\n\tloff_t max = start;\n\tloff_t bh_max = start;\n\tvoid *addr;\n\tbool hole = false;\n\n\tif (rw != WRITE)\n\t\tend = min(end, i_size_read(inode));\n\n\twhile (pos < end) {\n\t\tunsigned len;\n\t\tif (pos == max) {\n\t\t\tunsigned blkbits = inode->i_blkbits;\n\t\t\tsector_t block = pos >> blkbits;\n\t\t\tunsigned first = pos - (block << blkbits);\n\t\t\tlong size;\n\n\t\t\tif (pos == bh_max) {\n\t\t\t\tbh->b_size = PAGE_ALIGN(end - pos);\n\t\t\t\tbh->b_state = 0;\n\t\t\t\tretval = get_block(inode, block, bh,\n\t\t\t\t\t\t\t\trw == WRITE);\n\t\t\t\tif (retval)\n\t\t\t\t\tbreak;\n\t\t\t\tif (!buffer_size_valid(bh))\n\t\t\t\t\tbh->b_size = 1 << blkbits;\n\t\t\t\tbh_max = pos - first + bh->b_size;\n\t\t\t} else {\n\t\t\t\tunsigned done = bh->b_size -\n\t\t\t\t\t\t(bh_max - (pos - first));\n\t\t\t\tbh->b_blocknr += done >> blkbits;\n\t\t\t\tbh->b_size -= done;\n\t\t\t}\n\n\t\t\thole = (rw != WRITE) && !buffer_written(bh);\n\t\t\tif (hole) {\n\t\t\t\taddr = NULL;\n\t\t\t\tsize = bh->b_size - first;\n\t\t\t} else {\n\t\t\t\tretval = dax_get_addr(bh, &addr, blkbits);\n\t\t\t\tif (retval < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (buffer_unwritten(bh) || buffer_new(bh))\n\t\t\t\t\tdax_new_buf(addr, retval, first, pos,\n\t\t\t\t\t\t\t\t\tend);\n\t\t\t\taddr += first;\n\t\t\t\tsize = retval - first;\n\t\t\t}\n\t\t\tmax = min(pos + size, end);\n\t\t}\n\n\t\tif (rw == WRITE)\n\t\t\tlen = copy_from_iter(addr, max - pos, iter);\n\t\telse if (!hole)\n\t\t\tlen = copy_to_iter(addr, max - pos, iter);\n\t\telse\n\t\t\tlen = iov_iter_zero(max - pos, iter);\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tpos += len;\n\t\taddr += len;\n\t}\n\n\treturn (pos == start) ? retval : pos - start;\n}"
  },
  {
    "function_name": "buffer_size_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "96-99",
    "snippet": "static bool buffer_size_valid(struct buffer_head *bh)\n{\n\treturn bh->b_state != 0;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool buffer_size_valid(struct buffer_head *bh)\n{\n\treturn bh->b_state != 0;\n}"
  },
  {
    "function_name": "buffer_written",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "84-87",
    "snippet": "static bool buffer_written(struct buffer_head *bh)\n{\n\treturn buffer_mapped(bh) && !buffer_unwritten(bh);\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "buffer_unwritten",
          "args": [
            "bh"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic bool buffer_written(struct buffer_head *bh)\n{\n\treturn buffer_mapped(bh) && !buffer_unwritten(bh);\n}"
  },
  {
    "function_name": "dax_new_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "73-82",
    "snippet": "static void dax_new_buf(void *addr, unsigned size, unsigned first, loff_t pos,\n\t\t\tloff_t end)\n{\n\tloff_t final = end - pos + first; /* The final byte of the buffer */\n\n\tif (first > 0)\n\t\tmemset(addr, 0, first);\n\tif (final < size)\n\t\tmemset(addr + final, 0, size - final);\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr + final",
            "0",
            "size - final"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr",
            "0",
            "first"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic void dax_new_buf(void *addr, unsigned size, unsigned first, loff_t pos,\n\t\t\tloff_t end)\n{\n\tloff_t final = end - pos + first; /* The final byte of the buffer */\n\n\tif (first > 0)\n\t\tmemset(addr, 0, first);\n\tif (final < size)\n\t\tmemset(addr + final, 0, size - final);\n}"
  },
  {
    "function_name": "dax_get_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "66-71",
    "snippet": "static long dax_get_addr(struct buffer_head *bh, void **addr, unsigned blkbits)\n{\n\tunsigned long pfn;\n\tsector_t sector = bh->b_blocknr << (blkbits - 9);\n\treturn bdev_direct_access(bh->b_bdev, sector, addr, &pfn, bh->b_size);\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bdev_direct_access",
          "args": [
            "bh->b_bdev",
            "sector",
            "addr",
            "&pfn",
            "bh->b_size"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_direct_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "441-461",
          "snippet": "long bdev_direct_access(struct block_device *bdev, sector_t sector,\n\t\t\tvoid **addr, unsigned long *pfn, long size)\n{\n\tlong avail;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (size < 0)\n\t\treturn size;\n\tif (!ops->direct_access)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector + DIV_ROUND_UP(size, 512)) >\n\t\t\t\t\tpart_nr_sects_read(bdev->bd_part))\n\t\treturn -ERANGE;\n\tsector += get_start_sect(bdev);\n\tif (sector % (PAGE_SIZE / 512))\n\t\treturn -EINVAL;\n\tavail = ops->direct_access(bdev, sector, addr, pfn, size);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nlong bdev_direct_access(struct block_device *bdev, sector_t sector,\n\t\t\tvoid **addr, unsigned long *pfn, long size)\n{\n\tlong avail;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (size < 0)\n\t\treturn size;\n\tif (!ops->direct_access)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector + DIV_ROUND_UP(size, 512)) >\n\t\t\t\t\tpart_nr_sects_read(bdev->bd_part))\n\t\treturn -ERANGE;\n\tsector += get_start_sect(bdev);\n\tif (sector % (PAGE_SIZE / 512))\n\t\treturn -EINVAL;\n\tavail = ops->direct_access(bdev, sector, addr, pfn, size);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, size);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nstatic long dax_get_addr(struct buffer_head *bh, void **addr, unsigned blkbits)\n{\n\tunsigned long pfn;\n\tsector_t sector = bh->b_blocknr << (blkbits - 9);\n\treturn bdev_direct_access(bh->b_bdev, sector, addr, &pfn, bh->b_size);\n}"
  },
  {
    "function_name": "dax_clear_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dax.c",
    "lines": "30-63",
    "snippet": "int dax_clear_blocks(struct inode *inode, sector_t block, long size)\n{\n\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\tsector_t sector = block << (inode->i_blkbits - 9);\n\n\tmight_sleep();\n\tdo {\n\t\tvoid *addr;\n\t\tunsigned long pfn;\n\t\tlong count;\n\n\t\tcount = bdev_direct_access(bdev, sector, &addr, &pfn, size);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t\tBUG_ON(size < count);\n\t\twhile (count > 0) {\n\t\t\tunsigned pgsz = PAGE_SIZE - offset_in_page(addr);\n\t\t\tif (pgsz > count)\n\t\t\t\tpgsz = count;\n\t\t\tif (pgsz < PAGE_SIZE)\n\t\t\t\tmemset(addr, 0, pgsz);\n\t\t\telse\n\t\t\t\tclear_page(addr);\n\t\t\taddr += pgsz;\n\t\t\tsize -= pgsz;\n\t\t\tcount -= pgsz;\n\t\t\tBUG_ON(pgsz & 511);\n\t\t\tsector += pgsz / 512;\n\t\t\tcond_resched();\n\t\t}\n\t} while (size);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/vmstat.h>",
      "#include <linux/uio.h>",
      "#include <linux/sched.h>",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/highmem.h>",
      "#include <linux/genhd.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/atomic.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pgsz & 511"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "addr"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "addr",
            "0",
            "pgsz"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "addr"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size < count"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_direct_access",
          "args": [
            "bdev",
            "sector",
            "&addr",
            "&pfn",
            "size"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "bdev_direct_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "441-461",
          "snippet": "long bdev_direct_access(struct block_device *bdev, sector_t sector,\n\t\t\tvoid **addr, unsigned long *pfn, long size)\n{\n\tlong avail;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (size < 0)\n\t\treturn size;\n\tif (!ops->direct_access)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector + DIV_ROUND_UP(size, 512)) >\n\t\t\t\t\tpart_nr_sects_read(bdev->bd_part))\n\t\treturn -ERANGE;\n\tsector += get_start_sect(bdev);\n\tif (sector % (PAGE_SIZE / 512))\n\t\treturn -EINVAL;\n\tavail = ops->direct_access(bdev, sector, addr, pfn, size);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, size);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nlong bdev_direct_access(struct block_device *bdev, sector_t sector,\n\t\t\tvoid **addr, unsigned long *pfn, long size)\n{\n\tlong avail;\n\tconst struct block_device_operations *ops = bdev->bd_disk->fops;\n\n\tif (size < 0)\n\t\treturn size;\n\tif (!ops->direct_access)\n\t\treturn -EOPNOTSUPP;\n\tif ((sector + DIV_ROUND_UP(size, 512)) >\n\t\t\t\t\tpart_nr_sects_read(bdev->bd_part))\n\t\treturn -ERANGE;\n\tsector += get_start_sect(bdev);\n\tif (sector % (PAGE_SIZE / 512))\n\t\treturn -EINVAL;\n\tavail = ops->direct_access(bdev, sector, addr, pfn, size);\n\tif (!avail)\n\t\treturn -ERANGE;\n\treturn min(avail, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "might_sleep",
          "args": [],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/vmstat.h>\n#include <linux/uio.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/memcontrol.h>\n#include <linux/highmem.h>\n#include <linux/genhd.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/atomic.h>\n\nint dax_clear_blocks(struct inode *inode, sector_t block, long size)\n{\n\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\tsector_t sector = block << (inode->i_blkbits - 9);\n\n\tmight_sleep();\n\tdo {\n\t\tvoid *addr;\n\t\tunsigned long pfn;\n\t\tlong count;\n\n\t\tcount = bdev_direct_access(bdev, sector, &addr, &pfn, size);\n\t\tif (count < 0)\n\t\t\treturn count;\n\t\tBUG_ON(size < count);\n\t\twhile (count > 0) {\n\t\t\tunsigned pgsz = PAGE_SIZE - offset_in_page(addr);\n\t\t\tif (pgsz > count)\n\t\t\t\tpgsz = count;\n\t\t\tif (pgsz < PAGE_SIZE)\n\t\t\t\tmemset(addr, 0, pgsz);\n\t\t\telse\n\t\t\t\tclear_page(addr);\n\t\t\taddr += pgsz;\n\t\t\tsize -= pgsz;\n\t\t\tcount -= pgsz;\n\t\t\tBUG_ON(pgsz & 511);\n\t\t\tsector += pgsz / 512;\n\t\t\tcond_resched();\n\t\t}\n\t} while (size);\n\n\treturn 0;\n}"
  }
]