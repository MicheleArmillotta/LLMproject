[
  {
    "function_name": "_bytes(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "731-753",
    "snippet": "g_check_bud_bytes(struct ubifs_info *c)\n{\n\tint i, err = 0;\n\tstruct ubifs_bud *bud;\n\tlong long bud_bytes = 0;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tspin_lock(&c->buds_lock);\n\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\tlist_for_each_entry(bud, &c->jheads[i].buds_list, list)\n\t\t\tbud_bytes += c->leb_size - bud->start;\n\n\tif (c->bud_bytes != bud_bytes) {\n\t\tubifs_err(\"bad bud_bytes %lld, calculated %lld\",\n\t\t\t  c->bud_bytes, bud_bytes);\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&c->buds_lock);\n\n\treturn err;\n}",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->buds_loc",
          "args": [
            ");\n\n\treturn e"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d bud_byt",
          "args": [
            "s %lld, calculated %lld\",\n\t\t\t  c->bud",
            "bud_bytes);",
            "err = -E"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(bud, &c->jhe",
          "args": [
            "ds[",
            ".buds_list, list)\n\t\t\tbu",
            "byte"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">buds_loc",
          "args": [
            ");\n\tfor (i ="
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c))\n\t\treturn",
          "args": [
            "0"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\ng_check_bud_bytes(struct ubifs_info *c)\n{\n\tint i, err = 0;\n\tstruct ubifs_bud *bud;\n\tlong long bud_bytes = 0;\n\n\tif (!dbg_is_chk_gen(c))\n\t\treturn 0;\n\n\tspin_lock(&c->buds_lock);\n\tfor (i = 0; i < c->jhead_cnt; i++)\n\t\tlist_for_each_entry(bud, &c->jheads[i].buds_list, list)\n\t\t\tbud_bytes += c->leb_size - bud->start;\n\n\tif (c->bud_bytes != bud_bytes) {\n\t\tubifs_err(\"bad bud_bytes %lld, calculated %lld\",\n\t\t\t  c->bud_bytes, bud_bytes);\n\t\terr = -EINVAL;\n\t}\n\tspin_unlock(&c->buds_lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "date_log(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "633-721",
    "snippet": "solidate_log(struct ubifs_info *c)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tstruct rb_root done_tree = RB_ROOT;\n\tint lnum, err, first = 1, write_lnum, offs = 0;\n\tvoid *buf;\n\n\tdbg_rcvry(\"log tail LEB %d, log head LEB %d\", c->ltail_lnum,\n\t\t  c->lhead_lnum);\n\tbuf = vmalloc(c->leb_size);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tlnum = c->ltail_lnum;\n\twrite_lnum = lnum;\n\twhile (1) {\n\t\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tgoto out_free;\n\t\t}\n\t\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\t\tswitch (snod->type) {\n\t\t\tcase UBIFS_REF_NODE: {\n\t\t\t\tstruct ubifs_ref_node *ref = snod->node;\n\t\t\t\tint ref_lnum = le32_to_cpu(ref->lnum);\n\n\t\t\t\terr = done_already(&done_tree, ref_lnum);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto out_scan;\n\t\t\t\tif (err != 1) {\n\t\t\t\t\terr = add_node(c, buf, &write_lnum,\n\t\t\t\t\t\t       &offs, snod->node);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\tgoto out_scan;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase UBIFS_CS_NODE:\n\t\t\t\tif (!first)\n\t\t\t\t\tbreak;\n\t\t\t\terr = add_node(c, buf, &write_lnum, &offs,\n\t\t\t\t\t       snod->node);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_scan;\n\t\t\t\tfirst = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t\tif (lnum == c->lhead_lnum)\n\t\t\tbreak;\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t}\n\tif (offs) {\n\t\tint sz = ALIGN(offs, c->min_io_size);\n\n\t\tubifs_pad(c, buf + offs, sz - offs);\n\t\terr = ubifs_leb_change(c, write_lnum, buf, sz);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\toffs = ALIGN(offs, c->min_io_size);\n\t}\n\tdestroy_done_tree(&done_tree);\n\tvfree(buf);\n\tif (write_lnum == c->lhead_lnum) {\n\t\tubifs_err(\"log is too full\");\n\t\treturn -EINVAL;\n\t}\n\t/* Unmap remaining LEBs */\n\tlnum = write_lnum;\n\tdo {\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (lnum != c->lhead_lnum);\n\tc->lhead_lnum = write_lnum;\n\tc->lhead_offs = offs;\n\tdbg_rcvry(\"new log head at %d:%d\", c->lhead_lnum, c->lhead_offs);\n\treturn 0;\n\nout_scan:\n\tubifs_scan_destroy(sleb);\nout_free:\n\tdestroy_done_tree(&done_tree);\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * dbg_",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tree(&done_tree);",
          "args": [
            "vfree(buf"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\nout_f",
          "args": [
            "ee:"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "w log hea",
          "args": [
            "at %d:%d\", c->lhead_ln",
            ", c->lhead_of",
            ");\n\treturn 0;"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "f",
            "err)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, lnum);",
          "args": [
            "r",
            "= ub"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g is too",
          "args": [
            "ull\");\n\t\treturn -"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "if (w",
          "args": [
            "ite"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tree(&done_tree);",
          "args": [
            "vfree(buf"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->min",
          "args": [
            "io_s",
            "e);\n\t}\n\tdestro"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nge(c, write_lnu",
          "args": [
            ",",
            "uf, sz);",
            "f (",
            "r)"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf + off",
          "args": [
            ",",
            "z - offs);",
            "err = ub"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, lnum);\n\t}",
          "args": [
            "(of"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\t\tif",
          "args": [
            "lnum"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf, &wri",
          "args": [
            "e",
            "num",
            "&offs,",
            "if (er"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uf, &wri",
          "args": [
            "e",
            "num",
            "node)",
            "if (e"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&done_tree,",
          "args": [
            "ef_lnum);",
            "if (er"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ef->lnum);",
          "args": [
            "err ="
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_entry(snod, &sleb-",
          "args": [
            "node",
            "list) {",
            "itch"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\t\tgo",
          "args": [
            "o ou"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "{",
          "args": [
            "rr ="
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": "lnum, 0,",
          "args": [
            "-",
            "buf,",
            ")",
            "if (I",
            "E"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_size)",
          "args": [
            "if (!buf)"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g tail LE",
          "args": [
            "%d, log head LEB %d\", c->ltail_ln",
            ",\n\t\t  c->lhea",
            ");\n\tbuf = vma"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\nsolidate_log(struct ubifs_info *c)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tstruct ubifs_scan_node *snod;\n\tstruct rb_root done_tree = RB_ROOT;\n\tint lnum, err, first = 1, write_lnum, offs = 0;\n\tvoid *buf;\n\n\tdbg_rcvry(\"log tail LEB %d, log head LEB %d\", c->ltail_lnum,\n\t\t  c->lhead_lnum);\n\tbuf = vmalloc(c->leb_size);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tlnum = c->ltail_lnum;\n\twrite_lnum = lnum;\n\twhile (1) {\n\t\tsleb = ubifs_scan(c, lnum, 0, c->sbuf, 0);\n\t\tif (IS_ERR(sleb)) {\n\t\t\terr = PTR_ERR(sleb);\n\t\t\tgoto out_free;\n\t\t}\n\t\tlist_for_each_entry(snod, &sleb->nodes, list) {\n\t\t\tswitch (snod->type) {\n\t\t\tcase UBIFS_REF_NODE: {\n\t\t\t\tstruct ubifs_ref_node *ref = snod->node;\n\t\t\t\tint ref_lnum = le32_to_cpu(ref->lnum);\n\n\t\t\t\terr = done_already(&done_tree, ref_lnum);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto out_scan;\n\t\t\t\tif (err != 1) {\n\t\t\t\t\terr = add_node(c, buf, &write_lnum,\n\t\t\t\t\t\t       &offs, snod->node);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\tgoto out_scan;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase UBIFS_CS_NODE:\n\t\t\t\tif (!first)\n\t\t\t\t\tbreak;\n\t\t\t\terr = add_node(c, buf, &write_lnum, &offs,\n\t\t\t\t\t       snod->node);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out_scan;\n\t\t\t\tfirst = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t\tif (lnum == c->lhead_lnum)\n\t\t\tbreak;\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t}\n\tif (offs) {\n\t\tint sz = ALIGN(offs, c->min_io_size);\n\n\t\tubifs_pad(c, buf + offs, sz - offs);\n\t\terr = ubifs_leb_change(c, write_lnum, buf, sz);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\toffs = ALIGN(offs, c->min_io_size);\n\t}\n\tdestroy_done_tree(&done_tree);\n\tvfree(buf);\n\tif (write_lnum == c->lhead_lnum) {\n\t\tubifs_err(\"log is too full\");\n\t\treturn -EINVAL;\n\t}\n\t/* Unmap remaining LEBs */\n\tlnum = write_lnum;\n\tdo {\n\t\tlnum = ubifs_next_log_lnum(c, lnum);\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t} while (lnum != c->lhead_lnum);\n\tc->lhead_lnum = write_lnum;\n\tc->lhead_offs = offs;\n\tdbg_rcvry(\"new log head at %d:%d\", c->lhead_lnum, c->lhead_offs);\n\treturn 0;\n\nout_scan:\n\tubifs_scan_destroy(sleb);\nout_free:\n\tdestroy_done_tree(&done_tree);\n\tvfree(buf);\n\treturn err;\n}\n\n/**\n * dbg_"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "602-621",
    "snippet": "d_node(struct ubifs_info *c, void *buf, int *lnum, int *offs,\n\t\t    void *node)\n{\n\tstruct ubifs_ch *ch = node;\n\tint len = le32_to_cpu(ch->len), remains = c->leb_size - *offs;\n\n\tif (len > remains) {\n\t\tint sz = ALIGN(*offs, c->min_io_size), err;\n\n\t\tubifs_pad(c, buf + *offs, sz - *offs);\n\t\terr = ubifs_leb_change(c, *lnum, buf, sz);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*lnum = ubifs_next_log_lnum(c, *lnum);\n\t\t*offs = 0;\n\t}\n\tmemcpy(buf + *offs, node, len);\n\t*offs += ALIGN(len, 8);\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [
      "g_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": ";\n\tre",
          "args": [
            "urn",
            ";"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*offs,",
          "args": [
            "node, len);",
            "*off",
            "+="
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, *lnum);",
          "args": [
            "*",
            "fs ="
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, *lnum, bu",
          "args": [
            ",",
            "z);",
            "f (",
            "r)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf + *of",
          "args": [
            "s",
            "sz - *offs)",
            "err = ub"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->mi",
          "args": [
            "_io_s",
            "e), err;\n\n\t\tub"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len), re",
          "args": [
            "ains ="
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\ng_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif;\n\nd_node(struct ubifs_info *c, void *buf, int *lnum, int *offs,\n\t\t    void *node)\n{\n\tstruct ubifs_ch *ch = node;\n\tint len = le32_to_cpu(ch->len), remains = c->leb_size - *offs;\n\n\tif (len > remains) {\n\t\tint sz = ALIGN(*offs, c->min_io_size), err;\n\n\t\tubifs_pad(c, buf + *offs, sz - *offs);\n\t\terr = ubifs_leb_change(c, *lnum, buf, sz);\n\t\tif (err)\n\t\t\treturn err;\n\t\t*lnum = ubifs_next_log_lnum(c, *lnum);\n\t\t*offs = 0;\n\t}\n\tmemcpy(buf + *offs, node, len);\n\t*offs += ALIGN(len, 8);\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "tree(struct rb_ro",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "584-590",
    "snippet": "estroy_done_tree(struct rb_root *done_tree)\n{\n\tstruct done_ref *dr, *n;\n\n\trbtree_postorder_for_each_entry_safe(dr, n, done_tree, rb)\n\t\tkfree(dr);\n}\n\n/**\n * add_",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "/**",
          "args": [
            "*"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "der_for_each_entry_safe(dr, n, done_",
          "args": [
            "re",
            ")\n\t\tkfree",
            "r)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\nestroy_done_tree(struct rb_root *done_tree)\n{\n\tstruct done_ref *dr, *n;\n\n\trbtree_postorder_for_each_entry_safe(dr, n, done_tree, rb)\n\t\tkfree(dr);\n}\n\n/**\n * add_"
  },
  {
    "function_name": "struct rb_ro",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "552-578",
    "snippet": "ne_already(struct rb_root *done_tree, int lnum)\n{\n\tstruct rb_node **p = &done_tree->rb_node, *parent = NULL;\n\tstruct done_ref *dr;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tdr = rb_entry(parent, struct done_ref, rb);\n\t\tif (lnum < dr->lnum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (lnum > dr->lnum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\tdr = kzalloc(sizeof(struct done_ref), GFP_NOFS);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdr->lnum = lnum;\n\n\trb_link_node(&dr->rb, parent, p);\n\trb_insert_color(&dr->rb, done_tree);\n\n\treturn 0;\n}\n\n/**\n * dest",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "or(&dr->rb, don",
          "args": [
            "_tree);",
            "return 0"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&dr->rb, par",
          "args": [
            "nt, p);",
            "rb_ins",
            "t"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "done_ref), GFP_NOFS);",
            "f (!dr)"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "nt, stru",
          "args": [
            "t done",
            "ef, rb;\n\t\tif (",
            "um"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\nne_already(struct rb_root *done_tree, int lnum)\n{\n\tstruct rb_node **p = &done_tree->rb_node, *parent = NULL;\n\tstruct done_ref *dr;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tdr = rb_entry(parent, struct done_ref, rb);\n\t\tif (lnum < dr->lnum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (lnum > dr->lnum)\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\tdr = kzalloc(sizeof(struct done_ref), GFP_NOFS);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdr->lnum = lnum;\n\n\trb_link_node(&dr->rb, parent, p);\n\trb_insert_color(&dr->rb, done_tree);\n\n\treturn 0;\n}\n\n/**\n * dest"
  },
  {
    "function_name": "t_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "507-532",
    "snippet": "_post_commit(struct ubifs_info *c, int old_ltail_lnum)\n{\n\tint lnum, err = 0;\n\n\twhile (!list_empty(&c->old_buds)) {\n\t\tstruct ubifs_bud *bud;\n\n\t\tbud = list_entry(c->old_buds.next, struct ubifs_bud, list);\n\t\terr = ubifs_return_leb(c, bud->lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlist_del(&bud->list);\n\t\tkfree(bud);\n\t}\n\tmutex_lock(&c->log_mutex);\n\tfor (lnum = old_ltail_lnum; lnum != c->ltail_lnum;\n\t     lnum = ubifs_next_log_lnum(c, lnum)) {\n\t\tdbg_log(\"unmap log LEB %d\", lnum);\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&c->log_mutex);\n\treturn err;\n}\n\n/**\n * stru",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->log_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "f",
            "err)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p log L",
          "args": [
            "B %d\", lnum);\n\t\ter",
            "= ub"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, lnum)) {",
          "args": [
            "g_lo"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->log_mute",
          "args": [
            ");\n\tfor (lnum"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}\n\tmu",
          "args": [
            "ex_"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->list);",
          "args": [
            "kfree(bu"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb(c, bud->lnum",
          "args": [
            ";",
            "if (err)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">old_buds.",
          "args": [
            "ext, struct ubif",
            "bud, lst);\n\t\ter",
            "= ub"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->old_buds",
          "args": [
            ") {\n\t\tstruct"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\n_post_commit(struct ubifs_info *c, int old_ltail_lnum)\n{\n\tint lnum, err = 0;\n\n\twhile (!list_empty(&c->old_buds)) {\n\t\tstruct ubifs_bud *bud;\n\n\t\tbud = list_entry(c->old_buds.next, struct ubifs_bud, list);\n\t\terr = ubifs_return_leb(c, bud->lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlist_del(&bud->list);\n\t\tkfree(bud);\n\t}\n\tmutex_lock(&c->log_mutex);\n\tfor (lnum = old_ltail_lnum; lnum != c->ltail_lnum;\n\t     lnum = ubifs_next_log_lnum(c, lnum)) {\n\t\tdbg_log(\"unmap log LEB %d\", lnum);\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&c->log_mutex);\n\treturn err;\n}\n\n/**\n * stru"
  },
  {
    "function_name": "_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "458-492",
    "snippet": "_end_commit(struct ubifs_info *c, int ltail_lnum)\n{\n\tint err;\n\n\t/*\n\t * At this phase we have to lock 'c->log_mutex' because UBIFS allows FS\n\t * writes during commit. Its only short \"commit\" start phase when\n\t * writers are blocked.\n\t */\n\tmutex_lock(&c->log_mutex);\n\n\tdbg_log(\"old tail was LEB %d:0, new tail is LEB %d:0\",\n\t\tc->ltail_lnum, ltail_lnum);\n\n\tc->ltail_lnum = ltail_lnum;\n\t/*\n\t * The commit is finished and from now on it must be guaranteed that\n\t * there is always enough space for the next commit.\n\t */\n\tc->min_log_bytes = c->leb_size;\n\n\tspin_lock(&c->buds_lock);\n\tc->bud_bytes -= c->cmt_bud_bytes;\n\tspin_unlock(&c->buds_lock);\n\n\terr = dbg_check_bud_bytes(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_write_master(c);\n\nout:\n\tmutex_unlock(&c->log_mutex);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [
      "g_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "&c->log_mute",
          "args": [
            ");\n\treturn er"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aster(c);\n\nout:\n\tm",
          "args": [
            "t"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bytes(c);\n\tif (err",
          "args": [],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->buds_loc",
          "args": [
            ");\n\n\terr = db"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">buds_loc",
          "args": [
            ");\n\tc->bud_by"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tail wa",
          "args": [
            "LEB %d:0, new tail is LEB %d:0\",\n\t\tc->ltail_",
            ", ltail_lnum)",
            "c->ltail"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->log_mute",
          "args": [
            ");\n\n\tdbg_log("
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\ng_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif;\n\n_end_commit(struct ubifs_info *c, int ltail_lnum)\n{\n\tint err;\n\n\t/*\n\t * At this phase we have to lock 'c->log_mutex' because UBIFS allows FS\n\t * writes during commit. Its only short \"commit\" start phase when\n\t * writers are blocked.\n\t */\n\tmutex_lock(&c->log_mutex);\n\n\tdbg_log(\"old tail was LEB %d:0, new tail is LEB %d:0\",\n\t\tc->ltail_lnum, ltail_lnum);\n\n\tc->ltail_lnum = ltail_lnum;\n\t/*\n\t * The commit is finished and from now on it must be guaranteed that\n\t * there is always enough space for the next commit.\n\t */\n\tc->min_log_bytes = c->leb_size;\n\n\tspin_lock(&c->buds_lock);\n\tc->bud_bytes -= c->cmt_bud_bytes;\n\tspin_unlock(&c->buds_lock);\n\n\terr = dbg_check_bud_bytes(c);\n\tif (err)\n\t\tgoto out;\n\n\terr = ubifs_write_master(c);\n\nout:\n\tmutex_unlock(&c->log_mutex);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "rt_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "359-446",
    "snippet": "_start_commit(struct ubifs_info *c, int *ltail_lnum)\n{\n\tvoid *buf;\n\tstruct ubifs_cs_node *cs;\n\tstruct ubifs_ref_node *ref;\n\tint err, i, max_len, len;\n\n\terr = dbg_check_bud_bytes(c);\n\tif (err)\n\t\treturn err;\n\n\tmax_len = UBIFS_CS_NODE_SZ + c->jhead_cnt * UBIFS_REF_NODE_SZ;\n\tmax_len = ALIGN(max_len, c->min_io_size);\n\tbuf = cs = kmalloc(max_len, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcs->ch.node_type = UBIFS_CS_NODE;\n\tcs->cmt_no = cpu_to_le64(c->cmt_no);\n\tubifs_prepare_node(c, cs, UBIFS_CS_NODE_SZ, 0);\n\n\t/*\n\t * Note, we do not lock 'c->log_mutex' because this is the commit start\n\t * phase and we are exclusively using the log. And we do not lock\n\t * write-buffer because nobody can write to the file-system at this\n\t * phase.\n\t */\n\n\tlen = UBIFS_CS_NODE_SZ;\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tint lnum = c->jheads[i].wbuf.lnum;\n\t\tint offs = c->jheads[i].wbuf.offs;\n\n\t\tif (lnum == -1 || offs == c->leb_size)\n\t\t\tcontinue;\n\n\t\tdbg_log(\"add ref to LEB %d:%d for jhead %s\",\n\t\t\tlnum, offs, dbg_jhead(i));\n\t\tref = buf + len;\n\t\tref->ch.node_type = UBIFS_REF_NODE;\n\t\tref->lnum = cpu_to_le32(lnum);\n\t\tref->offs = cpu_to_le32(offs);\n\t\tref->jhead = cpu_to_le32(i);\n\n\t\tubifs_prepare_node(c, ref, UBIFS_REF_NODE_SZ, 0);\n\t\tlen += UBIFS_REF_NODE_SZ;\n\t}\n\n\tubifs_pad(c, buf + len, ALIGN(len, c->min_io_size) - len);\n\n\t/* Switch to the next log LEB */\n\tif (c->lhead_offs) {\n\t\tc->lhead_lnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\t\tubifs_assert(c->lhead_lnum != c->ltail_lnum);\n\t\tc->lhead_offs = 0;\n\t}\n\n\t/* Must ensure next LEB has been unmapped */\n\terr = ubifs_leb_unmap(c, c->lhead_lnum);\n\tif (err)\n\t\tgoto out;\n\n\tlen = ALIGN(len, c->min_io_size);\n\tdbg_log(\"writing commit start at LEB %d:0, len %d\", c->lhead_lnum, len);\n\terr = ubifs_leb_write(c, c->lhead_lnum, cs, 0, len);\n\tif (err)\n\t\tgoto out;\n\n\t*ltail_lnum = c->lhead_lnum;\n\n\tc->lhead_offs += len;\n\tif (c->lhead_offs == c->leb_size) {\n\t\tc->lhead_lnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\t\tc->lhead_offs = 0;\n\t}\n\n\tremove_buds(c);\n\n\t/*\n\t * We have started the commit and now users may use the rest of the log\n\t * for new writes.\n\t */\n\tc->min_log_bytes = 0;\n\nout:\n\tkfree(buf);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [
      "g_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": ");\n\n\t/*\n\t *",
          "args": [
            "W"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, c->lhead_",
          "args": [
            "n",
            ");\n\t\tc->lhead"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "te(c, c->lhead_",
          "args": [
            "n",
            ", cs, 0, len)",
            "i",
            "(",
            "r)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ing com",
          "args": [
            "it start at LEB %d:0, len %d\", c->lhead_ln",
            ", len);\n\terr",
            "ubi"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e);\n\tdbg_log(\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, c->lhead_",
          "args": [
            "n",
            ");\n\tif (err)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lhead_lnu",
          "args": [
            "!= c->ltail_lnum);\n\t\tc->lhead"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, c->lhead_",
          "args": [
            "n",
            ");\n\t\tubifs_as"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf + len",
          "args": [
            "IGN(len,",
            ">min_io_size) - len);\n\n\t/* Switc"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">min_",
          "args": [
            "o_s",
            "e) - len);\n\n\t/"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, ref, UBIF",
          "args": [
            "_",
            "F_N",
            "E_SZ, 0);\n\t\tlen +",
            "U"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\tubifs",
          "args": [
            "p"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs);\n\t\tref",
          "args": [
            ">jhe"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num);\n\t\tref",
          "args": [
            ">off"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ref to",
          "args": [
            "EB %d:%d for jhead %s\",\n\t\t\tlnum, of",
            "bg_j",
            "ad(i",
            ";\n\t\tref = bu"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\tref =",
          "args": [
            "b"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, cs, UBIFS",
          "args": [
            "C",
            "NO",
            "_SZ, 0);\n\n\t/*",
            "N"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->cmt_no);",
          "args": [
            "ubifs_pre"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "en, GFP",
          "args": [
            "NOFS);",
            "f (!buf)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", c->",
          "args": [
            "in_io_s",
            "e);\n\tbuf = cs"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bytes(c);\n\tif (err",
          "args": [],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\ng_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif;\n\n_start_commit(struct ubifs_info *c, int *ltail_lnum)\n{\n\tvoid *buf;\n\tstruct ubifs_cs_node *cs;\n\tstruct ubifs_ref_node *ref;\n\tint err, i, max_len, len;\n\n\terr = dbg_check_bud_bytes(c);\n\tif (err)\n\t\treturn err;\n\n\tmax_len = UBIFS_CS_NODE_SZ + c->jhead_cnt * UBIFS_REF_NODE_SZ;\n\tmax_len = ALIGN(max_len, c->min_io_size);\n\tbuf = cs = kmalloc(max_len, GFP_NOFS);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcs->ch.node_type = UBIFS_CS_NODE;\n\tcs->cmt_no = cpu_to_le64(c->cmt_no);\n\tubifs_prepare_node(c, cs, UBIFS_CS_NODE_SZ, 0);\n\n\t/*\n\t * Note, we do not lock 'c->log_mutex' because this is the commit start\n\t * phase and we are exclusively using the log. And we do not lock\n\t * write-buffer because nobody can write to the file-system at this\n\t * phase.\n\t */\n\n\tlen = UBIFS_CS_NODE_SZ;\n\tfor (i = 0; i < c->jhead_cnt; i++) {\n\t\tint lnum = c->jheads[i].wbuf.lnum;\n\t\tint offs = c->jheads[i].wbuf.offs;\n\n\t\tif (lnum == -1 || offs == c->leb_size)\n\t\t\tcontinue;\n\n\t\tdbg_log(\"add ref to LEB %d:%d for jhead %s\",\n\t\t\tlnum, offs, dbg_jhead(i));\n\t\tref = buf + len;\n\t\tref->ch.node_type = UBIFS_REF_NODE;\n\t\tref->lnum = cpu_to_le32(lnum);\n\t\tref->offs = cpu_to_le32(offs);\n\t\tref->jhead = cpu_to_le32(i);\n\n\t\tubifs_prepare_node(c, ref, UBIFS_REF_NODE_SZ, 0);\n\t\tlen += UBIFS_REF_NODE_SZ;\n\t}\n\n\tubifs_pad(c, buf + len, ALIGN(len, c->min_io_size) - len);\n\n\t/* Switch to the next log LEB */\n\tif (c->lhead_offs) {\n\t\tc->lhead_lnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\t\tubifs_assert(c->lhead_lnum != c->ltail_lnum);\n\t\tc->lhead_offs = 0;\n\t}\n\n\t/* Must ensure next LEB has been unmapped */\n\terr = ubifs_leb_unmap(c, c->lhead_lnum);\n\tif (err)\n\t\tgoto out;\n\n\tlen = ALIGN(len, c->min_io_size);\n\tdbg_log(\"writing commit start at LEB %d:0, len %d\", c->lhead_lnum, len);\n\terr = ubifs_leb_write(c, c->lhead_lnum, cs, 0, len);\n\tif (err)\n\t\tgoto out;\n\n\t*ltail_lnum = c->lhead_lnum;\n\n\tc->lhead_offs += len;\n\tif (c->lhead_offs == c->leb_size) {\n\t\tc->lhead_lnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\t\tc->lhead_offs = 0;\n\t}\n\n\tremove_buds(c);\n\n\t/*\n\t * We have started the commit and now users may use the rest of the log\n\t * for new writes.\n\t */\n\tc->min_log_bytes = 0;\n\nout:\n\tkfree(buf);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "truct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "300-344",
    "snippet": "emove_buds(struct ubifs_info *c)\n{\n\tstruct rb_node *p;\n\n\tubifs_assert(list_empty(&c->old_buds));\n\tc->cmt_bud_bytes = 0;\n\tspin_lock(&c->buds_lock);\n\tp = rb_first(&c->buds);\n\twhile (p) {\n\t\tstruct rb_node *p1 = p;\n\t\tstruct ubifs_bud *bud;\n\t\tstruct ubifs_wbuf *wbuf;\n\n\t\tp = rb_next(p);\n\t\tbud = rb_entry(p1, struct ubifs_bud, rb);\n\t\twbuf = &c->jheads[bud->jhead].wbuf;\n\n\t\tif (wbuf->lnum == bud->lnum) {\n\t\t\t/*\n\t\t\t * Do not remove buds which are pointed to by journal\n\t\t\t * heads (non-closed buds).\n\t\t\t */\n\t\t\tc->cmt_bud_bytes += wbuf->offs - bud->start;\n\t\t\tdbg_log(\"preserve %d:%d, jhead %s, bud bytes %d, cmt_bud_bytes %lld\",\n\t\t\t\tbud->lnum, bud->start, dbg_jhead(bud->jhead),\n\t\t\t\twbuf->offs - bud->start, c->cmt_bud_bytes);\n\t\t\tbud->start = wbuf->offs;\n\t\t} else {\n\t\t\tc->cmt_bud_bytes += c->leb_size - bud->start;\n\t\t\tdbg_log(\"remove %d:%d, jhead %s, bud bytes %d, cmt_bud_bytes %lld\",\n\t\t\t\tbud->lnum, bud->start, dbg_jhead(bud->jhead),\n\t\t\t\tc->leb_size - bud->start, c->cmt_bud_bytes);\n\t\t\trb_erase(p1, &c->buds);\n\t\t\t/*\n\t\t\t * If the commit does not finish, the recovery will need\n\t\t\t * to replay the journal, in which case the old buds\n\t\t\t * must be unchanged. Do not release them until post\n\t\t\t * commit i.e. do not allow them to be garbage\n\t\t\t * collected.\n\t\t\t */\n\t\t\tlist_move(&bud->list, &c->old_buds);\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [
      "g_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->buds_loc",
          "args": [
            ");\n}\n\n/**\n *"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->list,",
          "args": [
            "c->old_bud",
            ";\n\t\t}\n\t}\n\tsp"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->buds",
          "args": [
            ";",
            "/*"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ve %d:%",
          "args": [
            ", jhead %s, bud bytes %d, cmt_bud_bytes %lld\",\n\t\t\t\tbud->ln",
            "d->start,",
            "bg_jhead(b",
            "->jhead),\n\t\t\t\tc->leb_",
            "bud->start, c->cmt_bud_",
            "tes);\n\t\t\trb_eras"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->jhead),",
          "args": [
            "c->leb"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "erve %d",
          "args": [
            "%d, jhead %s, bud bytes %d, cmt_bud_bytes %lld\",\n\t\t\t\tbud->ln",
            "d->start,",
            "bg_jhead(b",
            "->jhead),\n\t\t\t\twbuf->o",
            "bud->start, c->cmt_bud_",
            "tes);\n\t\t\tbud->st"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->jhead),",
          "args": [
            "wbuf->"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "struct u",
          "args": [
            "if",
            "bud, r);\n\t\twbuf",
            "&"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "d_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "458-494",
          "snippet": "_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\n_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bud =",
          "args": [
            "b"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buds);",
          "args": [
            "hile (p)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">buds_loc",
          "args": [
            ");\n\tp = rb_fi"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty(&",
          "args": [
            "->old_buds));\n\tc->cmt_bu"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->old_buds",
          "args": [
            ");\n\tc->cmt_b"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\ng_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif;\n\nemove_buds(struct ubifs_info *c)\n{\n\tstruct rb_node *p;\n\n\tubifs_assert(list_empty(&c->old_buds));\n\tc->cmt_bud_bytes = 0;\n\tspin_lock(&c->buds_lock);\n\tp = rb_first(&c->buds);\n\twhile (p) {\n\t\tstruct rb_node *p1 = p;\n\t\tstruct ubifs_bud *bud;\n\t\tstruct ubifs_wbuf *wbuf;\n\n\t\tp = rb_next(p);\n\t\tbud = rb_entry(p1, struct ubifs_bud, rb);\n\t\twbuf = &c->jheads[bud->jhead].wbuf;\n\n\t\tif (wbuf->lnum == bud->lnum) {\n\t\t\t/*\n\t\t\t * Do not remove buds which are pointed to by journal\n\t\t\t * heads (non-closed buds).\n\t\t\t */\n\t\t\tc->cmt_bud_bytes += wbuf->offs - bud->start;\n\t\t\tdbg_log(\"preserve %d:%d, jhead %s, bud bytes %d, cmt_bud_bytes %lld\",\n\t\t\t\tbud->lnum, bud->start, dbg_jhead(bud->jhead),\n\t\t\t\twbuf->offs - bud->start, c->cmt_bud_bytes);\n\t\t\tbud->start = wbuf->offs;\n\t\t} else {\n\t\t\tc->cmt_bud_bytes += c->leb_size - bud->start;\n\t\t\tdbg_log(\"remove %d:%d, jhead %s, bud bytes %d, cmt_bud_bytes %lld\",\n\t\t\t\tbud->lnum, bud->start, dbg_jhead(bud->jhead),\n\t\t\t\tc->leb_size - bud->start, c->cmt_bud_bytes);\n\t\t\trb_erase(p1, &c->buds);\n\t\t\t/*\n\t\t\t * If the commit does not finish, the recovery will need\n\t\t\t * to replay the journal, in which case the old buds\n\t\t\t * must be unchanged. Do not release them until post\n\t\t\t * commit i.e. do not allow them to be garbage\n\t\t\t * collected.\n\t\t\t */\n\t\t\tlist_move(&bud->list, &c->old_buds);\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_to_log(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "176-291",
    "snippet": "_bud_to_log(struct ubifs_info *c, int jhead, int lnum, int offs)\n{\n\tint err;\n\tstruct ubifs_bud *bud;\n\tstruct ubifs_ref_node *ref;\n\n\tbud = kmalloc(sizeof(struct ubifs_bud), GFP_NOFS);\n\tif (!bud)\n\t\treturn -ENOMEM;\n\tref = kzalloc(c->ref_node_alsz, GFP_NOFS);\n\tif (!ref) {\n\t\tkfree(bud);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&c->log_mutex);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Make sure we have enough space in the log */\n\tif (empty_log_bytes(c) - c->ref_node_alsz < c->min_log_bytes) {\n\t\tdbg_log(\"not enough log space - %lld, required %d\",\n\t\t\tempty_log_bytes(c), c->min_log_bytes);\n\t\tubifs_commit_required(c);\n\t\terr = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Make sure the amount of space in buds will not exceed the\n\t * 'c->max_bud_bytes' limit, because we want to guarantee mount time\n\t * limits.\n\t *\n\t * It is not necessary to hold @c->buds_lock when reading @c->bud_bytes\n\t * because we are holding @c->log_mutex. All @c->bud_bytes take place\n\t * when both @c->log_mutex and @c->bud_bytes are locked.\n\t */\n\tif (c->bud_bytes + c->leb_size - offs > c->max_bud_bytes) {\n\t\tdbg_log(\"bud bytes %lld (%lld max), require commit\",\n\t\t\tc->bud_bytes, c->max_bud_bytes);\n\t\tubifs_commit_required(c);\n\t\terr = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If the journal is full enough - start background commit. Note, it is\n\t * OK to read 'c->cmt_state' without spinlock because integer reads\n\t * are atomic in the kernel.\n\t */\n\tif (c->bud_bytes >= c->bg_bud_bytes &&\n\t    c->cmt_state == COMMIT_RESTING) {\n\t\tdbg_log(\"bud bytes %lld (%lld max), initiate BG commit\",\n\t\t\tc->bud_bytes, c->max_bud_bytes);\n\t\tubifs_request_bg_commit(c);\n\t}\n\n\tbud->lnum = lnum;\n\tbud->start = offs;\n\tbud->jhead = jhead;\n\n\tref->ch.node_type = UBIFS_REF_NODE;\n\tref->lnum = cpu_to_le32(bud->lnum);\n\tref->offs = cpu_to_le32(bud->start);\n\tref->jhead = cpu_to_le32(jhead);\n\n\tif (c->lhead_offs > c->leb_size - c->ref_node_alsz) {\n\t\tc->lhead_lnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\t\tubifs_assert(c->lhead_lnum != c->ltail_lnum);\n\t\tc->lhead_offs = 0;\n\t}\n\n\tif (c->lhead_offs == 0) {\n\t\t/* Must ensure next log LEB has been unmapped */\n\t\terr = ubifs_leb_unmap(c, c->lhead_lnum);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (bud->start == 0) {\n\t\t/*\n\t\t * Before writing the LEB reference which refers an empty LEB\n\t\t * to the log, we have to make sure it is mapped, because\n\t\t * otherwise we'd risk to refer an LEB with garbage in case of\n\t\t * an unclean reboot, because the target LEB might have been\n\t\t * unmapped, but not yet physically erased.\n\t\t */\n\t\terr = ubifs_leb_map(c, bud->lnum);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tdbg_log(\"write ref LEB %d:%d\",\n\t\tc->lhead_lnum, c->lhead_offs);\n\terr = ubifs_write_node(c, ref, UBIFS_REF_NODE_SZ, c->lhead_lnum,\n\t\t\t       c->lhead_offs);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tc->lhead_offs += c->ref_node_alsz;\n\n\tubifs_add_bud(c, bud);\n\n\tmutex_unlock(&c->log_mutex);\n\tkfree(ref);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&c->log_mutex);\n\tkfree(ref);\n\tkfree(bud);\n\treturn err;\n}\n\n/**\n * remo",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retur",
          "args": [
            "er"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bud"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->log_mute",
          "args": [
            ");\n\tkfree(ref"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&c->log_mute",
          "args": [
            ");\n\tkfree(ref"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, bud);\n\n\tm",
          "args": [
            "t",
            "_un"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, ref, UBIF",
          "args": [
            "_",
            "F_N",
            "E_SZ, c->lhead_ln",
            ",\n\t\t\t       c",
            ");\n\tif (err)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e ref L",
          "args": [
            "B %d:%d\",\n\t\tc->lhead_",
            ", c->lhead_of",
            ");\n\terr = ubi"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, bud->lnum",
          "args": [
            ";",
            "if (err)"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, c->lhead_",
          "args": [
            "n",
            ");\n\t\tif (err)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->lhead_lnu",
          "args": [
            "!= c->ltail_lnum);\n\t\tc->lhead"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_lnum(c, c->lhead_",
          "args": [
            "n",
            ");\n\t\tubifs_as"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "head);\n\n\tif",
          "args": [
            "(c->l"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ud->start);",
          "args": [
            "ref->jhea"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ud->lnum);",
          "args": [
            "ref->offs"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_bg_commit(c);\n\t}\n\n\tbud",
          "args": [
            ">"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes %",
          "args": [
            "ld (%lld max), initiate BG commit\",\n\t\t\tc->bud_b",
            "c->max_bud_",
            "tes);\n\t\tubifs_re"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "required(c);\n\t\terr =",
          "args": [
            "E"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bytes %",
          "args": [
            "ld (%lld max), require commit\",\n\t\t\tc->bud_b",
            "c->max_bud_",
            "tes);\n\t\tubifs_co"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "required(c);\n\t\terr =",
          "args": [
            "E"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enough",
          "args": [
            "og space - %lld, required %d\",\n\t\t\tempty_lo",
            "es(c), c->min_log_",
            "tes);\n\t\tubifs_co"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(c), c->min_l",
          "args": [
            "g"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "es(c) - c->ref_",
          "args": [
            "o"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_media",
          "args": [
            "&& !c->ro_mount);\n\tif (c->ro"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->log_mute",
          "args": [
            ");\n\tubifs_ass"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_node_",
          "args": [
            "lsz, GFP_NOFS);",
            "f (!ref)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_bud), GFP_NOFS);",
            "f (!bud)"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\n_bud_to_log(struct ubifs_info *c, int jhead, int lnum, int offs)\n{\n\tint err;\n\tstruct ubifs_bud *bud;\n\tstruct ubifs_ref_node *ref;\n\n\tbud = kmalloc(sizeof(struct ubifs_bud), GFP_NOFS);\n\tif (!bud)\n\t\treturn -ENOMEM;\n\tref = kzalloc(c->ref_node_alsz, GFP_NOFS);\n\tif (!ref) {\n\t\tkfree(bud);\n\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&c->log_mutex);\n\tubifs_assert(!c->ro_media && !c->ro_mount);\n\tif (c->ro_error) {\n\t\terr = -EROFS;\n\t\tgoto out_unlock;\n\t}\n\n\t/* Make sure we have enough space in the log */\n\tif (empty_log_bytes(c) - c->ref_node_alsz < c->min_log_bytes) {\n\t\tdbg_log(\"not enough log space - %lld, required %d\",\n\t\t\tempty_log_bytes(c), c->min_log_bytes);\n\t\tubifs_commit_required(c);\n\t\terr = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * Make sure the amount of space in buds will not exceed the\n\t * 'c->max_bud_bytes' limit, because we want to guarantee mount time\n\t * limits.\n\t *\n\t * It is not necessary to hold @c->buds_lock when reading @c->bud_bytes\n\t * because we are holding @c->log_mutex. All @c->bud_bytes take place\n\t * when both @c->log_mutex and @c->bud_bytes are locked.\n\t */\n\tif (c->bud_bytes + c->leb_size - offs > c->max_bud_bytes) {\n\t\tdbg_log(\"bud bytes %lld (%lld max), require commit\",\n\t\t\tc->bud_bytes, c->max_bud_bytes);\n\t\tubifs_commit_required(c);\n\t\terr = -EAGAIN;\n\t\tgoto out_unlock;\n\t}\n\n\t/*\n\t * If the journal is full enough - start background commit. Note, it is\n\t * OK to read 'c->cmt_state' without spinlock because integer reads\n\t * are atomic in the kernel.\n\t */\n\tif (c->bud_bytes >= c->bg_bud_bytes &&\n\t    c->cmt_state == COMMIT_RESTING) {\n\t\tdbg_log(\"bud bytes %lld (%lld max), initiate BG commit\",\n\t\t\tc->bud_bytes, c->max_bud_bytes);\n\t\tubifs_request_bg_commit(c);\n\t}\n\n\tbud->lnum = lnum;\n\tbud->start = offs;\n\tbud->jhead = jhead;\n\n\tref->ch.node_type = UBIFS_REF_NODE;\n\tref->lnum = cpu_to_le32(bud->lnum);\n\tref->offs = cpu_to_le32(bud->start);\n\tref->jhead = cpu_to_le32(jhead);\n\n\tif (c->lhead_offs > c->leb_size - c->ref_node_alsz) {\n\t\tc->lhead_lnum = ubifs_next_log_lnum(c, c->lhead_lnum);\n\t\tubifs_assert(c->lhead_lnum != c->ltail_lnum);\n\t\tc->lhead_offs = 0;\n\t}\n\n\tif (c->lhead_offs == 0) {\n\t\t/* Must ensure next log LEB has been unmapped */\n\t\terr = ubifs_leb_unmap(c, c->lhead_lnum);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (bud->start == 0) {\n\t\t/*\n\t\t * Before writing the LEB reference which refers an empty LEB\n\t\t * to the log, we have to make sure it is mapped, because\n\t\t * otherwise we'd risk to refer an LEB with garbage in case of\n\t\t * an unclean reboot, because the target LEB might have been\n\t\t * unmapped, but not yet physically erased.\n\t\t */\n\t\terr = ubifs_leb_map(c, bud->lnum);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tdbg_log(\"write ref LEB %d:%d\",\n\t\tc->lhead_lnum, c->lhead_offs);\n\terr = ubifs_write_node(c, ref, UBIFS_REF_NODE_SZ, c->lhead_lnum,\n\t\t\t       c->lhead_offs);\n\tif (err)\n\t\tgoto out_unlock;\n\n\tc->lhead_offs += c->ref_node_alsz;\n\n\tubifs_add_bud(c, bud);\n\n\tmutex_unlock(&c->log_mutex);\n\tkfree(ref);\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&c->log_mutex);\n\tkfree(ref);\n\tkfree(bud);\n\treturn err;\n}\n\n/**\n * remo"
  },
  {
    "function_name": "(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "124-161",
    "snippet": "d_bud(struct ubifs_info *c, struct ubifs_bud *bud)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct ubifs_bud *b;\n\tstruct ubifs_jhead *jhead;\n\n\tspin_lock(&c->buds_lock);\n\tp = &c->buds.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tb = rb_entry(parent, struct ubifs_bud, rb);\n\t\tubifs_assert(bud->lnum != b->lnum);\n\t\tif (bud->lnum < b->lnum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&bud->rb, parent, p);\n\trb_insert_color(&bud->rb, &c->buds);\n\tif (c->jheads) {\n\t\tjhead = &c->jheads[bud->jhead];\n\t\tlist_add_tail(&bud->list, &jhead->buds_list);\n\t} else\n\t\tubifs_assert(c->replaying && c->ro_mount);\n\n\t/*\n\t * Note, although this is a new bud, we anyway account this space now,\n\t * before any data has been written to it, because this is about to\n\t * guarantee fixed mount time, and this bud will anyway be read and\n\t * scanned.\n\t */\n\tc->bud_bytes += c->leb_size - bud->start;\n\n\tdbg_log(\"LEB %d:%d, jhead %s, bud_bytes %lld\", bud->lnum,\n\t\tbud->start, dbg_jhead(bud->jhead), c->bud_bytes);\n\tspin_unlock(&c->buds_lock);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [
      "g_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->buds_loc",
          "args": [
            ");\n}\n\n/**\n *"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d:%d,",
          "args": [
            "head %s, bud_bytes %lld\", bud->lnum,",
            "bud->star",
            "bg_jhead(b",
            "->jhead), c->bud_byte",
            ";\n\tspin_unlo"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->jhead),",
          "args": [
            "c->bud_byt"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->replaying",
          "args": [
            "&& c->ro_mount);\n\n\t/*\n\t * N"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&bud->list,",
          "args": [
            "jhead->bud",
            "list);\n\t} else"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "or(&bud->rb, &c",
          "args": [
            ">buds);",
            "f (c->jh"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&bud->rb, pa",
          "args": [
            "ent, p);",
            "rb_ins",
            "t"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bud->lnum !=",
          "args": [
            "b->lnum);\n\t\tif (bud-"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nt, stru",
          "args": [
            "t ubif",
            "bud, r);\n\t\tubif",
            "as"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">buds_loc",
          "args": [
            ");\n\tp = &c->b"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\ng_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif;\n\nd_bud(struct ubifs_info *c, struct ubifs_bud *bud)\n{\n\tstruct rb_node **p, *parent = NULL;\n\tstruct ubifs_bud *b;\n\tstruct ubifs_jhead *jhead;\n\n\tspin_lock(&c->buds_lock);\n\tp = &c->buds.rb_node;\n\twhile (*p) {\n\t\tparent = *p;\n\t\tb = rb_entry(parent, struct ubifs_bud, rb);\n\t\tubifs_assert(bud->lnum != b->lnum);\n\t\tif (bud->lnum < b->lnum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\trb_link_node(&bud->rb, parent, p);\n\trb_insert_color(&bud->rb, &c->buds);\n\tif (c->jheads) {\n\t\tjhead = &c->jheads[bud->jhead];\n\t\tlist_add_tail(&bud->list, &jhead->buds_list);\n\t} else\n\t\tubifs_assert(c->replaying && c->ro_mount);\n\n\t/*\n\t * Note, although this is a new bud, we anyway account this space now,\n\t * before any data has been written to it, because this is about to\n\t * guarantee fixed mount time, and this bud will anyway be read and\n\t * scanned.\n\t */\n\tc->bud_bytes += c->leb_size - bud->start;\n\n\tdbg_log(\"LEB %d:%d, jhead %s, bud_bytes %lld\", bud->lnum,\n\t\tbud->start, dbg_jhead(bud->jhead), c->bud_bytes);\n\tspin_unlock(&c->buds_lock);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "es(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "102-117",
    "snippet": "long long empty_log_bytes(const struct ubifs_info *c)\n{\n\tlong long h, t;\n\n\th = (long long)c->lhead_lnum * c->leb_size + c->lhead_offs;\n\tt = (long long)c->ltail_lnum * c->leb_size;\n\n\tif (h > t)\n\t\treturn c->log_bytes - h + t;\n\telse if (h != t)\n\t\treturn t - h;\n\telse if (c->lhead_lnum != c->ltail_lnum)\n\t\treturn 0;\n\telse\n\t\treturn c->log_bytes;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [
      "g_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif"
    ],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\ng_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif;\n\nlong long empty_log_bytes(const struct ubifs_info *c)\n{\n\tlong long h, t;\n\n\th = (long long)c->lhead_lnum * c->leb_size + c->lhead_offs;\n\tt = (long long)c->ltail_lnum * c->leb_size;\n\n\tif (h > t)\n\t\treturn c->log_bytes - h + t;\n\telse if (h != t)\n\t\treturn t - h;\n\telse if (c->lhead_lnum != c->ltail_lnum)\n\t\treturn 0;\n\telse\n\t\treturn c->log_bytes;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "f(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "71-96",
    "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->buds_loc",
          "args": [
            ");\n\treturn NU"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->buds_loc",
          "args": [
            ");\n\t\t\treturn"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truct ub",
          "args": [
            "f",
            "bud, r);\n\t\tif (",
            "um"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "d_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "458-494",
          "snippet": "_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\n_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": ">buds_loc",
          "args": [
            ");\n\tp = c->bu"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
  },
  {
    "function_name": "bud(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
    "lines": "42-62",
    "snippet": "bud *ubifs_search_bud(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn bud;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\nstatic int d"
    ],
    "macros_used": [],
    "globals_used": [
      "g_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->buds_loc",
          "args": [
            ");\n\treturn NU"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->buds_loc",
          "args": [
            ");\n\t\t\treturn"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truct ub",
          "args": [
            "f",
            "bud, r);\n\t\tif (",
            "um"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "d_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/tnc_misc.c",
          "lines": "458-494",
          "snippet": "_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * ubifs"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * ubifs\n\n_read_node(struct ubifs_info *c, struct ubifs_zbranch *zbr,\n\t\t\tvoid *node)\n{\n\tunion ubifs_key key1, *key = &zbr->key;\n\tint err, type = key_type(c, key);\n\tstruct ubifs_wbuf *wbuf;\n\n\t/*\n\t * 'zbr' has to point to on-flash node. The node may sit in a bud and\n\t * may even be in a write buffer, so we have to take care about this.\n\t */\n\twbuf = ubifs_get_wbuf(c, zbr->lnum);\n\tif (wbuf)\n\t\terr = ubifs_read_node_wbuf(wbuf, node, type, zbr->len,\n\t\t\t\t\t   zbr->lnum, zbr->offs);\n\telse\n\t\terr = ubifs_read_node(c, node, type, zbr->len, zbr->lnum,\n\t\t\t\t      zbr->offs);\n\n\tif (err) {\n\t\tdbg_tnck(key, \"key \");\n\t\treturn err;\n\t}\n\n\t/* Make sure the key of the read node is correct */\n\tkey_read(c, node + UBIFS_KEY_OFFSET, &key1);\n\tif (!keys_eq(c, key, &key1)) {\n\t\tubifs_err(\"bad key in node at LEB %d:%d\",\n\t\t\t  zbr->lnum, zbr->offs);\n\t\tdbg_tnck(key, \"looked for key \");\n\t\tdbg_tnck(&key1, \"but found node's key \");\n\t\tubifs_dump_node(c, node);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": ">buds_loc",
          "args": [
            ");\n\tp = c->bu"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\nstatic int d\n\ng_check_bud_bytes(struct ubifs_info *c);\n\n/**\n * ubif;\n\nbud *ubifs_search_bud(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn bud;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * ubif"
  }
]