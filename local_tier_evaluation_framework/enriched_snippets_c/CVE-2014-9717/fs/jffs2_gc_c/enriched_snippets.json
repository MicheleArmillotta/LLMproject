[
  {
    "function_name": "fs2_garbage_collect_dnode(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "1144-1378",
    "snippet": "atic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *orig_jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end)\n{\n\tstruct jffs2_full_dnode *new_fn;\n\tstruct jffs2_raw_inode ri;\n\tuint32_t alloclen, offset, orig_end, orig_start;\n\tint ret = 0;\n\tunsigned char *comprbuf = NULL, *writebuf;\n\tunsigned long pg;\n\tunsigned char *pg_ptr;\n\n\tmemset(&ri, 0, sizeof(ri));\n\n\tjffs2_dbg(1, \"Writing replacement dnode for ino #%u from offset 0x%x to 0x%x\\n\",\n\t\t  f->inocache->ino, start, end);\n\n\torig_end = end;\n\torig_start = start;\n\n\tif (c->nr_free_blocks + c->nr_erasing_blocks > c->resv_blocks_gcmerge) {\n\t\t/* Attempt to do some merging. But only expand to cover logically\n\t\t   adjacent frags if the block containing them is already considered\n\t\t   to be dirty. Otherwise we end up with GC just going round in\n\t\t   circles dirtying the nodes it already wrote out, especially\n\t\t   on NAND where we have small eraseblocks and hence a much higher\n\t\t   chance of nodes having to be split to cross boundaries. */\n\n\t\tstruct jffs2_node_frag *frag;\n\t\tuint32_t min, max;\n\n\t\tmin = start & ~(PAGE_CACHE_SIZE-1);\n\t\tmax = min + PAGE_CACHE_SIZE;\n\n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, start);\n\n\t\t/* BUG_ON(!frag) but that'll happen anyway... */\n\n\t\tBUG_ON(frag->ofs != start);\n\n\t\t/* First grow down... */\n\t\twhile((frag = frag_prev(frag)) && frag->ofs >= min) {\n\n\t\t\t/* If the previous frag doesn't even reach the beginning, there's\n\t\t\t   excessive fragmentation. Just merge. */\n\t\t\tif (frag->ofs > min) {\n\t\t\t\tjffs2_dbg(1, \"Expanding down to cover partial frag (0x%x-0x%x)\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tstart = frag->ofs;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* OK. This frag holds the first byte of the page. */\n\t\t\tif (!frag->node || !frag->node->raw) {\n\t\t\t\tjffs2_dbg(1, \"First frag in page is hole (0x%x-0x%x). Not expanding down.\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\t/* OK, it's a frag which extends to the beginning of the page. Does it live\n\t\t\t\t   in a block which is still considered clean? If so, don't obsolete it.\n\t\t\t\t   If not, cover it anyway. */\n\n\t\t\t\tstruct jffs2_raw_node_ref *raw = frag->node->raw;\n\t\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\t\tjeb = &c->blocks[raw->flash_offset / c->sector_size];\n\n\t\t\t\tif (jeb == c->gcblock) {\n\t\t\t\t\tjffs2_dbg(1, \"Expanding down to cover frag (0x%x-0x%x) in gcblock at %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  ref_offset(raw));\n\t\t\t\t\tstart = frag->ofs;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ISDIRTY(jeb->dirty_size + jeb->wasted_size)) {\n\t\t\t\t\tjffs2_dbg(1, \"Not expanding down to cover frag (0x%x-0x%x) in clean block %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  jeb->offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"Expanding down to cover frag (0x%x-0x%x) in dirty block %08x\\n\",\n\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tstart = frag->ofs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* ... then up */\n\n\t\t/* Find last frag which is actually part of the node we're to GC. */\n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, end-1);\n\n\t\twhile((frag = frag_next(frag)) && frag->ofs+frag->size <= max) {\n\n\t\t\t/* If the previous frag doesn't even reach the beginning, there's lots\n\t\t\t   of fragmentation. Just merge. */\n\t\t\tif (frag->ofs+frag->size < max) {\n\t\t\t\tjffs2_dbg(1, \"Expanding up to cover partial frag (0x%x-0x%x)\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!frag->node || !frag->node->raw) {\n\t\t\t\tjffs2_dbg(1, \"Last frag in page is hole (0x%x-0x%x). Not expanding up.\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\t/* OK, it's a frag which extends to the beginning of the page. Does it live\n\t\t\t\t   in a block which is still considered clean? If so, don't obsolete it.\n\t\t\t\t   If not, cover it anyway. */\n\n\t\t\t\tstruct jffs2_raw_node_ref *raw = frag->node->raw;\n\t\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\t\tjeb = &c->blocks[raw->flash_offset / c->sector_size];\n\n\t\t\t\tif (jeb == c->gcblock) {\n\t\t\t\t\tjffs2_dbg(1, \"Expanding up to cover frag (0x%x-0x%x) in gcblock at %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  ref_offset(raw));\n\t\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ISDIRTY(jeb->dirty_size + jeb->wasted_size)) {\n\t\t\t\t\tjffs2_dbg(1, \"Not expanding up to cover frag (0x%x-0x%x) in clean block %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  jeb->offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"Expanding up to cover frag (0x%x-0x%x) in dirty block %08x\\n\",\n\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Expanded dnode to write from (0x%x-0x%x) to (0x%x-0x%x)\\n\",\n\t\t\t  orig_start, orig_end, start, end);\n\n\t\tD1(BUG_ON(end > frag_last(&f->fragtree)->ofs + frag_last(&f->fragtree)->size));\n\t\tBUG_ON(end < orig_end);\n\t\tBUG_ON(start > orig_start);\n\t}\n\n\t/* First, use readpage() to read the appropriate page into the page cache */\n\t/* Q: What happens if we actually try to GC the _same_ page for which commit_write()\n\t *    triggered garbage collection in the first place?\n\t * A: I _think_ it's OK. read_cache_page shouldn't deadlock, we'll write out the\n\t *    page OK. We'll actually write it out again in commit_write, which is a little\n\t *    suboptimal, but at least we're correct.\n\t */\n\tpg_ptr = jffs2_gc_fetch_page(c, f, start, &pg);\n\n\tif (IS_ERR(pg_ptr)) {\n\t\tpr_warn(\"read_cache_page() returned error: %ld\\n\",\n\t\t\tPTR_ERR(pg_ptr));\n\t\treturn PTR_ERR(pg_ptr);\n\t}\n\n\toffset = start;\n\twhile(offset < orig_end) {\n\t\tuint32_t datalen;\n\t\tuint32_t cdatalen;\n\t\tuint16_t comprtype = JFFS2_COMPR_NONE;\n\n\t\tret = jffs2_reserve_space_gc(c, sizeof(ri) + JFFS2_MIN_DATA_LEN,\n\t\t\t\t\t&alloclen, JFFS2_SUMMARY_INODE_SIZE);\n\n\t\tif (ret) {\n\t\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_dnode failed: %d\\n\",\n\t\t\t\tsizeof(ri) + JFFS2_MIN_DATA_LEN, ret);\n\t\t\tbreak;\n\t\t}\n\t\tcdatalen = min_t(uint32_t, alloclen - sizeof(ri), end - offset);\n\t\tdatalen = end - offset;\n\n\t\twritebuf = pg_ptr + (offset & (PAGE_CACHE_SIZE -1));\n\n\t\tcomprtype = jffs2_compress(c, f, writebuf, &comprbuf, &datalen, &cdatalen);\n\n\t\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri.totlen = cpu_to_je32(sizeof(ri) + cdatalen);\n\t\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri.ino = cpu_to_je32(f->inocache->ino);\n\t\tri.version = cpu_to_je32(++f->highest_version);\n\t\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\t\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\t\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\t\tri.isize = cpu_to_je32(JFFS2_F_I_SIZE(f));\n\t\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\t\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\t\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\t\tri.offset = cpu_to_je32(offset);\n\t\tri.csize = cpu_to_je32(cdatalen);\n\t\tri.dsize = cpu_to_je32(datalen);\n\t\tri.compr = comprtype & 0xff;\n\t\tri.usercompr = (comprtype >> 8) & 0xff;\n\t\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\t\tri.data_crc = cpu_to_je32(crc32(0, comprbuf, cdatalen));\n\n\t\tnew_fn = jffs2_write_dnode(c, f, &ri, comprbuf, cdatalen, ALLOC_GC);\n\n\t\tjffs2_free_comprbuf(comprbuf, writebuf);\n\n\t\tif (IS_ERR(new_fn)) {\n\t\t\tpr_warn(\"Error writing new dnode: %ld\\n\",\n\t\t\t\tPTR_ERR(new_fn));\n\t\t\tret = PTR_ERR(new_fn);\n\t\t\tbreak;\n\t\t}\n\t\tret = jffs2_add_full_dnode_to_inode(c, f, new_fn);\n\t\toffset += datalen;\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t}\n\n\tjffs2_gc_release_page(c, pg_ptr, &pg);\n\treturn ret;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns",
      "atic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns",
      "atic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_gc_release_page(c",
          "args": [
            "_ptr,",
            "g);"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dnode(f",
          "args": [
            ">metadata);"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            ">metadata->raw);"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_add_full_dnode_to_inode(c",
          "args": [
            "w_fn);"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_fn);"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rror writing new dnode: %ld\\n\",",
            "R_ERR(new_fn));"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_fn))"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(n",
          "args": [
            "w_fn))"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_comprbuf(c",
          "args": [
            "mprbuf,",
            "itebuf);"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_write_dnode(c",
          "args": [
            "i,",
            "mprbuf,",
            "atalen,",
            "LOC_GC);"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, comprbuf, cdatalen));"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "mprbuf,",
            "atalen))"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &ri, sizeof(ri)-8));"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "i,",
            "zeof(ri)-8))"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(d",
          "args": [
            "talen);"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "atalen);"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(o",
          "args": [
            "fset);"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_MTIME(f));"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MTIME(f",
          "args": [
            ")"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_CTIME(f));"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_CTIME(f",
          "args": [
            ")"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_ATIME(f));"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_ATIME(f",
          "args": [
            ")"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_SIZE(f));"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_SIZE(f",
          "args": [
            ")"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_F_I_GID(f));"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_GID(f",
          "args": [
            ")"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_F_I_UID(f));"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_UID(f",
          "args": [
            ")"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_jemode(J",
          "args": [
            "FS2_F_I_MODE(f));"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MODE(f",
          "args": [
            ")"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(+",
          "args": [
            "f->highest_version);"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(f",
          "args": [
            ">inocache->ino);"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &ri, sizeof(struct jffs2_unknown_node)-4));"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "i,",
            "zeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(s",
          "args": [
            "zeof(ri) + cdatalen);"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_NODETYPE_INODE);"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_MAGIC_BITMASK);"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_compress(c",
          "args": [
            "itebuf,",
            "omprbuf,",
            "atalen,",
            "datalen);"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n_t(u",
          "args": [
            "nt32_t,",
            "loclen - sizeof(ri),",
            "d - offset);"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ffs2_reserve_space_gc of %zd bytes for garbage_collect_dnode failed: %d\\n\",",
            "zeof(ri) + JFFS2_MIN_DATA_LEN,",
            "t);"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_reserve_space_gc(c",
          "args": [
            "zeof(ri) + JFFS2_MIN_DATA_LEN,",
            "lloclen,",
            "FS2_SUMMARY_INODE_SIZE);"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(p",
          "args": [
            "_ptr);"
          ],
          "line": 1311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ead_cache_page() returned error: %ld\\n\",",
            "R_ERR(pg_ptr));"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(p",
          "args": [
            "_ptr))"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(p",
          "args": [
            "_ptr))"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_gc_fetch_page(c",
          "args": [
            "art,",
            "g);"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(s",
          "args": [
            "art > orig_start);"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(e",
          "args": [
            "d < orig_end);"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(B",
          "args": [
            "G_ON(end > frag_last(&f->fragtree)->ofs + frag_last(&f->fragtree)->size));"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(e",
          "args": [
            "d > frag_last(&f->fragtree)->ofs + frag_last(&f->fragtree)->size))"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_last(&",
          "args": [
            "->fragtree)-"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_last(&",
          "args": [
            "->fragtree)-"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "xpanded dnode to write from (0x%x-0x%x) to (0x%x-0x%x)\\n\",",
            "ig_start,",
            "ig_end,",
            "art,",
            "d);"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "xpanding up to cover frag (0x%x-0x%x) in dirty block %08x\\n\",",
            "ag->ofs,",
            "ag->ofs + frag->size,",
            "b->offset);"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ot expanding up to cover frag (0x%x-0x%x) in clean block %08x\\n\",",
            "ag->ofs,",
            "ag->ofs + frag->size,",
            "b->offset);"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY(j",
          "args": [
            "b->dirty_size + jeb->wasted_size))"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "xpanding up to cover frag (0x%x-0x%x) in gcblock at %08x\\n\",",
            "ag->ofs,",
            "ag->ofs + frag->size,",
            "f_offset(raw));"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ast frag in page is hole (0x%x-0x%x). Not expanding up.\\n\",",
            "ag->ofs,",
            "ag->ofs+frag->size);"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "xpanding up to cover partial frag (0x%x-0x%x)\\n\",",
            "ag->ofs,",
            "ag->ofs+frag->size);"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_next(f",
          "args": [
            "ag))"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_lookup_node_frag(&",
          "args": [
            "->fragtree,",
            "d-1);"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "xpanding down to cover frag (0x%x-0x%x) in dirty block %08x\\n\",",
            "ag->ofs,",
            "ag->ofs + frag->size,",
            "b->offset);"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ot expanding down to cover frag (0x%x-0x%x) in clean block %08x\\n\",",
            "ag->ofs,",
            "ag->ofs + frag->size,",
            "b->offset);"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIRTY(j",
          "args": [
            "b->dirty_size + jeb->wasted_size))"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "xpanding down to cover frag (0x%x-0x%x) in gcblock at %08x\\n\",",
            "ag->ofs,",
            "ag->ofs + frag->size,",
            "f_offset(raw));"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "irst frag in page is hole (0x%x-0x%x). Not expanding down.\\n\",",
            "ag->ofs,",
            "ag->ofs+frag->size);"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "xpanding down to cover partial frag (0x%x-0x%x)\\n\",",
            "ag->ofs,",
            "ag->ofs+frag->size);"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_prev(f",
          "args": [
            "ag))"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_ON(f",
          "args": [
            "ag->ofs != start);"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_lookup_node_frag(&",
          "args": [
            "->fragtree,",
            "art);"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "riting replacement dnode for ino #%u from offset 0x%x to 0x%x\\n\",",
            ">inocache->ino,",
            "art,",
            "d);"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mset(&",
          "args": [
            "i,",
            "zeof(ri));"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns;\natic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns;\natic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);\n\natic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *orig_jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end)\n{\n\tstruct jffs2_full_dnode *new_fn;\n\tstruct jffs2_raw_inode ri;\n\tuint32_t alloclen, offset, orig_end, orig_start;\n\tint ret = 0;\n\tunsigned char *comprbuf = NULL, *writebuf;\n\tunsigned long pg;\n\tunsigned char *pg_ptr;\n\n\tmemset(&ri, 0, sizeof(ri));\n\n\tjffs2_dbg(1, \"Writing replacement dnode for ino #%u from offset 0x%x to 0x%x\\n\",\n\t\t  f->inocache->ino, start, end);\n\n\torig_end = end;\n\torig_start = start;\n\n\tif (c->nr_free_blocks + c->nr_erasing_blocks > c->resv_blocks_gcmerge) {\n\t\t/* Attempt to do some merging. But only expand to cover logically\n\t\t   adjacent frags if the block containing them is already considered\n\t\t   to be dirty. Otherwise we end up with GC just going round in\n\t\t   circles dirtying the nodes it already wrote out, especially\n\t\t   on NAND where we have small eraseblocks and hence a much higher\n\t\t   chance of nodes having to be split to cross boundaries. */\n\n\t\tstruct jffs2_node_frag *frag;\n\t\tuint32_t min, max;\n\n\t\tmin = start & ~(PAGE_CACHE_SIZE-1);\n\t\tmax = min + PAGE_CACHE_SIZE;\n\n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, start);\n\n\t\t/* BUG_ON(!frag) but that'll happen anyway... */\n\n\t\tBUG_ON(frag->ofs != start);\n\n\t\t/* First grow down... */\n\t\twhile((frag = frag_prev(frag)) && frag->ofs >= min) {\n\n\t\t\t/* If the previous frag doesn't even reach the beginning, there's\n\t\t\t   excessive fragmentation. Just merge. */\n\t\t\tif (frag->ofs > min) {\n\t\t\t\tjffs2_dbg(1, \"Expanding down to cover partial frag (0x%x-0x%x)\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tstart = frag->ofs;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* OK. This frag holds the first byte of the page. */\n\t\t\tif (!frag->node || !frag->node->raw) {\n\t\t\t\tjffs2_dbg(1, \"First frag in page is hole (0x%x-0x%x). Not expanding down.\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\t/* OK, it's a frag which extends to the beginning of the page. Does it live\n\t\t\t\t   in a block which is still considered clean? If so, don't obsolete it.\n\t\t\t\t   If not, cover it anyway. */\n\n\t\t\t\tstruct jffs2_raw_node_ref *raw = frag->node->raw;\n\t\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\t\tjeb = &c->blocks[raw->flash_offset / c->sector_size];\n\n\t\t\t\tif (jeb == c->gcblock) {\n\t\t\t\t\tjffs2_dbg(1, \"Expanding down to cover frag (0x%x-0x%x) in gcblock at %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  ref_offset(raw));\n\t\t\t\t\tstart = frag->ofs;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ISDIRTY(jeb->dirty_size + jeb->wasted_size)) {\n\t\t\t\t\tjffs2_dbg(1, \"Not expanding down to cover frag (0x%x-0x%x) in clean block %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  jeb->offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"Expanding down to cover frag (0x%x-0x%x) in dirty block %08x\\n\",\n\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tstart = frag->ofs;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* ... then up */\n\n\t\t/* Find last frag which is actually part of the node we're to GC. */\n\t\tfrag = jffs2_lookup_node_frag(&f->fragtree, end-1);\n\n\t\twhile((frag = frag_next(frag)) && frag->ofs+frag->size <= max) {\n\n\t\t\t/* If the previous frag doesn't even reach the beginning, there's lots\n\t\t\t   of fragmentation. Just merge. */\n\t\t\tif (frag->ofs+frag->size < max) {\n\t\t\t\tjffs2_dbg(1, \"Expanding up to cover partial frag (0x%x-0x%x)\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!frag->node || !frag->node->raw) {\n\t\t\t\tjffs2_dbg(1, \"Last frag in page is hole (0x%x-0x%x). Not expanding up.\\n\",\n\t\t\t\t\t  frag->ofs, frag->ofs+frag->size);\n\t\t\t\tbreak;\n\t\t\t} else {\n\n\t\t\t\t/* OK, it's a frag which extends to the beginning of the page. Does it live\n\t\t\t\t   in a block which is still considered clean? If so, don't obsolete it.\n\t\t\t\t   If not, cover it anyway. */\n\n\t\t\t\tstruct jffs2_raw_node_ref *raw = frag->node->raw;\n\t\t\t\tstruct jffs2_eraseblock *jeb;\n\n\t\t\t\tjeb = &c->blocks[raw->flash_offset / c->sector_size];\n\n\t\t\t\tif (jeb == c->gcblock) {\n\t\t\t\t\tjffs2_dbg(1, \"Expanding up to cover frag (0x%x-0x%x) in gcblock at %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  ref_offset(raw));\n\t\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!ISDIRTY(jeb->dirty_size + jeb->wasted_size)) {\n\t\t\t\t\tjffs2_dbg(1, \"Not expanding up to cover frag (0x%x-0x%x) in clean block %08x\\n\",\n\t\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t\t  jeb->offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tjffs2_dbg(1, \"Expanding up to cover frag (0x%x-0x%x) in dirty block %08x\\n\",\n\t\t\t\t\t  frag->ofs,\n\t\t\t\t\t  frag->ofs + frag->size,\n\t\t\t\t\t  jeb->offset);\n\t\t\t\tend = frag->ofs + frag->size;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tjffs2_dbg(1, \"Expanded dnode to write from (0x%x-0x%x) to (0x%x-0x%x)\\n\",\n\t\t\t  orig_start, orig_end, start, end);\n\n\t\tD1(BUG_ON(end > frag_last(&f->fragtree)->ofs + frag_last(&f->fragtree)->size));\n\t\tBUG_ON(end < orig_end);\n\t\tBUG_ON(start > orig_start);\n\t}\n\n\t/* First, use readpage() to read the appropriate page into the page cache */\n\t/* Q: What happens if we actually try to GC the _same_ page for which commit_write()\n\t *    triggered garbage collection in the first place?\n\t * A: I _think_ it's OK. read_cache_page shouldn't deadlock, we'll write out the\n\t *    page OK. We'll actually write it out again in commit_write, which is a little\n\t *    suboptimal, but at least we're correct.\n\t */\n\tpg_ptr = jffs2_gc_fetch_page(c, f, start, &pg);\n\n\tif (IS_ERR(pg_ptr)) {\n\t\tpr_warn(\"read_cache_page() returned error: %ld\\n\",\n\t\t\tPTR_ERR(pg_ptr));\n\t\treturn PTR_ERR(pg_ptr);\n\t}\n\n\toffset = start;\n\twhile(offset < orig_end) {\n\t\tuint32_t datalen;\n\t\tuint32_t cdatalen;\n\t\tuint16_t comprtype = JFFS2_COMPR_NONE;\n\n\t\tret = jffs2_reserve_space_gc(c, sizeof(ri) + JFFS2_MIN_DATA_LEN,\n\t\t\t\t\t&alloclen, JFFS2_SUMMARY_INODE_SIZE);\n\n\t\tif (ret) {\n\t\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_dnode failed: %d\\n\",\n\t\t\t\tsizeof(ri) + JFFS2_MIN_DATA_LEN, ret);\n\t\t\tbreak;\n\t\t}\n\t\tcdatalen = min_t(uint32_t, alloclen - sizeof(ri), end - offset);\n\t\tdatalen = end - offset;\n\n\t\twritebuf = pg_ptr + (offset & (PAGE_CACHE_SIZE -1));\n\n\t\tcomprtype = jffs2_compress(c, f, writebuf, &comprbuf, &datalen, &cdatalen);\n\n\t\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri.totlen = cpu_to_je32(sizeof(ri) + cdatalen);\n\t\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri.ino = cpu_to_je32(f->inocache->ino);\n\t\tri.version = cpu_to_je32(++f->highest_version);\n\t\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\t\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\t\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\t\tri.isize = cpu_to_je32(JFFS2_F_I_SIZE(f));\n\t\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\t\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\t\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\t\tri.offset = cpu_to_je32(offset);\n\t\tri.csize = cpu_to_je32(cdatalen);\n\t\tri.dsize = cpu_to_je32(datalen);\n\t\tri.compr = comprtype & 0xff;\n\t\tri.usercompr = (comprtype >> 8) & 0xff;\n\t\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\t\tri.data_crc = cpu_to_je32(crc32(0, comprbuf, cdatalen));\n\n\t\tnew_fn = jffs2_write_dnode(c, f, &ri, comprbuf, cdatalen, ALLOC_GC);\n\n\t\tjffs2_free_comprbuf(comprbuf, writebuf);\n\n\t\tif (IS_ERR(new_fn)) {\n\t\t\tpr_warn(\"Error writing new dnode: %ld\\n\",\n\t\t\t\tPTR_ERR(new_fn));\n\t\t\tret = PTR_ERR(new_fn);\n\t\t\tbreak;\n\t\t}\n\t\tret = jffs2_add_full_dnode_to_inode(c, f, new_fn);\n\t\toffset += datalen;\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t}\n\n\tjffs2_gc_release_page(c, pg_ptr, &pg);\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_garbage_collect_hole(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "993-1142",
    "snippet": "atic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end)\n{\n\tstruct jffs2_raw_inode ri;\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dnode *new_fn;\n\tuint32_t alloclen, ilen;\n\tint ret;\n\n\tjffs2_dbg(1, \"Writing replacement hole node for ino #%u from offset 0x%x to 0x%x\\n\",\n\t\t  f->inocache->ino, start, end);\n\n\tmemset(&ri, 0, sizeof(ri));\n\n\tif(fn->frags > 1) {\n\t\tsize_t readlen;\n\t\tuint32_t crc;\n\t\t/* It's partially obsoleted by a later write. So we have to\n\t\t   write it out again with the _same_ version as before */\n\t\tret = jffs2_flash_read(c, ref_offset(fn->raw), sizeof(ri), &readlen, (char *)&ri);\n\t\tif (readlen != sizeof(ri) || ret) {\n\t\t\tpr_warn(\"Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %zd. Data will be lost by writing new hole node\\n\",\n\t\t\t\tret, readlen);\n\t\t\tgoto fill;\n\t\t}\n\t\tif (je16_to_cpu(ri.nodetype) != JFFS2_NODETYPE_INODE) {\n\t\t\tpr_warn(\"%s(): Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje16_to_cpu(ri.nodetype), JFFS2_NODETYPE_INODE);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (je32_to_cpu(ri.totlen) != sizeof(ri)) {\n\t\t\tpr_warn(\"%s(): Node at 0x%08x had totlen 0x%x instead of expected 0x%zx\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje32_to_cpu(ri.totlen), sizeof(ri));\n\t\t\treturn -EIO;\n\t\t}\n\t\tcrc = crc32(0, &ri, sizeof(ri)-8);\n\t\tif (crc != je32_to_cpu(ri.node_crc)) {\n\t\t\tpr_warn(\"%s: Node at 0x%08x had CRC 0x%08x which doesn't match calculated CRC 0x%08x\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje32_to_cpu(ri.node_crc), crc);\n\t\t\t/* FIXME: We could possibly deal with this by writing new holes for each frag */\n\t\t\tpr_warn(\"Data in the range 0x%08x to 0x%08x of inode #%u will be lost\\n\",\n\t\t\t\tstart, end, f->inocache->ino);\n\t\t\tgoto fill;\n\t\t}\n\t\tif (ri.compr != JFFS2_COMPR_ZERO) {\n\t\t\tpr_warn(\"%s(): Node 0x%08x wasn't a hole node!\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw));\n\t\t\tpr_warn(\"Data in the range 0x%08x to 0x%08x of inode #%u will be lost\\n\",\n\t\t\t\tstart, end, f->inocache->ino);\n\t\t\tgoto fill;\n\t\t}\n\t} else {\n\tfill:\n\t\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri.totlen = cpu_to_je32(sizeof(ri));\n\t\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri.ino = cpu_to_je32(f->inocache->ino);\n\t\tri.version = cpu_to_je32(++f->highest_version);\n\t\tri.offset = cpu_to_je32(start);\n\t\tri.dsize = cpu_to_je32(end - start);\n\t\tri.csize = cpu_to_je32(0);\n\t\tri.compr = JFFS2_COMPR_ZERO;\n\t}\n\n\tfrag = frag_last(&f->fragtree);\n\tif (frag)\n\t\t/* Fetch the inode length from the fragtree rather then\n\t\t * from i_size since i_size may have not been updated yet */\n\t\tilen = frag->ofs + frag->size;\n\telse\n\t\tilen = JFFS2_F_I_SIZE(f);\n\n\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\tri.isize = cpu_to_je32(ilen);\n\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\tri.data_crc = cpu_to_je32(0);\n\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\n\tret = jffs2_reserve_space_gc(c, sizeof(ri), &alloclen,\n\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_hole failed: %d\\n\",\n\t\t\tsizeof(ri), ret);\n\t\treturn ret;\n\t}\n\tnew_fn = jffs2_write_dnode(c, f, &ri, NULL, 0, ALLOC_GC);\n\n\tif (IS_ERR(new_fn)) {\n\t\tpr_warn(\"Error writing new hole node: %ld\\n\", PTR_ERR(new_fn));\n\t\treturn PTR_ERR(new_fn);\n\t}\n\tif (je32_to_cpu(ri.version) == f->highest_version) {\n\t\tjffs2_add_full_dnode_to_inode(c, f, new_fn);\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We should only get here in the case where the node we are\n\t * replacing had more than one frag, so we kept the same version\n\t * number as before. (Except in case of error -- see 'goto fill;'\n\t * above.)\n\t */\n\tD1(if(unlikely(fn->frags <= 1)) {\n\t\t\tpr_warn(\"%s(): Replacing fn with %d frag(s) but new ver %d != highest_version %d of ino #%d\\n\",\n\t\t\t\t__func__, fn->frags, je32_to_cpu(ri.version),\n\t\t\t\tf->highest_version, je32_to_cpu(ri.ino));\n\t});\n\n\t/* This is a partially-overlapped hole node. Mark it REF_NORMAL not REF_PRISTINE */\n\tmark_ref_normal(new_fn->raw);\n\n\tfor (frag = jffs2_lookup_node_frag(&f->fragtree, fn->ofs);\n\t     frag; frag = frag_next(frag)) {\n\t\tif (frag->ofs > fn->size + fn->ofs)\n\t\t\tbreak;\n\t\tif (frag->node == fn) {\n\t\t\tfrag->node = new_fn;\n\t\t\tnew_fn->frags++;\n\t\t\tfn->frags--;\n\t\t}\n\t}\n\tif (fn->frags) {\n\t\tpr_warn(\"%s(): Old node still has frags!\\n\", __func__);\n\t\tBUG();\n\t}\n\tif (!new_fn->frags) {\n\t\tpr_warn(\"%s(): New node has no frags!\\n\", __func__);\n\t\tBUG();\n\t}\n\n\tjffs2_mark_node_obsolete(c, fn->raw);\n\tjffs2_free_full_dnode(fn);\n\n\treturn 0;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns",
      "atic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns",
      "atic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_free_full_dnode(f",
          "args": [
            ");"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            "->raw);"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): New node has no frags!\\n\",",
            "func__);"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Old node still has frags!\\n\",",
            "func__);"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_next(f",
          "args": [
            "ag))"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_lookup_node_frag(&",
          "args": [
            "->fragtree,",
            "->ofs);"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rk_ref_normal(n",
          "args": [
            "w_fn->raw);"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(i",
          "args": [
            "(unlikely(fn->frags <= 1)) {\t\t\tpr_warn(\"%s(): Replacing fn with %d frag(s) but new ver %d != highest_version %d of ino #%d\\n\",\n\t\t\t\t__func__, fn->frags, je32_to_cpu(ri.version),\n\t\t\t\tf->highest_version, je32_to_cpu(ri.ino));\n\t});"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "fs_sysctl(i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/sysctl.h",
          "lines": "35-38",
          "snippet": "atic inline int ntfs_sysctl(int add)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "atic inline int ntfs_sysctl(int add)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Replacing fn with %d frag(s) but new ver %d != highest_version %d of ino #%d\\n\",",
            "func__,",
            "->frags,",
            "32_to_cpu(ri.version),",
            ">highest_version,",
            "32_to_cpu(ri.ino));"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            ".ino))"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            ".version),"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(u",
          "args": [
            "likely(fn->frags <= 1))"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "lculate_inocache_hashsize(u",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/fs.c",
          "lines": "493-511",
          "snippet": "atic int calculate_inocache_hashsize(uint32_t flash_size)\n{\n\t/*\n\t * Pick a inocache hash size based on the size of the medium.\n\t * Count how many megabytes we're dealing with, apply a hashsize twice\n\t * that size, but rounding down to the usual big powers of 2. And keep\n\t * to sensible bounds.\n\t */\n\n\tint size_mb = flash_size / 1024 / 1024;\n\tint hashsize = (size_mb * 2) & ~0x3f;\n\n\tif (hashsize < INOCACHE_HASHSIZE_MIN)\n\t\treturn INOCACHE_HASHSIZE_MIN;\n\tif (hashsize > INOCACHE_HASHSIZE_MAX)\n\t\treturn INOCACHE_HASHSIZE_MAX;\n\n\treturn hashsize;\n}",
          "includes": [
            "nclude \"nodelist.h\"\n\ns",
            "nclude <linux/crc32.h>\n#i",
            "nclude <linux/vfs.h>\n#i",
            "nclude <linux/vmalloc.h>\n#i",
            "nclude <linux/slab.h>\n#i",
            "nclude <linux/pagemap.h>\n#i",
            "nclude <linux/mtd/mtd.h>\n#i",
            "nclude <linux/list.h>\n#i",
            "nclude <linux/fs.h>\n#i",
            "nclude <linux/sched.h>\n#i",
            "nclude <linux/kernel.h>\n#i",
            "nclude <linux/capability.h>\n#i"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "nclude \"nodelist.h\"\n\ns\nnclude <linux/crc32.h>\n#i\nnclude <linux/vfs.h>\n#i\nnclude <linux/vmalloc.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/list.h>\n#i\nnclude <linux/fs.h>\n#i\nnclude <linux/sched.h>\n#i\nnclude <linux/kernel.h>\n#i\nnclude <linux/capability.h>\n#i\n\natic int calculate_inocache_hashsize(uint32_t flash_size)\n{\n\t/*\n\t * Pick a inocache hash size based on the size of the medium.\n\t * Count how many megabytes we're dealing with, apply a hashsize twice\n\t * that size, but rounding down to the usual big powers of 2. And keep\n\t * to sensible bounds.\n\t */\n\n\tint size_mb = flash_size / 1024 / 1024;\n\tint hashsize = (size_mb * 2) & ~0x3f;\n\n\tif (hashsize < INOCACHE_HASHSIZE_MIN)\n\t\treturn INOCACHE_HASHSIZE_MIN;\n\tif (hashsize > INOCACHE_HASHSIZE_MAX)\n\t\treturn INOCACHE_HASHSIZE_MAX;\n\n\treturn hashsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely(f",
          "args": [
            "->frags <= 1))"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dnode(f",
          "args": [
            ">metadata);"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            ">metadata->raw);"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_add_full_dnode_to_inode(c",
          "args": [
            "w_fn);"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            ".version)"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_fn);"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rror writing new hole node: %ld\\n\",",
            "R_ERR(new_fn));"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_fn))"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(n",
          "args": [
            "w_fn))"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_write_dnode(c",
          "args": [
            "i,",
            "LL,",
            "LOC_GC);"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ffs2_reserve_space_gc of %zd bytes for garbage_collect_hole failed: %d\\n\",",
            "zeof(ri),",
            "t);"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_reserve_space_gc(c",
          "args": [
            "zeof(ri),",
            "lloclen,",
            "FS2_SUMMARY_INODE_SIZE);"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &ri, sizeof(ri)-8));"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "i,",
            "zeof(ri)-8))"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(0",
          "args": [
            ";"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_MTIME(f));"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MTIME(f",
          "args": [
            ")"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_CTIME(f));"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_CTIME(f",
          "args": [
            ")"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_ATIME(f));"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_ATIME(f",
          "args": [
            ")"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(i",
          "args": [
            "en);"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_F_I_GID(f));"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_GID(f",
          "args": [
            ")"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_F_I_UID(f));"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_UID(f",
          "args": [
            ")"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_jemode(J",
          "args": [
            "FS2_F_I_MODE(f));"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MODE(f",
          "args": [
            ")"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_SIZE(f",
          "args": [
            ";"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_last(&",
          "args": [
            "->fragtree);"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(0",
          "args": [
            ";"
          ],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(e",
          "args": [
            "d - start);"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(s",
          "args": [
            "art);"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(+",
          "args": [
            "f->highest_version);"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(f",
          "args": [
            ">inocache->ino);"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &ri, sizeof(struct jffs2_unknown_node)-4));"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "i,",
            "zeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(s",
          "args": [
            "zeof(ri));"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_NODETYPE_INODE);"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_MAGIC_BITMASK);"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ata in the range 0x%08x to 0x%08x of inode #%u will be lost\\n\",",
            "art,",
            "d,",
            ">inocache->ino);"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Node 0x%08x wasn't a hole node!\\n\",",
            "func__,",
            "f_offset(fn->raw));"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(f",
          "args": [
            "->raw))"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ata in the range 0x%08x to 0x%08x of inode #%u will be lost\\n\",",
            "art,",
            "d,",
            ">inocache->ino);"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s: Node at 0x%08x had CRC 0x%08x which doesn't match calculated CRC 0x%08x\\n\",",
            "func__,",
            "f_offset(fn->raw),",
            "32_to_cpu(ri.node_crc),",
            "c);"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            ".node_crc),"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(f",
          "args": [
            "->raw),"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            ".node_crc))"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "i,",
            "zeof(ri)-8);"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Node at 0x%08x had totlen 0x%x instead of expected 0x%zx\\n\",",
            "func__,",
            "f_offset(fn->raw),",
            "32_to_cpu(ri.totlen),",
            "zeof(ri));"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            ".totlen),"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(f",
          "args": [
            "->raw),"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            ".totlen)"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)\\n\",",
            "func__,",
            "f_offset(fn->raw),",
            "16_to_cpu(ri.nodetype),",
            "FS2_NODETYPE_INODE);"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(r",
          "args": [
            ".nodetype),"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(f",
          "args": [
            "->raw),"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(r",
          "args": [
            ".nodetype)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ode read failed in jffs2_garbage_collect_hole. Ret %d, retlen %zd. Data will be lost by writing new hole node\\n\",",
            "t,",
            "adlen);"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_read(c",
          "args": [
            "f_offset(fn->raw),",
            "zeof(ri),",
            "eadlen,",
            "har *)&ri);"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(f",
          "args": [
            "->raw),"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mset(&",
          "args": [
            "i,",
            "zeof(ri));"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "riting replacement hole node for ino #%u from offset 0x%x to 0x%x\\n\",",
            ">inocache->ino,",
            "art,",
            "d);"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns;\natic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns;\natic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);\n\natic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end)\n{\n\tstruct jffs2_raw_inode ri;\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dnode *new_fn;\n\tuint32_t alloclen, ilen;\n\tint ret;\n\n\tjffs2_dbg(1, \"Writing replacement hole node for ino #%u from offset 0x%x to 0x%x\\n\",\n\t\t  f->inocache->ino, start, end);\n\n\tmemset(&ri, 0, sizeof(ri));\n\n\tif(fn->frags > 1) {\n\t\tsize_t readlen;\n\t\tuint32_t crc;\n\t\t/* It's partially obsoleted by a later write. So we have to\n\t\t   write it out again with the _same_ version as before */\n\t\tret = jffs2_flash_read(c, ref_offset(fn->raw), sizeof(ri), &readlen, (char *)&ri);\n\t\tif (readlen != sizeof(ri) || ret) {\n\t\t\tpr_warn(\"Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %zd. Data will be lost by writing new hole node\\n\",\n\t\t\t\tret, readlen);\n\t\t\tgoto fill;\n\t\t}\n\t\tif (je16_to_cpu(ri.nodetype) != JFFS2_NODETYPE_INODE) {\n\t\t\tpr_warn(\"%s(): Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje16_to_cpu(ri.nodetype), JFFS2_NODETYPE_INODE);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (je32_to_cpu(ri.totlen) != sizeof(ri)) {\n\t\t\tpr_warn(\"%s(): Node at 0x%08x had totlen 0x%x instead of expected 0x%zx\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje32_to_cpu(ri.totlen), sizeof(ri));\n\t\t\treturn -EIO;\n\t\t}\n\t\tcrc = crc32(0, &ri, sizeof(ri)-8);\n\t\tif (crc != je32_to_cpu(ri.node_crc)) {\n\t\t\tpr_warn(\"%s: Node at 0x%08x had CRC 0x%08x which doesn't match calculated CRC 0x%08x\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw),\n\t\t\t\tje32_to_cpu(ri.node_crc), crc);\n\t\t\t/* FIXME: We could possibly deal with this by writing new holes for each frag */\n\t\t\tpr_warn(\"Data in the range 0x%08x to 0x%08x of inode #%u will be lost\\n\",\n\t\t\t\tstart, end, f->inocache->ino);\n\t\t\tgoto fill;\n\t\t}\n\t\tif (ri.compr != JFFS2_COMPR_ZERO) {\n\t\t\tpr_warn(\"%s(): Node 0x%08x wasn't a hole node!\\n\",\n\t\t\t\t__func__, ref_offset(fn->raw));\n\t\t\tpr_warn(\"Data in the range 0x%08x to 0x%08x of inode #%u will be lost\\n\",\n\t\t\t\tstart, end, f->inocache->ino);\n\t\t\tgoto fill;\n\t\t}\n\t} else {\n\tfill:\n\t\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\t\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\t\tri.totlen = cpu_to_je32(sizeof(ri));\n\t\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\t\tri.ino = cpu_to_je32(f->inocache->ino);\n\t\tri.version = cpu_to_je32(++f->highest_version);\n\t\tri.offset = cpu_to_je32(start);\n\t\tri.dsize = cpu_to_je32(end - start);\n\t\tri.csize = cpu_to_je32(0);\n\t\tri.compr = JFFS2_COMPR_ZERO;\n\t}\n\n\tfrag = frag_last(&f->fragtree);\n\tif (frag)\n\t\t/* Fetch the inode length from the fragtree rather then\n\t\t * from i_size since i_size may have not been updated yet */\n\t\tilen = frag->ofs + frag->size;\n\telse\n\t\tilen = JFFS2_F_I_SIZE(f);\n\n\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\tri.isize = cpu_to_je32(ilen);\n\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\tri.data_crc = cpu_to_je32(0);\n\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\n\tret = jffs2_reserve_space_gc(c, sizeof(ri), &alloclen,\n\t\t\t\t     JFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_hole failed: %d\\n\",\n\t\t\tsizeof(ri), ret);\n\t\treturn ret;\n\t}\n\tnew_fn = jffs2_write_dnode(c, f, &ri, NULL, 0, ALLOC_GC);\n\n\tif (IS_ERR(new_fn)) {\n\t\tpr_warn(\"Error writing new hole node: %ld\\n\", PTR_ERR(new_fn));\n\t\treturn PTR_ERR(new_fn);\n\t}\n\tif (je32_to_cpu(ri.version) == f->highest_version) {\n\t\tjffs2_add_full_dnode_to_inode(c, f, new_fn);\n\t\tif (f->metadata) {\n\t\t\tjffs2_mark_node_obsolete(c, f->metadata->raw);\n\t\t\tjffs2_free_full_dnode(f->metadata);\n\t\t\tf->metadata = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * We should only get here in the case where the node we are\n\t * replacing had more than one frag, so we kept the same version\n\t * number as before. (Except in case of error -- see 'goto fill;'\n\t * above.)\n\t */\n\tD1(if(unlikely(fn->frags <= 1)) {\n\t\t\tpr_warn(\"%s(): Replacing fn with %d frag(s) but new ver %d != highest_version %d of ino #%d\\n\",\n\t\t\t\t__func__, fn->frags, je32_to_cpu(ri.version),\n\t\t\t\tf->highest_version, je32_to_cpu(ri.ino));\n\t});\n\n\t/* This is a partially-overlapped hole node. Mark it REF_NORMAL not REF_PRISTINE */\n\tmark_ref_normal(new_fn->raw);\n\n\tfor (frag = jffs2_lookup_node_frag(&f->fragtree, fn->ofs);\n\t     frag; frag = frag_next(frag)) {\n\t\tif (frag->ofs > fn->size + fn->ofs)\n\t\t\tbreak;\n\t\tif (frag->node == fn) {\n\t\t\tfrag->node = new_fn;\n\t\t\tnew_fn->frags++;\n\t\t\tfn->frags--;\n\t\t}\n\t}\n\tif (fn->frags) {\n\t\tpr_warn(\"%s(): Old node still has frags!\\n\", __func__);\n\t\tBUG();\n\t}\n\tif (!new_fn->frags) {\n\t\tpr_warn(\"%s(): New node has no frags!\\n\", __func__);\n\t\tBUG();\n\t}\n\n\tjffs2_mark_node_obsolete(c, fn->raw);\n\tjffs2_free_full_dnode(fn);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_garbage_collect_deletion_dirent(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "875-991",
    "snippet": "atic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent **fdp = &f->dents;\n\tint found = 0;\n\n\t/* On a medium where we can't actually mark nodes obsolete\n\t   pernamently, such as NAND flash, we need to work out\n\t   whether this deletion dirent is still needed to actively\n\t   delete a 'real' dirent with the same name that's still\n\t   somewhere else on the flash. */\n\tif (!jffs2_can_mark_obsolete(c)) {\n\t\tstruct jffs2_raw_dirent *rd;\n\t\tstruct jffs2_raw_node_ref *raw;\n\t\tint ret;\n\t\tsize_t retlen;\n\t\tint name_len = strlen(fd->name);\n\t\tuint32_t name_crc = crc32(0, fd->name, name_len);\n\t\tuint32_t rawlen = ref_totlen(c, jeb, fd->raw);\n\n\t\trd = kmalloc(rawlen, GFP_KERNEL);\n\t\tif (!rd)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Prevent the erase code from nicking the obsolete node refs while\n\t\t   we're looking at them. I really don't like this extra lock but\n\t\t   can't see any alternative. Suggestions on a postcard to... */\n\t\tmutex_lock(&c->erase_free_sem);\n\n\t\tfor (raw = f->inocache->nodes; raw != (void *)f->inocache; raw = raw->next_in_ino) {\n\n\t\t\tcond_resched();\n\n\t\t\t/* We only care about obsolete ones */\n\t\t\tif (!(ref_obsolete(raw)))\n\t\t\t\tcontinue;\n\n\t\t\t/* Any dirent with the same name is going to have the same length... */\n\t\t\tif (ref_totlen(c, NULL, raw) != rawlen)\n\t\t\t\tcontinue;\n\n\t\t\t/* Doesn't matter if there's one in the same erase block. We're going to\n\t\t\t   delete it too at the same time. */\n\t\t\tif (SECTOR_ADDR(raw->flash_offset) == SECTOR_ADDR(fd->raw->flash_offset))\n\t\t\t\tcontinue;\n\n\t\t\tjffs2_dbg(1, \"Check potential deletion dirent at %08x\\n\",\n\t\t\t\t  ref_offset(raw));\n\n\t\t\t/* This is an obsolete node belonging to the same directory, and it's of the right\n\t\t\t   length. We need to take a closer look...*/\n\t\t\tret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)rd);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s(): Read error (%d) reading obsolete node at %08x\\n\",\n\t\t\t\t\t__func__, ret, ref_offset(raw));\n\t\t\t\t/* If we can't read it, we don't need to continue to obsolete it. Continue */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (retlen != rawlen) {\n\t\t\t\tpr_warn(\"%s(): Short read (%zd not %u) reading header from obsolete node at %08x\\n\",\n\t\t\t\t\t__func__, retlen, rawlen,\n\t\t\t\t\tref_offset(raw));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (je16_to_cpu(rd->nodetype) != JFFS2_NODETYPE_DIRENT)\n\t\t\t\tcontinue;\n\n\t\t\t/* If the name CRC doesn't match, skip */\n\t\t\tif (je32_to_cpu(rd->name_crc) != name_crc)\n\t\t\t\tcontinue;\n\n\t\t\t/* If the name length doesn't match, or it's another deletion dirent, skip */\n\t\t\tif (rd->nsize != name_len || !je32_to_cpu(rd->ino))\n\t\t\t\tcontinue;\n\n\t\t\t/* OK, check the actual name now */\n\t\t\tif (memcmp(rd->name, fd->name, name_len))\n\t\t\t\tcontinue;\n\n\t\t\t/* OK. The name really does match. There really is still an older node on\n\t\t\t   the flash which our deletion dirent obsoletes. So we have to write out\n\t\t\t   a new deletion dirent to replace it */\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\n\t\t\tjffs2_dbg(1, \"Deletion dirent at %08x still obsoletes real dirent \\\"%s\\\" at %08x for ino #%u\\n\",\n\t\t\t\t  ref_offset(fd->raw), fd->name,\n\t\t\t\t  ref_offset(raw), je32_to_cpu(rd->ino));\n\t\t\tkfree(rd);\n\n\t\t\treturn jffs2_garbage_collect_dirent(c, jeb, f, fd);\n\t\t}\n\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\tkfree(rd);\n\t}\n\n\t/* FIXME: If we're deleting a dirent which contains the current mtime and ctime,\n\t   we should update the metadata node with those times accordingly */\n\n\t/* No need for it any more. Just mark it obsolete and remove it from the list */\n\twhile (*fdp) {\n\t\tif ((*fdp) == fd) {\n\t\t\tfound = 1;\n\t\t\t*fdp = fd->next;\n\t\t\tbreak;\n\t\t}\n\t\tfdp = &(*fdp)->next;\n\t}\n\tif (!found) {\n\t\tpr_warn(\"Deletion dirent \\\"%s\\\" not found in list for ino #%u\\n\",\n\t\t\tfd->name, f->inocache->ino);\n\t}\n\tjffs2_mark_node_obsolete(c, fd->raw);\n\tjffs2_free_full_dirent(fd);\n\treturn 0;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns",
      "atic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns",
      "atic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_free_full_dirent(f",
          "args": [
            ");"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            "->raw);"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "eletion dirent \\\"%s\\\" not found in list for ino #%u\\n\",",
            "->name,",
            ">inocache->ino);"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(r",
          "args": [
            ");"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_dirent(c",
          "args": [
            "b,",
            ");"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(r",
          "args": [
            ");"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "eletion dirent at %08x still obsoletes real dirent \\\"%s\\\" at %08x for ino #%u\\n\",",
            "f_offset(fd->raw),",
            "->name,",
            "f_offset(raw),",
            "32_to_cpu(rd->ino));"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            "->ino))"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(f",
          "args": [
            "->raw),"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mcmp(r",
          "args": [
            "->name,",
            "->name,",
            "me_len))"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            "->ino))"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(r",
          "args": [
            "->name_crc)"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(r",
          "args": [
            "->nodetype)"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Short read (%zd not %u) reading header from obsolete node at %08x\\n\",",
            "func__,",
            "tlen,",
            "wlen,",
            "f_offset(raw));"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "s(): Read error (%d) reading obsolete node at %08x\\n\",",
            "func__,",
            "t,",
            "f_offset(raw));"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_read(c",
          "args": [
            "f_offset(raw),",
            "wlen,",
            "etlen,",
            "har *)rd);"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "heck potential deletion dirent at %08x\\n\",",
            "f_offset(raw));"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTOR_ADDR(f",
          "args": [
            "->raw->flash_offset))"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CTOR_ADDR(r",
          "args": [
            "w->flash_offset)"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_totlen(c",
          "args": [
            "LL,",
            "w)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(r",
          "args": [
            "w))"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_resched()",
          "args": [],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->erase_free_sem);"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(r",
          "args": [
            "wlen,",
            "P_KERNEL);"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_totlen(c",
          "args": [
            "b,",
            "->raw);"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "->name,",
            "me_len);"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlen(f",
          "args": [
            "->name);"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_can_mark_obsolete(c",
          "args": [
            ")"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns;\natic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns;\natic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);\n\natic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent **fdp = &f->dents;\n\tint found = 0;\n\n\t/* On a medium where we can't actually mark nodes obsolete\n\t   pernamently, such as NAND flash, we need to work out\n\t   whether this deletion dirent is still needed to actively\n\t   delete a 'real' dirent with the same name that's still\n\t   somewhere else on the flash. */\n\tif (!jffs2_can_mark_obsolete(c)) {\n\t\tstruct jffs2_raw_dirent *rd;\n\t\tstruct jffs2_raw_node_ref *raw;\n\t\tint ret;\n\t\tsize_t retlen;\n\t\tint name_len = strlen(fd->name);\n\t\tuint32_t name_crc = crc32(0, fd->name, name_len);\n\t\tuint32_t rawlen = ref_totlen(c, jeb, fd->raw);\n\n\t\trd = kmalloc(rawlen, GFP_KERNEL);\n\t\tif (!rd)\n\t\t\treturn -ENOMEM;\n\n\t\t/* Prevent the erase code from nicking the obsolete node refs while\n\t\t   we're looking at them. I really don't like this extra lock but\n\t\t   can't see any alternative. Suggestions on a postcard to... */\n\t\tmutex_lock(&c->erase_free_sem);\n\n\t\tfor (raw = f->inocache->nodes; raw != (void *)f->inocache; raw = raw->next_in_ino) {\n\n\t\t\tcond_resched();\n\n\t\t\t/* We only care about obsolete ones */\n\t\t\tif (!(ref_obsolete(raw)))\n\t\t\t\tcontinue;\n\n\t\t\t/* Any dirent with the same name is going to have the same length... */\n\t\t\tif (ref_totlen(c, NULL, raw) != rawlen)\n\t\t\t\tcontinue;\n\n\t\t\t/* Doesn't matter if there's one in the same erase block. We're going to\n\t\t\t   delete it too at the same time. */\n\t\t\tif (SECTOR_ADDR(raw->flash_offset) == SECTOR_ADDR(fd->raw->flash_offset))\n\t\t\t\tcontinue;\n\n\t\t\tjffs2_dbg(1, \"Check potential deletion dirent at %08x\\n\",\n\t\t\t\t  ref_offset(raw));\n\n\t\t\t/* This is an obsolete node belonging to the same directory, and it's of the right\n\t\t\t   length. We need to take a closer look...*/\n\t\t\tret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)rd);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"%s(): Read error (%d) reading obsolete node at %08x\\n\",\n\t\t\t\t\t__func__, ret, ref_offset(raw));\n\t\t\t\t/* If we can't read it, we don't need to continue to obsolete it. Continue */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (retlen != rawlen) {\n\t\t\t\tpr_warn(\"%s(): Short read (%zd not %u) reading header from obsolete node at %08x\\n\",\n\t\t\t\t\t__func__, retlen, rawlen,\n\t\t\t\t\tref_offset(raw));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (je16_to_cpu(rd->nodetype) != JFFS2_NODETYPE_DIRENT)\n\t\t\t\tcontinue;\n\n\t\t\t/* If the name CRC doesn't match, skip */\n\t\t\tif (je32_to_cpu(rd->name_crc) != name_crc)\n\t\t\t\tcontinue;\n\n\t\t\t/* If the name length doesn't match, or it's another deletion dirent, skip */\n\t\t\tif (rd->nsize != name_len || !je32_to_cpu(rd->ino))\n\t\t\t\tcontinue;\n\n\t\t\t/* OK, check the actual name now */\n\t\t\tif (memcmp(rd->name, fd->name, name_len))\n\t\t\t\tcontinue;\n\n\t\t\t/* OK. The name really does match. There really is still an older node on\n\t\t\t   the flash which our deletion dirent obsoletes. So we have to write out\n\t\t\t   a new deletion dirent to replace it */\n\t\t\tmutex_unlock(&c->erase_free_sem);\n\n\t\t\tjffs2_dbg(1, \"Deletion dirent at %08x still obsoletes real dirent \\\"%s\\\" at %08x for ino #%u\\n\",\n\t\t\t\t  ref_offset(fd->raw), fd->name,\n\t\t\t\t  ref_offset(raw), je32_to_cpu(rd->ino));\n\t\t\tkfree(rd);\n\n\t\t\treturn jffs2_garbage_collect_dirent(c, jeb, f, fd);\n\t\t}\n\n\t\tmutex_unlock(&c->erase_free_sem);\n\t\tkfree(rd);\n\t}\n\n\t/* FIXME: If we're deleting a dirent which contains the current mtime and ctime,\n\t   we should update the metadata node with those times accordingly */\n\n\t/* No need for it any more. Just mark it obsolete and remove it from the list */\n\twhile (*fdp) {\n\t\tif ((*fdp) == fd) {\n\t\t\tfound = 1;\n\t\t\t*fdp = fd->next;\n\t\t\tbreak;\n\t\t}\n\t\tfdp = &(*fdp)->next;\n\t}\n\tif (!found) {\n\t\tpr_warn(\"Deletion dirent \\\"%s\\\" not found in list for ino #%u\\n\",\n\t\t\tfd->name, f->inocache->ino);\n\t}\n\tjffs2_mark_node_obsolete(c, fd->raw);\n\tjffs2_free_full_dirent(fd);\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_garbage_collect_dirent(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "830-873",
    "snippet": "atic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent *new_fd;\n\tstruct jffs2_raw_dirent rd;\n\tuint32_t alloclen;\n\tint ret;\n\n\trd.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd.nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd.nsize = strlen(fd->name);\n\trd.totlen = cpu_to_je32(sizeof(rd) + rd.nsize);\n\trd.hdr_crc = cpu_to_je32(crc32(0, &rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd.pino = cpu_to_je32(f->inocache->ino);\n\trd.version = cpu_to_je32(++f->highest_version);\n\trd.ino = cpu_to_je32(fd->ino);\n\t/* If the times on this inode were set by explicit utime() they can be different,\n\t   so refrain from splatting them. */\n\tif (JFFS2_F_I_MTIME(f) == JFFS2_F_I_CTIME(f))\n\t\trd.mctime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\telse\n\t\trd.mctime = cpu_to_je32(0);\n\trd.type = fd->type;\n\trd.node_crc = cpu_to_je32(crc32(0, &rd, sizeof(rd)-8));\n\trd.name_crc = cpu_to_je32(crc32(0, fd->name, rd.nsize));\n\n\tret = jffs2_reserve_space_gc(c, sizeof(rd)+rd.nsize, &alloclen,\n\t\t\t\tJFFS2_SUMMARY_DIRENT_SIZE(rd.nsize));\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_dirent failed: %d\\n\",\n\t\t\tsizeof(rd)+rd.nsize, ret);\n\t\treturn ret;\n\t}\n\tnew_fd = jffs2_write_dirent(c, f, &rd, fd->name, rd.nsize, ALLOC_GC);\n\n\tif (IS_ERR(new_fd)) {\n\t\tpr_warn(\"jffs2_write_dirent in garbage_collect_dirent failed: %ld\\n\",\n\t\t\tPTR_ERR(new_fd));\n\t\treturn PTR_ERR(new_fd);\n\t}\n\tjffs2_add_fd_to_list(c, new_fd, &f->dents);\n\treturn 0;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_add_fd_to_list(c",
          "args": [
            "w_fd,",
            "->dents);"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_fd);"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ffs2_write_dirent in garbage_collect_dirent failed: %ld\\n\",",
            "R_ERR(new_fd));"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_fd))"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(n",
          "args": [
            "w_fd))"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_write_dirent(c",
          "args": [
            "d,",
            "->name,",
            ".nsize,",
            "LOC_GC);"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ffs2_reserve_space_gc of %zd bytes for garbage_collect_dirent failed: %d\\n\",",
            "zeof(rd)+rd.nsize,",
            "t);"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_reserve_space_gc(c",
          "args": [
            "zeof(rd)+rd.nsize,",
            "lloclen,",
            "FS2_SUMMARY_DIRENT_SIZE(rd.nsize));"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_SUMMARY_DIRENT_SIZE(r",
          "args": [
            ".nsize))"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, fd->name, rd.nsize));"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "->name,",
            ".nsize))"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &rd, sizeof(rd)-8));"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "d,",
            "zeof(rd)-8))"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(0",
          "args": [
            ";"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_MTIME(f));"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MTIME(f",
          "args": [
            ")"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_CTIME(f",
          "args": [
            ")"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MTIME(f",
          "args": [],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(f",
          "args": [
            "->ino);"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(+",
          "args": [
            "f->highest_version);"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(f",
          "args": [
            ">inocache->ino);"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &rd, sizeof(struct jffs2_unknown_node)-4));"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "d,",
            "zeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(s",
          "args": [
            "zeof(rd) + rd.nsize);"
          ],
          "line": 841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlen(f",
          "args": [
            "->name);"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_NODETYPE_DIRENT);"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_MAGIC_BITMASK);"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);\n\natic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd)\n{\n\tstruct jffs2_full_dirent *new_fd;\n\tstruct jffs2_raw_dirent rd;\n\tuint32_t alloclen;\n\tint ret;\n\n\trd.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\trd.nodetype = cpu_to_je16(JFFS2_NODETYPE_DIRENT);\n\trd.nsize = strlen(fd->name);\n\trd.totlen = cpu_to_je32(sizeof(rd) + rd.nsize);\n\trd.hdr_crc = cpu_to_je32(crc32(0, &rd, sizeof(struct jffs2_unknown_node)-4));\n\n\trd.pino = cpu_to_je32(f->inocache->ino);\n\trd.version = cpu_to_je32(++f->highest_version);\n\trd.ino = cpu_to_je32(fd->ino);\n\t/* If the times on this inode were set by explicit utime() they can be different,\n\t   so refrain from splatting them. */\n\tif (JFFS2_F_I_MTIME(f) == JFFS2_F_I_CTIME(f))\n\t\trd.mctime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\telse\n\t\trd.mctime = cpu_to_je32(0);\n\trd.type = fd->type;\n\trd.node_crc = cpu_to_je32(crc32(0, &rd, sizeof(rd)-8));\n\trd.name_crc = cpu_to_je32(crc32(0, fd->name, rd.nsize));\n\n\tret = jffs2_reserve_space_gc(c, sizeof(rd)+rd.nsize, &alloclen,\n\t\t\t\tJFFS2_SUMMARY_DIRENT_SIZE(rd.nsize));\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_dirent failed: %d\\n\",\n\t\t\tsizeof(rd)+rd.nsize, ret);\n\t\treturn ret;\n\t}\n\tnew_fd = jffs2_write_dirent(c, f, &rd, fd->name, rd.nsize, ALLOC_GC);\n\n\tif (IS_ERR(new_fd)) {\n\t\tpr_warn(\"jffs2_write_dirent in garbage_collect_dirent failed: %ld\\n\",\n\t\t\tPTR_ERR(new_fd));\n\t\treturn PTR_ERR(new_fd);\n\t}\n\tjffs2_add_fd_to_list(c, new_fd, &f->dents);\n\treturn 0;\n}"
  },
  {
    "function_name": "fs2_garbage_collect_metadata(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "738-828",
    "snippet": "atic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\n{\n\tstruct jffs2_full_dnode *new_fn;\n\tstruct jffs2_raw_inode ri;\n\tstruct jffs2_node_frag *last_frag;\n\tunion jffs2_device_node dev;\n\tchar *mdata = NULL;\n\tint mdatalen = 0;\n\tuint32_t alloclen, ilen;\n\tint ret;\n\n\tif (S_ISBLK(JFFS2_F_I_MODE(f)) ||\n\t    S_ISCHR(JFFS2_F_I_MODE(f)) ) {\n\t\t/* For these, we don't actually need to read the old node */\n\t\tmdatalen = jffs2_encode_dev(&dev, JFFS2_F_I_RDEV(f));\n\t\tmdata = (char *)&dev;\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of kdev_t\\n\",\n\t\t\t  __func__, mdatalen);\n\t} else if (S_ISLNK(JFFS2_F_I_MODE(f))) {\n\t\tmdatalen = fn->size;\n\t\tmdata = kmalloc(fn->size, GFP_KERNEL);\n\t\tif (!mdata) {\n\t\t\tpr_warn(\"kmalloc of mdata failed in jffs2_garbage_collect_metadata()\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = jffs2_read_dnode(c, f, fn, mdata, 0, mdatalen);\n\t\tif (ret) {\n\t\t\tpr_warn(\"read of old metadata failed in jffs2_garbage_collect_metadata(): %d\\n\",\n\t\t\t\tret);\n\t\t\tkfree(mdata);\n\t\t\treturn ret;\n\t\t}\n\t\tjffs2_dbg(1, \"%s(): Writing %d bites of symlink target\\n\",\n\t\t\t  __func__, mdatalen);\n\n\t}\n\n\tret = jffs2_reserve_space_gc(c, sizeof(ri) + mdatalen, &alloclen,\n\t\t\t\tJFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_metadata failed: %d\\n\",\n\t\t\tsizeof(ri) + mdatalen, ret);\n\t\tgoto out;\n\t}\n\n\tlast_frag = frag_last(&f->fragtree);\n\tif (last_frag)\n\t\t/* Fetch the inode length from the fragtree rather then\n\t\t * from i_size since i_size may have not been updated yet */\n\t\tilen = last_frag->ofs + last_frag->size;\n\telse\n\t\tilen = JFFS2_F_I_SIZE(f);\n\n\tmemset(&ri, 0, sizeof(ri));\n\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\tri.totlen = cpu_to_je32(sizeof(ri) + mdatalen);\n\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\tri.ino = cpu_to_je32(f->inocache->ino);\n\tri.version = cpu_to_je32(++f->highest_version);\n\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\tri.isize = cpu_to_je32(ilen);\n\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\tri.offset = cpu_to_je32(0);\n\tri.csize = cpu_to_je32(mdatalen);\n\tri.dsize = cpu_to_je32(mdatalen);\n\tri.compr = JFFS2_COMPR_NONE;\n\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\tri.data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));\n\n\tnew_fn = jffs2_write_dnode(c, f, &ri, mdata, mdatalen, ALLOC_GC);\n\n\tif (IS_ERR(new_fn)) {\n\t\tpr_warn(\"Error writing new dnode: %ld\\n\", PTR_ERR(new_fn));\n\t\tret = PTR_ERR(new_fn);\n\t\tgoto out;\n\t}\n\tjffs2_mark_node_obsolete(c, fn->raw);\n\tjffs2_free_full_dnode(fn);\n\tf->metadata = new_fn;\n out:\n\tif (S_ISLNK(JFFS2_F_I_MODE(f)))\n\t\tkfree(mdata);\n\treturn ret;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns",
      "atic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns",
      "atic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(m",
          "args": [
            "ata);"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISLNK(J",
          "args": [
            "FS2_F_I_MODE(f)))"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MODE(f",
          "args": [
            ")"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_free_full_dnode(f",
          "args": [
            ");"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            "->raw);"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_fn);"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rror writing new dnode: %ld\\n\",",
            "R_ERR(new_fn));"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(n",
          "args": [
            "w_fn))"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(n",
          "args": [
            "w_fn))"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_write_dnode(c",
          "args": [
            "i,",
            "ata,",
            "atalen,",
            "LOC_GC);"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, mdata, mdatalen));"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "ata,",
            "atalen))"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &ri, sizeof(ri)-8));"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "i,",
            "zeof(ri)-8))"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(m",
          "args": [
            "atalen);"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(m",
          "args": [
            "atalen);"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(0",
          "args": [
            ";"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_MTIME(f));"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MTIME(f",
          "args": [
            ")"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_CTIME(f));"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_CTIME(f",
          "args": [
            ")"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(J",
          "args": [
            "FS2_F_I_ATIME(f));"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_ATIME(f",
          "args": [
            ")"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(i",
          "args": [
            "en);"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_F_I_GID(f));"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_GID(f",
          "args": [
            ")"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_F_I_UID(f));"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_UID(f",
          "args": [
            ")"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_jemode(J",
          "args": [
            "FS2_F_I_MODE(f));"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MODE(f",
          "args": [
            ")"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(+",
          "args": [
            "f->highest_version);"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(f",
          "args": [
            ">inocache->ino);"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(c",
          "args": [
            "c32(0, &ri, sizeof(struct jffs2_unknown_node)-4));"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "i,",
            "zeof(struct jffs2_unknown_node)-4))"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je32(s",
          "args": [
            "zeof(ri) + mdatalen);"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_NODETYPE_INODE);"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u_to_je16(J",
          "args": [
            "FS2_MAGIC_BITMASK);"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mset(&",
          "args": [
            "i,",
            "zeof(ri));"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_SIZE(f",
          "args": [
            ";"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_last(&",
          "args": [
            "->fragtree);"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ffs2_reserve_space_gc of %zd bytes for garbage_collect_metadata failed: %d\\n\",",
            "zeof(ri) + mdatalen,",
            "t);"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_reserve_space_gc(c",
          "args": [
            "zeof(ri) + mdatalen,",
            "lloclen,",
            "FS2_SUMMARY_INODE_SIZE);"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): Writing %d bites of symlink target\\n\",",
            "func__,",
            "atalen);"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ree(m",
          "args": [
            "ata);"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ead of old metadata failed in jffs2_garbage_collect_metadata(): %d\\n\",",
            "t);"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_read_dnode(c",
          "args": [
            ",",
            "ata,",
            "atalen);"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "malloc of mdata failed in jffs2_garbage_collect_metadata()\\n\");"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(f",
          "args": [
            "->size,",
            "P_KERNEL);"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISLNK(J",
          "args": [
            "FS2_F_I_MODE(f)))"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MODE(f",
          "args": [
            ")"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): Writing %d bytes of kdev_t\\n\",",
            "func__,",
            "atalen);"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_encode_dev(&",
          "args": [
            "ev,",
            "FS2_F_I_RDEV(f));"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_RDEV(f",
          "args": [
            ")"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISCHR(J",
          "args": [
            "FS2_F_I_MODE(f))"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MODE(f",
          "args": [
            ")"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISBLK(J",
          "args": [
            "FS2_F_I_MODE(f))"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FS2_F_I_MODE(f",
          "args": [
            ")"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns;\natic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns;\natic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);\n\natic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\n{\n\tstruct jffs2_full_dnode *new_fn;\n\tstruct jffs2_raw_inode ri;\n\tstruct jffs2_node_frag *last_frag;\n\tunion jffs2_device_node dev;\n\tchar *mdata = NULL;\n\tint mdatalen = 0;\n\tuint32_t alloclen, ilen;\n\tint ret;\n\n\tif (S_ISBLK(JFFS2_F_I_MODE(f)) ||\n\t    S_ISCHR(JFFS2_F_I_MODE(f)) ) {\n\t\t/* For these, we don't actually need to read the old node */\n\t\tmdatalen = jffs2_encode_dev(&dev, JFFS2_F_I_RDEV(f));\n\t\tmdata = (char *)&dev;\n\t\tjffs2_dbg(1, \"%s(): Writing %d bytes of kdev_t\\n\",\n\t\t\t  __func__, mdatalen);\n\t} else if (S_ISLNK(JFFS2_F_I_MODE(f))) {\n\t\tmdatalen = fn->size;\n\t\tmdata = kmalloc(fn->size, GFP_KERNEL);\n\t\tif (!mdata) {\n\t\t\tpr_warn(\"kmalloc of mdata failed in jffs2_garbage_collect_metadata()\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = jffs2_read_dnode(c, f, fn, mdata, 0, mdatalen);\n\t\tif (ret) {\n\t\t\tpr_warn(\"read of old metadata failed in jffs2_garbage_collect_metadata(): %d\\n\",\n\t\t\t\tret);\n\t\t\tkfree(mdata);\n\t\t\treturn ret;\n\t\t}\n\t\tjffs2_dbg(1, \"%s(): Writing %d bites of symlink target\\n\",\n\t\t\t  __func__, mdatalen);\n\n\t}\n\n\tret = jffs2_reserve_space_gc(c, sizeof(ri) + mdatalen, &alloclen,\n\t\t\t\tJFFS2_SUMMARY_INODE_SIZE);\n\tif (ret) {\n\t\tpr_warn(\"jffs2_reserve_space_gc of %zd bytes for garbage_collect_metadata failed: %d\\n\",\n\t\t\tsizeof(ri) + mdatalen, ret);\n\t\tgoto out;\n\t}\n\n\tlast_frag = frag_last(&f->fragtree);\n\tif (last_frag)\n\t\t/* Fetch the inode length from the fragtree rather then\n\t\t * from i_size since i_size may have not been updated yet */\n\t\tilen = last_frag->ofs + last_frag->size;\n\telse\n\t\tilen = JFFS2_F_I_SIZE(f);\n\n\tmemset(&ri, 0, sizeof(ri));\n\tri.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK);\n\tri.nodetype = cpu_to_je16(JFFS2_NODETYPE_INODE);\n\tri.totlen = cpu_to_je32(sizeof(ri) + mdatalen);\n\tri.hdr_crc = cpu_to_je32(crc32(0, &ri, sizeof(struct jffs2_unknown_node)-4));\n\n\tri.ino = cpu_to_je32(f->inocache->ino);\n\tri.version = cpu_to_je32(++f->highest_version);\n\tri.mode = cpu_to_jemode(JFFS2_F_I_MODE(f));\n\tri.uid = cpu_to_je16(JFFS2_F_I_UID(f));\n\tri.gid = cpu_to_je16(JFFS2_F_I_GID(f));\n\tri.isize = cpu_to_je32(ilen);\n\tri.atime = cpu_to_je32(JFFS2_F_I_ATIME(f));\n\tri.ctime = cpu_to_je32(JFFS2_F_I_CTIME(f));\n\tri.mtime = cpu_to_je32(JFFS2_F_I_MTIME(f));\n\tri.offset = cpu_to_je32(0);\n\tri.csize = cpu_to_je32(mdatalen);\n\tri.dsize = cpu_to_je32(mdatalen);\n\tri.compr = JFFS2_COMPR_NONE;\n\tri.node_crc = cpu_to_je32(crc32(0, &ri, sizeof(ri)-8));\n\tri.data_crc = cpu_to_je32(crc32(0, mdata, mdatalen));\n\n\tnew_fn = jffs2_write_dnode(c, f, &ri, mdata, mdatalen, ALLOC_GC);\n\n\tif (IS_ERR(new_fn)) {\n\t\tpr_warn(\"Error writing new dnode: %ld\\n\", PTR_ERR(new_fn));\n\t\tret = PTR_ERR(new_fn);\n\t\tgoto out;\n\t}\n\tjffs2_mark_node_obsolete(c, fn->raw);\n\tjffs2_free_full_dnode(fn);\n\tf->metadata = new_fn;\n out:\n\tif (S_ISLNK(JFFS2_F_I_MODE(f)))\n\t\tkfree(mdata);\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_garbage_collect_pristine(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "571-736",
    "snippet": "atic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw)\n{\n\tunion jffs2_node_union *node;\n\tsize_t retlen;\n\tint ret;\n\tuint32_t phys_ofs, alloclen;\n\tuint32_t crc, rawlen;\n\tint retried = 0;\n\n\tjffs2_dbg(1, \"Going to GC REF_PRISTINE node at 0x%08x\\n\",\n\t\t  ref_offset(raw));\n\n\talloclen = rawlen = ref_totlen(c, c->gcblock, raw);\n\n\t/* Ask for a small amount of space (or the totlen if smaller) because we\n\t   don't want to force wastage of the end of a block if splitting would\n\t   work. */\n\tif (ic && alloclen > sizeof(struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN)\n\t\talloclen = sizeof(struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN;\n\n\tret = jffs2_reserve_space_gc(c, alloclen, &alloclen, rawlen);\n\t/* 'rawlen' is not the exact summary size; it is only an upper estimation */\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (alloclen < rawlen) {\n\t\t/* Doesn't fit untouched. We'll go the old route and split it */\n\t\treturn -EBADFD;\n\t}\n\n\tnode = kmalloc(rawlen, GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)node);\n\tif (!ret && retlen != rawlen)\n\t\tret = -EIO;\n\tif (ret)\n\t\tgoto out_node;\n\n\tcrc = crc32(0, node, sizeof(struct jffs2_unknown_node)-4);\n\tif (je32_to_cpu(node->u.hdr_crc) != crc) {\n\t\tpr_warn(\"Header CRC failed on REF_PRISTINE node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\tref_offset(raw), je32_to_cpu(node->u.hdr_crc), crc);\n\t\tgoto bail;\n\t}\n\n\tswitch(je16_to_cpu(node->u.nodetype)) {\n\tcase JFFS2_NODETYPE_INODE:\n\t\tcrc = crc32(0, node, sizeof(node->i)-8);\n\t\tif (je32_to_cpu(node->i.node_crc) != crc) {\n\t\t\tpr_warn(\"Node CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\tref_offset(raw), je32_to_cpu(node->i.node_crc),\n\t\t\t\tcrc);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (je32_to_cpu(node->i.dsize)) {\n\t\t\tcrc = crc32(0, node->i.data, je32_to_cpu(node->i.csize));\n\t\t\tif (je32_to_cpu(node->i.data_crc) != crc) {\n\t\t\t\tpr_warn(\"Data CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\t\tref_offset(raw),\n\t\t\t\t\tje32_to_cpu(node->i.data_crc), crc);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\t\tcrc = crc32(0, node, sizeof(node->d)-8);\n\t\tif (je32_to_cpu(node->d.node_crc) != crc) {\n\t\t\tpr_warn(\"Node CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\tref_offset(raw),\n\t\t\t\tje32_to_cpu(node->d.node_crc), crc);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (strnlen(node->d.name, node->d.nsize) != node->d.nsize) {\n\t\t\tpr_warn(\"Name in dirent node at 0x%08x contains zeroes\\n\",\n\t\t\t\tref_offset(raw));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (node->d.nsize) {\n\t\t\tcrc = crc32(0, node->d.name, node->d.nsize);\n\t\t\tif (je32_to_cpu(node->d.name_crc) != crc) {\n\t\t\t\tpr_warn(\"Name CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\t\tref_offset(raw),\n\t\t\t\t\tje32_to_cpu(node->d.name_crc), crc);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* If it's inode-less, we don't _know_ what it is. Just copy it intact */\n\t\tif (ic) {\n\t\t\tpr_warn(\"Unknown node type for REF_PRISTINE node at 0x%08x: 0x%04x\\n\",\n\t\t\t\tref_offset(raw), je16_to_cpu(node->u.nodetype));\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* OK, all the CRCs are good; this node can just be copied as-is. */\n retry:\n\tphys_ofs = write_ofs(c);\n\n\tret = jffs2_flash_write(c, phys_ofs, rawlen, &retlen, (char *)node);\n\n\tif (ret || (retlen != rawlen)) {\n\t\tpr_notice(\"Write of %d bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  rawlen, phys_ofs, ret, retlen);\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, rawlen, NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  phys_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[phys_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write of REF_PRISTINE node.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tret = jffs2_reserve_space_gc(c, rawlen, &dummy, rawlen);\n\t\t\t\t\t\t/* this is not the exact summary size of it,\n\t\t\t\t\t\t\tit is only an upper estimation */\n\n\t\t\tif (!ret) {\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  phys_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto out_node;\n\t}\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, rawlen, ic);\n\n\tjffs2_mark_node_obsolete(c, raw);\n\tjffs2_dbg(1, \"WHEEE! GC REF_PRISTINE node at 0x%08x succeeded\\n\",\n\t\t  ref_offset(raw));\n\n out_node:\n\tkfree(node);\n\treturn ret;\n bail:\n\tret = -EBADFD;\n\tgoto out_node;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns",
      "atic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns",
      "atic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ree(n",
          "args": [
            "de);"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "HEEE! GC REF_PRISTINE node at 0x%08x succeeded\\n\",",
            "f_offset(raw));"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            "w);"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_add_physical_node_ref(c",
          "args": [
            "ys_ofs | REF_PRISTINE,",
            "wlen,",
            ");"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ailed to allocate space to retry failed write: %d!\\n\",",
            "t);"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_paranoia_check(c",
          "args": [
            "b);"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_sanity_check(c",
          "args": [
            "j",
            "b);"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "llocated space at 0x%08x to retry failed write.\\n\",",
            "ys_ofs);"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_reserve_space_gc(c",
          "args": [
            "wlen,",
            "ummy,",
            "wlen);"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_paranoia_check(c",
          "args": [
            "b);"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_acct_sanity_check(c",
          "args": [
            "j",
            "b);"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "etrying failed write of REF_PRISTINE node.\\n\");"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "ot marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",",
            "ys_ofs);"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_add_physical_node_ref(c",
          "args": [
            "ys_ofs | REF_OBSOLETE,",
            "wlen,",
            "LL);"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_notice(\"",
          "args": [
            "rite of %d bytes at 0x%08x failed. returned %d, retlen %zd\\n\",",
            "wlen,",
            "ys_ofs,",
            "t,",
            "tlen);"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_write(c",
          "args": [
            "ys_ofs,",
            "wlen,",
            "etlen,",
            "har *)node);"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ite_ofs(c",
          "args": [
            ";"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "nknown node type for REF_PRISTINE node at 0x%08x: 0x%04x\\n\",",
            "f_offset(raw),",
            "16_to_cpu(node->u.nodetype));"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(n",
          "args": [
            "de->u.nodetype))"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ame CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",",
            "f_offset(raw),",
            "32_to_cpu(node->d.name_crc),",
            "c);"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->d.name_crc),"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->d.name_crc)"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "de->d.name,",
            "de->d.nsize);"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ame in dirent node at 0x%08x contains zeroes\\n\",",
            "f_offset(raw));"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rnlen(n",
          "args": [
            "de->d.name,",
            "de->d.nsize)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ode CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",",
            "f_offset(raw),",
            "32_to_cpu(node->d.node_crc),",
            "c);"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->d.node_crc),"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->d.node_crc)"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "de,",
            "zeof(node->d)-8);"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ata CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",",
            "f_offset(raw),",
            "32_to_cpu(node->i.data_crc),",
            "c);"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->i.data_crc),"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->i.data_crc)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "de->i.data,",
            "32_to_cpu(node->i.csize));"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->i.csize))"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->i.dsize))"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ode CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",",
            "f_offset(raw),",
            "32_to_cpu(node->i.node_crc),",
            "c);"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->i.node_crc),"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->i.node_crc)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "de,",
            "zeof(node->i)-8);"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "16_to_cpu(n",
          "args": [
            "de->u.nodetype))"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "eader CRC failed on REF_PRISTINE node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",",
            "f_offset(raw),",
            "32_to_cpu(node->u.hdr_crc),",
            "c);"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->u.hdr_crc),"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "32_to_cpu(n",
          "args": [
            "de->u.hdr_crc)"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c32(0",
          "args": [
            "de,",
            "zeof(struct jffs2_unknown_node)-4);"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flash_read(c",
          "args": [
            "f_offset(raw),",
            "wlen,",
            "etlen,",
            "har *)node);"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc(r",
          "args": [
            "wlen,",
            "P_KERNEL);"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_reserve_space_gc(c",
          "args": [
            "loclen,",
            "lloclen,",
            "wlen);"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_totlen(c",
          "args": [
            ">gcblock,",
            "w);"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "oing to GC REF_PRISTINE node at 0x%08x\\n\",",
            "f_offset(raw));"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns;\natic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns;\natic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns;\n\natic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw)\n{\n\tunion jffs2_node_union *node;\n\tsize_t retlen;\n\tint ret;\n\tuint32_t phys_ofs, alloclen;\n\tuint32_t crc, rawlen;\n\tint retried = 0;\n\n\tjffs2_dbg(1, \"Going to GC REF_PRISTINE node at 0x%08x\\n\",\n\t\t  ref_offset(raw));\n\n\talloclen = rawlen = ref_totlen(c, c->gcblock, raw);\n\n\t/* Ask for a small amount of space (or the totlen if smaller) because we\n\t   don't want to force wastage of the end of a block if splitting would\n\t   work. */\n\tif (ic && alloclen > sizeof(struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN)\n\t\talloclen = sizeof(struct jffs2_raw_inode) + JFFS2_MIN_DATA_LEN;\n\n\tret = jffs2_reserve_space_gc(c, alloclen, &alloclen, rawlen);\n\t/* 'rawlen' is not the exact summary size; it is only an upper estimation */\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (alloclen < rawlen) {\n\t\t/* Doesn't fit untouched. We'll go the old route and split it */\n\t\treturn -EBADFD;\n\t}\n\n\tnode = kmalloc(rawlen, GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tret = jffs2_flash_read(c, ref_offset(raw), rawlen, &retlen, (char *)node);\n\tif (!ret && retlen != rawlen)\n\t\tret = -EIO;\n\tif (ret)\n\t\tgoto out_node;\n\n\tcrc = crc32(0, node, sizeof(struct jffs2_unknown_node)-4);\n\tif (je32_to_cpu(node->u.hdr_crc) != crc) {\n\t\tpr_warn(\"Header CRC failed on REF_PRISTINE node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\tref_offset(raw), je32_to_cpu(node->u.hdr_crc), crc);\n\t\tgoto bail;\n\t}\n\n\tswitch(je16_to_cpu(node->u.nodetype)) {\n\tcase JFFS2_NODETYPE_INODE:\n\t\tcrc = crc32(0, node, sizeof(node->i)-8);\n\t\tif (je32_to_cpu(node->i.node_crc) != crc) {\n\t\t\tpr_warn(\"Node CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\tref_offset(raw), je32_to_cpu(node->i.node_crc),\n\t\t\t\tcrc);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (je32_to_cpu(node->i.dsize)) {\n\t\t\tcrc = crc32(0, node->i.data, je32_to_cpu(node->i.csize));\n\t\t\tif (je32_to_cpu(node->i.data_crc) != crc) {\n\t\t\t\tpr_warn(\"Data CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\t\tref_offset(raw),\n\t\t\t\t\tje32_to_cpu(node->i.data_crc), crc);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase JFFS2_NODETYPE_DIRENT:\n\t\tcrc = crc32(0, node, sizeof(node->d)-8);\n\t\tif (je32_to_cpu(node->d.node_crc) != crc) {\n\t\t\tpr_warn(\"Node CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\tref_offset(raw),\n\t\t\t\tje32_to_cpu(node->d.node_crc), crc);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (strnlen(node->d.name, node->d.nsize) != node->d.nsize) {\n\t\t\tpr_warn(\"Name in dirent node at 0x%08x contains zeroes\\n\",\n\t\t\t\tref_offset(raw));\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (node->d.nsize) {\n\t\t\tcrc = crc32(0, node->d.name, node->d.nsize);\n\t\t\tif (je32_to_cpu(node->d.name_crc) != crc) {\n\t\t\t\tpr_warn(\"Name CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x\\n\",\n\t\t\t\t\tref_offset(raw),\n\t\t\t\t\tje32_to_cpu(node->d.name_crc), crc);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t/* If it's inode-less, we don't _know_ what it is. Just copy it intact */\n\t\tif (ic) {\n\t\t\tpr_warn(\"Unknown node type for REF_PRISTINE node at 0x%08x: 0x%04x\\n\",\n\t\t\t\tref_offset(raw), je16_to_cpu(node->u.nodetype));\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* OK, all the CRCs are good; this node can just be copied as-is. */\n retry:\n\tphys_ofs = write_ofs(c);\n\n\tret = jffs2_flash_write(c, phys_ofs, rawlen, &retlen, (char *)node);\n\n\tif (ret || (retlen != rawlen)) {\n\t\tpr_notice(\"Write of %d bytes at 0x%08x failed. returned %d, retlen %zd\\n\",\n\t\t\t  rawlen, phys_ofs, ret, retlen);\n\t\tif (retlen) {\n\t\t\tjffs2_add_physical_node_ref(c, phys_ofs | REF_OBSOLETE, rawlen, NULL);\n\t\t} else {\n\t\t\tpr_notice(\"Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero\\n\",\n\t\t\t\t  phys_ofs);\n\t\t}\n\t\tif (!retried) {\n\t\t\t/* Try to reallocate space and retry */\n\t\t\tuint32_t dummy;\n\t\t\tstruct jffs2_eraseblock *jeb = &c->blocks[phys_ofs / c->sector_size];\n\n\t\t\tretried = 1;\n\n\t\t\tjffs2_dbg(1, \"Retrying failed write of REF_PRISTINE node.\\n\");\n\n\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\tret = jffs2_reserve_space_gc(c, rawlen, &dummy, rawlen);\n\t\t\t\t\t\t/* this is not the exact summary size of it,\n\t\t\t\t\t\t\tit is only an upper estimation */\n\n\t\t\tif (!ret) {\n\t\t\t\tjffs2_dbg(1, \"Allocated space at 0x%08x to retry failed write.\\n\",\n\t\t\t\t\t  phys_ofs);\n\n\t\t\t\tjffs2_dbg_acct_sanity_check(c,jeb);\n\t\t\t\tjffs2_dbg_acct_paranoia_check(c, jeb);\n\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t\tjffs2_dbg(1, \"Failed to allocate space to retry failed write: %d!\\n\",\n\t\t\t\t  ret);\n\t\t}\n\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tgoto out_node;\n\t}\n\tjffs2_add_physical_node_ref(c, phys_ofs | REF_PRISTINE, rawlen, ic);\n\n\tjffs2_mark_node_obsolete(c, raw);\n\tjffs2_dbg(1, \"WHEEE! GC REF_PRISTINE node at 0x%08x succeeded\\n\",\n\t\t  ref_offset(raw));\n\n out_node:\n\tkfree(node);\n\treturn ret;\n bail:\n\tret = -EBADFD;\n\tgoto out_node;\n}"
  },
  {
    "function_name": "fs2_garbage_collect_live(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "477-569",
    "snippet": "atic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f)\n{\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dnode *fn = NULL;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t start = 0, end = 0, nrfrags = 0;\n\tint ret = 0;\n\n\tmutex_lock(&f->sem);\n\n\t/* Now we have the lock for this inode. Check that it's still the one at the head\n\t   of the list. */\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tif (c->gcblock != jeb) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_dbg(1, \"GC block is no longer gcblock. Restart\\n\");\n\t\tgoto upnout;\n\t}\n\tif (ref_obsolete(raw)) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_dbg(1, \"node to be GC'd was obsoleted in the meantime.\\n\");\n\t\t/* They'll call again */\n\t\tgoto upnout;\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t/* OK. Looks safe. And nobody can get us now because we have the semaphore. Move the block */\n\tif (f->metadata && f->metadata->raw == raw) {\n\t\tfn = f->metadata;\n\t\tret = jffs2_garbage_collect_metadata(c, jeb, f, fn);\n\t\tgoto upnout;\n\t}\n\n\t/* FIXME. Read node and do lookup? */\n\tfor (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {\n\t\tif (frag->node && frag->node->raw == raw) {\n\t\t\tfn = frag->node;\n\t\t\tend = frag->ofs + frag->size;\n\t\t\tif (!nrfrags++)\n\t\t\t\tstart = frag->ofs;\n\t\t\tif (nrfrags == frag->node->frags)\n\t\t\t\tbreak; /* We've found them all */\n\t\t}\n\t}\n\tif (fn) {\n\t\tif (ref_flags(raw) == REF_PRISTINE) {\n\t\t\tret = jffs2_garbage_collect_pristine(c, f->inocache, raw);\n\t\t\tif (!ret) {\n\t\t\t\t/* Urgh. Return it sensibly. */\n\t\t\t\tfrag->node->raw = f->inocache->nodes;\n\t\t\t}\n\t\t\tif (ret != -EBADFD)\n\t\t\t\tgoto upnout;\n\t\t}\n\t\t/* We found a datanode. Do the GC */\n\t\tif((start >> PAGE_CACHE_SHIFT) < ((end-1) >> PAGE_CACHE_SHIFT)) {\n\t\t\t/* It crosses a page boundary. Therefore, it must be a hole. */\n\t\t\tret = jffs2_garbage_collect_hole(c, jeb, f, fn, start, end);\n\t\t} else {\n\t\t\t/* It could still be a hole. But we GC the page this way anyway */\n\t\t\tret = jffs2_garbage_collect_dnode(c, jeb, f, fn, start, end);\n\t\t}\n\t\tgoto upnout;\n\t}\n\n\t/* Wasn't a dnode. Try dirent */\n\tfor (fd = f->dents; fd; fd=fd->next) {\n\t\tif (fd->raw == raw)\n\t\t\tbreak;\n\t}\n\n\tif (fd && fd->ino) {\n\t\tret = jffs2_garbage_collect_dirent(c, jeb, f, fd);\n\t} else if (fd) {\n\t\tret = jffs2_garbage_collect_deletion_dirent(c, jeb, f, fd);\n\t} else {\n\t\tpr_warn(\"Raw node at 0x%08x wasn't in node lists for ino #%u\\n\",\n\t\t\tref_offset(raw), f->inocache->ino);\n\t\tif (ref_obsolete(raw)) {\n\t\t\tpr_warn(\"But it's obsolete so we don't mind too much\\n\");\n\t\t} else {\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(raw));\n\t\t\tBUG();\n\t\t}\n\t}\n upnout:\n\tmutex_unlock(&f->sem);\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns",
      "atic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns",
      "atic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->sem);"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_dump_node(c",
          "args": [
            "f_offset(raw));"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ut it's obsolete so we don't mind too much\\n\");"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(r",
          "args": [
            "w))"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "aw node at 0x%08x wasn't in node lists for ino #%u\\n\",",
            "f_offset(raw),",
            ">inocache->ino);"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_deletion_dirent(c",
          "args": [
            "b,",
            ");"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_dirent(c",
          "args": [
            "b,",
            ");"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_dnode(c",
          "args": [
            "b,",
            ",",
            "art,",
            "d);"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_hole(c",
          "args": [
            "b,",
            ",",
            "art,",
            "d);"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_pristine(c",
          "args": [
            ">inocache,",
            "w);"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(r",
          "args": [
            "w)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_next(f",
          "args": [
            "ag))"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ag_first(&",
          "args": [
            "->fragtree);"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_metadata(c",
          "args": [
            "b,",
            ");"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ode to be GC'd was obsoleted in the meantime.\\n\");"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(r",
          "args": [
            "w))"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "C block is no longer gcblock. Restart\\n\");"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->sem);"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns;\natic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns;\natic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);\n\natic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f)\n{\n\tstruct jffs2_node_frag *frag;\n\tstruct jffs2_full_dnode *fn = NULL;\n\tstruct jffs2_full_dirent *fd;\n\tuint32_t start = 0, end = 0, nrfrags = 0;\n\tint ret = 0;\n\n\tmutex_lock(&f->sem);\n\n\t/* Now we have the lock for this inode. Check that it's still the one at the head\n\t   of the list. */\n\n\tspin_lock(&c->erase_completion_lock);\n\n\tif (c->gcblock != jeb) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_dbg(1, \"GC block is no longer gcblock. Restart\\n\");\n\t\tgoto upnout;\n\t}\n\tif (ref_obsolete(raw)) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_dbg(1, \"node to be GC'd was obsoleted in the meantime.\\n\");\n\t\t/* They'll call again */\n\t\tgoto upnout;\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\t/* OK. Looks safe. And nobody can get us now because we have the semaphore. Move the block */\n\tif (f->metadata && f->metadata->raw == raw) {\n\t\tfn = f->metadata;\n\t\tret = jffs2_garbage_collect_metadata(c, jeb, f, fn);\n\t\tgoto upnout;\n\t}\n\n\t/* FIXME. Read node and do lookup? */\n\tfor (frag = frag_first(&f->fragtree); frag; frag = frag_next(frag)) {\n\t\tif (frag->node && frag->node->raw == raw) {\n\t\t\tfn = frag->node;\n\t\t\tend = frag->ofs + frag->size;\n\t\t\tif (!nrfrags++)\n\t\t\t\tstart = frag->ofs;\n\t\t\tif (nrfrags == frag->node->frags)\n\t\t\t\tbreak; /* We've found them all */\n\t\t}\n\t}\n\tif (fn) {\n\t\tif (ref_flags(raw) == REF_PRISTINE) {\n\t\t\tret = jffs2_garbage_collect_pristine(c, f->inocache, raw);\n\t\t\tif (!ret) {\n\t\t\t\t/* Urgh. Return it sensibly. */\n\t\t\t\tfrag->node->raw = f->inocache->nodes;\n\t\t\t}\n\t\t\tif (ret != -EBADFD)\n\t\t\t\tgoto upnout;\n\t\t}\n\t\t/* We found a datanode. Do the GC */\n\t\tif((start >> PAGE_CACHE_SHIFT) < ((end-1) >> PAGE_CACHE_SHIFT)) {\n\t\t\t/* It crosses a page boundary. Therefore, it must be a hole. */\n\t\t\tret = jffs2_garbage_collect_hole(c, jeb, f, fn, start, end);\n\t\t} else {\n\t\t\t/* It could still be a hole. But we GC the page this way anyway */\n\t\t\tret = jffs2_garbage_collect_dnode(c, jeb, f, fn, start, end);\n\t\t}\n\t\tgoto upnout;\n\t}\n\n\t/* Wasn't a dnode. Try dirent */\n\tfor (fd = f->dents; fd; fd=fd->next) {\n\t\tif (fd->raw == raw)\n\t\t\tbreak;\n\t}\n\n\tif (fd && fd->ino) {\n\t\tret = jffs2_garbage_collect_dirent(c, jeb, f, fd);\n\t} else if (fd) {\n\t\tret = jffs2_garbage_collect_deletion_dirent(c, jeb, f, fd);\n\t} else {\n\t\tpr_warn(\"Raw node at 0x%08x wasn't in node lists for ino #%u\\n\",\n\t\t\tref_offset(raw), f->inocache->ino);\n\t\tif (ref_obsolete(raw)) {\n\t\t\tpr_warn(\"But it's obsolete so we don't mind too much\\n\");\n\t\t} else {\n\t\t\tjffs2_dbg_dump_node(c, ref_offset(raw));\n\t\t\tBUG();\n\t\t}\n\t}\n upnout:\n\tmutex_unlock(&f->sem);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_garbage_collect_pass(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "124-475",
    "snippet": "t jffs2_garbage_collect_pass(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t gcblock_dirty;\n\tint ret = 0, inum, nlink;\n\tint xattr = 0;\n\n\tif (mutex_lock_interruptible(&c->alloc_sem))\n\t\treturn -EINTR;\n\n\tfor (;;) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tif (!c->unchecked_size)\n\t\t\tbreak;\n\n\t\t/* We can't start doing GC yet. We haven't finished checking\n\t\t   the node CRCs etc. Do it now. */\n\n\t\t/* checked_ino is protected by the alloc_sem */\n\t\tif (c->checked_ino > c->highest_ino && xattr) {\n\t\t\tpr_crit(\"Checked all inodes but still 0x%x bytes of unchecked space?\\n\",\n\t\t\t\tc->unchecked_size);\n\t\t\tjffs2_dbg_dump_block_lists_nolock(c);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (!xattr)\n\t\t\txattr = jffs2_verify_xattr(c);\n\n\t\tspin_lock(&c->inocache_lock);\n\n\t\tic = jffs2_get_ino_cache(c, c->checked_ino++);\n\n\t\tif (!ic) {\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ic->pino_nlink) {\n\t\t\tjffs2_dbg(1, \"Skipping check of ino #%d with nlink/pino zero\\n\",\n\t\t\t\t  ic->ino);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tjffs2_xattr_delete_inode(c, ic);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(ic->state) {\n\t\tcase INO_STATE_CHECKEDABSENT:\n\t\tcase INO_STATE_PRESENT:\n\t\t\tjffs2_dbg(1, \"Skipping ino #%u already checked\\n\",\n\t\t\t\t  ic->ino);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tcontinue;\n\n\t\tcase INO_STATE_GC:\n\t\tcase INO_STATE_CHECKING:\n\t\t\tpr_warn(\"Inode #%u is in state %d during CRC check phase!\\n\",\n\t\t\t\tic->ino, ic->state);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tBUG();\n\n\t\tcase INO_STATE_READING:\n\t\t\t/* We need to wait for it to finish, lest we move on\n\t\t\t   and trigger the BUG() above while we haven't yet\n\t\t\t   finished checking all its nodes */\n\t\t\tjffs2_dbg(1, \"Waiting for ino #%u to finish reading\\n\",\n\t\t\t\t  ic->ino);\n\t\t\t/* We need to come back again for the _same_ inode. We've\n\t\t\t made no progress in this case, but that should be OK */\n\t\t\tc->checked_ino--;\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\tBUG();\n\n\t\tcase INO_STATE_UNCHECKED:\n\t\t\t;\n\t\t}\n\t\tic->state = INO_STATE_CHECKING;\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tjffs2_dbg(1, \"%s(): triggering inode scan of ino#%u\\n\",\n\t\t\t  __func__, ic->ino);\n\n\t\tret = jffs2_do_crccheck_inode(c, ic);\n\t\tif (ret)\n\t\t\tpr_warn(\"Returned error for crccheck of ino #%u. Expect badness...\\n\",\n\t\t\t\tic->ino);\n\n\t\tjffs2_set_inocache_state(c, ic, INO_STATE_CHECKEDABSENT);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn ret;\n\t}\n\n\t/* If there are any blocks which need erasing, erase them now */\n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list)) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tjffs2_dbg(1, \"%s(): erasing pending blocks\\n\", __func__);\n\t\tif (jffs2_erase_pending_blocks(c, 1))\n\t\t\treturn 0;\n\n\t\tjffs2_dbg(1, \"No progress from erasing block; doing GC anyway\\n\");\n\t\tmutex_lock(&c->alloc_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\t/* First, work out which block we're garbage-collecting */\n\tjeb = c->gcblock;\n\n\tif (!jeb)\n\t\tjeb = jffs2_find_gc_block(c);\n\n\tif (!jeb) {\n\t\t/* Couldn't find a free block. But maybe we can just erase one and make 'progress'? */\n\t\tif (c->nr_erasing_blocks) {\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tjffs2_dbg(1, \"Couldn't find erase block to garbage collect!\\n\");\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn -EIO;\n\t}\n\n\tjffs2_dbg(1, \"GC from block %08x, used_size %08x, dirty_size %08x, free_size %08x\\n\",\n\t\t  jeb->offset, jeb->used_size, jeb->dirty_size, jeb->free_size);\n\tD1(if (c->nextblock)\n\t   printk(KERN_DEBUG \"Nextblock at  %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x\\n\", c->nextblock->offset, c->nextblock->used_size, c->nextblock->dirty_size, c->nextblock->wasted_size, c->nextblock->free_size));\n\n\tif (!jeb->used_size) {\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tgoto eraseit;\n\t}\n\n\traw = jeb->gc_node;\n\tgcblock_dirty = jeb->dirty_size;\n\n\twhile(ref_obsolete(raw)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x is obsolete... skipping\\n\",\n\t\t\t  ref_offset(raw));\n\t\traw = ref_next(raw);\n\t\tif (unlikely(!raw)) {\n\t\t\tpr_warn(\"eep. End of raw list while still supposedly nodes to GC\\n\");\n\t\t\tpr_warn(\"erase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x\\n\",\n\t\t\t\tjeb->offset, jeb->free_size,\n\t\t\t\tjeb->dirty_size, jeb->used_size);\n\t\t\tjeb->gc_node = raw;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\tBUG();\n\t\t}\n\t}\n\tjeb->gc_node = raw;\n\n\tjffs2_dbg(1, \"Going to garbage collect node at 0x%08x\\n\",\n\t\t  ref_offset(raw));\n\n\tif (!raw->next_in_ino) {\n\t\t/* Inode-less node. Clean marker, snapshot or something like that */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tif (ref_flags(raw) == REF_PRISTINE) {\n\t\t\t/* It's an unknown node with JFFS2_FEATURE_RWCOMPAT_COPY */\n\t\t\tjffs2_garbage_collect_pristine(c, NULL, raw);\n\t\t} else {\n\t\t\t/* Just mark it obsolete */\n\t\t\tjffs2_mark_node_obsolete(c, raw);\n\t\t}\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tgoto eraseit_lock;\n\t}\n\n\tic = jffs2_raw_ref_to_ic(raw);\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t/* When 'ic' refers xattr_datum/xattr_ref, this node is GCed as xattr.\n\t * We can decide whether this node is inode or xattr by ic->class.     */\n\tif (ic->class == RAWNODE_CLASS_XATTR_DATUM\n\t    || ic->class == RAWNODE_CLASS_XATTR_REF) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ic->class == RAWNODE_CLASS_XATTR_DATUM) {\n\t\t\tret = jffs2_garbage_collect_xattr_datum(c, (struct jffs2_xattr_datum *)ic, raw);\n\t\t} else {\n\t\t\tret = jffs2_garbage_collect_xattr_ref(c, (struct jffs2_xattr_ref *)ic, raw);\n\t\t}\n\t\tgoto test_gcnode;\n\t}\n#endif\n\n\t/* We need to hold the inocache. Either the erase_completion_lock or\n\t   the inocache_lock are sufficient; we trade down since the inocache_lock\n\t   causes less contention. */\n\tspin_lock(&c->inocache_lock);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjffs2_dbg(1, \"%s(): collecting from block @0x%08x. Node @0x%08x(%d), ino #%u\\n\",\n\t\t  __func__, jeb->offset, ref_offset(raw), ref_flags(raw),\n\t\t  ic->ino);\n\n\t/* Three possibilities:\n\t   1. Inode is already in-core. We must iget it and do proper\n\t      updating to its fragtree, etc.\n\t   2. Inode is not in-core, node is REF_PRISTINE. We lock the\n\t      inocache to prevent a read_inode(), copy the node intact.\n\t   3. Inode is not in-core, node is not pristine. We must iget()\n\t      and take the slow path.\n\t*/\n\n\tswitch(ic->state) {\n\tcase INO_STATE_CHECKEDABSENT:\n\t\t/* It's been checked, but it's not currently in-core.\n\t\t   We can just copy any pristine nodes, but have\n\t\t   to prevent anyone else from doing read_inode() while\n\t\t   we're at it, so we set the state accordingly */\n\t\tif (ref_flags(raw) == REF_PRISTINE)\n\t\t\tic->state = INO_STATE_GC;\n\t\telse {\n\t\t\tjffs2_dbg(1, \"Ino #%u is absent but node not REF_PRISTINE. Reading.\\n\",\n\t\t\t\t  ic->ino);\n\t\t}\n\t\tbreak;\n\n\tcase INO_STATE_PRESENT:\n\t\t/* It's in-core. GC must iget() it. */\n\t\tbreak;\n\n\tcase INO_STATE_UNCHECKED:\n\tcase INO_STATE_CHECKING:\n\tcase INO_STATE_GC:\n\t\t/* Should never happen. We should have finished checking\n\t\t   by the time we actually start doing any GC, and since\n\t\t   we're holding the alloc_sem, no other garbage collection\n\t\t   can happen.\n\t\t*/\n\t\tpr_crit(\"Inode #%u already in state %d in jffs2_garbage_collect_pass()!\\n\",\n\t\t\tic->ino, ic->state);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tspin_unlock(&c->inocache_lock);\n\t\tBUG();\n\n\tcase INO_STATE_READING:\n\t\t/* Someone's currently trying to read it. We must wait for\n\t\t   them to finish and then go through the full iget() route\n\t\t   to do the GC. However, sometimes read_inode() needs to get\n\t\t   the alloc_sem() (for marking nodes invalid) so we must\n\t\t   drop the alloc_sem before sleeping. */\n\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tjffs2_dbg(1, \"%s(): waiting for ino #%u in state %d\\n\",\n\t\t\t  __func__, ic->ino, ic->state);\n\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t/* And because we dropped the alloc_sem we must start again from the\n\t\t   beginning. Ponder chance of livelock here -- we're returning success\n\t\t   without actually making any progress.\n\n\t\t   Q: What are the chances that the inode is back in INO_STATE_READING\n\t\t   again by the time we next enter this function? And that this happens\n\t\t   enough times to cause a real delay?\n\n\t\t   A: Small enough that I don't care :)\n\t\t*/\n\t\treturn 0;\n\t}\n\n\t/* OK. Now if the inode is in state INO_STATE_GC, we are going to copy the\n\t   node intact, and we don't have to muck about with the fragtree etc.\n\t   because we know it's not in-core. If it _was_ in-core, we go through\n\t   all the iget() crap anyway */\n\n\tif (ic->state == INO_STATE_GC) {\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tret = jffs2_garbage_collect_pristine(c, ic, raw);\n\n\t\tspin_lock(&c->inocache_lock);\n\t\tic->state = INO_STATE_CHECKEDABSENT;\n\t\twake_up(&c->inocache_wq);\n\n\t\tif (ret != -EBADFD) {\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tgoto test_gcnode;\n\t\t}\n\n\t\t/* Fall through if it wanted us to, with inocache_lock held */\n\t}\n\n\t/* Prevent the fairly unlikely race where the gcblock is\n\t   entirely obsoleted by the final close of a file which had\n\t   the only valid nodes in the block, followed by erasure,\n\t   followed by freeing of the ic because the erased block(s)\n\t   held _all_ the nodes of that inode.... never been seen but\n\t   it's vaguely possible. */\n\n\tinum = ic->ino;\n\tnlink = ic->pino_nlink;\n\tspin_unlock(&c->inocache_lock);\n\n\tf = jffs2_gc_fetch_inode(c, inum, !nlink);\n\tif (IS_ERR(f)) {\n\t\tret = PTR_ERR(f);\n\t\tgoto release_sem;\n\t}\n\tif (!f) {\n\t\tret = 0;\n\t\tgoto release_sem;\n\t}\n\n\tret = jffs2_garbage_collect_live(c, jeb, raw, f);\n\n\tjffs2_gc_release_inode(c, f);\n\n test_gcnode:\n\tif (jeb->dirty_size == gcblock_dirty && !ref_obsolete(jeb->gc_node)) {\n\t\t/* Eep. This really should never happen. GC is broken */\n\t\tpr_err(\"Error garbage collecting node at %08x!\\n\",\n\t\t       ref_offset(jeb->gc_node));\n\t\tret = -ENOSPC;\n\t}\n release_sem:\n\tmutex_unlock(&c->alloc_sem);\n\n eraseit_lock:\n\t/* If we've finished this block, start it erasing */\n\tspin_lock(&c->erase_completion_lock);\n\n eraseit:\n\tif (c->gcblock && !c->gcblock->used_size) {\n\t\tjffs2_dbg(1, \"Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list\\n\",\n\t\t\t  c->gcblock->offset);\n\t\t/* We're GC'ing an empty block? */\n\t\tlist_add_tail(&c->gcblock->list, &c->erase_pending_list);\n\t\tc->gcblock = NULL;\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [
      "atic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns",
      "atic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns",
      "atic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns",
      "atic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns",
      "atic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_trigger(c",
          "args": [
            ";"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_add_tail(&",
          "args": [
            "->gcblock->list,",
            "->erase_pending_list);"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "lock at 0x%08x completely obsoleted by GC. Moving to erase_pending_list\\n\",",
            ">gcblock->offset);"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_err(\"",
          "args": [
            "rror garbage collecting node at %08x!\\n\",",
            "f_offset(jeb->gc_node));"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(j",
          "args": [
            "b->gc_node))"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(j",
          "args": [
            "b->gc_node))"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_gc_release_inode(c",
          "args": [
            ";"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_live(c",
          "args": [
            "b,",
            "w,",
            ";"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "R_ERR(f",
          "args": [
            ";"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_ERR(f",
          "args": [
            ")"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_gc_fetch_inode(c",
          "args": [
            "um,",
            "link);"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ke_up(&",
          "args": [
            "->inocache_wq);"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_pristine(c",
          "args": [
            ",",
            "w);"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eep_on_spinunlock(&",
          "args": [
            "->inocache_wq,",
            "->inocache_lock);"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): waiting for ino #%u in state %d\\n\",",
            "func__,",
            "->ino,",
            "->state);"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "node #%u already in state %d in jffs2_garbage_collect_pass()!\\n\",",
            "->ino,",
            "->state);"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "no #%u is absent but node not REF_PRISTINE. Reading.\\n\",",
            "->ino);"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(r",
          "args": [
            "w)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): collecting from block @0x%08x. Node @0x%08x(%d), ino #%u\\n\",",
            "func__,",
            "b->offset,",
            "f_offset(raw),",
            "f_flags(raw),",
            "->ino);"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(r",
          "args": [
            "w),"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w),"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_xattr_ref(c",
          "args": [
            "truct jffs2_xattr_ref *)ic,",
            "w);"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_xattr_datum(c",
          "args": [
            "truct jffs2_xattr_datum *)ic,",
            "w);"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_raw_ref_to_ic(r",
          "args": [
            "w);"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_mark_node_obsolete(c",
          "args": [
            "w);"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_garbage_collect_pristine(c",
          "args": [
            "LL,",
            "w);"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_flags(r",
          "args": [
            "w)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "oing to garbage collect node at 0x%08x\\n\",",
            "f_offset(raw));"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "rase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x\\n\",",
            "b->offset,",
            "b->free_size,",
            "b->dirty_size,",
            "b->used_size);"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ep. End of raw list while still supposedly nodes to GC\\n\");"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely(!",
          "args": [
            "aw))"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_next(r",
          "args": [
            "w);"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ode at 0x%08x is obsolete... skipping\\n\",",
            "f_offset(raw));"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_offset(r",
          "args": [
            "w))"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f_obsolete(r",
          "args": [
            "w))"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(i",
          "args": [
            "(c->nextblock)\n\tintk(KERN_DEBUG \"Nextblock at  %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x\\n\", c->nextblock->offset, c->nextblock->used_size, c->nextblock->dirty_size, c->nextblock->wasted_size, c->nextblock->free_size));"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "fs_sysctl(i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/sysctl.h",
          "lines": "35-38",
          "snippet": "atic inline int ntfs_sysctl(int add)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "atic inline int ntfs_sysctl(int add)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "intk(K",
          "args": [
            "RN_DEBUG \"Nextblock at  %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x\\n\",",
            ">nextblock->offset,",
            ">nextblock->used_size,",
            ">nextblock->dirty_size,",
            ">nextblock->wasted_size,",
            ">nextblock->free_size))"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(",
          "args": [
            ">nextblock)"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "fs2_garbage_collect_pass(s",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
          "lines": "124-475",
          "snippet": "t jffs2_garbage_collect_pass(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t gcblock_dirty;\n\tint ret = 0, inum, nlink;\n\tint xattr = 0;\n\n\tif (mutex_lock_interruptible(&c->alloc_sem))\n\t\treturn -EINTR;\n\n\tfor (;;) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tif (!c->unchecked_size)\n\t\t\tbreak;\n\n\t\t/* We can't start doing GC yet. We haven't finished checking\n\t\t   the node CRCs etc. Do it now. */\n\n\t\t/* checked_ino is protected by the alloc_sem */\n\t\tif (c->checked_ino > c->highest_ino && xattr) {\n\t\t\tpr_crit(\"Checked all inodes but still 0x%x bytes of unchecked space?\\n\",\n\t\t\t\tc->unchecked_size);\n\t\t\tjffs2_dbg_dump_block_lists_nolock(c);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (!xattr)\n\t\t\txattr = jffs2_verify_xattr(c);\n\n\t\tspin_lock(&c->inocache_lock);\n\n\t\tic = jffs2_get_ino_cache(c, c->checked_ino++);\n\n\t\tif (!ic) {\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ic->pino_nlink) {\n\t\t\tjffs2_dbg(1, \"Skipping check of ino #%d with nlink/pino zero\\n\",\n\t\t\t\t  ic->ino);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tjffs2_xattr_delete_inode(c, ic);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(ic->state) {\n\t\tcase INO_STATE_CHECKEDABSENT:\n\t\tcase INO_STATE_PRESENT:\n\t\t\tjffs2_dbg(1, \"Skipping ino #%u already checked\\n\",\n\t\t\t\t  ic->ino);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tcontinue;\n\n\t\tcase INO_STATE_GC:\n\t\tcase INO_STATE_CHECKING:\n\t\t\tpr_warn(\"Inode #%u is in state %d during CRC check phase!\\n\",\n\t\t\t\tic->ino, ic->state);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tBUG();\n\n\t\tcase INO_STATE_READING:\n\t\t\t/* We need to wait for it to finish, lest we move on\n\t\t\t   and trigger the BUG() above while we haven't yet\n\t\t\t   finished checking all its nodes */\n\t\t\tjffs2_dbg(1, \"Waiting for ino #%u to finish reading\\n\",\n\t\t\t\t  ic->ino);\n\t\t\t/* We need to come back again for the _same_ inode. We've\n\t\t\t made no progress in this case, but that should be OK */\n\t\t\tc->checked_ino--;\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\tBUG();\n\n\t\tcase INO_STATE_UNCHECKED:\n\t\t\t;\n\t\t}\n\t\tic->state = INO_STATE_CHECKING;\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tjffs2_dbg(1, \"%s(): triggering inode scan of ino#%u\\n\",\n\t\t\t  __func__, ic->ino);\n\n\t\tret = jffs2_do_crccheck_inode(c, ic);\n\t\tif (ret)\n\t\t\tpr_warn(\"Returned error for crccheck of ino #%u. Expect badness...\\n\",\n\t\t\t\tic->ino);\n\n\t\tjffs2_set_inocache_state(c, ic, INO_STATE_CHECKEDABSENT);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn ret;\n\t}\n\n\t/* If there are any blocks which need erasing, erase them now */\n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list)) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tjffs2_dbg(1, \"%s(): erasing pending blocks\\n\", __func__);\n\t\tif (jffs2_erase_pending_blocks(c, 1))\n\t\t\treturn 0;\n\n\t\tjffs2_dbg(1, \"No progress from erasing block; doing GC anyway\\n\");\n\t\tmutex_lock(&c->alloc_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\t/* First, work out which block we're garbage-collecting */\n\tjeb = c->gcblock;\n\n\tif (!jeb)\n\t\tjeb = jffs2_find_gc_block(c);\n\n\tif (!jeb) {\n\t\t/* Couldn't find a free block. But maybe we can just erase one and make 'progress'? */\n\t\tif (c->nr_erasing_blocks) {\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tjffs2_dbg(1, \"Couldn't find erase block to garbage collect!\\n\");\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn -EIO;\n\t}\n\n\tjffs2_dbg(1, \"GC from block %08x, used_size %08x, dirty_size %08x, free_size %08x\\n\",\n\t\t  jeb->offset, jeb->used_size, jeb->dirty_size, jeb->free_size);\n\tD1(if (c->nextblock)\n\t   printk(KERN_DEBUG \"Nextblock at  %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x\\n\", c->nextblock->offset, c->nextblock->used_size, c->nextblock->dirty_size, c->nextblock->wasted_size, c->nextblock->free_size));\n\n\tif (!jeb->used_size) {\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tgoto eraseit;\n\t}\n\n\traw = jeb->gc_node;\n\tgcblock_dirty = jeb->dirty_size;\n\n\twhile(ref_obsolete(raw)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x is obsolete... skipping\\n\",\n\t\t\t  ref_offset(raw));\n\t\traw = ref_next(raw);\n\t\tif (unlikely(!raw)) {\n\t\t\tpr_warn(\"eep. End of raw list while still supposedly nodes to GC\\n\");\n\t\t\tpr_warn(\"erase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x\\n\",\n\t\t\t\tjeb->offset, jeb->free_size,\n\t\t\t\tjeb->dirty_size, jeb->used_size);\n\t\t\tjeb->gc_node = raw;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\tBUG();\n\t\t}\n\t}\n\tjeb->gc_node = raw;\n\n\tjffs2_dbg(1, \"Going to garbage collect node at 0x%08x\\n\",\n\t\t  ref_offset(raw));\n\n\tif (!raw->next_in_ino) {\n\t\t/* Inode-less node. Clean marker, snapshot or something like that */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tif (ref_flags(raw) == REF_PRISTINE) {\n\t\t\t/* It's an unknown node with JFFS2_FEATURE_RWCOMPAT_COPY */\n\t\t\tjffs2_garbage_collect_pristine(c, NULL, raw);\n\t\t} else {\n\t\t\t/* Just mark it obsolete */\n\t\t\tjffs2_mark_node_obsolete(c, raw);\n\t\t}\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tgoto eraseit_lock;\n\t}\n\n\tic = jffs2_raw_ref_to_ic(raw);\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t/* When 'ic' refers xattr_datum/xattr_ref, this node is GCed as xattr.\n\t * We can decide whether this node is inode or xattr by ic->class.     */\n\tif (ic->class == RAWNODE_CLASS_XATTR_DATUM\n\t    || ic->class == RAWNODE_CLASS_XATTR_REF) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ic->class == RAWNODE_CLASS_XATTR_DATUM) {\n\t\t\tret = jffs2_garbage_collect_xattr_datum(c, (struct jffs2_xattr_datum *)ic, raw);\n\t\t} else {\n\t\t\tret = jffs2_garbage_collect_xattr_ref(c, (struct jffs2_xattr_ref *)ic, raw);\n\t\t}\n\t\tgoto test_gcnode;\n\t}\n#endif\n\n\t/* We need to hold the inocache. Either the erase_completion_lock or\n\t   the inocache_lock are sufficient; we trade down since the inocache_lock\n\t   causes less contention. */\n\tspin_lock(&c->inocache_lock);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjffs2_dbg(1, \"%s(): collecting from block @0x%08x. Node @0x%08x(%d), ino #%u\\n\",\n\t\t  __func__, jeb->offset, ref_offset(raw), ref_flags(raw),\n\t\t  ic->ino);\n\n\t/* Three possibilities:\n\t   1. Inode is already in-core. We must iget it and do proper\n\t      updating to its fragtree, etc.\n\t   2. Inode is not in-core, node is REF_PRISTINE. We lock the\n\t      inocache to prevent a read_inode(), copy the node intact.\n\t   3. Inode is not in-core, node is not pristine. We must iget()\n\t      and take the slow path.\n\t*/\n\n\tswitch(ic->state) {\n\tcase INO_STATE_CHECKEDABSENT:\n\t\t/* It's been checked, but it's not currently in-core.\n\t\t   We can just copy any pristine nodes, but have\n\t\t   to prevent anyone else from doing read_inode() while\n\t\t   we're at it, so we set the state accordingly */\n\t\tif (ref_flags(raw) == REF_PRISTINE)\n\t\t\tic->state = INO_STATE_GC;\n\t\telse {\n\t\t\tjffs2_dbg(1, \"Ino #%u is absent but node not REF_PRISTINE. Reading.\\n\",\n\t\t\t\t  ic->ino);\n\t\t}\n\t\tbreak;\n\n\tcase INO_STATE_PRESENT:\n\t\t/* It's in-core. GC must iget() it. */\n\t\tbreak;\n\n\tcase INO_STATE_UNCHECKED:\n\tcase INO_STATE_CHECKING:\n\tcase INO_STATE_GC:\n\t\t/* Should never happen. We should have finished checking\n\t\t   by the time we actually start doing any GC, and since\n\t\t   we're holding the alloc_sem, no other garbage collection\n\t\t   can happen.\n\t\t*/\n\t\tpr_crit(\"Inode #%u already in state %d in jffs2_garbage_collect_pass()!\\n\",\n\t\t\tic->ino, ic->state);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tspin_unlock(&c->inocache_lock);\n\t\tBUG();\n\n\tcase INO_STATE_READING:\n\t\t/* Someone's currently trying to read it. We must wait for\n\t\t   them to finish and then go through the full iget() route\n\t\t   to do the GC. However, sometimes read_inode() needs to get\n\t\t   the alloc_sem() (for marking nodes invalid) so we must\n\t\t   drop the alloc_sem before sleeping. */\n\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tjffs2_dbg(1, \"%s(): waiting for ino #%u in state %d\\n\",\n\t\t\t  __func__, ic->ino, ic->state);\n\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t/* And because we dropped the alloc_sem we must start again from the\n\t\t   beginning. Ponder chance of livelock here -- we're returning success\n\t\t   without actually making any progress.\n\n\t\t   Q: What are the chances that the inode is back in INO_STATE_READING\n\t\t   again by the time we next enter this function? And that this happens\n\t\t   enough times to cause a real delay?\n\n\t\t   A: Small enough that I don't care :)\n\t\t*/\n\t\treturn 0;\n\t}\n\n\t/* OK. Now if the inode is in state INO_STATE_GC, we are going to copy the\n\t   node intact, and we don't have to muck about with the fragtree etc.\n\t   because we know it's not in-core. If it _was_ in-core, we go through\n\t   all the iget() crap anyway */\n\n\tif (ic->state == INO_STATE_GC) {\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tret = jffs2_garbage_collect_pristine(c, ic, raw);\n\n\t\tspin_lock(&c->inocache_lock);\n\t\tic->state = INO_STATE_CHECKEDABSENT;\n\t\twake_up(&c->inocache_wq);\n\n\t\tif (ret != -EBADFD) {\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tgoto test_gcnode;\n\t\t}\n\n\t\t/* Fall through if it wanted us to, with inocache_lock held */\n\t}\n\n\t/* Prevent the fairly unlikely race where the gcblock is\n\t   entirely obsoleted by the final close of a file which had\n\t   the only valid nodes in the block, followed by erasure,\n\t   followed by freeing of the ic because the erased block(s)\n\t   held _all_ the nodes of that inode.... never been seen but\n\t   it's vaguely possible. */\n\n\tinum = ic->ino;\n\tnlink = ic->pino_nlink;\n\tspin_unlock(&c->inocache_lock);\n\n\tf = jffs2_gc_fetch_inode(c, inum, !nlink);\n\tif (IS_ERR(f)) {\n\t\tret = PTR_ERR(f);\n\t\tgoto release_sem;\n\t}\n\tif (!f) {\n\t\tret = 0;\n\t\tgoto release_sem;\n\t}\n\n\tret = jffs2_garbage_collect_live(c, jeb, raw, f);\n\n\tjffs2_gc_release_inode(c, f);\n\n test_gcnode:\n\tif (jeb->dirty_size == gcblock_dirty && !ref_obsolete(jeb->gc_node)) {\n\t\t/* Eep. This really should never happen. GC is broken */\n\t\tpr_err(\"Error garbage collecting node at %08x!\\n\",\n\t\t       ref_offset(jeb->gc_node));\n\t\tret = -ENOSPC;\n\t}\n release_sem:\n\tmutex_unlock(&c->alloc_sem);\n\n eraseit_lock:\n\t/* If we've finished this block, start it erasing */\n\tspin_lock(&c->erase_completion_lock);\n\n eraseit:\n\tif (c->gcblock && !c->gcblock->used_size) {\n\t\tjffs2_dbg(1, \"Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list\\n\",\n\t\t\t  c->gcblock->offset);\n\t\t/* We're GC'ing an empty block? */\n\t\tlist_add_tail(&c->gcblock->list, &c->erase_pending_list);\n\t\tc->gcblock = NULL;\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "C from block %08x, used_size %08x, dirty_size %08x, free_size %08x\\n\",",
            "b->offset,",
            "b->used_size,",
            "b->dirty_size,",
            "b->free_size);"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ouldn't find erase block to garbage collect!\\n\");"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_find_gc_block(c",
          "args": [
            ";"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "o progress from erasing block; doing GC anyway\\n\");"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_erase_pending_blocks(c",
          "args": [
            ")"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): erasing pending blocks\\n\",",
            "func__);"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erase_pending_list))"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erase_complete_list)"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_set_inocache_state(c",
          "args": [
            ",",
            "O_STATE_CHECKEDABSENT);"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "eturned error for crccheck of ino #%u. Expect badness...\\n\",",
            "->ino);"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_do_crccheck_inode(c",
          "args": [
            ");"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "s(): triggering inode scan of ino#%u\\n\",",
            "func__,",
            "->ino);"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eep_on_spinunlock(&",
          "args": [
            "->inocache_wq,",
            "->inocache_lock);"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "aiting for ino #%u to finish reading\\n\",",
            "->ino);"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "node #%u is in state %d during CRC check phase!\\n\",",
            "->ino,",
            "->state);"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "kipping ino #%u already checked\\n\",",
            "->ino);"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_xattr_delete_inode(c",
          "args": [
            ");"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "kipping check of ino #%d with nlink/pino zero\\n\",",
            "->ino);"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_get_ino_cache(c",
          "args": [
            ">checked_ino++);"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->inocache_lock);"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_verify_xattr(c",
          "args": [
            ";"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_unlock(&",
          "args": [
            "->alloc_sem);"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg_dump_block_lists_nolock(c",
          "args": [
            ";"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_crit(\"",
          "args": [
            "hecked all inodes but still 0x%x bytes of unchecked space?\\n\",",
            ">unchecked_size);"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tex_lock_interruptible(&",
          "args": [
            "->alloc_sem))"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic int jffs2_garbage_collect_pristine(struct jffs2_sb_info *c,\n\t\t\t\t\t  struct jffs2_inode_cache *ic,\n\t\t\t\t\t  struct jffs2_raw_node_ref *raw);\ns;\natic int jffs2_garbage_collect_metadata(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dnode *fd);\ns;\natic int jffs2_garbage_collect_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_deletion_dirent(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t\tstruct jffs2_inode_info *f, struct jffs2_full_dirent *fd);\ns;\natic int jffs2_garbage_collect_hole(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t      struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t      uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_dnode(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\n\t\t\t\t       struct jffs2_inode_info *f, struct jffs2_full_dnode *fn,\n\t\t\t\t       uint32_t start, uint32_t end);\ns;\natic int jffs2_garbage_collect_live(struct jffs2_sb_info *c,  struct jffs2_eraseblock *jeb,\n\t\t\t       struct jffs2_raw_node_ref *raw, struct jffs2_inode_info *f);\n\nt jffs2_garbage_collect_pass(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_inode_info *f;\n\tstruct jffs2_inode_cache *ic;\n\tstruct jffs2_eraseblock *jeb;\n\tstruct jffs2_raw_node_ref *raw;\n\tuint32_t gcblock_dirty;\n\tint ret = 0, inum, nlink;\n\tint xattr = 0;\n\n\tif (mutex_lock_interruptible(&c->alloc_sem))\n\t\treturn -EINTR;\n\n\tfor (;;) {\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tif (!c->unchecked_size)\n\t\t\tbreak;\n\n\t\t/* We can't start doing GC yet. We haven't finished checking\n\t\t   the node CRCs etc. Do it now. */\n\n\t\t/* checked_ino is protected by the alloc_sem */\n\t\tif (c->checked_ino > c->highest_ino && xattr) {\n\t\t\tpr_crit(\"Checked all inodes but still 0x%x bytes of unchecked space?\\n\",\n\t\t\t\tc->unchecked_size);\n\t\t\tjffs2_dbg_dump_block_lists_nolock(c);\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (!xattr)\n\t\t\txattr = jffs2_verify_xattr(c);\n\n\t\tspin_lock(&c->inocache_lock);\n\n\t\tic = jffs2_get_ino_cache(c, c->checked_ino++);\n\n\t\tif (!ic) {\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ic->pino_nlink) {\n\t\t\tjffs2_dbg(1, \"Skipping check of ino #%d with nlink/pino zero\\n\",\n\t\t\t\t  ic->ino);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tjffs2_xattr_delete_inode(c, ic);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch(ic->state) {\n\t\tcase INO_STATE_CHECKEDABSENT:\n\t\tcase INO_STATE_PRESENT:\n\t\t\tjffs2_dbg(1, \"Skipping ino #%u already checked\\n\",\n\t\t\t\t  ic->ino);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tcontinue;\n\n\t\tcase INO_STATE_GC:\n\t\tcase INO_STATE_CHECKING:\n\t\t\tpr_warn(\"Inode #%u is in state %d during CRC check phase!\\n\",\n\t\t\t\tic->ino, ic->state);\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tBUG();\n\n\t\tcase INO_STATE_READING:\n\t\t\t/* We need to wait for it to finish, lest we move on\n\t\t\t   and trigger the BUG() above while we haven't yet\n\t\t\t   finished checking all its nodes */\n\t\t\tjffs2_dbg(1, \"Waiting for ino #%u to finish reading\\n\",\n\t\t\t\t  ic->ino);\n\t\t\t/* We need to come back again for the _same_ inode. We've\n\t\t\t made no progress in this case, but that should be OK */\n\t\t\tc->checked_ino--;\n\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t\treturn 0;\n\n\t\tdefault:\n\t\t\tBUG();\n\n\t\tcase INO_STATE_UNCHECKED:\n\t\t\t;\n\t\t}\n\t\tic->state = INO_STATE_CHECKING;\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tjffs2_dbg(1, \"%s(): triggering inode scan of ino#%u\\n\",\n\t\t\t  __func__, ic->ino);\n\n\t\tret = jffs2_do_crccheck_inode(c, ic);\n\t\tif (ret)\n\t\t\tpr_warn(\"Returned error for crccheck of ino #%u. Expect badness...\\n\",\n\t\t\t\tic->ino);\n\n\t\tjffs2_set_inocache_state(c, ic, INO_STATE_CHECKEDABSENT);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn ret;\n\t}\n\n\t/* If there are any blocks which need erasing, erase them now */\n\tif (!list_empty(&c->erase_complete_list) ||\n\t    !list_empty(&c->erase_pending_list)) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tjffs2_dbg(1, \"%s(): erasing pending blocks\\n\", __func__);\n\t\tif (jffs2_erase_pending_blocks(c, 1))\n\t\t\treturn 0;\n\n\t\tjffs2_dbg(1, \"No progress from erasing block; doing GC anyway\\n\");\n\t\tmutex_lock(&c->alloc_sem);\n\t\tspin_lock(&c->erase_completion_lock);\n\t}\n\n\t/* First, work out which block we're garbage-collecting */\n\tjeb = c->gcblock;\n\n\tif (!jeb)\n\t\tjeb = jffs2_find_gc_block(c);\n\n\tif (!jeb) {\n\t\t/* Couldn't find a free block. But maybe we can just erase one and make 'progress'? */\n\t\tif (c->nr_erasing_blocks) {\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t\tjffs2_dbg(1, \"Couldn't find erase block to garbage collect!\\n\");\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\treturn -EIO;\n\t}\n\n\tjffs2_dbg(1, \"GC from block %08x, used_size %08x, dirty_size %08x, free_size %08x\\n\",\n\t\t  jeb->offset, jeb->used_size, jeb->dirty_size, jeb->free_size);\n\tD1(if (c->nextblock)\n\t   printk(KERN_DEBUG \"Nextblock at  %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x\\n\", c->nextblock->offset, c->nextblock->used_size, c->nextblock->dirty_size, c->nextblock->wasted_size, c->nextblock->free_size));\n\n\tif (!jeb->used_size) {\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tgoto eraseit;\n\t}\n\n\traw = jeb->gc_node;\n\tgcblock_dirty = jeb->dirty_size;\n\n\twhile(ref_obsolete(raw)) {\n\t\tjffs2_dbg(1, \"Node at 0x%08x is obsolete... skipping\\n\",\n\t\t\t  ref_offset(raw));\n\t\traw = ref_next(raw);\n\t\tif (unlikely(!raw)) {\n\t\t\tpr_warn(\"eep. End of raw list while still supposedly nodes to GC\\n\");\n\t\t\tpr_warn(\"erase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x\\n\",\n\t\t\t\tjeb->offset, jeb->free_size,\n\t\t\t\tjeb->dirty_size, jeb->used_size);\n\t\t\tjeb->gc_node = raw;\n\t\t\tspin_unlock(&c->erase_completion_lock);\n\t\t\tmutex_unlock(&c->alloc_sem);\n\t\t\tBUG();\n\t\t}\n\t}\n\tjeb->gc_node = raw;\n\n\tjffs2_dbg(1, \"Going to garbage collect node at 0x%08x\\n\",\n\t\t  ref_offset(raw));\n\n\tif (!raw->next_in_ino) {\n\t\t/* Inode-less node. Clean marker, snapshot or something like that */\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tif (ref_flags(raw) == REF_PRISTINE) {\n\t\t\t/* It's an unknown node with JFFS2_FEATURE_RWCOMPAT_COPY */\n\t\t\tjffs2_garbage_collect_pristine(c, NULL, raw);\n\t\t} else {\n\t\t\t/* Just mark it obsolete */\n\t\t\tjffs2_mark_node_obsolete(c, raw);\n\t\t}\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tgoto eraseit_lock;\n\t}\n\n\tic = jffs2_raw_ref_to_ic(raw);\n\n#ifdef CONFIG_JFFS2_FS_XATTR\n\t/* When 'ic' refers xattr_datum/xattr_ref, this node is GCed as xattr.\n\t * We can decide whether this node is inode or xattr by ic->class.     */\n\tif (ic->class == RAWNODE_CLASS_XATTR_DATUM\n\t    || ic->class == RAWNODE_CLASS_XATTR_REF) {\n\t\tspin_unlock(&c->erase_completion_lock);\n\n\t\tif (ic->class == RAWNODE_CLASS_XATTR_DATUM) {\n\t\t\tret = jffs2_garbage_collect_xattr_datum(c, (struct jffs2_xattr_datum *)ic, raw);\n\t\t} else {\n\t\t\tret = jffs2_garbage_collect_xattr_ref(c, (struct jffs2_xattr_ref *)ic, raw);\n\t\t}\n\t\tgoto test_gcnode;\n\t}\n#endif\n\n\t/* We need to hold the inocache. Either the erase_completion_lock or\n\t   the inocache_lock are sufficient; we trade down since the inocache_lock\n\t   causes less contention. */\n\tspin_lock(&c->inocache_lock);\n\n\tspin_unlock(&c->erase_completion_lock);\n\n\tjffs2_dbg(1, \"%s(): collecting from block @0x%08x. Node @0x%08x(%d), ino #%u\\n\",\n\t\t  __func__, jeb->offset, ref_offset(raw), ref_flags(raw),\n\t\t  ic->ino);\n\n\t/* Three possibilities:\n\t   1. Inode is already in-core. We must iget it and do proper\n\t      updating to its fragtree, etc.\n\t   2. Inode is not in-core, node is REF_PRISTINE. We lock the\n\t      inocache to prevent a read_inode(), copy the node intact.\n\t   3. Inode is not in-core, node is not pristine. We must iget()\n\t      and take the slow path.\n\t*/\n\n\tswitch(ic->state) {\n\tcase INO_STATE_CHECKEDABSENT:\n\t\t/* It's been checked, but it's not currently in-core.\n\t\t   We can just copy any pristine nodes, but have\n\t\t   to prevent anyone else from doing read_inode() while\n\t\t   we're at it, so we set the state accordingly */\n\t\tif (ref_flags(raw) == REF_PRISTINE)\n\t\t\tic->state = INO_STATE_GC;\n\t\telse {\n\t\t\tjffs2_dbg(1, \"Ino #%u is absent but node not REF_PRISTINE. Reading.\\n\",\n\t\t\t\t  ic->ino);\n\t\t}\n\t\tbreak;\n\n\tcase INO_STATE_PRESENT:\n\t\t/* It's in-core. GC must iget() it. */\n\t\tbreak;\n\n\tcase INO_STATE_UNCHECKED:\n\tcase INO_STATE_CHECKING:\n\tcase INO_STATE_GC:\n\t\t/* Should never happen. We should have finished checking\n\t\t   by the time we actually start doing any GC, and since\n\t\t   we're holding the alloc_sem, no other garbage collection\n\t\t   can happen.\n\t\t*/\n\t\tpr_crit(\"Inode #%u already in state %d in jffs2_garbage_collect_pass()!\\n\",\n\t\t\tic->ino, ic->state);\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tspin_unlock(&c->inocache_lock);\n\t\tBUG();\n\n\tcase INO_STATE_READING:\n\t\t/* Someone's currently trying to read it. We must wait for\n\t\t   them to finish and then go through the full iget() route\n\t\t   to do the GC. However, sometimes read_inode() needs to get\n\t\t   the alloc_sem() (for marking nodes invalid) so we must\n\t\t   drop the alloc_sem before sleeping. */\n\n\t\tmutex_unlock(&c->alloc_sem);\n\t\tjffs2_dbg(1, \"%s(): waiting for ino #%u in state %d\\n\",\n\t\t\t  __func__, ic->ino, ic->state);\n\t\tsleep_on_spinunlock(&c->inocache_wq, &c->inocache_lock);\n\t\t/* And because we dropped the alloc_sem we must start again from the\n\t\t   beginning. Ponder chance of livelock here -- we're returning success\n\t\t   without actually making any progress.\n\n\t\t   Q: What are the chances that the inode is back in INO_STATE_READING\n\t\t   again by the time we next enter this function? And that this happens\n\t\t   enough times to cause a real delay?\n\n\t\t   A: Small enough that I don't care :)\n\t\t*/\n\t\treturn 0;\n\t}\n\n\t/* OK. Now if the inode is in state INO_STATE_GC, we are going to copy the\n\t   node intact, and we don't have to muck about with the fragtree etc.\n\t   because we know it's not in-core. If it _was_ in-core, we go through\n\t   all the iget() crap anyway */\n\n\tif (ic->state == INO_STATE_GC) {\n\t\tspin_unlock(&c->inocache_lock);\n\n\t\tret = jffs2_garbage_collect_pristine(c, ic, raw);\n\n\t\tspin_lock(&c->inocache_lock);\n\t\tic->state = INO_STATE_CHECKEDABSENT;\n\t\twake_up(&c->inocache_wq);\n\n\t\tif (ret != -EBADFD) {\n\t\t\tspin_unlock(&c->inocache_lock);\n\t\t\tgoto test_gcnode;\n\t\t}\n\n\t\t/* Fall through if it wanted us to, with inocache_lock held */\n\t}\n\n\t/* Prevent the fairly unlikely race where the gcblock is\n\t   entirely obsoleted by the final close of a file which had\n\t   the only valid nodes in the block, followed by erasure,\n\t   followed by freeing of the ic because the erased block(s)\n\t   held _all_ the nodes of that inode.... never been seen but\n\t   it's vaguely possible. */\n\n\tinum = ic->ino;\n\tnlink = ic->pino_nlink;\n\tspin_unlock(&c->inocache_lock);\n\n\tf = jffs2_gc_fetch_inode(c, inum, !nlink);\n\tif (IS_ERR(f)) {\n\t\tret = PTR_ERR(f);\n\t\tgoto release_sem;\n\t}\n\tif (!f) {\n\t\tret = 0;\n\t\tgoto release_sem;\n\t}\n\n\tret = jffs2_garbage_collect_live(c, jeb, raw, f);\n\n\tjffs2_gc_release_inode(c, f);\n\n test_gcnode:\n\tif (jeb->dirty_size == gcblock_dirty && !ref_obsolete(jeb->gc_node)) {\n\t\t/* Eep. This really should never happen. GC is broken */\n\t\tpr_err(\"Error garbage collecting node at %08x!\\n\",\n\t\t       ref_offset(jeb->gc_node));\n\t\tret = -ENOSPC;\n\t}\n release_sem:\n\tmutex_unlock(&c->alloc_sem);\n\n eraseit_lock:\n\t/* If we've finished this block, start it erasing */\n\tspin_lock(&c->erase_completion_lock);\n\n eraseit:\n\tif (c->gcblock && !c->gcblock->used_size) {\n\t\tjffs2_dbg(1, \"Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list\\n\",\n\t\t\t  c->gcblock->offset);\n\t\t/* We're GC'ing an empty block? */\n\t\tlist_add_tail(&c->gcblock->list, &c->erase_pending_list);\n\t\tc->gcblock = NULL;\n\t\tc->nr_erasing_blocks++;\n\t\tjffs2_garbage_collect_trigger(c);\n\t}\n\tspin_unlock(&c->erase_completion_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fs2_find_gc_block(s",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/gc.c",
    "lines": "44-118",
    "snippet": "atic struct jffs2_eraseblock *jffs2_find_gc_block(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_eraseblock *ret;\n\tstruct list_head *nextlist = NULL;\n\tint n = jiffies % 128;\n\n\t/* Pick an eraseblock to garbage collect next. This is where we'll\n\t   put the clever wear-levelling algorithms. Eventually.  */\n\t/* We possibly want to favour the dirtier blocks more when the\n\t   number of free blocks is low. */\nagain:\n\tif (!list_empty(&c->bad_used_list) && c->nr_free_blocks > c->resv_blocks_gcbad) {\n\t\tjffs2_dbg(1, \"Picking block from bad_used_list to GC next\\n\");\n\t\tnextlist = &c->bad_used_list;\n\t} else if (n < 50 && !list_empty(&c->erasable_list)) {\n\t\t/* Note that most of them will have gone directly to be erased.\n\t\t   So don't favour the erasable_list _too_ much. */\n\t\tjffs2_dbg(1, \"Picking block from erasable_list to GC next\\n\");\n\t\tnextlist = &c->erasable_list;\n\t} else if (n < 110 && !list_empty(&c->very_dirty_list)) {\n\t\t/* Most of the time, pick one off the very_dirty list */\n\t\tjffs2_dbg(1, \"Picking block from very_dirty_list to GC next\\n\");\n\t\tnextlist = &c->very_dirty_list;\n\t} else if (n < 126 && !list_empty(&c->dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from dirty_list to GC next\\n\");\n\t\tnextlist = &c->dirty_list;\n\t} else if (!list_empty(&c->clean_list)) {\n\t\tjffs2_dbg(1, \"Picking block from clean_list to GC next\\n\");\n\t\tnextlist = &c->clean_list;\n\t} else if (!list_empty(&c->dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from dirty_list to GC next (clean_list was empty)\\n\");\n\n\t\tnextlist = &c->dirty_list;\n\t} else if (!list_empty(&c->very_dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from very_dirty_list to GC next (clean_list and dirty_list were empty)\\n\");\n\t\tnextlist = &c->very_dirty_list;\n\t} else if (!list_empty(&c->erasable_list)) {\n\t\tjffs2_dbg(1, \"Picking block from erasable_list to GC next (clean_list and {very_,}dirty_list were empty)\\n\");\n\n\t\tnextlist = &c->erasable_list;\n\t} else if (!list_empty(&c->erasable_pending_wbuf_list)) {\n\t\t/* There are blocks are wating for the wbuf sync */\n\t\tjffs2_dbg(1, \"Synching wbuf in order to reuse erasable_pending_wbuf_list blocks\\n\");\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_flush_wbuf_pad(c);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tgoto again;\n\t} else {\n\t\t/* Eep. All were empty */\n\t\tjffs2_dbg(1, \"No clean, dirty _or_ erasable blocks to GC from! Where are they all?\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = list_entry(nextlist->next, struct jffs2_eraseblock, list);\n\tlist_del(&ret->list);\n\tc->gcblock = ret;\n\tret->gc_node = ret->first_node;\n\tif (!ret->gc_node) {\n\t\tpr_warn(\"Eep. ret->gc_node for block at 0x%08x is NULL\\n\",\n\t\t\tret->offset);\n\t\tBUG();\n\t}\n\n\t/* Have we accidentally picked a clean block with wasted space ? */\n\tif (ret->wasted_size) {\n\t\tjffs2_dbg(1, \"Converting wasted_size %08x to dirty_size\\n\",\n\t\t\t  ret->wasted_size);\n\t\tret->dirty_size += ret->wasted_size;\n\t\tc->wasted_size -= ret->wasted_size;\n\t\tc->dirty_size += ret->wasted_size;\n\t\tret->wasted_size = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "nclude \"compr.h\"\n\ns",
      "nclude \"nodelist.h\"\n#i",
      "nclude <linux/stat.h>\n#i",
      "nclude <linux/compiler.h>\n#i",
      "nclude <linux/crc32.h>\n#i",
      "nclude <linux/pagemap.h>\n#i",
      "nclude <linux/slab.h>\n#i",
      "nclude <linux/mtd/mtd.h>\n#i",
      "nclude <linux/kernel.h>\n#i"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "onverting wasted_size %08x to dirty_size\\n\",",
            "t->wasted_size);"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G()",
          "args": [],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_warn(\"",
          "args": [
            "ep. ret->gc_node for block at 0x%08x is NULL\\n\",",
            "t->offset);"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_del(&",
          "args": [
            "et->list);"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_entry(n",
          "args": [
            "xtlist->next,",
            "ruct jfs2_eraseblock,",
            "st);"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "o clean, dirty _or_ erasable blocks to GC from! Where are they all?\\n\");"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_lock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_flush_wbuf_pad(c",
          "args": [
            ";"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_unlock(&",
          "args": [
            "->erase_completion_lock);"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "ynching wbuf in order to reuse erasable_pending_wbuf_list blocks\\n\");"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erasable_pending_wbuf_list))"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "icking block from erasable_list to GC next (clean_list and {very_,}dirty_list were empty)\\n\");"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erasable_list))"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "icking block from very_dirty_list to GC next (clean_list and dirty_list were empty)\\n\");"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->very_dirty_list))"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "icking block from dirty_list to GC next (clean_list was empty)\\n\");"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->dirty_list))"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "icking block from clean_list to GC next\\n\");"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->clean_list))"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "icking block from dirty_list to GC next\\n\");"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->dirty_list))"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "icking block from very_dirty_list to GC next\\n\");"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->very_dirty_list))"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "icking block from erasable_list to GC next\\n\");"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->erasable_list))"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs2_dbg(1",
          "args": [
            "icking block from bad_used_list to GC next\\n\");"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_empty(&",
          "args": [
            "->bad_used_list)"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "nclude \"compr.h\"\n\ns\nnclude \"nodelist.h\"\n#i\nnclude <linux/stat.h>\n#i\nnclude <linux/compiler.h>\n#i\nnclude <linux/crc32.h>\n#i\nnclude <linux/pagemap.h>\n#i\nnclude <linux/slab.h>\n#i\nnclude <linux/mtd/mtd.h>\n#i\nnclude <linux/kernel.h>\n#i\n\natic struct jffs2_eraseblock *jffs2_find_gc_block(struct jffs2_sb_info *c)\n{\n\tstruct jffs2_eraseblock *ret;\n\tstruct list_head *nextlist = NULL;\n\tint n = jiffies % 128;\n\n\t/* Pick an eraseblock to garbage collect next. This is where we'll\n\t   put the clever wear-levelling algorithms. Eventually.  */\n\t/* We possibly want to favour the dirtier blocks more when the\n\t   number of free blocks is low. */\nagain:\n\tif (!list_empty(&c->bad_used_list) && c->nr_free_blocks > c->resv_blocks_gcbad) {\n\t\tjffs2_dbg(1, \"Picking block from bad_used_list to GC next\\n\");\n\t\tnextlist = &c->bad_used_list;\n\t} else if (n < 50 && !list_empty(&c->erasable_list)) {\n\t\t/* Note that most of them will have gone directly to be erased.\n\t\t   So don't favour the erasable_list _too_ much. */\n\t\tjffs2_dbg(1, \"Picking block from erasable_list to GC next\\n\");\n\t\tnextlist = &c->erasable_list;\n\t} else if (n < 110 && !list_empty(&c->very_dirty_list)) {\n\t\t/* Most of the time, pick one off the very_dirty list */\n\t\tjffs2_dbg(1, \"Picking block from very_dirty_list to GC next\\n\");\n\t\tnextlist = &c->very_dirty_list;\n\t} else if (n < 126 && !list_empty(&c->dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from dirty_list to GC next\\n\");\n\t\tnextlist = &c->dirty_list;\n\t} else if (!list_empty(&c->clean_list)) {\n\t\tjffs2_dbg(1, \"Picking block from clean_list to GC next\\n\");\n\t\tnextlist = &c->clean_list;\n\t} else if (!list_empty(&c->dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from dirty_list to GC next (clean_list was empty)\\n\");\n\n\t\tnextlist = &c->dirty_list;\n\t} else if (!list_empty(&c->very_dirty_list)) {\n\t\tjffs2_dbg(1, \"Picking block from very_dirty_list to GC next (clean_list and dirty_list were empty)\\n\");\n\t\tnextlist = &c->very_dirty_list;\n\t} else if (!list_empty(&c->erasable_list)) {\n\t\tjffs2_dbg(1, \"Picking block from erasable_list to GC next (clean_list and {very_,}dirty_list were empty)\\n\");\n\n\t\tnextlist = &c->erasable_list;\n\t} else if (!list_empty(&c->erasable_pending_wbuf_list)) {\n\t\t/* There are blocks are wating for the wbuf sync */\n\t\tjffs2_dbg(1, \"Synching wbuf in order to reuse erasable_pending_wbuf_list blocks\\n\");\n\t\tspin_unlock(&c->erase_completion_lock);\n\t\tjffs2_flush_wbuf_pad(c);\n\t\tspin_lock(&c->erase_completion_lock);\n\t\tgoto again;\n\t} else {\n\t\t/* Eep. All were empty */\n\t\tjffs2_dbg(1, \"No clean, dirty _or_ erasable blocks to GC from! Where are they all?\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = list_entry(nextlist->next, struct jffs2_eraseblock, list);\n\tlist_del(&ret->list);\n\tc->gcblock = ret;\n\tret->gc_node = ret->first_node;\n\tif (!ret->gc_node) {\n\t\tpr_warn(\"Eep. ret->gc_node for block at 0x%08x is NULL\\n\",\n\t\t\tret->offset);\n\t\tBUG();\n\t}\n\n\t/* Have we accidentally picked a clean block with wasted space ? */\n\tif (ret->wasted_size) {\n\t\tjffs2_dbg(1, \"Converting wasted_size %08x to dirty_size\\n\",\n\t\t\t  ret->wasted_size);\n\t\tret->dirty_size += ret->wasted_size;\n\t\tc->wasted_size -= ret->wasted_size;\n\t\tc->dirty_size += ret->wasted_size;\n\t\tret->wasted_size = 0;\n\t}\n\n\treturn ret;\n}"
  }
]