[
  {
    "function_name": "xlog_cil_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "985-997",
    "snippet": "void\nxlog_cil_destroy(\n\tstruct xlog\t*log)\n{\n\tif (log->l_cilp->xc_ctx) {\n\t\tif (log->l_cilp->xc_ctx->ticket)\n\t\t\txfs_log_ticket_put(log->l_cilp->xc_ctx->ticket);\n\t\tkmem_free(log->l_cilp->xc_ctx);\n\t}\n\n\tASSERT(list_empty(&log->l_cilp->xc_cil));\n\tkmem_free(log->l_cilp);\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "log->l_cilp"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "list_empty(&log->l_cilp->xc_cil)"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&log->l_cilp->xc_cil"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_put",
          "args": [
            "log->l_cilp->xc_ctx->ticket"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3496-3503",
          "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxlog_cil_destroy(\n\tstruct xlog\t*log)\n{\n\tif (log->l_cilp->xc_ctx) {\n\t\tif (log->l_cilp->xc_ctx->ticket)\n\t\t\txfs_log_ticket_put(log->l_cilp->xc_ctx->ticket);\n\t\tkmem_free(log->l_cilp->xc_ctx);\n\t}\n\n\tASSERT(list_empty(&log->l_cilp->xc_cil));\n\tkmem_free(log->l_cilp);\n}"
  },
  {
    "function_name": "xlog_cil_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "948-983",
    "snippet": "int\nxlog_cil_init(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil;\n\tstruct xfs_cil_ctx *ctx;\n\n\tcil = kmem_zalloc(sizeof(*cil), KM_SLEEP|KM_MAYFAIL);\n\tif (!cil)\n\t\treturn -ENOMEM;\n\n\tctx = kmem_zalloc(sizeof(*ctx), KM_SLEEP|KM_MAYFAIL);\n\tif (!ctx) {\n\t\tkmem_free(cil);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&cil->xc_push_work, xlog_cil_push_work);\n\tINIT_LIST_HEAD(&cil->xc_cil);\n\tINIT_LIST_HEAD(&cil->xc_committing);\n\tspin_lock_init(&cil->xc_cil_lock);\n\tspin_lock_init(&cil->xc_push_lock);\n\tinit_rwsem(&cil->xc_ctx_lock);\n\tinit_waitqueue_head(&cil->xc_commit_wait);\n\n\tINIT_LIST_HEAD(&ctx->committing);\n\tINIT_LIST_HEAD(&ctx->busy_extents);\n\tctx->sequence = 1;\n\tctx->cil = cil;\n\tcil->xc_ctx = ctx;\n\tcil->xc_current_sequence = ctx->sequence;\n\n\tcil->xc_log = log;\n\tlog->l_cilp = cil;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctx->busy_extents"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ctx->committing"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&cil->xc_commit_wait"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&cil->xc_ctx_lock"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cil->xc_cil_lock"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cil->xc_committing"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cil->xc_cil"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cil->xc_push_work",
            "xlog_cil_push_work"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "cil"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*ctx)",
            "KM_SLEEP|KM_MAYFAIL"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxlog_cil_init(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil;\n\tstruct xfs_cil_ctx *ctx;\n\n\tcil = kmem_zalloc(sizeof(*cil), KM_SLEEP|KM_MAYFAIL);\n\tif (!cil)\n\t\treturn -ENOMEM;\n\n\tctx = kmem_zalloc(sizeof(*ctx), KM_SLEEP|KM_MAYFAIL);\n\tif (!ctx) {\n\t\tkmem_free(cil);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_WORK(&cil->xc_push_work, xlog_cil_push_work);\n\tINIT_LIST_HEAD(&cil->xc_cil);\n\tINIT_LIST_HEAD(&cil->xc_committing);\n\tspin_lock_init(&cil->xc_cil_lock);\n\tspin_lock_init(&cil->xc_push_lock);\n\tinit_rwsem(&cil->xc_ctx_lock);\n\tinit_waitqueue_head(&cil->xc_commit_wait);\n\n\tINIT_LIST_HEAD(&ctx->committing);\n\tINIT_LIST_HEAD(&ctx->busy_extents);\n\tctx->sequence = 1;\n\tctx->cil = cil;\n\tcil->xc_ctx = ctx;\n\tcil->xc_current_sequence = ctx->sequence;\n\n\tcil->xc_log = log;\n\tlog->l_cilp = cil;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_log_item_in_current_chkpt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "924-943",
    "snippet": "bool\nxfs_log_item_in_current_chkpt(\n\tstruct xfs_log_item *lip)\n{\n\tstruct xfs_cil_ctx *ctx;\n\n\tif (list_empty(&lip->li_cil))\n\t\treturn false;\n\n\tctx = lip->li_mountp->m_log->l_cilp->xc_ctx;\n\n\t/*\n\t * li_seq is written on the first commit of a log item to record the\n\t * first checkpoint it is written to. Hence if it is different to the\n\t * current sequence, we're in a new checkpoint.\n\t */\n\tif (XFS_LSN_CMP(lip->li_seq, ctx->sequence) != 0)\n\t\treturn false;\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_LSN_CMP",
          "args": [
            "lip->li_seq",
            "ctx->sequence"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lip->li_cil"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxfs_log_item_in_current_chkpt(\n\tstruct xfs_log_item *lip)\n{\n\tstruct xfs_cil_ctx *ctx;\n\n\tif (list_empty(&lip->li_cil))\n\t\treturn false;\n\n\tctx = lip->li_mountp->m_log->l_cilp->xc_ctx;\n\n\t/*\n\t * li_seq is written on the first commit of a log item to record the\n\t * first checkpoint it is written to. Hence if it is different to the\n\t * current sequence, we're in a new checkpoint.\n\t */\n\tif (XFS_LSN_CMP(lip->li_seq, ctx->sequence) != 0)\n\t\treturn false;\n\treturn true;\n}"
  },
  {
    "function_name": "xlog_cil_force_lsn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "829-913",
    "snippet": "xfs_lsn_t\nxlog_cil_force_lsn(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tsequence)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx;\n\txfs_lsn_t\t\tcommit_lsn = NULLCOMMITLSN;\n\n\tASSERT(sequence <= cil->xc_current_sequence);\n\n\t/*\n\t * check to see if we need to force out the current context.\n\t * xlog_cil_push() handles racing pushes for the same sequence,\n\t * so no need to deal with it here.\n\t */\nrestart:\n\txlog_cil_push_now(log, sequence);\n\n\t/*\n\t * See if we can find a previous sequence still committing.\n\t * We need to wait for all previous sequence commits to complete\n\t * before allowing the force of push_seq to go ahead. Hence block\n\t * on commits for those as well.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(ctx, &cil->xc_committing, committing) {\n\t\t/*\n\t\t * Avoid getting stuck in this loop because we were woken by the\n\t\t * shutdown, but then went back to sleep once already in the\n\t\t * shutdown state.\n\t\t */\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto out_shutdown;\n\t\tif (ctx->sequence > sequence)\n\t\t\tcontinue;\n\t\tif (!ctx->commit_lsn) {\n\t\t\t/*\n\t\t\t * It is still being pushed! Wait for the push to\n\t\t\t * complete, then start again from the beginning.\n\t\t\t */\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (ctx->sequence != sequence)\n\t\t\tcontinue;\n\t\t/* found it! */\n\t\tcommit_lsn = ctx->commit_lsn;\n\t}\n\n\t/*\n\t * The call to xlog_cil_push_now() executes the push in the background.\n\t * Hence by the time we have got here it our sequence may not have been\n\t * pushed yet. This is true if the current sequence still matches the\n\t * push sequence after the above wait loop and the CIL still contains\n\t * dirty objects. This is guaranteed by the push code first adding the\n\t * context to the committing list before emptying the CIL.\n\t *\n\t * Hence if we don't find the context in the committing list and the\n\t * current sequence number is unchanged then the CIL contents are\n\t * significant.  If the CIL is empty, if means there was nothing to push\n\t * and that means there is nothing to wait for. If the CIL is not empty,\n\t * it means we haven't yet started the push, because if it had started\n\t * we would have found the context on the committing list.\n\t */\n\tif (sequence == cil->xc_current_sequence &&\n\t    !list_empty(&cil->xc_cil)) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto restart;\n\t}\n\n\tspin_unlock(&cil->xc_push_lock);\n\treturn commit_lsn;\n\n\t/*\n\t * We detected a shutdown in progress. We need to trigger the log force\n\t * to pass through it's iclog state machine error handling, even though\n\t * we are already in a shutdown state. Hence we can't return\n\t * NULLCOMMITLSN here as that has special meaning to log forces (i.e.\n\t * LSN is already stable), so we return a zero LSN instead.\n\t */\nout_shutdown:\n\tspin_unlock(&cil->xc_push_lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cil->xc_cil"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_wait",
          "args": [
            "&cil->xc_commit_wait",
            "&cil->xc_push_lock"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "550-559",
          "snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ctx",
            "&cil->xc_committing",
            "committing"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_cil_push_now",
          "args": [
            "log",
            "sequence"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_push_now",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "714-742",
          "snippet": "static void\nxlog_cil_push_now(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tpush_seq)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\tif (!cil)\n\t\treturn;\n\n\tASSERT(push_seq && push_seq <= cil->xc_current_sequence);\n\n\t/* start on any pending background push to minimise wait time on it */\n\tflush_work(&cil->xc_push_work);\n\n\t/*\n\t * If the CIL is empty or we've already pushed the sequence then\n\t * there's no work we need to do.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tif (list_empty(&cil->xc_cil) || push_seq <= cil->xc_push_seq) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\treturn;\n\t}\n\n\tcil->xc_push_seq = push_seq;\n\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\tspin_unlock(&cil->xc_push_lock);\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_push_now(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tpush_seq)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\tif (!cil)\n\t\treturn;\n\n\tASSERT(push_seq && push_seq <= cil->xc_current_sequence);\n\n\t/* start on any pending background push to minimise wait time on it */\n\tflush_work(&cil->xc_push_work);\n\n\t/*\n\t * If the CIL is empty or we've already pushed the sequence then\n\t * there's no work we need to do.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tif (list_empty(&cil->xc_cil) || push_seq <= cil->xc_push_seq) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\treturn;\n\t}\n\n\tcil->xc_push_seq = push_seq;\n\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\tspin_unlock(&cil->xc_push_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "sequence <= cil->xc_current_sequence"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_lsn_t\nxlog_cil_force_lsn(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tsequence)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx;\n\txfs_lsn_t\t\tcommit_lsn = NULLCOMMITLSN;\n\n\tASSERT(sequence <= cil->xc_current_sequence);\n\n\t/*\n\t * check to see if we need to force out the current context.\n\t * xlog_cil_push() handles racing pushes for the same sequence,\n\t * so no need to deal with it here.\n\t */\nrestart:\n\txlog_cil_push_now(log, sequence);\n\n\t/*\n\t * See if we can find a previous sequence still committing.\n\t * We need to wait for all previous sequence commits to complete\n\t * before allowing the force of push_seq to go ahead. Hence block\n\t * on commits for those as well.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(ctx, &cil->xc_committing, committing) {\n\t\t/*\n\t\t * Avoid getting stuck in this loop because we were woken by the\n\t\t * shutdown, but then went back to sleep once already in the\n\t\t * shutdown state.\n\t\t */\n\t\tif (XLOG_FORCED_SHUTDOWN(log))\n\t\t\tgoto out_shutdown;\n\t\tif (ctx->sequence > sequence)\n\t\t\tcontinue;\n\t\tif (!ctx->commit_lsn) {\n\t\t\t/*\n\t\t\t * It is still being pushed! Wait for the push to\n\t\t\t * complete, then start again from the beginning.\n\t\t\t */\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t\tif (ctx->sequence != sequence)\n\t\t\tcontinue;\n\t\t/* found it! */\n\t\tcommit_lsn = ctx->commit_lsn;\n\t}\n\n\t/*\n\t * The call to xlog_cil_push_now() executes the push in the background.\n\t * Hence by the time we have got here it our sequence may not have been\n\t * pushed yet. This is true if the current sequence still matches the\n\t * push sequence after the above wait loop and the CIL still contains\n\t * dirty objects. This is guaranteed by the push code first adding the\n\t * context to the committing list before emptying the CIL.\n\t *\n\t * Hence if we don't find the context in the committing list and the\n\t * current sequence number is unchanged then the CIL contents are\n\t * significant.  If the CIL is empty, if means there was nothing to push\n\t * and that means there is nothing to wait for. If the CIL is not empty,\n\t * it means we haven't yet started the push, because if it had started\n\t * we would have found the context on the committing list.\n\t */\n\tif (sequence == cil->xc_current_sequence &&\n\t    !list_empty(&cil->xc_cil)) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto restart;\n\t}\n\n\tspin_unlock(&cil->xc_push_lock);\n\treturn commit_lsn;\n\n\t/*\n\t * We detected a shutdown in progress. We need to trigger the log force\n\t * to pass through it's iclog state machine error handling, even though\n\t * we are already in a shutdown state. Hence we can't return\n\t * NULLCOMMITLSN here as that has special meaning to log forces (i.e.\n\t * LSN is already stable), so we return a zero LSN instead.\n\t */\nout_shutdown:\n\tspin_unlock(&cil->xc_push_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_log_commit_cil",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "771-817",
    "snippet": "void\nxfs_log_commit_cil(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\t*commit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tint\t\t\tlog_flags = 0;\n\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES)\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\n\t/* lock out background commit */\n\tdown_read(&cil->xc_ctx_lock);\n\n\txlog_cil_insert_items(log, tp);\n\n\t/* check we didn't blow the reservation */\n\tif (tp->t_ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(mp, tp->t_ticket);\n\n\ttp->t_commit_lsn = cil->xc_ctx->sequence;\n\tif (commit_lsn)\n\t\t*commit_lsn = tp->t_commit_lsn;\n\n\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * Once all the items of the transaction have been copied to the CIL,\n\t * the items can be unlocked and freed.\n\t *\n\t * This needs to be done before we drop the CIL context lock because we\n\t * have to update state in the log items and unlock them before they go\n\t * to disk. If we don't, then the CIL checkpoint can race with us and\n\t * we can run checkpoint completion before we've updated and unlocked\n\t * the log items. This affects (at least) processing of stale buffers,\n\t * inodes and EFIs.\n\t */\n\txfs_trans_free_items(tp, tp->t_commit_lsn, 0);\n\n\txlog_cil_push_background(log);\n\n\tup_read(&cil->xc_ctx_lock);\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&cil->xc_ctx_lock"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_cil_push_background",
          "args": [
            "log"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_push_background",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "680-706",
          "snippet": "static void\nxlog_cil_push_background(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\t/*\n\t * The cil won't be empty because we are called while holding the\n\t * context lock so whatever we added to the CIL will still be there\n\t */\n\tASSERT(!list_empty(&cil->xc_cil));\n\n\t/*\n\t * don't do a background push if we haven't used up all the\n\t * space available yet.\n\t */\n\tif (cil->xc_ctx->space_used < XLOG_CIL_SPACE_LIMIT(log))\n\t\treturn;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (cil->xc_push_seq < cil->xc_current_sequence) {\n\t\tcil->xc_push_seq = cil->xc_current_sequence;\n\t\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_push_background(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\t/*\n\t * The cil won't be empty because we are called while holding the\n\t * context lock so whatever we added to the CIL will still be there\n\t */\n\tASSERT(!list_empty(&cil->xc_cil));\n\n\t/*\n\t * don't do a background push if we haven't used up all the\n\t * space available yet.\n\t */\n\tif (cil->xc_ctx->space_used < XLOG_CIL_SPACE_LIMIT(log))\n\t\treturn;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (cil->xc_push_seq < cil->xc_current_sequence) {\n\t\tcil->xc_push_seq = cil->xc_current_sequence;\n\t\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_free_items",
          "args": [
            "tp",
            "tp->t_commit_lsn",
            "0"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_free_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "693-714",
          "snippet": "void\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xfs_log_item_desc *lidp, *next;\n\n\tlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\tlip->li_desc = NULL;\n\n\t\tif (commit_lsn != NULLCOMMITLSN)\n\t\t\tlip->li_ops->iop_committing(lip, commit_lsn);\n\t\tif (flags & XFS_TRANS_ABORT)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\tlip->li_ops->iop_unlock(lip);\n\n\t\txfs_trans_free_item_desc(lidp);\n\t}\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_free_items(\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xfs_log_item_desc *lidp, *next;\n\n\tlist_for_each_entry_safe(lidp, next, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\tlip->li_desc = NULL;\n\n\t\tif (commit_lsn != NULLCOMMITLSN)\n\t\t\tlip->li_ops->iop_committing(lip, commit_lsn);\n\t\tif (flags & XFS_TRANS_ABORT)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\tlip->li_ops->iop_unlock(lip);\n\n\t\txfs_trans_free_item_desc(lidp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_unreserve_and_mod_sb",
          "args": [
            "tp"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_unreserve_and_mod_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "510-644",
          "snippet": "void\nxfs_trans_unreserve_and_mod_sb(\n\txfs_trans_t\t*tp)\n{\n\txfs_mod_sb_t\tmsb[9];\t/* If you add cases, add entries */\n\txfs_mod_sb_t\t*msbp;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\t/* REFERENCED */\n\tint\t\terror;\n\tint\t\trsvd;\n\tint64_t\t\tblkdelta = 0;\n\tint64_t\t\trtxdelta = 0;\n\tint64_t\t\tidelta = 0;\n\tint64_t\t\tifreedelta = 0;\n\n\tmsbp = msb;\n\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* calculate deltas */\n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t/* apply the per-cpu counters */\n\tif (blkdelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t blkdelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (idelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT,\n\t\t\t\t\t\t idelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_fdblocks;\n\t}\n\n\tif (ifreedelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,\n\t\t\t\t\t\t ifreedelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_icount;\n\t}\n\n\t/* apply remaining deltas */\n\tif (rtxdelta != 0) {\n\t\tmsbp->msb_field = XFS_SBS_FREXTENTS;\n\t\tmsbp->msb_delta = rtxdelta;\n\t\tmsbp++;\n\t}\n\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY) {\n\t\tif (tp->t_dblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_DBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_dblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_agcount_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_AGCOUNT;\n\t\t\tmsbp->msb_delta = tp->t_agcount_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_imaxpct_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_IMAX_PCT;\n\t\t\tmsbp->msb_delta = tp->t_imaxpct_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextsize_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSIZE;\n\t\t\tmsbp->msb_delta = tp->t_rextsize_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rbmblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBMBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rbmblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextents_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTENTS;\n\t\t\tmsbp->msb_delta = tp->t_rextents_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextslog_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSLOG;\n\t\t\tmsbp->msb_delta = tp->t_rextslog_delta;\n\t\t\tmsbp++;\n\t\t}\n\t}\n\n\t/*\n\t * If we need to change anything, do it.\n\t */\n\tif (msbp > msb) {\n\t\terror = xfs_mod_incore_sb_batch(tp->t_mountp, msb,\n\t\t\t(uint)(msbp - msb), rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_ifreecount;\n\t}\n\n\treturn;\n\nout_undo_ifreecount:\n\tif (ifreedelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);\nout_undo_icount:\n\tif (idelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);\nout_undo_fdblocks:\n\tif (blkdelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, -blkdelta, rsvd);\nout:\n\tASSERT(error == 0);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_unreserve_and_mod_sb(\n\txfs_trans_t\t*tp)\n{\n\txfs_mod_sb_t\tmsb[9];\t/* If you add cases, add entries */\n\txfs_mod_sb_t\t*msbp;\n\txfs_mount_t\t*mp = tp->t_mountp;\n\t/* REFERENCED */\n\tint\t\terror;\n\tint\t\trsvd;\n\tint64_t\t\tblkdelta = 0;\n\tint64_t\t\trtxdelta = 0;\n\tint64_t\t\tidelta = 0;\n\tint64_t\t\tifreedelta = 0;\n\n\tmsbp = msb;\n\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* calculate deltas */\n\tif (tp->t_blk_res > 0)\n\t\tblkdelta = tp->t_blk_res;\n\tif ((tp->t_fdblocks_delta != 0) &&\n\t    (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)))\n\t        blkdelta += tp->t_fdblocks_delta;\n\n\tif (tp->t_rtx_res > 0)\n\t\trtxdelta = tp->t_rtx_res;\n\tif ((tp->t_frextents_delta != 0) &&\n\t    (tp->t_flags & XFS_TRANS_SB_DIRTY))\n\t\trtxdelta += tp->t_frextents_delta;\n\n\tif (xfs_sb_version_haslazysbcount(&mp->m_sb) ||\n\t     (tp->t_flags & XFS_TRANS_SB_DIRTY)) {\n\t\tidelta = tp->t_icount_delta;\n\t\tifreedelta = tp->t_ifree_delta;\n\t}\n\n\t/* apply the per-cpu counters */\n\tif (blkdelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t blkdelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\n\tif (idelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT,\n\t\t\t\t\t\t idelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_fdblocks;\n\t}\n\n\tif (ifreedelta) {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_IFREE,\n\t\t\t\t\t\t ifreedelta, rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_icount;\n\t}\n\n\t/* apply remaining deltas */\n\tif (rtxdelta != 0) {\n\t\tmsbp->msb_field = XFS_SBS_FREXTENTS;\n\t\tmsbp->msb_delta = rtxdelta;\n\t\tmsbp++;\n\t}\n\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY) {\n\t\tif (tp->t_dblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_DBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_dblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_agcount_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_AGCOUNT;\n\t\t\tmsbp->msb_delta = tp->t_agcount_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_imaxpct_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_IMAX_PCT;\n\t\t\tmsbp->msb_delta = tp->t_imaxpct_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextsize_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSIZE;\n\t\t\tmsbp->msb_delta = tp->t_rextsize_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rbmblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBMBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rbmblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rblocks_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_RBLOCKS;\n\t\t\tmsbp->msb_delta = tp->t_rblocks_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextents_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTENTS;\n\t\t\tmsbp->msb_delta = tp->t_rextents_delta;\n\t\t\tmsbp++;\n\t\t}\n\t\tif (tp->t_rextslog_delta != 0) {\n\t\t\tmsbp->msb_field = XFS_SBS_REXTSLOG;\n\t\t\tmsbp->msb_delta = tp->t_rextslog_delta;\n\t\t\tmsbp++;\n\t\t}\n\t}\n\n\t/*\n\t * If we need to change anything, do it.\n\t */\n\tif (msbp > msb) {\n\t\terror = xfs_mod_incore_sb_batch(tp->t_mountp, msb,\n\t\t\t(uint)(msbp - msb), rsvd);\n\t\tif (error)\n\t\t\tgoto out_undo_ifreecount;\n\t}\n\n\treturn;\n\nout_undo_ifreecount:\n\tif (ifreedelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_IFREE, -ifreedelta, rsvd);\nout_undo_icount:\n\tif (idelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_ICOUNT, -idelta, rsvd);\nout_undo_fdblocks:\n\tif (blkdelta)\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, -blkdelta, rsvd);\nout:\n\tASSERT(error == 0);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_done",
          "args": [
            "mp",
            "tp->t_ticket",
            "NULL",
            "log_flags"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "511-557",
          "snippet": "xfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_print_tic_res",
          "args": [
            "mp",
            "tp->t_ticket"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_cil_insert_items",
          "args": [
            "log",
            "tp"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_insert_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "277-351",
          "snippet": "static void\nxlog_cil_insert_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx = cil->xc_ctx;\n\tstruct xfs_log_item_desc *lidp;\n\tint\t\t\tlen = 0;\n\tint\t\t\tdiff_iovecs = 0;\n\tint\t\t\ticlog_space;\n\n\tASSERT(tp);\n\n\t/*\n\t * We can do this safely because the context can't checkpoint until we\n\t * are done so it doesn't matter exactly how we update the CIL.\n\t */\n\txlog_cil_insert_format_items(log, tp, &len, &diff_iovecs);\n\n\t/*\n\t * Now (re-)position everything modified at the tail of the CIL.\n\t * We do this here so we only need to take the CIL lock once during\n\t * the transaction commit.\n\t */\n\tspin_lock(&cil->xc_cil_lock);\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\t/* Skip items which aren't dirty in this transaction. */\n\t\tif (!(lidp->lid_flags & XFS_LID_DIRTY))\n\t\t\tcontinue;\n\n\t\tlist_move_tail(&lip->li_cil, &cil->xc_cil);\n\t}\n\n\t/* account for space used by new iovec headers  */\n\tlen += diff_iovecs * sizeof(xlog_op_header_t);\n\tctx->nvecs += diff_iovecs;\n\n\t/* attach the transaction to the CIL if it has any busy extents */\n\tif (!list_empty(&tp->t_busy))\n\t\tlist_splice_init(&tp->t_busy, &ctx->busy_extents);\n\n\t/*\n\t * Now transfer enough transaction reservation to the context ticket\n\t * for the checkpoint. The context ticket is special - the unit\n\t * reservation has to grow as well as the current reservation as we\n\t * steal from tickets so we can correctly determine the space used\n\t * during the transaction commit.\n\t */\n\tif (ctx->ticket->t_curr_res == 0) {\n\t\tctx->ticket->t_curr_res = ctx->ticket->t_unit_res;\n\t\ttp->t_ticket->t_curr_res -= ctx->ticket->t_unit_res;\n\t}\n\n\t/* do we need space for more log record headers? */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tif (len > 0 && (ctx->space_used / iclog_space !=\n\t\t\t\t(ctx->space_used + len) / iclog_space)) {\n\t\tint hdrs;\n\n\t\thdrs = (len + iclog_space - 1) / iclog_space;\n\t\t/* need to take into account split region headers, too */\n\t\thdrs *= log->l_iclog_hsize + sizeof(struct xlog_op_header);\n\t\tctx->ticket->t_unit_res += hdrs;\n\t\tctx->ticket->t_curr_res += hdrs;\n\t\ttp->t_ticket->t_curr_res -= hdrs;\n\t\tASSERT(tp->t_ticket->t_curr_res >= len);\n\t}\n\ttp->t_ticket->t_curr_res -= len;\n\tctx->space_used += len;\n\n\tspin_unlock(&cil->xc_cil_lock);\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_insert_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx = cil->xc_ctx;\n\tstruct xfs_log_item_desc *lidp;\n\tint\t\t\tlen = 0;\n\tint\t\t\tdiff_iovecs = 0;\n\tint\t\t\ticlog_space;\n\n\tASSERT(tp);\n\n\t/*\n\t * We can do this safely because the context can't checkpoint until we\n\t * are done so it doesn't matter exactly how we update the CIL.\n\t */\n\txlog_cil_insert_format_items(log, tp, &len, &diff_iovecs);\n\n\t/*\n\t * Now (re-)position everything modified at the tail of the CIL.\n\t * We do this here so we only need to take the CIL lock once during\n\t * the transaction commit.\n\t */\n\tspin_lock(&cil->xc_cil_lock);\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\t/* Skip items which aren't dirty in this transaction. */\n\t\tif (!(lidp->lid_flags & XFS_LID_DIRTY))\n\t\t\tcontinue;\n\n\t\tlist_move_tail(&lip->li_cil, &cil->xc_cil);\n\t}\n\n\t/* account for space used by new iovec headers  */\n\tlen += diff_iovecs * sizeof(xlog_op_header_t);\n\tctx->nvecs += diff_iovecs;\n\n\t/* attach the transaction to the CIL if it has any busy extents */\n\tif (!list_empty(&tp->t_busy))\n\t\tlist_splice_init(&tp->t_busy, &ctx->busy_extents);\n\n\t/*\n\t * Now transfer enough transaction reservation to the context ticket\n\t * for the checkpoint. The context ticket is special - the unit\n\t * reservation has to grow as well as the current reservation as we\n\t * steal from tickets so we can correctly determine the space used\n\t * during the transaction commit.\n\t */\n\tif (ctx->ticket->t_curr_res == 0) {\n\t\tctx->ticket->t_curr_res = ctx->ticket->t_unit_res;\n\t\ttp->t_ticket->t_curr_res -= ctx->ticket->t_unit_res;\n\t}\n\n\t/* do we need space for more log record headers? */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tif (len > 0 && (ctx->space_used / iclog_space !=\n\t\t\t\t(ctx->space_used + len) / iclog_space)) {\n\t\tint hdrs;\n\n\t\thdrs = (len + iclog_space - 1) / iclog_space;\n\t\t/* need to take into account split region headers, too */\n\t\thdrs *= log->l_iclog_hsize + sizeof(struct xlog_op_header);\n\t\tctx->ticket->t_unit_res += hdrs;\n\t\tctx->ticket->t_curr_res += hdrs;\n\t\ttp->t_ticket->t_curr_res -= hdrs;\n\t\tASSERT(tp->t_ticket->t_curr_res >= len);\n\t}\n\ttp->t_ticket->t_curr_res -= len;\n\tctx->space_used += len;\n\n\tspin_unlock(&cil->xc_cil_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&cil->xc_ctx_lock"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_commit_cil(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_trans\t*tp,\n\txfs_lsn_t\t\t*commit_lsn,\n\tint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tint\t\t\tlog_flags = 0;\n\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES)\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\n\t/* lock out background commit */\n\tdown_read(&cil->xc_ctx_lock);\n\n\txlog_cil_insert_items(log, tp);\n\n\t/* check we didn't blow the reservation */\n\tif (tp->t_ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(mp, tp->t_ticket);\n\n\ttp->t_commit_lsn = cil->xc_ctx->sequence;\n\tif (commit_lsn)\n\t\t*commit_lsn = tp->t_commit_lsn;\n\n\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * Once all the items of the transaction have been copied to the CIL,\n\t * the items can be unlocked and freed.\n\t *\n\t * This needs to be done before we drop the CIL context lock because we\n\t * have to update state in the log items and unlock them before they go\n\t * to disk. If we don't, then the CIL checkpoint can race with us and\n\t * we can run checkpoint completion before we've updated and unlocked\n\t * the log items. This affects (at least) processing of stale buffers,\n\t * inodes and EFIs.\n\t */\n\txfs_trans_free_items(tp, tp->t_commit_lsn, 0);\n\n\txlog_cil_push_background(log);\n\n\tup_read(&cil->xc_ctx_lock);\n}"
  },
  {
    "function_name": "xlog_cil_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "744-756",
    "snippet": "bool\nxlog_cil_empty(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\tbool\t\tempty = false;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (list_empty(&cil->xc_cil))\n\t\tempty = true;\n\tspin_unlock(&cil->xc_push_lock);\n\treturn empty;\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cil->xc_cil"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nbool\nxlog_cil_empty(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\tbool\t\tempty = false;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (list_empty(&cil->xc_cil))\n\t\tempty = true;\n\tspin_unlock(&cil->xc_push_lock);\n\treturn empty;\n}"
  },
  {
    "function_name": "xlog_cil_push_now",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "714-742",
    "snippet": "static void\nxlog_cil_push_now(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tpush_seq)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\tif (!cil)\n\t\treturn;\n\n\tASSERT(push_seq && push_seq <= cil->xc_current_sequence);\n\n\t/* start on any pending background push to minimise wait time on it */\n\tflush_work(&cil->xc_push_work);\n\n\t/*\n\t * If the CIL is empty or we've already pushed the sequence then\n\t * there's no work we need to do.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tif (list_empty(&cil->xc_cil) || push_seq <= cil->xc_push_seq) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\treturn;\n\t}\n\n\tcil->xc_push_seq = push_seq;\n\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\tspin_unlock(&cil->xc_push_lock);\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "log->l_mp->m_cil_workqueue",
            "&cil->xc_push_work"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cil->xc_cil"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&cil->xc_push_work"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "push_seq && push_seq <= cil->xc_current_sequence"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_push_now(\n\tstruct xlog\t*log,\n\txfs_lsn_t\tpush_seq)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\tif (!cil)\n\t\treturn;\n\n\tASSERT(push_seq && push_seq <= cil->xc_current_sequence);\n\n\t/* start on any pending background push to minimise wait time on it */\n\tflush_work(&cil->xc_push_work);\n\n\t/*\n\t * If the CIL is empty or we've already pushed the sequence then\n\t * there's no work we need to do.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tif (list_empty(&cil->xc_cil) || push_seq <= cil->xc_push_seq) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\treturn;\n\t}\n\n\tcil->xc_push_seq = push_seq;\n\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\tspin_unlock(&cil->xc_push_lock);\n}"
  },
  {
    "function_name": "xlog_cil_push_background",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "680-706",
    "snippet": "static void\nxlog_cil_push_background(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\t/*\n\t * The cil won't be empty because we are called while holding the\n\t * context lock so whatever we added to the CIL will still be there\n\t */\n\tASSERT(!list_empty(&cil->xc_cil));\n\n\t/*\n\t * don't do a background push if we haven't used up all the\n\t * space available yet.\n\t */\n\tif (cil->xc_ctx->space_used < XLOG_CIL_SPACE_LIMIT(log))\n\t\treturn;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (cil->xc_push_seq < cil->xc_current_sequence) {\n\t\tcil->xc_push_seq = cil->xc_current_sequence;\n\t\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "log->l_mp->m_cil_workqueue",
            "&cil->xc_push_work"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "bdi_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "108-123",
          "snippet": "static void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void bdi_queue_work(struct backing_dev_info *bdi,\n\t\t\t   struct wb_writeback_work *work)\n{\n\ttrace_writeback_queue(bdi, work);\n\n\tspin_lock_bh(&bdi->wb_lock);\n\tif (!test_bit(BDI_registered, &bdi->state)) {\n\t\tif (work->done)\n\t\t\tcomplete(work->done);\n\t\tgoto out_unlock;\n\t}\n\tlist_add_tail(&work->list, &bdi->work_list);\n\tmod_delayed_work(bdi_wq, &bdi->wb.dwork, 0);\nout_unlock:\n\tspin_unlock_bh(&bdi->wb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XLOG_CIL_SPACE_LIMIT",
          "args": [
            "log"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!list_empty(&cil->xc_cil)"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cil->xc_cil"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_push_background(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\t/*\n\t * The cil won't be empty because we are called while holding the\n\t * context lock so whatever we added to the CIL will still be there\n\t */\n\tASSERT(!list_empty(&cil->xc_cil));\n\n\t/*\n\t * don't do a background push if we haven't used up all the\n\t * space available yet.\n\t */\n\tif (cil->xc_ctx->space_used < XLOG_CIL_SPACE_LIMIT(log))\n\t\treturn;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (cil->xc_push_seq < cil->xc_current_sequence) {\n\t\tcil->xc_push_seq = cil->xc_current_sequence;\n\t\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\n}"
  },
  {
    "function_name": "xlog_cil_push_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "664-671",
    "snippet": "static void\nxlog_cil_push_work(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_cil\t\t*cil = container_of(work, struct xfs_cil,\n\t\t\t\t\t\t\txc_push_work);\n\txlog_cil_push(cil->xc_log);\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_cil_push",
          "args": [
            "cil->xc_log"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_push_background",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "680-706",
          "snippet": "static void\nxlog_cil_push_background(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\t/*\n\t * The cil won't be empty because we are called while holding the\n\t * context lock so whatever we added to the CIL will still be there\n\t */\n\tASSERT(!list_empty(&cil->xc_cil));\n\n\t/*\n\t * don't do a background push if we haven't used up all the\n\t * space available yet.\n\t */\n\tif (cil->xc_ctx->space_used < XLOG_CIL_SPACE_LIMIT(log))\n\t\treturn;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (cil->xc_push_seq < cil->xc_current_sequence) {\n\t\tcil->xc_push_seq = cil->xc_current_sequence;\n\t\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_push_background(\n\tstruct xlog\t*log)\n{\n\tstruct xfs_cil\t*cil = log->l_cilp;\n\n\t/*\n\t * The cil won't be empty because we are called while holding the\n\t * context lock so whatever we added to the CIL will still be there\n\t */\n\tASSERT(!list_empty(&cil->xc_cil));\n\n\t/*\n\t * don't do a background push if we haven't used up all the\n\t * space available yet.\n\t */\n\tif (cil->xc_ctx->space_used < XLOG_CIL_SPACE_LIMIT(log))\n\t\treturn;\n\n\tspin_lock(&cil->xc_push_lock);\n\tif (cil->xc_push_seq < cil->xc_current_sequence) {\n\t\tcil->xc_push_seq = cil->xc_current_sequence;\n\t\tqueue_work(log->l_mp->m_cil_workqueue, &cil->xc_push_work);\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structxfs_cil",
            "xc_push_work"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_push_work(\n\tstruct work_struct\t*work)\n{\n\tstruct xfs_cil\t\t*cil = container_of(work, struct xfs_cil,\n\t\t\t\t\t\t\txc_push_work);\n\txlog_cil_push(cil->xc_log);\n}"
  },
  {
    "function_name": "xlog_cil_push",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "424-662",
    "snippet": "STATIC int\nxlog_cil_push(\n\tstruct xlog\t\t*log)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_log_vec\t*lv;\n\tstruct xfs_cil_ctx\t*ctx;\n\tstruct xfs_cil_ctx\t*new_ctx;\n\tstruct xlog_in_core\t*commit_iclog;\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tnum_iovecs;\n\tint\t\t\terror = 0;\n\tstruct xfs_trans_header thdr;\n\tstruct xfs_log_iovec\tlhdr;\n\tstruct xfs_log_vec\tlvhdr = { NULL };\n\txfs_lsn_t\t\tcommit_lsn;\n\txfs_lsn_t\t\tpush_seq;\n\n\tif (!cil)\n\t\treturn 0;\n\n\tnew_ctx = kmem_zalloc(sizeof(*new_ctx), KM_SLEEP|KM_NOFS);\n\tnew_ctx->ticket = xlog_cil_ticket_alloc(log);\n\n\tdown_write(&cil->xc_ctx_lock);\n\tctx = cil->xc_ctx;\n\n\tspin_lock(&cil->xc_push_lock);\n\tpush_seq = cil->xc_push_seq;\n\tASSERT(push_seq <= ctx->sequence);\n\n\t/*\n\t * Check if we've anything to push. If there is nothing, then we don't\n\t * move on to a new sequence number and so we have to be able to push\n\t * this sequence again later.\n\t */\n\tif (list_empty(&cil->xc_cil)) {\n\t\tcil->xc_push_seq = 0;\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto out_skip;\n\t}\n\n\n\t/* check for a previously pushed seqeunce */\n\tif (push_seq < cil->xc_ctx->sequence) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto out_skip;\n\t}\n\n\t/*\n\t * We are now going to push this context, so add it to the committing\n\t * list before we do anything else. This ensures that anyone waiting on\n\t * this push can easily detect the difference between a \"push in\n\t * progress\" and \"CIL is empty, nothing to do\".\n\t *\n\t * IOWs, a wait loop can now check for:\n\t *\tthe current sequence not being found on the committing list;\n\t *\tan empty CIL; and\n\t *\tan unchanged sequence number\n\t * to detect a push that had nothing to do and therefore does not need\n\t * waiting on. If the CIL is not empty, we get put on the committing\n\t * list before emptying the CIL and bumping the sequence number. Hence\n\t * an empty CIL and an unchanged sequence number means we jumped out\n\t * above after doing nothing.\n\t *\n\t * Hence the waiter will either find the commit sequence on the\n\t * committing list or the sequence number will be unchanged and the CIL\n\t * still dirty. In that latter case, the push has not yet started, and\n\t * so the waiter will have to continue trying to check the CIL\n\t * committing list until it is found. In extreme cases of delay, the\n\t * sequence may fully commit between the attempts the wait makes to wait\n\t * on the commit sequence.\n\t */\n\tlist_add(&ctx->committing, &cil->xc_committing);\n\tspin_unlock(&cil->xc_push_lock);\n\n\t/*\n\t * pull all the log vectors off the items in the CIL, and\n\t * remove the items from the CIL. We don't need the CIL lock\n\t * here because it's only needed on the transaction commit\n\t * side which is currently locked out by the flush lock.\n\t */\n\tlv = NULL;\n\tnum_iovecs = 0;\n\twhile (!list_empty(&cil->xc_cil)) {\n\t\tstruct xfs_log_item\t*item;\n\n\t\titem = list_first_entry(&cil->xc_cil,\n\t\t\t\t\tstruct xfs_log_item, li_cil);\n\t\tlist_del_init(&item->li_cil);\n\t\tif (!ctx->lv_chain)\n\t\t\tctx->lv_chain = item->li_lv;\n\t\telse\n\t\t\tlv->lv_next = item->li_lv;\n\t\tlv = item->li_lv;\n\t\titem->li_lv = NULL;\n\t\tnum_iovecs += lv->lv_niovecs;\n\t}\n\n\t/*\n\t * initialise the new context and attach it to the CIL. Then attach\n\t * the current context to the CIL committing lsit so it can be found\n\t * during log forces to extract the commit lsn of the sequence that\n\t * needs to be forced.\n\t */\n\tINIT_LIST_HEAD(&new_ctx->committing);\n\tINIT_LIST_HEAD(&new_ctx->busy_extents);\n\tnew_ctx->sequence = ctx->sequence + 1;\n\tnew_ctx->cil = cil;\n\tcil->xc_ctx = new_ctx;\n\n\t/*\n\t * The switch is now done, so we can drop the context lock and move out\n\t * of a shared context. We can't just go straight to the commit record,\n\t * though - we need to synchronise with previous and future commits so\n\t * that the commit records are correctly ordered in the log to ensure\n\t * that we process items during log IO completion in the correct order.\n\t *\n\t * For example, if we get an EFI in one checkpoint and the EFD in the\n\t * next (e.g. due to log forces), we do not want the checkpoint with\n\t * the EFD to be committed before the checkpoint with the EFI.  Hence\n\t * we must strictly order the commit records of the checkpoints so\n\t * that: a) the checkpoint callbacks are attached to the iclogs in the\n\t * correct order; and b) the checkpoints are replayed in correct order\n\t * in log recovery.\n\t *\n\t * Hence we need to add this context to the committing context list so\n\t * that higher sequences will wait for us to write out a commit record\n\t * before they do.\n\t *\n\t * xfs_log_force_lsn requires us to mirror the new sequence into the cil\n\t * structure atomically with the addition of this sequence to the\n\t * committing list. This also ensures that we can do unlocked checks\n\t * against the current sequence in log forces without risking\n\t * deferencing a freed context pointer.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tcil->xc_current_sequence = new_ctx->sequence;\n\tspin_unlock(&cil->xc_push_lock);\n\tup_write(&cil->xc_ctx_lock);\n\n\t/*\n\t * Build a checkpoint transaction header and write it to the log to\n\t * begin the transaction. We need to account for the space used by the\n\t * transaction header here as it is not accounted for in xlog_write().\n\t *\n\t * The LSN we need to pass to the log items on transaction commit is\n\t * the LSN reported by the first log vector write. If we use the commit\n\t * record lsn then we can move the tail beyond the grant write head.\n\t */\n\ttic = ctx->ticket;\n\tthdr.th_magic = XFS_TRANS_HEADER_MAGIC;\n\tthdr.th_type = XFS_TRANS_CHECKPOINT;\n\tthdr.th_tid = tic->t_tid;\n\tthdr.th_num_items = num_iovecs;\n\tlhdr.i_addr = &thdr;\n\tlhdr.i_len = sizeof(xfs_trans_header_t);\n\tlhdr.i_type = XLOG_REG_TYPE_TRANSHDR;\n\ttic->t_curr_res -= lhdr.i_len + sizeof(xlog_op_header_t);\n\n\tlvhdr.lv_niovecs = 1;\n\tlvhdr.lv_iovecp = &lhdr;\n\tlvhdr.lv_next = ctx->lv_chain;\n\n\terror = xlog_write(log, &lvhdr, tic, &ctx->start_lsn, NULL, 0);\n\tif (error)\n\t\tgoto out_abort_free_ticket;\n\n\t/*\n\t * now that we've written the checkpoint into the log, strictly\n\t * order the commit records so replay will get them in the right order.\n\t */\nrestart:\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(new_ctx, &cil->xc_committing, committing) {\n\t\t/*\n\t\t * Avoid getting stuck in this loop because we were woken by the\n\t\t * shutdown, but then went back to sleep once already in the\n\t\t * shutdown state.\n\t\t */\n\t\tif (XLOG_FORCED_SHUTDOWN(log)) {\n\t\t\tspin_unlock(&cil->xc_push_lock);\n\t\t\tgoto out_abort_free_ticket;\n\t\t}\n\n\t\t/*\n\t\t * Higher sequences will wait for this one so skip them.\n\t\t * Don't wait for our own sequence, either.\n\t\t */\n\t\tif (new_ctx->sequence >= ctx->sequence)\n\t\t\tcontinue;\n\t\tif (!new_ctx->commit_lsn) {\n\t\t\t/*\n\t\t\t * It is still being pushed! Wait for the push to\n\t\t\t * complete, then start again from the beginning.\n\t\t\t */\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\n\t/* xfs_log_done always frees the ticket on error. */\n\tcommit_lsn = xfs_log_done(log->l_mp, tic, &commit_iclog, 0);\n\tif (commit_lsn == -1)\n\t\tgoto out_abort;\n\n\t/* attach all the transactions w/ busy extents to iclog */\n\tctx->log_cb.cb_func = xlog_cil_committed;\n\tctx->log_cb.cb_arg = ctx;\n\terror = xfs_log_notify(log->l_mp, commit_iclog, &ctx->log_cb);\n\tif (error)\n\t\tgoto out_abort;\n\n\t/*\n\t * now the checkpoint commit is complete and we've attached the\n\t * callbacks to the iclog we can assign the commit LSN to the context\n\t * and wake up anyone who is waiting for the commit to complete.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tctx->commit_lsn = commit_lsn;\n\twake_up_all(&cil->xc_commit_wait);\n\tspin_unlock(&cil->xc_push_lock);\n\n\t/* release the hounds! */\n\treturn xfs_log_release_iclog(log->l_mp, commit_iclog);\n\nout_skip:\n\tup_write(&cil->xc_ctx_lock);\n\txfs_log_ticket_put(new_ctx->ticket);\n\tkmem_free(new_ctx);\n\treturn 0;\n\nout_abort_free_ticket:\n\txfs_log_ticket_put(tic);\nout_abort:\n\txlog_cil_committed(ctx, XFS_LI_ABORTED);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_cil_committed",
          "args": [
            "ctx",
            "XFS_LI_ABORTED"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_committed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "371-408",
          "snippet": "static void\nxlog_cil_committed(\n\tvoid\t*args,\n\tint\tabort)\n{\n\tstruct xfs_cil_ctx\t*ctx = args;\n\tstruct xfs_mount\t*mp = ctx->cil->xc_log->l_mp;\n\n\txfs_trans_committed_bulk(ctx->cil->xc_log->l_ailp, ctx->lv_chain,\n\t\t\t\t\tctx->start_lsn, abort);\n\n\txfs_extent_busy_sort(&ctx->busy_extents);\n\txfs_extent_busy_clear(mp, &ctx->busy_extents,\n\t\t\t     (mp->m_flags & XFS_MOUNT_DISCARD) && !abort);\n\n\t/*\n\t * If we are aborting the commit, wake up anyone waiting on the\n\t * committing list.  If we don't, then a shutdown we can leave processes\n\t * waiting in xlog_cil_force_lsn() waiting on a sequence commit that\n\t * will never happen because we aborted it.\n\t */\n\tspin_lock(&ctx->cil->xc_push_lock);\n\tif (abort)\n\t\twake_up_all(&ctx->cil->xc_commit_wait);\n\tlist_del(&ctx->committing);\n\tspin_unlock(&ctx->cil->xc_push_lock);\n\n\txlog_cil_free_logvec(ctx->lv_chain);\n\n\tif (!list_empty(&ctx->busy_extents)) {\n\t\tASSERT(mp->m_flags & XFS_MOUNT_DISCARD);\n\n\t\txfs_discard_extents(mp, &ctx->busy_extents);\n\t\txfs_extent_busy_clear(mp, &ctx->busy_extents, false);\n\t}\n\n\tkmem_free(ctx);\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_committed(\n\tvoid\t*args,\n\tint\tabort)\n{\n\tstruct xfs_cil_ctx\t*ctx = args;\n\tstruct xfs_mount\t*mp = ctx->cil->xc_log->l_mp;\n\n\txfs_trans_committed_bulk(ctx->cil->xc_log->l_ailp, ctx->lv_chain,\n\t\t\t\t\tctx->start_lsn, abort);\n\n\txfs_extent_busy_sort(&ctx->busy_extents);\n\txfs_extent_busy_clear(mp, &ctx->busy_extents,\n\t\t\t     (mp->m_flags & XFS_MOUNT_DISCARD) && !abort);\n\n\t/*\n\t * If we are aborting the commit, wake up anyone waiting on the\n\t * committing list.  If we don't, then a shutdown we can leave processes\n\t * waiting in xlog_cil_force_lsn() waiting on a sequence commit that\n\t * will never happen because we aborted it.\n\t */\n\tspin_lock(&ctx->cil->xc_push_lock);\n\tif (abort)\n\t\twake_up_all(&ctx->cil->xc_commit_wait);\n\tlist_del(&ctx->committing);\n\tspin_unlock(&ctx->cil->xc_push_lock);\n\n\txlog_cil_free_logvec(ctx->lv_chain);\n\n\tif (!list_empty(&ctx->busy_extents)) {\n\t\tASSERT(mp->m_flags & XFS_MOUNT_DISCARD);\n\n\t\txfs_discard_extents(mp, &ctx->busy_extents);\n\t\txfs_extent_busy_clear(mp, &ctx->busy_extents, false);\n\t}\n\n\tkmem_free(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_ticket_put",
          "args": [
            "tic"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_ticket_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3496-3503",
          "snippet": "void\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\n\nvoid\nxfs_log_ticket_put(\n\txlog_ticket_t\t*ticket)\n{\n\tASSERT(atomic_read(&ticket->t_ref) > 0);\n\tif (atomic_dec_and_test(&ticket->t_ref))\n\t\tkmem_zone_free(xfs_log_ticket_zone, ticket);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "new_ctx"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cil->xc_ctx_lock"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_release_iclog",
          "args": [
            "log->l_mp",
            "commit_iclog"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_release_iclog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "586-597",
          "snippet": "int\nxfs_log_release_iclog(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_in_core\t*iclog)\n{\n\tif (xlog_state_release_iclog(mp->m_log, iclog)) {\n\t\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC struct;\n\nint\nxfs_log_release_iclog(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_in_core\t*iclog)\n{\n\tif (xlog_state_release_iclog(mp->m_log, iclog)) {\n\t\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&cil->xc_commit_wait"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cil->xc_push_lock"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_notify",
          "args": [
            "log->l_mp",
            "commit_iclog",
            "&ctx->log_cb"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "565-584",
          "snippet": "int\nxfs_log_notify(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_in_core\t*iclog,\n\txfs_log_callback_t\t*cb)\n{\n\tint\tabortflg;\n\n\tspin_lock(&iclog->ic_callback_lock);\n\tabortflg = (iclog->ic_state & XLOG_STATE_IOERROR);\n\tif (!abortflg) {\n\t\tASSERT_ALWAYS((iclog->ic_state == XLOG_STATE_ACTIVE) ||\n\t\t\t      (iclog->ic_state == XLOG_STATE_WANT_SYNC));\n\t\tcb->cb_next = NULL;\n\t\t*(iclog->ic_callback_tail) = cb;\n\t\ticlog->ic_callback_tail = &(cb->cb_next);\n\t}\n\tspin_unlock(&iclog->ic_callback_lock);\n\treturn abortflg;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC struct;\n\nint\nxfs_log_notify(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_in_core\t*iclog,\n\txfs_log_callback_t\t*cb)\n{\n\tint\tabortflg;\n\n\tspin_lock(&iclog->ic_callback_lock);\n\tabortflg = (iclog->ic_state & XLOG_STATE_IOERROR);\n\tif (!abortflg) {\n\t\tASSERT_ALWAYS((iclog->ic_state == XLOG_STATE_ACTIVE) ||\n\t\t\t      (iclog->ic_state == XLOG_STATE_WANT_SYNC));\n\t\tcb->cb_next = NULL;\n\t\t*(iclog->ic_callback_tail) = cb;\n\t\ticlog->ic_callback_tail = &(cb->cb_next);\n\t}\n\tspin_unlock(&iclog->ic_callback_lock);\n\treturn abortflg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_done",
          "args": [
            "log->l_mp",
            "tic",
            "&commit_iclog",
            "0"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "511-557",
          "snippet": "xfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nxfs_lsn_t\nxfs_log_done(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket,\n\tstruct xlog_in_core\t**iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog\t\t*log = mp->m_log;\n\txfs_lsn_t\t\tlsn = 0;\n\n\tif (XLOG_FORCED_SHUTDOWN(log) ||\n\t    /*\n\t     * If nothing was ever written, don't write out commit record.\n\t     * If we get an error, just continue and give back the log ticket.\n\t     */\n\t    (((ticket->t_flags & XLOG_TIC_INITED) == 0) &&\n\t     (xlog_commit_record(log, ticket, iclog, &lsn)))) {\n\t\tlsn = (xfs_lsn_t) -1;\n\t\tif (ticket->t_flags & XLOG_TIC_PERM_RESERV) {\n\t\t\tflags |= XFS_LOG_REL_PERM_RESERV;\n\t\t}\n\t}\n\n\n\tif ((ticket->t_flags & XLOG_TIC_PERM_RESERV) == 0 ||\n\t    (flags & XFS_LOG_REL_PERM_RESERV)) {\n\t\ttrace_xfs_log_done_nonperm(log, ticket);\n\n\t\t/*\n\t\t * Release ticket if not permanent reservation or a specific\n\t\t * request has been made to release a permanent reservation.\n\t\t */\n\t\txlog_ungrant_log_space(log, ticket);\n\t\txfs_log_ticket_put(ticket);\n\t} else {\n\t\ttrace_xfs_log_done_perm(log, ticket);\n\n\t\txlog_regrant_reserve_log_space(log, ticket);\n\t\t/* If this ticket was a permanent reservation and we aren't\n\t\t * trying to release it, reset the inited flags; so next time\n\t\t * we write, a start record will be written out.\n\t\t */\n\t\tticket->t_flags |= XLOG_TIC_INITED;\n\t}\n\n\treturn lsn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_wait",
          "args": [
            "&cil->xc_commit_wait",
            "&cil->xc_push_lock"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_priv.h",
          "lines": "550-559",
          "snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xlog_wait(wait_queue_head_t *wq, spinlock_t *lock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tadd_wait_queue_exclusive(wq, &wait);\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\tspin_unlock(lock);\n\tschedule();\n\tremove_wait_queue(wq, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XLOG_FORCED_SHUTDOWN",
          "args": [
            "log"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "new_ctx",
            "&cil->xc_committing",
            "committing"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_write",
          "args": [
            "log",
            "&lvhdr",
            "tic",
            "&ctx->start_lsn",
            "NULL",
            "0"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "2298-2462",
          "snippet": "int\nxlog_write(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*log_vector,\n\tstruct xlog_ticket\t*ticket,\n\txfs_lsn_t\t\t*start_lsn,\n\tstruct xlog_in_core\t**commit_iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog_in_core\t*iclog = NULL;\n\tstruct xfs_log_iovec\t*vecp;\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\tlen;\n\tint\t\t\tindex;\n\tint\t\t\tpartial_copy = 0;\n\tint\t\t\tpartial_copy_len = 0;\n\tint\t\t\tcontwr = 0;\n\tint\t\t\trecord_cnt = 0;\n\tint\t\t\tdata_cnt = 0;\n\tint\t\t\terror;\n\n\t*start_lsn = 0;\n\n\tlen = xlog_write_calc_vec_length(ticket, log_vector);\n\n\t/*\n\t * Region headers and bytes are already accounted for.\n\t * We only need to take into account start records and\n\t * split regions in this function.\n\t */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\t/*\n\t * Commit record headers need to be accounted for. These\n\t * come in as separate writes so are easy to detect.\n\t */\n\tif (flags & (XLOG_COMMIT_TRANS | XLOG_UNMOUNT_TRANS))\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\tif (ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(log->l_mp, ticket);\n\n\tindex = 0;\n\tlv = log_vector;\n\tvecp = lv->lv_iovecp;\n\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\tvoid\t\t*ptr;\n\t\tint\t\tlog_offset;\n\n\t\terror = xlog_state_get_iclog_space(log, len, &iclog, ticket,\n\t\t\t\t\t\t   &contwr, &log_offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(log_offset <= iclog->ic_size - 1);\n\t\tptr = iclog->ic_datap + log_offset;\n\n\t\t/* start_lsn is the first lsn written to. That's all we need. */\n\t\tif (!*start_lsn)\n\t\t\t*start_lsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\t\t/*\n\t\t * This loop writes out as many regions as can fit in the amount\n\t\t * of space which was allocated by xlog_state_get_iclog_space().\n\t\t */\n\t\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\t\tstruct xfs_log_iovec\t*reg;\n\t\t\tstruct xlog_op_header\t*ophdr;\n\t\t\tint\t\t\tstart_rec_copy;\n\t\t\tint\t\t\tcopy_len;\n\t\t\tint\t\t\tcopy_off;\n\t\t\tbool\t\t\tordered = false;\n\n\t\t\t/* ordered log vectors have no regions to write */\n\t\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED) {\n\t\t\t\tASSERT(lv->lv_niovecs == 0);\n\t\t\t\tordered = true;\n\t\t\t\tgoto next_lv;\n\t\t\t}\n\n\t\t\treg = &vecp[index];\n\t\t\tASSERT(reg->i_len % sizeof(__int32_t) == 0);\n\t\t\tASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);\n\n\t\t\tstart_rec_copy = xlog_write_start_rec(ptr, ticket);\n\t\t\tif (start_rec_copy) {\n\t\t\t\trecord_cnt++;\n\t\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t\t   start_rec_copy);\n\t\t\t}\n\n\t\t\tophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);\n\t\t\tif (!ophdr)\n\t\t\t\treturn -EIO;\n\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t   sizeof(struct xlog_op_header));\n\n\t\t\tlen += xlog_write_setup_copy(ticket, ophdr,\n\t\t\t\t\t\t     iclog->ic_size-log_offset,\n\t\t\t\t\t\t     reg->i_len,\n\t\t\t\t\t\t     &copy_off, &copy_len,\n\t\t\t\t\t\t     &partial_copy,\n\t\t\t\t\t\t     &partial_copy_len);\n\t\t\txlog_verify_dest_ptr(log, ptr);\n\n\t\t\t/* copy region */\n\t\t\tASSERT(copy_len >= 0);\n\t\t\tmemcpy(ptr, reg->i_addr + copy_off, copy_len);\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset, copy_len);\n\n\t\t\tcopy_len += start_rec_copy + sizeof(xlog_op_header_t);\n\t\t\trecord_cnt++;\n\t\t\tdata_cnt += contwr ? copy_len : 0;\n\n\t\t\terror = xlog_write_copy_finish(log, iclog, flags,\n\t\t\t\t\t\t       &record_cnt, &data_cnt,\n\t\t\t\t\t\t       &partial_copy,\n\t\t\t\t\t\t       &partial_copy_len,\n\t\t\t\t\t\t       log_offset,\n\t\t\t\t\t\t       commit_iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * if we had a partial copy, we need to get more iclog\n\t\t\t * space but we don't want to increment the region\n\t\t\t * index because there is still more is this region to\n\t\t\t * write.\n\t\t\t *\n\t\t\t * If we completed writing this region, and we flushed\n\t\t\t * the iclog (indicated by resetting of the record\n\t\t\t * count), then we also need to get more log space. If\n\t\t\t * this was the last record, though, we are done and\n\t\t\t * can just return.\n\t\t\t */\n\t\t\tif (partial_copy)\n\t\t\t\tbreak;\n\n\t\t\tif (++index == lv->lv_niovecs) {\nnext_lv:\n\t\t\t\tlv = lv->lv_next;\n\t\t\t\tindex = 0;\n\t\t\t\tif (lv)\n\t\t\t\t\tvecp = lv->lv_iovecp;\n\t\t\t}\n\t\t\tif (record_cnt == 0 && ordered == false) {\n\t\t\t\tif (!lv)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT(len == 0);\n\n\txlog_state_finish_copy(log, iclog, record_cnt, data_cnt);\n\tif (!commit_iclog)\n\t\treturn xlog_state_release_iclog(log, iclog);\n\n\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t*commit_iclog = iclog;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);",
            "STATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC int\nxlog_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC void xlog_state_done_syncing(xlog_in_core_t *iclog, int);\nSTATIC void\nxlog_state_do_callback(\n\tstruct xlog\t\t*log,\n\tint\t\t\taborted,\n\tstruct xlog_in_core\t*iclog);\nSTATIC int\nxlog_state_release_iclog(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_state_want_sync(\n\tstruct xlog\t\t*log,\n\tstruct xlog_in_core\t*iclog);\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nint\nxlog_write(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*log_vector,\n\tstruct xlog_ticket\t*ticket,\n\txfs_lsn_t\t\t*start_lsn,\n\tstruct xlog_in_core\t**commit_iclog,\n\tuint\t\t\tflags)\n{\n\tstruct xlog_in_core\t*iclog = NULL;\n\tstruct xfs_log_iovec\t*vecp;\n\tstruct xfs_log_vec\t*lv;\n\tint\t\t\tlen;\n\tint\t\t\tindex;\n\tint\t\t\tpartial_copy = 0;\n\tint\t\t\tpartial_copy_len = 0;\n\tint\t\t\tcontwr = 0;\n\tint\t\t\trecord_cnt = 0;\n\tint\t\t\tdata_cnt = 0;\n\tint\t\t\terror;\n\n\t*start_lsn = 0;\n\n\tlen = xlog_write_calc_vec_length(ticket, log_vector);\n\n\t/*\n\t * Region headers and bytes are already accounted for.\n\t * We only need to take into account start records and\n\t * split regions in this function.\n\t */\n\tif (ticket->t_flags & XLOG_TIC_INITED)\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\t/*\n\t * Commit record headers need to be accounted for. These\n\t * come in as separate writes so are easy to detect.\n\t */\n\tif (flags & (XLOG_COMMIT_TRANS | XLOG_UNMOUNT_TRANS))\n\t\tticket->t_curr_res -= sizeof(xlog_op_header_t);\n\n\tif (ticket->t_curr_res < 0)\n\t\txlog_print_tic_res(log->l_mp, ticket);\n\n\tindex = 0;\n\tlv = log_vector;\n\tvecp = lv->lv_iovecp;\n\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\tvoid\t\t*ptr;\n\t\tint\t\tlog_offset;\n\n\t\terror = xlog_state_get_iclog_space(log, len, &iclog, ticket,\n\t\t\t\t\t\t   &contwr, &log_offset);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tASSERT(log_offset <= iclog->ic_size - 1);\n\t\tptr = iclog->ic_datap + log_offset;\n\n\t\t/* start_lsn is the first lsn written to. That's all we need. */\n\t\tif (!*start_lsn)\n\t\t\t*start_lsn = be64_to_cpu(iclog->ic_header.h_lsn);\n\n\t\t/*\n\t\t * This loop writes out as many regions as can fit in the amount\n\t\t * of space which was allocated by xlog_state_get_iclog_space().\n\t\t */\n\t\twhile (lv && (!lv->lv_niovecs || index < lv->lv_niovecs)) {\n\t\t\tstruct xfs_log_iovec\t*reg;\n\t\t\tstruct xlog_op_header\t*ophdr;\n\t\t\tint\t\t\tstart_rec_copy;\n\t\t\tint\t\t\tcopy_len;\n\t\t\tint\t\t\tcopy_off;\n\t\t\tbool\t\t\tordered = false;\n\n\t\t\t/* ordered log vectors have no regions to write */\n\t\t\tif (lv->lv_buf_len == XFS_LOG_VEC_ORDERED) {\n\t\t\t\tASSERT(lv->lv_niovecs == 0);\n\t\t\t\tordered = true;\n\t\t\t\tgoto next_lv;\n\t\t\t}\n\n\t\t\treg = &vecp[index];\n\t\t\tASSERT(reg->i_len % sizeof(__int32_t) == 0);\n\t\t\tASSERT((unsigned long)ptr % sizeof(__int32_t) == 0);\n\n\t\t\tstart_rec_copy = xlog_write_start_rec(ptr, ticket);\n\t\t\tif (start_rec_copy) {\n\t\t\t\trecord_cnt++;\n\t\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t\t   start_rec_copy);\n\t\t\t}\n\n\t\t\tophdr = xlog_write_setup_ophdr(log, ptr, ticket, flags);\n\t\t\tif (!ophdr)\n\t\t\t\treturn -EIO;\n\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset,\n\t\t\t\t\t   sizeof(struct xlog_op_header));\n\n\t\t\tlen += xlog_write_setup_copy(ticket, ophdr,\n\t\t\t\t\t\t     iclog->ic_size-log_offset,\n\t\t\t\t\t\t     reg->i_len,\n\t\t\t\t\t\t     &copy_off, &copy_len,\n\t\t\t\t\t\t     &partial_copy,\n\t\t\t\t\t\t     &partial_copy_len);\n\t\t\txlog_verify_dest_ptr(log, ptr);\n\n\t\t\t/* copy region */\n\t\t\tASSERT(copy_len >= 0);\n\t\t\tmemcpy(ptr, reg->i_addr + copy_off, copy_len);\n\t\t\txlog_write_adv_cnt(&ptr, &len, &log_offset, copy_len);\n\n\t\t\tcopy_len += start_rec_copy + sizeof(xlog_op_header_t);\n\t\t\trecord_cnt++;\n\t\t\tdata_cnt += contwr ? copy_len : 0;\n\n\t\t\terror = xlog_write_copy_finish(log, iclog, flags,\n\t\t\t\t\t\t       &record_cnt, &data_cnt,\n\t\t\t\t\t\t       &partial_copy,\n\t\t\t\t\t\t       &partial_copy_len,\n\t\t\t\t\t\t       log_offset,\n\t\t\t\t\t\t       commit_iclog);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\n\t\t\t/*\n\t\t\t * if we had a partial copy, we need to get more iclog\n\t\t\t * space but we don't want to increment the region\n\t\t\t * index because there is still more is this region to\n\t\t\t * write.\n\t\t\t *\n\t\t\t * If we completed writing this region, and we flushed\n\t\t\t * the iclog (indicated by resetting of the record\n\t\t\t * count), then we also need to get more log space. If\n\t\t\t * this was the last record, though, we are done and\n\t\t\t * can just return.\n\t\t\t */\n\t\t\tif (partial_copy)\n\t\t\t\tbreak;\n\n\t\t\tif (++index == lv->lv_niovecs) {\nnext_lv:\n\t\t\t\tlv = lv->lv_next;\n\t\t\t\tindex = 0;\n\t\t\t\tif (lv)\n\t\t\t\t\tvecp = lv->lv_iovecp;\n\t\t\t}\n\t\t\tif (record_cnt == 0 && ordered == false) {\n\t\t\t\tif (!lv)\n\t\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tASSERT(len == 0);\n\n\txlog_state_finish_copy(log, iclog, record_cnt, data_cnt);\n\tif (!commit_iclog)\n\t\treturn xlog_state_release_iclog(log, iclog);\n\n\tASSERT(flags & XLOG_COMMIT_TRANS);\n\t*commit_iclog = iclog;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&cil->xc_ctx_lock"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new_ctx->busy_extents"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&new_ctx->committing"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&item->li_cil"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&cil->xc_cil",
            "structxfs_log_item",
            "li_cil"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&cil->xc_cil"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ctx->committing",
            "&cil->xc_committing"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "push_seq <= ctx->sequence"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&cil->xc_ctx_lock"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xlog_cil_ticket_alloc",
          "args": [
            "log"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_ticket_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "46-62",
          "snippet": "static struct xlog_ticket *\nxlog_cil_ticket_alloc(\n\tstruct xlog\t*log)\n{\n\tstruct xlog_ticket *tic;\n\n\ttic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\n\t\t\t\tKM_SLEEP|KM_NOFS);\n\ttic->t_trans_type = XFS_TRANS_CHECKPOINT;\n\n\t/*\n\t * set the current reservation to zero so we know to steal the basic\n\t * transaction overhead reservation from the first transaction commit.\n\t */\n\ttic->t_curr_res = 0;\n\treturn tic;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xlog_ticket *\nxlog_cil_ticket_alloc(\n\tstruct xlog\t*log)\n{\n\tstruct xlog_ticket *tic;\n\n\ttic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\n\t\t\t\tKM_SLEEP|KM_NOFS);\n\ttic->t_trans_type = XFS_TRANS_CHECKPOINT;\n\n\t/*\n\t * set the current reservation to zero so we know to steal the basic\n\t * transaction overhead reservation from the first transaction commit.\n\t */\n\ttic->t_curr_res = 0;\n\treturn tic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "sizeof(*new_ctx)",
            "KM_SLEEP|KM_NOFS"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxlog_cil_push(\n\tstruct xlog\t\t*log)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_log_vec\t*lv;\n\tstruct xfs_cil_ctx\t*ctx;\n\tstruct xfs_cil_ctx\t*new_ctx;\n\tstruct xlog_in_core\t*commit_iclog;\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tnum_iovecs;\n\tint\t\t\terror = 0;\n\tstruct xfs_trans_header thdr;\n\tstruct xfs_log_iovec\tlhdr;\n\tstruct xfs_log_vec\tlvhdr = { NULL };\n\txfs_lsn_t\t\tcommit_lsn;\n\txfs_lsn_t\t\tpush_seq;\n\n\tif (!cil)\n\t\treturn 0;\n\n\tnew_ctx = kmem_zalloc(sizeof(*new_ctx), KM_SLEEP|KM_NOFS);\n\tnew_ctx->ticket = xlog_cil_ticket_alloc(log);\n\n\tdown_write(&cil->xc_ctx_lock);\n\tctx = cil->xc_ctx;\n\n\tspin_lock(&cil->xc_push_lock);\n\tpush_seq = cil->xc_push_seq;\n\tASSERT(push_seq <= ctx->sequence);\n\n\t/*\n\t * Check if we've anything to push. If there is nothing, then we don't\n\t * move on to a new sequence number and so we have to be able to push\n\t * this sequence again later.\n\t */\n\tif (list_empty(&cil->xc_cil)) {\n\t\tcil->xc_push_seq = 0;\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto out_skip;\n\t}\n\n\n\t/* check for a previously pushed seqeunce */\n\tif (push_seq < cil->xc_ctx->sequence) {\n\t\tspin_unlock(&cil->xc_push_lock);\n\t\tgoto out_skip;\n\t}\n\n\t/*\n\t * We are now going to push this context, so add it to the committing\n\t * list before we do anything else. This ensures that anyone waiting on\n\t * this push can easily detect the difference between a \"push in\n\t * progress\" and \"CIL is empty, nothing to do\".\n\t *\n\t * IOWs, a wait loop can now check for:\n\t *\tthe current sequence not being found on the committing list;\n\t *\tan empty CIL; and\n\t *\tan unchanged sequence number\n\t * to detect a push that had nothing to do and therefore does not need\n\t * waiting on. If the CIL is not empty, we get put on the committing\n\t * list before emptying the CIL and bumping the sequence number. Hence\n\t * an empty CIL and an unchanged sequence number means we jumped out\n\t * above after doing nothing.\n\t *\n\t * Hence the waiter will either find the commit sequence on the\n\t * committing list or the sequence number will be unchanged and the CIL\n\t * still dirty. In that latter case, the push has not yet started, and\n\t * so the waiter will have to continue trying to check the CIL\n\t * committing list until it is found. In extreme cases of delay, the\n\t * sequence may fully commit between the attempts the wait makes to wait\n\t * on the commit sequence.\n\t */\n\tlist_add(&ctx->committing, &cil->xc_committing);\n\tspin_unlock(&cil->xc_push_lock);\n\n\t/*\n\t * pull all the log vectors off the items in the CIL, and\n\t * remove the items from the CIL. We don't need the CIL lock\n\t * here because it's only needed on the transaction commit\n\t * side which is currently locked out by the flush lock.\n\t */\n\tlv = NULL;\n\tnum_iovecs = 0;\n\twhile (!list_empty(&cil->xc_cil)) {\n\t\tstruct xfs_log_item\t*item;\n\n\t\titem = list_first_entry(&cil->xc_cil,\n\t\t\t\t\tstruct xfs_log_item, li_cil);\n\t\tlist_del_init(&item->li_cil);\n\t\tif (!ctx->lv_chain)\n\t\t\tctx->lv_chain = item->li_lv;\n\t\telse\n\t\t\tlv->lv_next = item->li_lv;\n\t\tlv = item->li_lv;\n\t\titem->li_lv = NULL;\n\t\tnum_iovecs += lv->lv_niovecs;\n\t}\n\n\t/*\n\t * initialise the new context and attach it to the CIL. Then attach\n\t * the current context to the CIL committing lsit so it can be found\n\t * during log forces to extract the commit lsn of the sequence that\n\t * needs to be forced.\n\t */\n\tINIT_LIST_HEAD(&new_ctx->committing);\n\tINIT_LIST_HEAD(&new_ctx->busy_extents);\n\tnew_ctx->sequence = ctx->sequence + 1;\n\tnew_ctx->cil = cil;\n\tcil->xc_ctx = new_ctx;\n\n\t/*\n\t * The switch is now done, so we can drop the context lock and move out\n\t * of a shared context. We can't just go straight to the commit record,\n\t * though - we need to synchronise with previous and future commits so\n\t * that the commit records are correctly ordered in the log to ensure\n\t * that we process items during log IO completion in the correct order.\n\t *\n\t * For example, if we get an EFI in one checkpoint and the EFD in the\n\t * next (e.g. due to log forces), we do not want the checkpoint with\n\t * the EFD to be committed before the checkpoint with the EFI.  Hence\n\t * we must strictly order the commit records of the checkpoints so\n\t * that: a) the checkpoint callbacks are attached to the iclogs in the\n\t * correct order; and b) the checkpoints are replayed in correct order\n\t * in log recovery.\n\t *\n\t * Hence we need to add this context to the committing context list so\n\t * that higher sequences will wait for us to write out a commit record\n\t * before they do.\n\t *\n\t * xfs_log_force_lsn requires us to mirror the new sequence into the cil\n\t * structure atomically with the addition of this sequence to the\n\t * committing list. This also ensures that we can do unlocked checks\n\t * against the current sequence in log forces without risking\n\t * deferencing a freed context pointer.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tcil->xc_current_sequence = new_ctx->sequence;\n\tspin_unlock(&cil->xc_push_lock);\n\tup_write(&cil->xc_ctx_lock);\n\n\t/*\n\t * Build a checkpoint transaction header and write it to the log to\n\t * begin the transaction. We need to account for the space used by the\n\t * transaction header here as it is not accounted for in xlog_write().\n\t *\n\t * The LSN we need to pass to the log items on transaction commit is\n\t * the LSN reported by the first log vector write. If we use the commit\n\t * record lsn then we can move the tail beyond the grant write head.\n\t */\n\ttic = ctx->ticket;\n\tthdr.th_magic = XFS_TRANS_HEADER_MAGIC;\n\tthdr.th_type = XFS_TRANS_CHECKPOINT;\n\tthdr.th_tid = tic->t_tid;\n\tthdr.th_num_items = num_iovecs;\n\tlhdr.i_addr = &thdr;\n\tlhdr.i_len = sizeof(xfs_trans_header_t);\n\tlhdr.i_type = XLOG_REG_TYPE_TRANSHDR;\n\ttic->t_curr_res -= lhdr.i_len + sizeof(xlog_op_header_t);\n\n\tlvhdr.lv_niovecs = 1;\n\tlvhdr.lv_iovecp = &lhdr;\n\tlvhdr.lv_next = ctx->lv_chain;\n\n\terror = xlog_write(log, &lvhdr, tic, &ctx->start_lsn, NULL, 0);\n\tif (error)\n\t\tgoto out_abort_free_ticket;\n\n\t/*\n\t * now that we've written the checkpoint into the log, strictly\n\t * order the commit records so replay will get them in the right order.\n\t */\nrestart:\n\tspin_lock(&cil->xc_push_lock);\n\tlist_for_each_entry(new_ctx, &cil->xc_committing, committing) {\n\t\t/*\n\t\t * Avoid getting stuck in this loop because we were woken by the\n\t\t * shutdown, but then went back to sleep once already in the\n\t\t * shutdown state.\n\t\t */\n\t\tif (XLOG_FORCED_SHUTDOWN(log)) {\n\t\t\tspin_unlock(&cil->xc_push_lock);\n\t\t\tgoto out_abort_free_ticket;\n\t\t}\n\n\t\t/*\n\t\t * Higher sequences will wait for this one so skip them.\n\t\t * Don't wait for our own sequence, either.\n\t\t */\n\t\tif (new_ctx->sequence >= ctx->sequence)\n\t\t\tcontinue;\n\t\tif (!new_ctx->commit_lsn) {\n\t\t\t/*\n\t\t\t * It is still being pushed! Wait for the push to\n\t\t\t * complete, then start again from the beginning.\n\t\t\t */\n\t\t\txlog_wait(&cil->xc_commit_wait, &cil->xc_push_lock);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tspin_unlock(&cil->xc_push_lock);\n\n\t/* xfs_log_done always frees the ticket on error. */\n\tcommit_lsn = xfs_log_done(log->l_mp, tic, &commit_iclog, 0);\n\tif (commit_lsn == -1)\n\t\tgoto out_abort;\n\n\t/* attach all the transactions w/ busy extents to iclog */\n\tctx->log_cb.cb_func = xlog_cil_committed;\n\tctx->log_cb.cb_arg = ctx;\n\terror = xfs_log_notify(log->l_mp, commit_iclog, &ctx->log_cb);\n\tif (error)\n\t\tgoto out_abort;\n\n\t/*\n\t * now the checkpoint commit is complete and we've attached the\n\t * callbacks to the iclog we can assign the commit LSN to the context\n\t * and wake up anyone who is waiting for the commit to complete.\n\t */\n\tspin_lock(&cil->xc_push_lock);\n\tctx->commit_lsn = commit_lsn;\n\twake_up_all(&cil->xc_commit_wait);\n\tspin_unlock(&cil->xc_push_lock);\n\n\t/* release the hounds! */\n\treturn xfs_log_release_iclog(log->l_mp, commit_iclog);\n\nout_skip:\n\tup_write(&cil->xc_ctx_lock);\n\txfs_log_ticket_put(new_ctx->ticket);\n\tkmem_free(new_ctx);\n\treturn 0;\n\nout_abort_free_ticket:\n\txfs_log_ticket_put(tic);\nout_abort:\n\txlog_cil_committed(ctx, XFS_LI_ABORTED);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "xlog_cil_committed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "371-408",
    "snippet": "static void\nxlog_cil_committed(\n\tvoid\t*args,\n\tint\tabort)\n{\n\tstruct xfs_cil_ctx\t*ctx = args;\n\tstruct xfs_mount\t*mp = ctx->cil->xc_log->l_mp;\n\n\txfs_trans_committed_bulk(ctx->cil->xc_log->l_ailp, ctx->lv_chain,\n\t\t\t\t\tctx->start_lsn, abort);\n\n\txfs_extent_busy_sort(&ctx->busy_extents);\n\txfs_extent_busy_clear(mp, &ctx->busy_extents,\n\t\t\t     (mp->m_flags & XFS_MOUNT_DISCARD) && !abort);\n\n\t/*\n\t * If we are aborting the commit, wake up anyone waiting on the\n\t * committing list.  If we don't, then a shutdown we can leave processes\n\t * waiting in xlog_cil_force_lsn() waiting on a sequence commit that\n\t * will never happen because we aborted it.\n\t */\n\tspin_lock(&ctx->cil->xc_push_lock);\n\tif (abort)\n\t\twake_up_all(&ctx->cil->xc_commit_wait);\n\tlist_del(&ctx->committing);\n\tspin_unlock(&ctx->cil->xc_push_lock);\n\n\txlog_cil_free_logvec(ctx->lv_chain);\n\n\tif (!list_empty(&ctx->busy_extents)) {\n\t\tASSERT(mp->m_flags & XFS_MOUNT_DISCARD);\n\n\t\txfs_discard_extents(mp, &ctx->busy_extents);\n\t\txfs_extent_busy_clear(mp, &ctx->busy_extents, false);\n\t}\n\n\tkmem_free(ctx);\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "ctx"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_clear",
          "args": [
            "mp",
            "&ctx->busy_extents",
            "false"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.c",
          "lines": "559-591",
          "snippet": "void\nxfs_extent_busy_clear(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list,\n\tbool\t\t\tdo_discard)\n{\n\tstruct xfs_extent_busy\t*busyp, *n;\n\tstruct xfs_perag\t*pag = NULL;\n\txfs_agnumber_t\t\tagno = NULLAGNUMBER;\n\n\tlist_for_each_entry_safe(busyp, n, list, list) {\n\t\tif (busyp->agno != agno) {\n\t\t\tif (pag) {\n\t\t\t\tspin_unlock(&pag->pagb_lock);\n\t\t\t\txfs_perag_put(pag);\n\t\t\t}\n\t\t\tpag = xfs_perag_get(mp, busyp->agno);\n\t\t\tspin_lock(&pag->pagb_lock);\n\t\t\tagno = busyp->agno;\n\t\t}\n\n\t\tif (do_discard && busyp->length &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD))\n\t\t\tbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\n\t\telse\n\t\t\txfs_extent_busy_clear_one(mp, pag, busyp);\n\t}\n\n\tif (pag) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\txfs_perag_put(pag);\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_extent_busy_clear(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list,\n\tbool\t\t\tdo_discard)\n{\n\tstruct xfs_extent_busy\t*busyp, *n;\n\tstruct xfs_perag\t*pag = NULL;\n\txfs_agnumber_t\t\tagno = NULLAGNUMBER;\n\n\tlist_for_each_entry_safe(busyp, n, list, list) {\n\t\tif (busyp->agno != agno) {\n\t\t\tif (pag) {\n\t\t\t\tspin_unlock(&pag->pagb_lock);\n\t\t\t\txfs_perag_put(pag);\n\t\t\t}\n\t\t\tpag = xfs_perag_get(mp, busyp->agno);\n\t\t\tspin_lock(&pag->pagb_lock);\n\t\t\tagno = busyp->agno;\n\t\t}\n\n\t\tif (do_discard && busyp->length &&\n\t\t    !(busyp->flags & XFS_EXTENT_BUSY_SKIP_DISCARD))\n\t\t\tbusyp->flags = XFS_EXTENT_BUSY_DISCARDED;\n\t\telse\n\t\t\txfs_extent_busy_clear_one(mp, pag, busyp);\n\t}\n\n\tif (pag) {\n\t\tspin_unlock(&pag->pagb_lock);\n\t\txfs_perag_put(pag);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_discard_extents",
          "args": [
            "mp",
            "&ctx->busy_extents"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_discard_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_discard.c",
          "lines": "212-239",
          "snippet": "int\nxfs_discard_extents(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list)\n{\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\terror = 0;\n\n\tlist_for_each_entry(busyp, list, list) {\n\t\ttrace_xfs_discard_extent(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t busyp->length);\n\n\t\terror = blkdev_issue_discard(mp->m_ddev_targp->bt_bdev,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, busyp->agno, busyp->bno),\n\t\t\t\tXFS_FSB_TO_BB(mp, busyp->length),\n\t\t\t\tGFP_NOFS, 0);\n\t\tif (error && error != -EOPNOTSUPP) {\n\t\t\txfs_info(mp,\n\t \"discard failed for extent [0x%llu,%u], error %d\",\n\t\t\t\t (unsigned long long)busyp->bno,\n\t\t\t\t busyp->length,\n\t\t\t\t error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_discard_extents(\n\tstruct xfs_mount\t*mp,\n\tstruct list_head\t*list)\n{\n\tstruct xfs_extent_busy\t*busyp;\n\tint\t\t\terror = 0;\n\n\tlist_for_each_entry(busyp, list, list) {\n\t\ttrace_xfs_discard_extent(mp, busyp->agno, busyp->bno,\n\t\t\t\t\t busyp->length);\n\n\t\terror = blkdev_issue_discard(mp->m_ddev_targp->bt_bdev,\n\t\t\t\tXFS_AGB_TO_DADDR(mp, busyp->agno, busyp->bno),\n\t\t\t\tXFS_FSB_TO_BB(mp, busyp->length),\n\t\t\t\tGFP_NOFS, 0);\n\t\tif (error && error != -EOPNOTSUPP) {\n\t\t\txfs_info(mp,\n\t \"discard failed for extent [0x%llu,%u], error %d\",\n\t\t\t\t (unsigned long long)busyp->bno,\n\t\t\t\t busyp->length,\n\t\t\t\t error);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mp->m_flags & XFS_MOUNT_DISCARD"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx->busy_extents"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_cil_free_logvec",
          "args": [
            "ctx->lv_chain"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_free_logvec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "353-364",
          "snippet": "static void\nxlog_cil_free_logvec(\n\tstruct xfs_log_vec\t*log_vector)\n{\n\tstruct xfs_log_vec\t*lv;\n\n\tfor (lv = log_vector; lv; ) {\n\t\tstruct xfs_log_vec *next = lv->lv_next;\n\t\tkmem_free(lv);\n\t\tlv = next;\n\t}\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_free_logvec(\n\tstruct xfs_log_vec\t*log_vector)\n{\n\tstruct xfs_log_vec\t*lv;\n\n\tfor (lv = log_vector; lv; ) {\n\t\tstruct xfs_log_vec *next = lv->lv_next;\n\t\tkmem_free(lv);\n\t\tlv = next;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ctx->cil->xc_push_lock"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ctx->committing"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&ctx->cil->xc_commit_wait"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ctx->cil->xc_push_lock"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_extent_busy_sort",
          "args": [
            "&ctx->busy_extents"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_extent_busy_sort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_extent_busy.h",
          "lines": "68-71",
          "snippet": "static inline void xfs_extent_busy_sort(struct list_head *list)\n{\n\tlist_sort(NULL, list, xfs_extent_busy_ag_cmp);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_extent_busy_sort(struct list_head *list)\n{\n\tlist_sort(NULL, list, xfs_extent_busy_ag_cmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_committed_bulk",
          "args": [
            "ctx->cil->xc_log->l_ailp",
            "ctx->lv_chain",
            "ctx->start_lsn",
            "abort"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_committed_bulk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "757-831",
          "snippet": "void\nxfs_trans_committed_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_vec\t*log_vector,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\taborted)\n{\n#define LOG_ITEM_BATCH_SIZE\t32\n\tstruct xfs_log_item\t*log_items[LOG_ITEM_BATCH_SIZE];\n\tstruct xfs_log_vec\t*lv;\n\tstruct xfs_ail_cursor\tcur;\n\tint\t\t\ti = 0;\n\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_cursor_last(ailp, &cur, commit_lsn);\n\tspin_unlock(&ailp->xa_lock);\n\n\t/* unpin all the log items */\n\tfor (lv = log_vector; lv; lv = lv->lv_next ) {\n\t\tstruct xfs_log_item\t*lip = lv->lv_item;\n\t\txfs_lsn_t\t\titem_lsn;\n\n\t\tif (aborted)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\titem_lsn = lip->li_ops->iop_committed(lip, commit_lsn);\n\n\t\t/* item_lsn of -1 means the item needs no further processing */\n\t\tif (XFS_LSN_CMP(item_lsn, (xfs_lsn_t)-1) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if we are aborting the operation, no point in inserting the\n\t\t * object into the AIL as we are in a shutdown situation.\n\t\t */\n\t\tif (aborted) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(ailp->xa_mount));\n\t\t\tlip->li_ops->iop_unpin(lip, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (item_lsn != commit_lsn) {\n\n\t\t\t/*\n\t\t\t * Not a bulk update option due to unusual item_lsn.\n\t\t\t * Push into AIL immediately, rechecking the lsn once\n\t\t\t * we have the ail lock. Then unpin the item. This does\n\t\t\t * not affect the AIL cursor the bulk insert path is\n\t\t\t * using.\n\t\t\t */\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (XFS_LSN_CMP(item_lsn, lip->li_lsn) > 0)\n\t\t\t\txfs_trans_ail_update(ailp, lip, item_lsn);\n\t\t\telse\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tlip->li_ops->iop_unpin(lip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Item is a candidate for bulk AIL insert.  */\n\t\tlog_items[i++] = lv->lv_item;\n\t\tif (i >= LOG_ITEM_BATCH_SIZE) {\n\t\t\txfs_log_item_batch_insert(ailp, &cur, log_items,\n\t\t\t\t\tLOG_ITEM_BATCH_SIZE, commit_lsn);\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\t/* make sure we insert the remainder! */\n\tif (i)\n\t\txfs_log_item_batch_insert(ailp, &cur, log_items, i, commit_lsn);\n\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define LOG_ITEM_BATCH_SIZE\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define LOG_ITEM_BATCH_SIZE\t32\n\nvoid\nxfs_trans_committed_bulk(\n\tstruct xfs_ail\t\t*ailp,\n\tstruct xfs_log_vec\t*log_vector,\n\txfs_lsn_t\t\tcommit_lsn,\n\tint\t\t\taborted)\n{\n#define LOG_ITEM_BATCH_SIZE\t32\n\tstruct xfs_log_item\t*log_items[LOG_ITEM_BATCH_SIZE];\n\tstruct xfs_log_vec\t*lv;\n\tstruct xfs_ail_cursor\tcur;\n\tint\t\t\ti = 0;\n\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_cursor_last(ailp, &cur, commit_lsn);\n\tspin_unlock(&ailp->xa_lock);\n\n\t/* unpin all the log items */\n\tfor (lv = log_vector; lv; lv = lv->lv_next ) {\n\t\tstruct xfs_log_item\t*lip = lv->lv_item;\n\t\txfs_lsn_t\t\titem_lsn;\n\n\t\tif (aborted)\n\t\t\tlip->li_flags |= XFS_LI_ABORTED;\n\t\titem_lsn = lip->li_ops->iop_committed(lip, commit_lsn);\n\n\t\t/* item_lsn of -1 means the item needs no further processing */\n\t\tif (XFS_LSN_CMP(item_lsn, (xfs_lsn_t)-1) == 0)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * if we are aborting the operation, no point in inserting the\n\t\t * object into the AIL as we are in a shutdown situation.\n\t\t */\n\t\tif (aborted) {\n\t\t\tASSERT(XFS_FORCED_SHUTDOWN(ailp->xa_mount));\n\t\t\tlip->li_ops->iop_unpin(lip, 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (item_lsn != commit_lsn) {\n\n\t\t\t/*\n\t\t\t * Not a bulk update option due to unusual item_lsn.\n\t\t\t * Push into AIL immediately, rechecking the lsn once\n\t\t\t * we have the ail lock. Then unpin the item. This does\n\t\t\t * not affect the AIL cursor the bulk insert path is\n\t\t\t * using.\n\t\t\t */\n\t\t\tspin_lock(&ailp->xa_lock);\n\t\t\tif (XFS_LSN_CMP(item_lsn, lip->li_lsn) > 0)\n\t\t\t\txfs_trans_ail_update(ailp, lip, item_lsn);\n\t\t\telse\n\t\t\t\tspin_unlock(&ailp->xa_lock);\n\t\t\tlip->li_ops->iop_unpin(lip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Item is a candidate for bulk AIL insert.  */\n\t\tlog_items[i++] = lv->lv_item;\n\t\tif (i >= LOG_ITEM_BATCH_SIZE) {\n\t\t\txfs_log_item_batch_insert(ailp, &cur, log_items,\n\t\t\t\t\tLOG_ITEM_BATCH_SIZE, commit_lsn);\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\t/* make sure we insert the remainder! */\n\tif (i)\n\t\txfs_log_item_batch_insert(ailp, &cur, log_items, i, commit_lsn);\n\n\tspin_lock(&ailp->xa_lock);\n\txfs_trans_ail_cursor_done(&cur);\n\tspin_unlock(&ailp->xa_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_committed(\n\tvoid\t*args,\n\tint\tabort)\n{\n\tstruct xfs_cil_ctx\t*ctx = args;\n\tstruct xfs_mount\t*mp = ctx->cil->xc_log->l_mp;\n\n\txfs_trans_committed_bulk(ctx->cil->xc_log->l_ailp, ctx->lv_chain,\n\t\t\t\t\tctx->start_lsn, abort);\n\n\txfs_extent_busy_sort(&ctx->busy_extents);\n\txfs_extent_busy_clear(mp, &ctx->busy_extents,\n\t\t\t     (mp->m_flags & XFS_MOUNT_DISCARD) && !abort);\n\n\t/*\n\t * If we are aborting the commit, wake up anyone waiting on the\n\t * committing list.  If we don't, then a shutdown we can leave processes\n\t * waiting in xlog_cil_force_lsn() waiting on a sequence commit that\n\t * will never happen because we aborted it.\n\t */\n\tspin_lock(&ctx->cil->xc_push_lock);\n\tif (abort)\n\t\twake_up_all(&ctx->cil->xc_commit_wait);\n\tlist_del(&ctx->committing);\n\tspin_unlock(&ctx->cil->xc_push_lock);\n\n\txlog_cil_free_logvec(ctx->lv_chain);\n\n\tif (!list_empty(&ctx->busy_extents)) {\n\t\tASSERT(mp->m_flags & XFS_MOUNT_DISCARD);\n\n\t\txfs_discard_extents(mp, &ctx->busy_extents);\n\t\txfs_extent_busy_clear(mp, &ctx->busy_extents, false);\n\t}\n\n\tkmem_free(ctx);\n}"
  },
  {
    "function_name": "xlog_cil_free_logvec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "353-364",
    "snippet": "static void\nxlog_cil_free_logvec(\n\tstruct xfs_log_vec\t*log_vector)\n{\n\tstruct xfs_log_vec\t*lv;\n\n\tfor (lv = log_vector; lv; ) {\n\t\tstruct xfs_log_vec *next = lv->lv_next;\n\t\tkmem_free(lv);\n\t\tlv = next;\n\t}\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "lv"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_free_logvec(\n\tstruct xfs_log_vec\t*log_vector)\n{\n\tstruct xfs_log_vec\t*lv;\n\n\tfor (lv = log_vector; lv; ) {\n\t\tstruct xfs_log_vec *next = lv->lv_next;\n\t\tkmem_free(lv);\n\t\tlv = next;\n\t}\n}"
  },
  {
    "function_name": "xlog_cil_insert_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "277-351",
    "snippet": "static void\nxlog_cil_insert_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx = cil->xc_ctx;\n\tstruct xfs_log_item_desc *lidp;\n\tint\t\t\tlen = 0;\n\tint\t\t\tdiff_iovecs = 0;\n\tint\t\t\ticlog_space;\n\n\tASSERT(tp);\n\n\t/*\n\t * We can do this safely because the context can't checkpoint until we\n\t * are done so it doesn't matter exactly how we update the CIL.\n\t */\n\txlog_cil_insert_format_items(log, tp, &len, &diff_iovecs);\n\n\t/*\n\t * Now (re-)position everything modified at the tail of the CIL.\n\t * We do this here so we only need to take the CIL lock once during\n\t * the transaction commit.\n\t */\n\tspin_lock(&cil->xc_cil_lock);\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\t/* Skip items which aren't dirty in this transaction. */\n\t\tif (!(lidp->lid_flags & XFS_LID_DIRTY))\n\t\t\tcontinue;\n\n\t\tlist_move_tail(&lip->li_cil, &cil->xc_cil);\n\t}\n\n\t/* account for space used by new iovec headers  */\n\tlen += diff_iovecs * sizeof(xlog_op_header_t);\n\tctx->nvecs += diff_iovecs;\n\n\t/* attach the transaction to the CIL if it has any busy extents */\n\tif (!list_empty(&tp->t_busy))\n\t\tlist_splice_init(&tp->t_busy, &ctx->busy_extents);\n\n\t/*\n\t * Now transfer enough transaction reservation to the context ticket\n\t * for the checkpoint. The context ticket is special - the unit\n\t * reservation has to grow as well as the current reservation as we\n\t * steal from tickets so we can correctly determine the space used\n\t * during the transaction commit.\n\t */\n\tif (ctx->ticket->t_curr_res == 0) {\n\t\tctx->ticket->t_curr_res = ctx->ticket->t_unit_res;\n\t\ttp->t_ticket->t_curr_res -= ctx->ticket->t_unit_res;\n\t}\n\n\t/* do we need space for more log record headers? */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tif (len > 0 && (ctx->space_used / iclog_space !=\n\t\t\t\t(ctx->space_used + len) / iclog_space)) {\n\t\tint hdrs;\n\n\t\thdrs = (len + iclog_space - 1) / iclog_space;\n\t\t/* need to take into account split region headers, too */\n\t\thdrs *= log->l_iclog_hsize + sizeof(struct xlog_op_header);\n\t\tctx->ticket->t_unit_res += hdrs;\n\t\tctx->ticket->t_curr_res += hdrs;\n\t\ttp->t_ticket->t_curr_res -= hdrs;\n\t\tASSERT(tp->t_ticket->t_curr_res >= len);\n\t}\n\ttp->t_ticket->t_curr_res -= len;\n\tctx->space_used += len;\n\n\tspin_unlock(&cil->xc_cil_lock);\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cil->xc_cil_lock"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp->t_ticket->t_curr_res >= len"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&tp->t_busy",
            "&ctx->busy_extents"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tp->t_busy"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lip->li_cil",
            "&cil->xc_cil"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lidp",
            "&tp->t_items",
            "lid_trans"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cil->xc_cil_lock"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xlog_cil_insert_format_items",
          "args": [
            "log",
            "tp",
            "&len",
            "&diff_iovecs"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_insert_format_items",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "155-268",
          "snippet": "static void\nxlog_cil_insert_format_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp,\n\tint\t\t\t*diff_len,\n\tint\t\t\t*diff_iovecs)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\n\t/* Bail out if we didn't find a log item.  */\n\tif (list_empty(&tp->t_items)) {\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item *lip = lidp->lid_item;\n\t\tstruct xfs_log_vec *lv;\n\t\tstruct xfs_log_vec *old_lv;\n\t\tint\tniovecs = 0;\n\t\tint\tnbytes = 0;\n\t\tint\tbuf_size;\n\t\tbool\tordered = false;\n\n\t\t/* Skip items which aren't dirty in this transaction. */\n\t\tif (!(lidp->lid_flags & XFS_LID_DIRTY))\n\t\t\tcontinue;\n\n\t\t/* get number of vecs and size of data to be stored */\n\t\tlip->li_ops->iop_size(lip, &niovecs, &nbytes);\n\n\t\t/* Skip items that do not have any vectors for writing */\n\t\tif (!niovecs)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ordered items need to be tracked but we do not wish to write\n\t\t * them. We need a logvec to track the object, but we do not\n\t\t * need an iovec or buffer to be allocated for copying data.\n\t\t */\n\t\tif (niovecs == XFS_LOG_VEC_ORDERED) {\n\t\t\tordered = true;\n\t\t\tniovecs = 0;\n\t\t\tnbytes = 0;\n\t\t}\n\n\t\t/*\n\t\t * We 64-bit align the length of each iovec so that the start\n\t\t * of the next one is naturally aligned.  We'll need to\n\t\t * account for that slack space here. Then round nbytes up\n\t\t * to 64-bit alignment so that the initial buffer alignment is\n\t\t * easy to calculate and verify.\n\t\t */\n\t\tnbytes += niovecs * sizeof(uint64_t);\n\t\tnbytes = round_up(nbytes, sizeof(uint64_t));\n\n\t\t/* grab the old item if it exists for reservation accounting */\n\t\told_lv = lip->li_lv;\n\n\t\t/*\n\t\t * The data buffer needs to start 64-bit aligned, so round up\n\t\t * that space to ensure we can align it appropriately and not\n\t\t * overrun the buffer.\n\t\t */\n\t\tbuf_size = nbytes +\n\t\t\t   round_up((sizeof(struct xfs_log_vec) +\n\t\t\t\t     niovecs * sizeof(struct xfs_log_iovec)),\n\t\t\t\t    sizeof(uint64_t));\n\n\t\t/* compare to existing item size */\n\t\tif (lip->li_lv && buf_size <= lip->li_lv->lv_size) {\n\t\t\t/* same or smaller, optimise common overwrite case */\n\t\t\tlv = lip->li_lv;\n\t\t\tlv->lv_next = NULL;\n\n\t\t\tif (ordered)\n\t\t\t\tgoto insert;\n\n\t\t\t/*\n\t\t\t * set the item up as though it is a new insertion so\n\t\t\t * that the space reservation accounting is correct.\n\t\t\t */\n\t\t\t*diff_iovecs -= lv->lv_niovecs;\n\t\t\t*diff_len -= lv->lv_bytes;\n\t\t} else {\n\t\t\t/* allocate new data chunk */\n\t\t\tlv = kmem_zalloc(buf_size, KM_SLEEP|KM_NOFS);\n\t\t\tlv->lv_item = lip;\n\t\t\tlv->lv_size = buf_size;\n\t\t\tif (ordered) {\n\t\t\t\t/* track as an ordered logvec */\n\t\t\t\tASSERT(lip->li_lv == NULL);\n\t\t\t\tlv->lv_buf_len = XFS_LOG_VEC_ORDERED;\n\t\t\t\tgoto insert;\n\t\t\t}\n\t\t\tlv->lv_iovecp = (struct xfs_log_iovec *)&lv[1];\n\t\t}\n\n\t\t/* Ensure the lv is set up according to ->iop_size */\n\t\tlv->lv_niovecs = niovecs;\n\n\t\t/* The allocated data region lies beyond the iovec region */\n\t\tlv->lv_buf_len = 0;\n\t\tlv->lv_bytes = 0;\n\t\tlv->lv_buf = (char *)lv + buf_size - nbytes;\n\t\tASSERT(IS_ALIGNED((unsigned long)lv->lv_buf, sizeof(uint64_t)));\n\n\t\tlip->li_ops->iop_format(lip, lv);\ninsert:\n\t\tASSERT(lv->lv_buf_len <= nbytes);\n\t\txfs_cil_prepare_item(log, lv, old_lv, diff_len, diff_iovecs);\n\t}\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_insert_format_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp,\n\tint\t\t\t*diff_len,\n\tint\t\t\t*diff_iovecs)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\n\t/* Bail out if we didn't find a log item.  */\n\tif (list_empty(&tp->t_items)) {\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item *lip = lidp->lid_item;\n\t\tstruct xfs_log_vec *lv;\n\t\tstruct xfs_log_vec *old_lv;\n\t\tint\tniovecs = 0;\n\t\tint\tnbytes = 0;\n\t\tint\tbuf_size;\n\t\tbool\tordered = false;\n\n\t\t/* Skip items which aren't dirty in this transaction. */\n\t\tif (!(lidp->lid_flags & XFS_LID_DIRTY))\n\t\t\tcontinue;\n\n\t\t/* get number of vecs and size of data to be stored */\n\t\tlip->li_ops->iop_size(lip, &niovecs, &nbytes);\n\n\t\t/* Skip items that do not have any vectors for writing */\n\t\tif (!niovecs)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ordered items need to be tracked but we do not wish to write\n\t\t * them. We need a logvec to track the object, but we do not\n\t\t * need an iovec or buffer to be allocated for copying data.\n\t\t */\n\t\tif (niovecs == XFS_LOG_VEC_ORDERED) {\n\t\t\tordered = true;\n\t\t\tniovecs = 0;\n\t\t\tnbytes = 0;\n\t\t}\n\n\t\t/*\n\t\t * We 64-bit align the length of each iovec so that the start\n\t\t * of the next one is naturally aligned.  We'll need to\n\t\t * account for that slack space here. Then round nbytes up\n\t\t * to 64-bit alignment so that the initial buffer alignment is\n\t\t * easy to calculate and verify.\n\t\t */\n\t\tnbytes += niovecs * sizeof(uint64_t);\n\t\tnbytes = round_up(nbytes, sizeof(uint64_t));\n\n\t\t/* grab the old item if it exists for reservation accounting */\n\t\told_lv = lip->li_lv;\n\n\t\t/*\n\t\t * The data buffer needs to start 64-bit aligned, so round up\n\t\t * that space to ensure we can align it appropriately and not\n\t\t * overrun the buffer.\n\t\t */\n\t\tbuf_size = nbytes +\n\t\t\t   round_up((sizeof(struct xfs_log_vec) +\n\t\t\t\t     niovecs * sizeof(struct xfs_log_iovec)),\n\t\t\t\t    sizeof(uint64_t));\n\n\t\t/* compare to existing item size */\n\t\tif (lip->li_lv && buf_size <= lip->li_lv->lv_size) {\n\t\t\t/* same or smaller, optimise common overwrite case */\n\t\t\tlv = lip->li_lv;\n\t\t\tlv->lv_next = NULL;\n\n\t\t\tif (ordered)\n\t\t\t\tgoto insert;\n\n\t\t\t/*\n\t\t\t * set the item up as though it is a new insertion so\n\t\t\t * that the space reservation accounting is correct.\n\t\t\t */\n\t\t\t*diff_iovecs -= lv->lv_niovecs;\n\t\t\t*diff_len -= lv->lv_bytes;\n\t\t} else {\n\t\t\t/* allocate new data chunk */\n\t\t\tlv = kmem_zalloc(buf_size, KM_SLEEP|KM_NOFS);\n\t\t\tlv->lv_item = lip;\n\t\t\tlv->lv_size = buf_size;\n\t\t\tif (ordered) {\n\t\t\t\t/* track as an ordered logvec */\n\t\t\t\tASSERT(lip->li_lv == NULL);\n\t\t\t\tlv->lv_buf_len = XFS_LOG_VEC_ORDERED;\n\t\t\t\tgoto insert;\n\t\t\t}\n\t\t\tlv->lv_iovecp = (struct xfs_log_iovec *)&lv[1];\n\t\t}\n\n\t\t/* Ensure the lv is set up according to ->iop_size */\n\t\tlv->lv_niovecs = niovecs;\n\n\t\t/* The allocated data region lies beyond the iovec region */\n\t\tlv->lv_buf_len = 0;\n\t\tlv->lv_bytes = 0;\n\t\tlv->lv_buf = (char *)lv + buf_size - nbytes;\n\t\tASSERT(IS_ALIGNED((unsigned long)lv->lv_buf, sizeof(uint64_t)));\n\n\t\tlip->li_ops->iop_format(lip, lv);\ninsert:\n\t\tASSERT(lv->lv_buf_len <= nbytes);\n\t\txfs_cil_prepare_item(log, lv, old_lv, diff_len, diff_iovecs);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_insert_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_cil\t\t*cil = log->l_cilp;\n\tstruct xfs_cil_ctx\t*ctx = cil->xc_ctx;\n\tstruct xfs_log_item_desc *lidp;\n\tint\t\t\tlen = 0;\n\tint\t\t\tdiff_iovecs = 0;\n\tint\t\t\ticlog_space;\n\n\tASSERT(tp);\n\n\t/*\n\t * We can do this safely because the context can't checkpoint until we\n\t * are done so it doesn't matter exactly how we update the CIL.\n\t */\n\txlog_cil_insert_format_items(log, tp, &len, &diff_iovecs);\n\n\t/*\n\t * Now (re-)position everything modified at the tail of the CIL.\n\t * We do this here so we only need to take the CIL lock once during\n\t * the transaction commit.\n\t */\n\tspin_lock(&cil->xc_cil_lock);\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item\t*lip = lidp->lid_item;\n\n\t\t/* Skip items which aren't dirty in this transaction. */\n\t\tif (!(lidp->lid_flags & XFS_LID_DIRTY))\n\t\t\tcontinue;\n\n\t\tlist_move_tail(&lip->li_cil, &cil->xc_cil);\n\t}\n\n\t/* account for space used by new iovec headers  */\n\tlen += diff_iovecs * sizeof(xlog_op_header_t);\n\tctx->nvecs += diff_iovecs;\n\n\t/* attach the transaction to the CIL if it has any busy extents */\n\tif (!list_empty(&tp->t_busy))\n\t\tlist_splice_init(&tp->t_busy, &ctx->busy_extents);\n\n\t/*\n\t * Now transfer enough transaction reservation to the context ticket\n\t * for the checkpoint. The context ticket is special - the unit\n\t * reservation has to grow as well as the current reservation as we\n\t * steal from tickets so we can correctly determine the space used\n\t * during the transaction commit.\n\t */\n\tif (ctx->ticket->t_curr_res == 0) {\n\t\tctx->ticket->t_curr_res = ctx->ticket->t_unit_res;\n\t\ttp->t_ticket->t_curr_res -= ctx->ticket->t_unit_res;\n\t}\n\n\t/* do we need space for more log record headers? */\n\ticlog_space = log->l_iclog_size - log->l_iclog_hsize;\n\tif (len > 0 && (ctx->space_used / iclog_space !=\n\t\t\t\t(ctx->space_used + len) / iclog_space)) {\n\t\tint hdrs;\n\n\t\thdrs = (len + iclog_space - 1) / iclog_space;\n\t\t/* need to take into account split region headers, too */\n\t\thdrs *= log->l_iclog_hsize + sizeof(struct xlog_op_header);\n\t\tctx->ticket->t_unit_res += hdrs;\n\t\tctx->ticket->t_curr_res += hdrs;\n\t\ttp->t_ticket->t_curr_res -= hdrs;\n\t\tASSERT(tp->t_ticket->t_curr_res >= len);\n\t}\n\ttp->t_ticket->t_curr_res -= len;\n\tctx->space_used += len;\n\n\tspin_unlock(&cil->xc_cil_lock);\n}"
  },
  {
    "function_name": "xlog_cil_insert_format_items",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "155-268",
    "snippet": "static void\nxlog_cil_insert_format_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp,\n\tint\t\t\t*diff_len,\n\tint\t\t\t*diff_iovecs)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\n\t/* Bail out if we didn't find a log item.  */\n\tif (list_empty(&tp->t_items)) {\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item *lip = lidp->lid_item;\n\t\tstruct xfs_log_vec *lv;\n\t\tstruct xfs_log_vec *old_lv;\n\t\tint\tniovecs = 0;\n\t\tint\tnbytes = 0;\n\t\tint\tbuf_size;\n\t\tbool\tordered = false;\n\n\t\t/* Skip items which aren't dirty in this transaction. */\n\t\tif (!(lidp->lid_flags & XFS_LID_DIRTY))\n\t\t\tcontinue;\n\n\t\t/* get number of vecs and size of data to be stored */\n\t\tlip->li_ops->iop_size(lip, &niovecs, &nbytes);\n\n\t\t/* Skip items that do not have any vectors for writing */\n\t\tif (!niovecs)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ordered items need to be tracked but we do not wish to write\n\t\t * them. We need a logvec to track the object, but we do not\n\t\t * need an iovec or buffer to be allocated for copying data.\n\t\t */\n\t\tif (niovecs == XFS_LOG_VEC_ORDERED) {\n\t\t\tordered = true;\n\t\t\tniovecs = 0;\n\t\t\tnbytes = 0;\n\t\t}\n\n\t\t/*\n\t\t * We 64-bit align the length of each iovec so that the start\n\t\t * of the next one is naturally aligned.  We'll need to\n\t\t * account for that slack space here. Then round nbytes up\n\t\t * to 64-bit alignment so that the initial buffer alignment is\n\t\t * easy to calculate and verify.\n\t\t */\n\t\tnbytes += niovecs * sizeof(uint64_t);\n\t\tnbytes = round_up(nbytes, sizeof(uint64_t));\n\n\t\t/* grab the old item if it exists for reservation accounting */\n\t\told_lv = lip->li_lv;\n\n\t\t/*\n\t\t * The data buffer needs to start 64-bit aligned, so round up\n\t\t * that space to ensure we can align it appropriately and not\n\t\t * overrun the buffer.\n\t\t */\n\t\tbuf_size = nbytes +\n\t\t\t   round_up((sizeof(struct xfs_log_vec) +\n\t\t\t\t     niovecs * sizeof(struct xfs_log_iovec)),\n\t\t\t\t    sizeof(uint64_t));\n\n\t\t/* compare to existing item size */\n\t\tif (lip->li_lv && buf_size <= lip->li_lv->lv_size) {\n\t\t\t/* same or smaller, optimise common overwrite case */\n\t\t\tlv = lip->li_lv;\n\t\t\tlv->lv_next = NULL;\n\n\t\t\tif (ordered)\n\t\t\t\tgoto insert;\n\n\t\t\t/*\n\t\t\t * set the item up as though it is a new insertion so\n\t\t\t * that the space reservation accounting is correct.\n\t\t\t */\n\t\t\t*diff_iovecs -= lv->lv_niovecs;\n\t\t\t*diff_len -= lv->lv_bytes;\n\t\t} else {\n\t\t\t/* allocate new data chunk */\n\t\t\tlv = kmem_zalloc(buf_size, KM_SLEEP|KM_NOFS);\n\t\t\tlv->lv_item = lip;\n\t\t\tlv->lv_size = buf_size;\n\t\t\tif (ordered) {\n\t\t\t\t/* track as an ordered logvec */\n\t\t\t\tASSERT(lip->li_lv == NULL);\n\t\t\t\tlv->lv_buf_len = XFS_LOG_VEC_ORDERED;\n\t\t\t\tgoto insert;\n\t\t\t}\n\t\t\tlv->lv_iovecp = (struct xfs_log_iovec *)&lv[1];\n\t\t}\n\n\t\t/* Ensure the lv is set up according to ->iop_size */\n\t\tlv->lv_niovecs = niovecs;\n\n\t\t/* The allocated data region lies beyond the iovec region */\n\t\tlv->lv_buf_len = 0;\n\t\tlv->lv_bytes = 0;\n\t\tlv->lv_buf = (char *)lv + buf_size - nbytes;\n\t\tASSERT(IS_ALIGNED((unsigned long)lv->lv_buf, sizeof(uint64_t)));\n\n\t\tlip->li_ops->iop_format(lip, lv);\ninsert:\n\t\tASSERT(lv->lv_buf_len <= nbytes);\n\t\txfs_cil_prepare_item(log, lv, old_lv, diff_len, diff_iovecs);\n\t}\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_cil_prepare_item",
          "args": [
            "log",
            "lv",
            "old_lv",
            "diff_len",
            "diff_iovecs"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_cil_prepare_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "87-127",
          "snippet": "STATIC void\nxfs_cil_prepare_item(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_vec\t*old_lv,\n\tint\t\t\t*diff_len,\n\tint\t\t\t*diff_iovecs)\n{\n\t/* Account for the new LV being passed in */\n\tif (lv->lv_buf_len != XFS_LOG_VEC_ORDERED) {\n\t\t*diff_len += lv->lv_bytes;\n\t\t*diff_iovecs += lv->lv_niovecs;\n\t}\n\n\t/*\n\t * If there is no old LV, this is the first time we've seen the item in\n\t * this CIL context and so we need to pin it. If we are replacing the\n\t * old_lv, then remove the space it accounts for and free it.\n\t */\n\tif (!old_lv)\n\t\tlv->lv_item->li_ops->iop_pin(lv->lv_item);\n\telse if (old_lv != lv) {\n\t\tASSERT(lv->lv_buf_len != XFS_LOG_VEC_ORDERED);\n\n\t\t*diff_len -= old_lv->lv_bytes;\n\t\t*diff_iovecs -= old_lv->lv_niovecs;\n\t\tkmem_free(old_lv);\n\t}\n\n\t/* attach new log vector to log item */\n\tlv->lv_item->li_lv = lv;\n\n\t/*\n\t * If this is the first time the item is being committed to the\n\t * CIL, store the sequence number on the log item so we can\n\t * tell in future commits whether this is the first checkpoint\n\t * the item is being committed into.\n\t */\n\tif (!lv->lv_item->li_seq)\n\t\tlv->lv_item->li_seq = log->l_cilp->xc_ctx->sequence;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_cil_prepare_item(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_vec\t*old_lv,\n\tint\t\t\t*diff_len,\n\tint\t\t\t*diff_iovecs)\n{\n\t/* Account for the new LV being passed in */\n\tif (lv->lv_buf_len != XFS_LOG_VEC_ORDERED) {\n\t\t*diff_len += lv->lv_bytes;\n\t\t*diff_iovecs += lv->lv_niovecs;\n\t}\n\n\t/*\n\t * If there is no old LV, this is the first time we've seen the item in\n\t * this CIL context and so we need to pin it. If we are replacing the\n\t * old_lv, then remove the space it accounts for and free it.\n\t */\n\tif (!old_lv)\n\t\tlv->lv_item->li_ops->iop_pin(lv->lv_item);\n\telse if (old_lv != lv) {\n\t\tASSERT(lv->lv_buf_len != XFS_LOG_VEC_ORDERED);\n\n\t\t*diff_len -= old_lv->lv_bytes;\n\t\t*diff_iovecs -= old_lv->lv_niovecs;\n\t\tkmem_free(old_lv);\n\t}\n\n\t/* attach new log vector to log item */\n\tlv->lv_item->li_lv = lv;\n\n\t/*\n\t * If this is the first time the item is being committed to the\n\t * CIL, store the sequence number on the log item so we can\n\t * tell in future commits whether this is the first checkpoint\n\t * the item is being committed into.\n\t */\n\tif (!lv->lv_item->li_seq)\n\t\tlv->lv_item->li_seq = log->l_cilp->xc_ctx->sequence;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lv->lv_buf_len <= nbytes"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lip->li_ops->iop_format",
          "args": [
            "lip",
            "lv"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "IS_ALIGNED((unsigned long)lv->lv_buf, sizeof(uint64_t))"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "(unsigned long)lv->lv_buf",
            "sizeof(uint64_t)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lip->li_lv == NULL"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_zalloc",
          "args": [
            "buf_size",
            "KM_SLEEP|KM_NOFS"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zalloc_large",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "64-92",
          "snippet": "void *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zalloc_large(size_t size, xfs_km_flags_t flags)\n{\n\tunsigned noio_flag = 0;\n\tvoid\t*ptr;\n\tgfp_t\tlflags;\n\n\tptr = kmem_zalloc(size, flags | KM_MAYFAIL);\n\tif (ptr)\n\t\treturn ptr;\n\n\t/*\n\t * __vmalloc() will allocate data pages and auxillary structures (e.g.\n\t * pagetables) with GFP_KERNEL, yet we may be under GFP_NOFS context\n\t * here. Hence we need to tell memory reclaim that we are in such a\n\t * context via PF_MEMALLOC_NOIO to prevent memory reclaim re-entering\n\t * the filesystem here and potentially deadlocking.\n\t */\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tnoio_flag = memalloc_noio_save();\n\n\tlflags = kmem_flags_convert(flags);\n\tptr = __vmalloc(size, lflags | __GFP_HIGHMEM | __GFP_ZERO, PAGE_KERNEL);\n\n\tif ((current->flags & PF_FSTRANS) || (flags & KM_NOFS))\n\t\tmemalloc_noio_restore(noio_flag);\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "(sizeof(struct xfs_log_vec) +\n\t\t\t\t     niovecs * sizeof(struct xfs_log_iovec))",
            "sizeof(uint64_t)"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "nbytes",
            "sizeof(uint64_t)"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lip->li_ops->iop_size",
          "args": [
            "lip",
            "&niovecs",
            "&nbytes"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lidp",
            "&tp->t_items",
            "lid_trans"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tp->t_items"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxlog_cil_insert_format_items(\n\tstruct xlog\t\t*log,\n\tstruct xfs_trans\t*tp,\n\tint\t\t\t*diff_len,\n\tint\t\t\t*diff_iovecs)\n{\n\tstruct xfs_log_item_desc *lidp;\n\n\n\t/* Bail out if we didn't find a log item.  */\n\tif (list_empty(&tp->t_items)) {\n\t\tASSERT(0);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(lidp, &tp->t_items, lid_trans) {\n\t\tstruct xfs_log_item *lip = lidp->lid_item;\n\t\tstruct xfs_log_vec *lv;\n\t\tstruct xfs_log_vec *old_lv;\n\t\tint\tniovecs = 0;\n\t\tint\tnbytes = 0;\n\t\tint\tbuf_size;\n\t\tbool\tordered = false;\n\n\t\t/* Skip items which aren't dirty in this transaction. */\n\t\tif (!(lidp->lid_flags & XFS_LID_DIRTY))\n\t\t\tcontinue;\n\n\t\t/* get number of vecs and size of data to be stored */\n\t\tlip->li_ops->iop_size(lip, &niovecs, &nbytes);\n\n\t\t/* Skip items that do not have any vectors for writing */\n\t\tif (!niovecs)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Ordered items need to be tracked but we do not wish to write\n\t\t * them. We need a logvec to track the object, but we do not\n\t\t * need an iovec or buffer to be allocated for copying data.\n\t\t */\n\t\tif (niovecs == XFS_LOG_VEC_ORDERED) {\n\t\t\tordered = true;\n\t\t\tniovecs = 0;\n\t\t\tnbytes = 0;\n\t\t}\n\n\t\t/*\n\t\t * We 64-bit align the length of each iovec so that the start\n\t\t * of the next one is naturally aligned.  We'll need to\n\t\t * account for that slack space here. Then round nbytes up\n\t\t * to 64-bit alignment so that the initial buffer alignment is\n\t\t * easy to calculate and verify.\n\t\t */\n\t\tnbytes += niovecs * sizeof(uint64_t);\n\t\tnbytes = round_up(nbytes, sizeof(uint64_t));\n\n\t\t/* grab the old item if it exists for reservation accounting */\n\t\told_lv = lip->li_lv;\n\n\t\t/*\n\t\t * The data buffer needs to start 64-bit aligned, so round up\n\t\t * that space to ensure we can align it appropriately and not\n\t\t * overrun the buffer.\n\t\t */\n\t\tbuf_size = nbytes +\n\t\t\t   round_up((sizeof(struct xfs_log_vec) +\n\t\t\t\t     niovecs * sizeof(struct xfs_log_iovec)),\n\t\t\t\t    sizeof(uint64_t));\n\n\t\t/* compare to existing item size */\n\t\tif (lip->li_lv && buf_size <= lip->li_lv->lv_size) {\n\t\t\t/* same or smaller, optimise common overwrite case */\n\t\t\tlv = lip->li_lv;\n\t\t\tlv->lv_next = NULL;\n\n\t\t\tif (ordered)\n\t\t\t\tgoto insert;\n\n\t\t\t/*\n\t\t\t * set the item up as though it is a new insertion so\n\t\t\t * that the space reservation accounting is correct.\n\t\t\t */\n\t\t\t*diff_iovecs -= lv->lv_niovecs;\n\t\t\t*diff_len -= lv->lv_bytes;\n\t\t} else {\n\t\t\t/* allocate new data chunk */\n\t\t\tlv = kmem_zalloc(buf_size, KM_SLEEP|KM_NOFS);\n\t\t\tlv->lv_item = lip;\n\t\t\tlv->lv_size = buf_size;\n\t\t\tif (ordered) {\n\t\t\t\t/* track as an ordered logvec */\n\t\t\t\tASSERT(lip->li_lv == NULL);\n\t\t\t\tlv->lv_buf_len = XFS_LOG_VEC_ORDERED;\n\t\t\t\tgoto insert;\n\t\t\t}\n\t\t\tlv->lv_iovecp = (struct xfs_log_iovec *)&lv[1];\n\t\t}\n\n\t\t/* Ensure the lv is set up according to ->iop_size */\n\t\tlv->lv_niovecs = niovecs;\n\n\t\t/* The allocated data region lies beyond the iovec region */\n\t\tlv->lv_buf_len = 0;\n\t\tlv->lv_bytes = 0;\n\t\tlv->lv_buf = (char *)lv + buf_size - nbytes;\n\t\tASSERT(IS_ALIGNED((unsigned long)lv->lv_buf, sizeof(uint64_t)));\n\n\t\tlip->li_ops->iop_format(lip, lv);\ninsert:\n\t\tASSERT(lv->lv_buf_len <= nbytes);\n\t\txfs_cil_prepare_item(log, lv, old_lv, diff_len, diff_iovecs);\n\t}\n}"
  },
  {
    "function_name": "xfs_cil_prepare_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "87-127",
    "snippet": "STATIC void\nxfs_cil_prepare_item(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_vec\t*old_lv,\n\tint\t\t\t*diff_len,\n\tint\t\t\t*diff_iovecs)\n{\n\t/* Account for the new LV being passed in */\n\tif (lv->lv_buf_len != XFS_LOG_VEC_ORDERED) {\n\t\t*diff_len += lv->lv_bytes;\n\t\t*diff_iovecs += lv->lv_niovecs;\n\t}\n\n\t/*\n\t * If there is no old LV, this is the first time we've seen the item in\n\t * this CIL context and so we need to pin it. If we are replacing the\n\t * old_lv, then remove the space it accounts for and free it.\n\t */\n\tif (!old_lv)\n\t\tlv->lv_item->li_ops->iop_pin(lv->lv_item);\n\telse if (old_lv != lv) {\n\t\tASSERT(lv->lv_buf_len != XFS_LOG_VEC_ORDERED);\n\n\t\t*diff_len -= old_lv->lv_bytes;\n\t\t*diff_iovecs -= old_lv->lv_niovecs;\n\t\tkmem_free(old_lv);\n\t}\n\n\t/* attach new log vector to log item */\n\tlv->lv_item->li_lv = lv;\n\n\t/*\n\t * If this is the first time the item is being committed to the\n\t * CIL, store the sequence number on the log item so we can\n\t * tell in future commits whether this is the first checkpoint\n\t * the item is being committed into.\n\t */\n\tif (!lv->lv_item->li_seq)\n\t\tlv->lv_item->li_seq = log->l_cilp->xc_ctx->sequence;\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_free",
          "args": [
            "old_lv"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "66-69",
          "snippet": "static inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\nstatic inline void  kmem_free(const void *ptr)\n{\n\tkvfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lv->lv_buf_len != XFS_LOG_VEC_ORDERED"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lv->lv_item->li_ops->iop_pin",
          "args": [
            "lv->lv_item"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_cil_prepare_item(\n\tstruct xlog\t\t*log,\n\tstruct xfs_log_vec\t*lv,\n\tstruct xfs_log_vec\t*old_lv,\n\tint\t\t\t*diff_len,\n\tint\t\t\t*diff_iovecs)\n{\n\t/* Account for the new LV being passed in */\n\tif (lv->lv_buf_len != XFS_LOG_VEC_ORDERED) {\n\t\t*diff_len += lv->lv_bytes;\n\t\t*diff_iovecs += lv->lv_niovecs;\n\t}\n\n\t/*\n\t * If there is no old LV, this is the first time we've seen the item in\n\t * this CIL context and so we need to pin it. If we are replacing the\n\t * old_lv, then remove the space it accounts for and free it.\n\t */\n\tif (!old_lv)\n\t\tlv->lv_item->li_ops->iop_pin(lv->lv_item);\n\telse if (old_lv != lv) {\n\t\tASSERT(lv->lv_buf_len != XFS_LOG_VEC_ORDERED);\n\n\t\t*diff_len -= old_lv->lv_bytes;\n\t\t*diff_iovecs -= old_lv->lv_niovecs;\n\t\tkmem_free(old_lv);\n\t}\n\n\t/* attach new log vector to log item */\n\tlv->lv_item->li_lv = lv;\n\n\t/*\n\t * If this is the first time the item is being committed to the\n\t * CIL, store the sequence number on the log item so we can\n\t * tell in future commits whether this is the first checkpoint\n\t * the item is being committed into.\n\t */\n\tif (!lv->lv_item->li_seq)\n\t\tlv->lv_item->li_seq = log->l_cilp->xc_ctx->sequence;\n}"
  },
  {
    "function_name": "xlog_cil_init_post_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "74-80",
    "snippet": "void\nxlog_cil_init_post_recovery(\n\tstruct xlog\t*log)\n{\n\tlog->l_cilp->xc_ctx->ticket = xlog_cil_ticket_alloc(log);\n\tlog->l_cilp->xc_ctx->sequence = 1;\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_cil_ticket_alloc",
          "args": [
            "log"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_cil_ticket_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
          "lines": "46-62",
          "snippet": "static struct xlog_ticket *\nxlog_cil_ticket_alloc(\n\tstruct xlog\t*log)\n{\n\tstruct xlog_ticket *tic;\n\n\ttic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\n\t\t\t\tKM_SLEEP|KM_NOFS);\n\ttic->t_trans_type = XFS_TRANS_CHECKPOINT;\n\n\t/*\n\t * set the current reservation to zero so we know to steal the basic\n\t * transaction overhead reservation from the first transaction commit.\n\t */\n\ttic->t_curr_res = 0;\n\treturn tic;\n}",
          "includes": [
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_discard.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xlog_ticket *\nxlog_cil_ticket_alloc(\n\tstruct xlog\t*log)\n{\n\tstruct xlog_ticket *tic;\n\n\ttic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\n\t\t\t\tKM_SLEEP|KM_NOFS);\n\ttic->t_trans_type = XFS_TRANS_CHECKPOINT;\n\n\t/*\n\t * set the current reservation to zero so we know to steal the basic\n\t * transaction overhead reservation from the first transaction commit.\n\t */\n\ttic->t_curr_res = 0;\n\treturn tic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxlog_cil_init_post_recovery(\n\tstruct xlog\t*log)\n{\n\tlog->l_cilp->xc_ctx->ticket = xlog_cil_ticket_alloc(log);\n\tlog->l_cilp->xc_ctx->sequence = 1;\n}"
  },
  {
    "function_name": "xlog_cil_ticket_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log_cil.c",
    "lines": "46-62",
    "snippet": "static struct xlog_ticket *\nxlog_cil_ticket_alloc(\n\tstruct xlog\t*log)\n{\n\tstruct xlog_ticket *tic;\n\n\ttic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\n\t\t\t\tKM_SLEEP|KM_NOFS);\n\ttic->t_trans_type = XFS_TRANS_CHECKPOINT;\n\n\t/*\n\t * set the current reservation to zero so we know to steal the basic\n\t * transaction overhead reservation from the first transaction commit.\n\t */\n\ttic->t_curr_res = 0;\n\treturn tic;\n}",
    "includes": [
      "#include \"xfs_log_priv.h\"",
      "#include \"xfs_log.h\"",
      "#include \"xfs_trans_priv.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_discard.h\"",
      "#include \"xfs_extent_busy.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xlog_ticket_alloc",
          "args": [
            "log",
            "0",
            "1",
            "XFS_TRANSACTION",
            "0",
            "KM_SLEEP|KM_NOFS"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_ticket_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "3614-3649",
          "snippet": "struct xlog_ticket *\nxlog_ticket_alloc(\n\tstruct xlog\t\t*log,\n\tint\t\t\tunit_bytes,\n\tint\t\t\tcnt,\n\tchar\t\t\tclient,\n\tbool\t\t\tpermanent,\n\txfs_km_flags_t\t\talloc_flags)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tunit_res;\n\n\ttic = kmem_zone_zalloc(xfs_log_ticket_zone, alloc_flags);\n\tif (!tic)\n\t\treturn NULL;\n\n\tunit_res = xfs_log_calc_unit_res(log->l_mp, unit_bytes);\n\n\tatomic_set(&tic->t_ref, 1);\n\ttic->t_task\t\t= current;\n\tINIT_LIST_HEAD(&tic->t_queue);\n\ttic->t_unit_res\t\t= unit_res;\n\ttic->t_curr_res\t\t= unit_res;\n\ttic->t_cnt\t\t= cnt;\n\ttic->t_ocnt\t\t= cnt;\n\ttic->t_tid\t\t= prandom_u32();\n\ttic->t_clientid\t\t= client;\n\ttic->t_flags\t\t= XLOG_TIC_INITED;\n\ttic->t_trans_type\t= 0;\n\tif (permanent)\n\t\ttic->t_flags |= XLOG_TIC_PERM_RESERV;\n\n\txlog_tic_reset_res(tic);\n\n\treturn tic;\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_log_ticket_zone;",
            "STATIC struct",
            "STATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);",
            "STATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_log_ticket_zone;\nSTATIC struct;\nSTATIC void\nxlog_dealloc_log(\n\tstruct xlog\t\t*log);\nSTATIC int\nxlog_iclogs_empty(\n\tstruct xlog\t\t*log);\nSTATIC struct;\n\nstruct xlog_ticket *\nxlog_ticket_alloc(\n\tstruct xlog\t\t*log,\n\tint\t\t\tunit_bytes,\n\tint\t\t\tcnt,\n\tchar\t\t\tclient,\n\tbool\t\t\tpermanent,\n\txfs_km_flags_t\t\talloc_flags)\n{\n\tstruct xlog_ticket\t*tic;\n\tint\t\t\tunit_res;\n\n\ttic = kmem_zone_zalloc(xfs_log_ticket_zone, alloc_flags);\n\tif (!tic)\n\t\treturn NULL;\n\n\tunit_res = xfs_log_calc_unit_res(log->l_mp, unit_bytes);\n\n\tatomic_set(&tic->t_ref, 1);\n\ttic->t_task\t\t= current;\n\tINIT_LIST_HEAD(&tic->t_queue);\n\ttic->t_unit_res\t\t= unit_res;\n\ttic->t_curr_res\t\t= unit_res;\n\ttic->t_cnt\t\t= cnt;\n\ttic->t_ocnt\t\t= cnt;\n\ttic->t_tid\t\t= prandom_u32();\n\ttic->t_clientid\t\t= client;\n\ttic->t_flags\t\t= XLOG_TIC_INITED;\n\ttic->t_trans_type\t= 0;\n\tif (permanent)\n\t\ttic->t_flags |= XLOG_TIC_PERM_RESERV;\n\n\txlog_tic_reset_res(tic);\n\n\treturn tic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_discard.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic struct xlog_ticket *\nxlog_cil_ticket_alloc(\n\tstruct xlog\t*log)\n{\n\tstruct xlog_ticket *tic;\n\n\ttic = xlog_ticket_alloc(log, 0, 1, XFS_TRANSACTION, 0,\n\t\t\t\tKM_SLEEP|KM_NOFS);\n\ttic->t_trans_type = XFS_TRANS_CHECKPOINT;\n\n\t/*\n\t * set the current reservation to zero so we know to steal the basic\n\t * transaction overhead reservation from the first transaction commit.\n\t */\n\ttic->t_curr_res = 0;\n\treturn tic;\n}"
  }
]