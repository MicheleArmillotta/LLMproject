[
  {
    "function_name": "unregister_cld_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1547-1551",
    "snippet": "void\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_pipefs_notifier_unregister",
          "args": [
            "&nfsd4_cld_block"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\n\nvoid\nunregister_cld_notifier(void)\n{\n\trpc_pipefs_notifier_unregister(&nfsd4_cld_block);\n}"
  },
  {
    "function_name": "register_cld_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1541-1545",
    "snippet": "int\nregister_cld_notifier(void)\n{\n\treturn rpc_pipefs_notifier_register(&nfsd4_cld_block);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_pipefs_notifier_register",
          "args": [
            "&nfsd4_cld_block"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct notifier_block nfsd4_cld_block = {\n\t.notifier_call = rpc_pipefs_event,\n};\n\nint\nregister_cld_notifier(void)\n{\n\treturn rpc_pipefs_notifier_register(&nfsd4_cld_block);\n}"
  },
  {
    "function_name": "rpc_pipefs_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1498-1535",
    "snippet": "static int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_unregister_sb",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_unregister_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "782-787",
          "snippet": "static void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_register_sb",
          "args": [
            "sb",
            "cn->cn_pipe"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_register_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "769-780",
          "snippet": "static struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_CLD_PIPE\t\t\"cld\"",
            "#define NFSD_PIPE_DIR\t\t\"nfsd\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define NFSD_CLD_PIPE\t\t\"cld\"\n#define NFSD_PIPE_DIR\t\t\"nfsd\"\n\nstatic struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "THIS_MODULE"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "THIS_MODULE"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_record_grace_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1491-1496",
    "snippet": "void\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->grace_done",
          "args": [
            "nn"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_record_grace_done(struct nfsd_net *nn)\n{\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->grace_done(nn);\n}"
  },
  {
    "function_name": "nfsd4_client_record_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1480-1489",
    "snippet": "int\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->check",
          "args": [
            "clp"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nint\nnfsd4_client_record_check(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\treturn nn->client_tracking_ops->check(clp);\n\n\treturn -EOPNOTSUPP;\n}"
  },
  {
    "function_name": "nfsd4_client_record_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1471-1478",
    "snippet": "void\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->remove",
          "args": [
            "clp"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_client_record_remove(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->remove(clp);\n}"
  },
  {
    "function_name": "nfsd4_client_record_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1462-1469",
    "snippet": "void\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->create",
          "args": [
            "clp"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_client_record_create(struct nfs4_client *clp)\n{\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops)\n\t\tnn->client_tracking_ops->create(clp);\n}"
  },
  {
    "function_name": "nfsd4_client_tracking_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1450-1460",
    "snippet": "void\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->exit",
          "args": [
            "net"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}"
  },
  {
    "function_name": "nfsd4_client_tracking_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1402-1448",
    "snippet": "int\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/* just run the init if it the method is already decided */\n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t/*\n\t * First, try a UMH upcall. It should succeed or fail quickly, so\n\t * there's little harm in trying that first.\n\t */\n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t/*\n\t * See if the recoverydir exists and is a directory. If it is,\n\t * then use the legacy ops.\n\t */\n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (status)\n\t\t\tgoto do_init;\n\t}\n\n\t/* Finally, try to use nfsdcld */\n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tprintk(KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\");\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n};",
      "static struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n};",
      "static struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\"",
            "status"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->init",
          "args": [
            "net"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "path.dentry"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "nfs4_recoverydir()",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_recoverydir",
          "args": [],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "594-598",
          "snippet": "char *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nn->client_tracking_ops->init",
          "args": [
            "net"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct nfsd4_client_tracking_ops nfsd4_legacy_tracking_ops = {\n\t.init\t\t= nfsd4_legacy_tracking_init,\n\t.exit\t\t= nfsd4_legacy_tracking_exit,\n\t.create\t\t= nfsd4_create_clid_dir,\n\t.remove\t\t= nfsd4_remove_clid_dir,\n\t.check\t\t= nfsd4_check_legacy_client,\n\t.grace_done\t= nfsd4_recdir_purge_old,\n};\nstatic struct nfsd4_client_tracking_ops nfsd4_cld_tracking_ops = {\n\t.init\t\t= nfsd4_init_cld_pipe,\n\t.exit\t\t= nfsd4_remove_cld_pipe,\n\t.create\t\t= nfsd4_cld_create,\n\t.remove\t\t= nfsd4_cld_remove,\n\t.check\t\t= nfsd4_cld_check,\n\t.grace_done\t= nfsd4_cld_grace_done,\n};\nstatic struct nfsd4_client_tracking_ops nfsd4_umh_tracking_ops = {\n\t.init\t\t= nfsd4_umh_cltrack_init,\n\t.exit\t\t= NULL,\n\t.create\t\t= nfsd4_umh_cltrack_create,\n\t.remove\t\t= nfsd4_umh_cltrack_remove,\n\t.check\t\t= nfsd4_umh_cltrack_check,\n\t.grace_done\t= nfsd4_umh_cltrack_grace_done,\n};\n\nint\nnfsd4_client_tracking_init(struct net *net)\n{\n\tint status;\n\tstruct path path;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\t/* just run the init if it the method is already decided */\n\tif (nn->client_tracking_ops)\n\t\tgoto do_init;\n\n\t/*\n\t * First, try a UMH upcall. It should succeed or fail quickly, so\n\t * there's little harm in trying that first.\n\t */\n\tnn->client_tracking_ops = &nfsd4_umh_tracking_ops;\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (!status)\n\t\treturn status;\n\n\t/*\n\t * See if the recoverydir exists and is a directory. If it is,\n\t * then use the legacy ops.\n\t */\n\tnn->client_tracking_ops = &nfsd4_legacy_tracking_ops;\n\tstatus = kern_path(nfs4_recoverydir(), LOOKUP_FOLLOW, &path);\n\tif (!status) {\n\t\tstatus = d_is_dir(path.dentry);\n\t\tpath_put(&path);\n\t\tif (status)\n\t\t\tgoto do_init;\n\t}\n\n\t/* Finally, try to use nfsdcld */\n\tnn->client_tracking_ops = &nfsd4_cld_tracking_ops;\n\tprintk(KERN_WARNING \"NFSD: the nfsdcld client tracking upcall will be \"\n\t\t\t\"removed in 3.10. Please transition to using \"\n\t\t\t\"nfsdcltrack.\\n\");\ndo_init:\n\tstatus = nn->client_tracking_ops->init(net);\n\tif (status) {\n\t\tprintk(KERN_WARNING \"NFSD: Unable to initialize client \"\n\t\t\t\t    \"recovery tracking! (%d)\\n\", status);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_grace_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1381-1391",
    "snippet": "static void\nnfsd4_umh_cltrack_grace_done(struct nfsd_net *nn)\n{\n\tchar *legacy;\n\tchar timestr[22]; /* FIXME: better way to determine max size? */\n\n\tsprintf(timestr, \"%ld\", nn->boot_time);\n\tlegacy = nfsd4_cltrack_legacy_topdir();\n\tnfsd4_umh_cltrack_upcall(\"gracedone\", timestr, legacy, NULL);\n\tkfree(legacy);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "legacy"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"gracedone\"",
            "timestr",
            "legacy",
            "NULL"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1186-1227",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_legacy_topdir",
          "args": [],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_legacy_topdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1073-1099",
          "snippet": "static char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\""
          ],
          "globals_used": [
            "static bool cltrack_legacy_disable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\"\n\nstatic bool cltrack_legacy_disable;\n\nstatic char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "timestr",
            "\"%ld\"",
            "nn->boot_time"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_umh_cltrack_grace_done(struct nfsd_net *nn)\n{\n\tchar *legacy;\n\tchar timestr[22]; /* FIXME: better way to determine max size? */\n\n\tsprintf(timestr, \"%ld\", nn->boot_time);\n\tlegacy = nfsd4_cltrack_legacy_topdir();\n\tnfsd4_umh_cltrack_upcall(\"gracedone\", timestr, legacy, NULL);\n\tkfree(legacy);\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1347-1379",
    "snippet": "static int\nnfsd4_umh_cltrack_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tchar *hexid, *has_session, *legacy;\n\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tlegacy = nfsd4_cltrack_legacy_recdir(&clp->cl_name);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags)) {\n\t\tret = 0;\n\t} else {\n\t\tret = nfsd4_umh_cltrack_upcall(\"check\", hexid, has_session, legacy);\n\t\tif (ret == 0)\n\t\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\tnfsd4_cltrack_upcall_unlock(clp);\n\tkfree(has_session);\n\tkfree(legacy);\n\tkfree(hexid);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hexid"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "legacy"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "has_session"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_unlock",
          "args": [
            "clp"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1274-1281",
          "snippet": "static void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"check\"",
            "hexid",
            "has_session",
            "legacy"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1186-1227",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_lock",
          "args": [
            "clp"
          ],
          "line": 1365
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1267-1272",
          "snippet": "static void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_legacy_recdir",
          "args": [
            "&clp->cl_name"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_legacy_recdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1101-1134",
          "snippet": "static char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t/* +1 is for '/' between \"topdir\" and \"recdir\" */\n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t/* just return nothing if output will be truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\""
          ],
          "globals_used": [
            "static bool cltrack_legacy_disable;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\"\n\nstatic bool cltrack_legacy_disable;\n\nstatic char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t/* +1 is for '/' between \"topdir\" and \"recdir\" */\n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t/* just return nothing if output will be truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_client_has_session",
          "args": [
            "clp"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_client_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1136-1159",
          "snippet": "static char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\"\n\nstatic char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: can't allocate memory for upcall!\\n\"",
            "__func__"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_to_hex_dup",
          "args": [
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "bin_to_hex_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1229-1246",
          "snippet": "static char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_umh_cltrack_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tchar *hexid, *has_session, *legacy;\n\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tlegacy = nfsd4_cltrack_legacy_recdir(&clp->cl_name);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags)) {\n\t\tret = 0;\n\t} else {\n\t\tret = nfsd4_umh_cltrack_upcall(\"check\", hexid, has_session, legacy);\n\t\tif (ret == 0)\n\t\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\tnfsd4_cltrack_upcall_unlock(clp);\n\tkfree(has_session);\n\tkfree(legacy);\n\tkfree(hexid);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1324-1345",
    "snippet": "static void\nnfsd4_umh_cltrack_remove(struct nfs4_client *clp)\n{\n\tchar *hexid;\n\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags) &&\n\t    nfsd4_umh_cltrack_upcall(\"remove\", hexid, NULL, NULL) == 0)\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(hexid);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hexid"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_unlock",
          "args": [
            "clp"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1274-1281",
          "snippet": "static void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"remove\"",
            "hexid",
            "NULL",
            "NULL"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1186-1227",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_lock",
          "args": [
            "clp"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1267-1272",
          "snippet": "static void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: can't allocate memory for upcall!\\n\"",
            "__func__"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_to_hex_dup",
          "args": [
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "bin_to_hex_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1229-1246",
          "snippet": "static char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_umh_cltrack_remove(struct nfs4_client *clp)\n{\n\tchar *hexid;\n\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags) &&\n\t    nfsd4_umh_cltrack_upcall(\"remove\", hexid, NULL, NULL) == 0)\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(hexid);\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1283-1322",
    "snippet": "static void\nnfsd4_umh_cltrack_create(struct nfs4_client *clp)\n{\n\tchar *hexid, *has_session, *grace_start;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t/*\n\t * With v4.0 clients, there's little difference in outcome between a\n\t * create and check operation, and we can end up calling into this\n\t * function multiple times per client (once for each openowner). So,\n\t * for v4.0 clients skip upcalling once the client has been recorded\n\t * on stable storage.\n\t *\n\t * For v4.1+ clients, the outcome of the two operations is different,\n\t * so we must ensure that we upcall for the create operation. v4.1+\n\t * clients call this on RECLAIM_COMPLETE though, so we should only end\n\t * up doing a single create upcall per client.\n\t */\n\tif (clp->cl_minorversion == 0 &&\n\t    test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tgrace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (!nfsd4_umh_cltrack_upcall(\"create\", hexid, has_session, grace_start))\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(has_session);\n\tkfree(grace_start);\n\tkfree(hexid);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hexid"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "grace_start"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "has_session"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_unlock",
          "args": [
            "clp"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1274-1281",
          "snippet": "static void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"create\"",
            "hexid",
            "has_session",
            "grace_start"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1186-1227",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_upcall_lock",
          "args": [
            "clp"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_upcall_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1267-1272",
          "snippet": "static void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_grace_start",
          "args": [
            "nn->boot_time"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_grace_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1161-1184",
          "snippet": "static char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\"\n\nstatic char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_client_has_session",
          "args": [
            "clp"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_client_has_session",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1136-1159",
          "snippet": "static char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\"\n\nstatic char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: can't allocate memory for upcall!\\n\"",
            "__func__"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bin_to_hex_dup",
          "args": [
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "bin_to_hex_dup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1229-1246",
          "snippet": "static char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_umh_cltrack_create(struct nfs4_client *clp)\n{\n\tchar *hexid, *has_session, *grace_start;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t/*\n\t * With v4.0 clients, there's little difference in outcome between a\n\t * create and check operation, and we can end up calling into this\n\t * function multiple times per client (once for each openowner). So,\n\t * for v4.0 clients skip upcalling once the client has been recorded\n\t * on stable storage.\n\t *\n\t * For v4.1+ clients, the outcome of the two operations is different,\n\t * so we must ensure that we upcall for the create operation. v4.1+\n\t * clients call this on RECLAIM_COMPLETE though, so we should only end\n\t * up doing a single create upcall per client.\n\t */\n\tif (clp->cl_minorversion == 0 &&\n\t    test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\thexid = bin_to_hex_dup(clp->cl_name.data, clp->cl_name.len);\n\tif (!hexid) {\n\t\tdprintk(\"%s: can't allocate memory for upcall!\\n\", __func__);\n\t\treturn;\n\t}\n\n\thas_session = nfsd4_cltrack_client_has_session(clp);\n\tgrace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\tnfsd4_cltrack_upcall_lock(clp);\n\tif (!nfsd4_umh_cltrack_upcall(\"create\", hexid, has_session, grace_start))\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\tnfsd4_cltrack_upcall_unlock(clp);\n\n\tkfree(has_session);\n\tkfree(grace_start);\n\tkfree(hexid);\n}"
  },
  {
    "function_name": "nfsd4_cltrack_upcall_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1274-1281",
    "snippet": "static void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&clp->cl_flags",
            "NFSD4_CLIENT_UPCALL_LOCK"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_UPCALL_LOCK",
            "&clp->cl_flags"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__before_atomic",
          "args": [],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cltrack_upcall_unlock(struct nfs4_client *clp)\n{\n\tsmp_mb__before_atomic();\n\tclear_bit(NFSD4_CLIENT_UPCALL_LOCK, &clp->cl_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK);\n}"
  },
  {
    "function_name": "nfsd4_cltrack_upcall_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1267-1272",
    "snippet": "static void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_on_bit_lock",
          "args": [
            "&clp->cl_flags",
            "NFSD4_CLIENT_UPCALL_LOCK",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cltrack_upcall_lock(struct nfs4_client *clp)\n{\n\twait_on_bit_lock(&clp->cl_flags, NFSD4_CLIENT_UPCALL_LOCK,\n\t\t\t TASK_UNINTERRUPTIBLE);\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1248-1265",
    "snippet": "static int\nnfsd4_umh_cltrack_init(struct net *net)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tchar *grace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\t/* XXX: The usermode helper s not working in container yet. */\n\tif (net != &init_net) {\n\t\tWARN(1, KERN_ERR \"NFSD: attempt to initialize umh client \"\n\t\t\t\"tracking in a container!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = nfsd4_umh_cltrack_upcall(\"init\", NULL, grace_start, NULL);\n\tkfree(grace_start);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "grace_start"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_umh_cltrack_upcall",
          "args": [
            "\"init\"",
            "NULL",
            "grace_start",
            "NULL"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_umh_cltrack_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1186-1227",
          "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"NFSD: attempt to initialize umh client \"\n\t\t\t\"tracking in a container!\\n\""
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cltrack_grace_start",
          "args": [
            "nn->boot_time"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cltrack_grace_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1161-1184",
          "snippet": "static char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\"\n\nstatic char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_umh_cltrack_init(struct net *net)\n{\n\tint ret;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tchar *grace_start = nfsd4_cltrack_grace_start(nn->boot_time);\n\n\t/* XXX: The usermode helper s not working in container yet. */\n\tif (net != &init_net) {\n\t\tWARN(1, KERN_ERR \"NFSD: attempt to initialize umh client \"\n\t\t\t\"tracking in a container!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = nfsd4_umh_cltrack_upcall(\"init\", NULL, grace_start, NULL);\n\tkfree(grace_start);\n\treturn ret;\n}"
  },
  {
    "function_name": "bin_to_hex_dup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1229-1246",
    "snippet": "static char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "hex",
            "\"%2.2x\"",
            "*src++"
          ],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "(srclen * 2) + 1",
            "GFP_KERNEL"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char *\nbin_to_hex_dup(const unsigned char *src, int srclen)\n{\n\tint i;\n\tchar *buf, *hex;\n\n\t/* +1 for terminating NULL */\n\tbuf = kmalloc((srclen * 2) + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn buf;\n\n\thex = buf;\n\tfor (i = 0; i < srclen; i++) {\n\t\tsprintf(hex, \"%2.2x\", *src++);\n\t\thex += 2;\n\t}\n\treturn buf;\n}"
  },
  {
    "function_name": "nfsd4_umh_cltrack_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1186-1227",
    "snippet": "static int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: %s return value: %d\\n\"",
            "__func__",
            "cltrack_prog",
            "ret"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\"",
            "cltrack_prog",
            "ret"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_usermodehelper",
          "args": [
            "argv[0]",
            "argv",
            "envp",
            "UMH_WAIT_PROC"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: env1: %s\\n\"",
            "__func__",
            "env1 ? env1 : \"(null)\""
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: env0: %s\\n\"",
            "__func__",
            "env0 ? env0 : \"(null)\""
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: arg: %s\\n\"",
            "__func__",
            "arg ? arg : \"(null)\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: cmd: %s\\n\"",
            "__func__",
            "cmd"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: cltrack_prog is disabled\\n\"",
            "__func__"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!cltrack_prog[0]"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char cltrack_prog[PATH_MAX] = \"/sbin/nfsdcltrack\";\n\nstatic int\nnfsd4_umh_cltrack_upcall(char *cmd, char *arg, char *env0, char *env1)\n{\n\tchar *envp[3];\n\tchar *argv[4];\n\tint ret;\n\n\tif (unlikely(!cltrack_prog[0])) {\n\t\tdprintk(\"%s: cltrack_prog is disabled\\n\", __func__);\n\t\treturn -EACCES;\n\t}\n\n\tdprintk(\"%s: cmd: %s\\n\", __func__, cmd);\n\tdprintk(\"%s: arg: %s\\n\", __func__, arg ? arg : \"(null)\");\n\tdprintk(\"%s: env0: %s\\n\", __func__, env0 ? env0 : \"(null)\");\n\tdprintk(\"%s: env1: %s\\n\", __func__, env1 ? env1 : \"(null)\");\n\n\tenvp[0] = env0;\n\tenvp[1] = env1;\n\tenvp[2] = NULL;\n\n\targv[0] = (char *)cltrack_prog;\n\targv[1] = cmd;\n\targv[2] = arg;\n\targv[3] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\t/*\n\t * Disable the upcall mechanism if we're getting an ENOENT or EACCES\n\t * error. The admin can re-enable it on the fly by using sysfs\n\t * once the problem has been fixed.\n\t */\n\tif (ret == -ENOENT || ret == -EACCES) {\n\t\tdprintk(\"NFSD: %s was not found or isn't executable (%d). \"\n\t\t\t\"Setting cltrack_prog to blank string!\",\n\t\t\tcltrack_prog, ret);\n\t\tcltrack_prog[0] = '\\0';\n\t}\n\tdprintk(\"%s: %s return value: %d\\n\", __func__, cltrack_prog, ret);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_cltrack_grace_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1161-1184",
    "snippet": "static char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "GRACE_START_ENV_PREFIX \"%ld\"",
            "grace_start"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "GRACE_START_ENV_PREFIX"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define GRACE_START_ENV_PREFIX \"NFSDCLTRACK_GRACE_START=\"\n\nstatic char *\nnfsd4_cltrack_grace_start(time_t grace_start)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + max width of int64_t string + terminating NULL */\n\tlen = strlen(GRACE_START_ENV_PREFIX) + 22 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, GRACE_START_ENV_PREFIX \"%ld\",\n\t\t\t\tgrace_start);\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "nfsd4_cltrack_client_has_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1136-1159",
    "snippet": "static char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "HAS_SESSION_ENV_PREFIX \"%c\"",
            "clp->cl_minorversion ? 'Y' : 'N'"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1146
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "HAS_SESSION_ENV_PREFIX"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define HAS_SESSION_ENV_PREFIX \"NFSDCLTRACK_CLIENT_HAS_SESSION=\"\n\nstatic char *\nnfsd4_cltrack_client_has_session(struct nfs4_client *clp)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\t/* prefix + Y/N character + terminating NULL */\n\tlen = strlen(HAS_SESSION_ENV_PREFIX) + 1 + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, HAS_SESSION_ENV_PREFIX \"%c\",\n\t\t\t\tclp->cl_minorversion ? 'Y' : 'N');\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "nfsd4_cltrack_legacy_recdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1101-1134",
    "snippet": "static char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t/* +1 is for '/' between \"topdir\" and \"recdir\" */\n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t/* just return nothing if output will be truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\""
    ],
    "globals_used": [
      "static bool cltrack_legacy_disable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_make_rec_clidname",
          "args": [
            "result + copied",
            "name"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_make_rec_clidname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "103-141",
          "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "LEGACY_RECDIR_ENV_PREFIX \"%s/\"",
            "nfs4_recoverydir()"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_recoverydir",
          "args": [],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "594-598",
          "snippet": "char *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nfs4_recoverydir()"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define LEGACY_RECDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_RECDIR=\"\n\nstatic bool cltrack_legacy_disable;\n\nstatic char *\nnfsd4_cltrack_legacy_recdir(const struct xdr_netobj *name)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\t/* +1 is for '/' between \"topdir\" and \"recdir\" */\n\tlen = strlen(LEGACY_RECDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1 + HEXDIR_LEN;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_RECDIR_ENV_PREFIX \"%s/\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied > (len - HEXDIR_LEN)) {\n\t\t/* just return nothing if output will be truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\tcopied = nfs4_make_rec_clidname(result + copied, name);\n\tif (copied) {\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "nfsd4_cltrack_legacy_topdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1073-1099",
    "snippet": "static char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\""
    ],
    "globals_used": [
      "static bool cltrack_legacy_disable;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "result",
            "len",
            "LEGACY_TOPDIR_ENV_PREFIX \"%s\"",
            "nfs4_recoverydir()"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_recoverydir",
          "args": [],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_recoverydir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "594-598",
          "snippet": "char *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nfs4_recoverydir()"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define LEGACY_TOPDIR_ENV_PREFIX \"NFSDCLTRACK_LEGACY_TOPDIR=\"\n\nstatic bool cltrack_legacy_disable;\n\nstatic char *\nnfsd4_cltrack_legacy_topdir(void)\n{\n\tint copied;\n\tsize_t len;\n\tchar *result;\n\n\tif (cltrack_legacy_disable)\n\t\treturn NULL;\n\n\tlen = strlen(LEGACY_TOPDIR_ENV_PREFIX) +\n\t\tstrlen(nfs4_recoverydir()) + 1;\n\n\tresult = kmalloc(len, GFP_KERNEL);\n\tif (!result)\n\t\treturn result;\n\n\tcopied = snprintf(result, len, LEGACY_TOPDIR_ENV_PREFIX \"%s\",\n\t\t\t\tnfs4_recoverydir());\n\tif (copied >= len) {\n\t\t/* just return nothing if output was truncated */\n\t\tkfree(result);\n\t\treturn NULL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "nfsd4_cld_grace_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "1023-1046",
    "snippet": "static void\nnfsd4_cld_grace_done(struct nfsd_net *nn)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_GraceDone;\n\tcup->cu_msg.cm_u.cm_gracetime = (int64_t)nn->boot_time;\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret)\n\t\tret = cup->cu_msg.cm_status;\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to end grace period: %d\\n\", ret);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: Unable to end grace period: %d\\n\"",
            "ret"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cld_upcall",
          "args": [
            "cup"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "free_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "903-912",
          "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cld_pipe_upcall",
          "args": [
            "cn->cn_pipe",
            "&cup->cu_msg"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "686-700",
          "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cld_upcall",
          "args": [
            "cn"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "872-901",
          "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cld_grace_done(struct nfsd_net *nn)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct cld_net *cn = nn->cld_net;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_GraceDone;\n\tcup->cu_msg.cm_u.cm_gracetime = (int64_t)nn->boot_time;\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret)\n\t\tret = cup->cu_msg.cm_status;\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to end grace period: %d\\n\", ret);\n}"
  },
  {
    "function_name": "nfsd4_cld_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "989-1021",
    "snippet": "static int\nnfsd4_cld_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if one was already stored during this grace pd */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tprintk(KERN_ERR \"NFSD: Unable to check client record on \"\n\t\t\t\t\"stable storage: %d\\n\", -ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Check;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cld_upcall",
          "args": [
            "cup"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "free_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "903-912",
          "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cld_pipe_upcall",
          "args": [
            "cn->cn_pipe",
            "&cup->cu_msg"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "686-700",
          "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cup->cu_msg.cm_u.cm_name.cn_id",
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: Unable to check client record on \"\n\t\t\t\t\"stable storage: %d\\n\"",
            "-ENOMEM"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cld_upcall",
          "args": [
            "cn"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "872-901",
          "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_cld_check(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if one was already stored during this grace pd */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tprintk(KERN_ERR \"NFSD: Unable to check client record on \"\n\t\t\t\t\"stable storage: %d\\n\", -ENOMEM);\n\t\treturn -ENOMEM;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Check;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_cld_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "952-986",
    "snippet": "static void\nnfsd4_cld_remove(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if it's already removed */\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Remove;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to remove client \"\n\t\t\t\t\"record from stable storage: %d\\n\", ret);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: Unable to remove client \"\n\t\t\t\t\"record from stable storage: %d\\n\"",
            "ret"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cld_upcall",
          "args": [
            "cup"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "free_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "903-912",
          "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cld_pipe_upcall",
          "args": [
            "cn->cn_pipe",
            "&cup->cu_msg"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "686-700",
          "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cup->cu_msg.cm_u.cm_name.cn_id",
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cld_upcall",
          "args": [
            "cn"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "872-901",
          "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cld_remove(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if it's already removed */\n\tif (!test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Remove;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to remove client \"\n\t\t\t\t\"record from stable storage: %d\\n\", ret);\n}"
  },
  {
    "function_name": "nfsd4_cld_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "915-949",
    "snippet": "static void\nnfsd4_cld_create(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if it's already stored */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Create;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to create client \"\n\t\t\t\t\"record on stable storage: %d\\n\", ret);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: Unable to create client \"\n\t\t\t\t\"record on stable storage: %d\\n\"",
            "ret"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_cld_upcall",
          "args": [
            "cup"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "free_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "903-912",
          "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cld_pipe_upcall",
          "args": [
            "cn->cn_pipe",
            "&cup->cu_msg"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "686-700",
          "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cup->cu_msg.cm_u.cm_name.cn_id",
            "clp->cl_name.data",
            "clp->cl_name.len"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_cld_upcall",
          "args": [
            "cn"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_cld_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "872-901",
          "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cld_create(struct nfs4_client *clp)\n{\n\tint ret;\n\tstruct cld_upcall *cup;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\t/* Don't upcall if it's already stored */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tcup = alloc_cld_upcall(cn);\n\tif (!cup) {\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\tcup->cu_msg.cm_cmd = Cld_Create;\n\tcup->cu_msg.cm_u.cm_name.cn_len = clp->cl_name.len;\n\tmemcpy(cup->cu_msg.cm_u.cm_name.cn_id, clp->cl_name.data,\n\t\t\tclp->cl_name.len);\n\n\tret = cld_pipe_upcall(cn->cn_pipe, &cup->cu_msg);\n\tif (!ret) {\n\t\tret = cup->cu_msg.cm_status;\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t}\n\n\tfree_cld_upcall(cup);\nout_err:\n\tif (ret)\n\t\tprintk(KERN_ERR \"NFSD: Unable to create client \"\n\t\t\t\t\"record on stable storage: %d\\n\", ret);\n}"
  },
  {
    "function_name": "free_cld_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "903-912",
    "snippet": "static void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "victim"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&victim->cu_list"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nfree_cld_upcall(struct cld_upcall *victim)\n{\n\tstruct cld_net *cn = victim->cu_net;\n\n\tspin_lock(&cn->cn_lock);\n\tlist_del(&victim->cu_list);\n\tspin_unlock(&cn->cn_lock);\n\tkfree(victim);\n}"
  },
  {
    "function_name": "alloc_cld_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "872-901",
    "snippet": "static struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: allocated xid %u\\n\"",
            "__func__",
            "new->cu_msg.cm_xid"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&new->cu_list",
            "&cn->cn_list"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_unaligned",
          "args": [
            "cn->cn_xid++",
            "&new->cu_msg.cm_xid"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "put_unaligned_le8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/struct-funcs.c",
          "lines": "29-32",
          "snippet": "static inline void put_unaligned_le8(u8 val, void *p)\n{\n       *(u8 *)p = val;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/highmem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/highmem.h>\n\nstatic inline void put_unaligned_le8(u8 val, void *p)\n{\n       *(u8 *)p = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&cn->cn_list",
            "cu_list"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_KERNEL"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct cld_upcall *\nalloc_cld_upcall(struct cld_net *cn)\n{\n\tstruct cld_upcall *new, *tmp;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn new;\n\n\t/* FIXME: hard cap on number in flight? */\nrestart_search:\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (tmp->cu_msg.cm_xid == cn->cn_xid) {\n\t\t\tcn->cn_xid++;\n\t\t\tspin_unlock(&cn->cn_lock);\n\t\t\tgoto restart_search;\n\t\t}\n\t}\n\tnew->cu_task = current;\n\tnew->cu_msg.cm_vers = CLD_UPCALL_VERSION;\n\tput_unaligned(cn->cn_xid++, &new->cu_msg.cm_xid);\n\tnew->cu_net = cn;\n\tlist_add(&new->cu_list, &cn->cn_list);\n\tspin_unlock(&cn->cn_lock);\n\n\tdprintk(\"%s: allocated xid %u\\n\", __func__, new->cu_msg.cm_xid);\n\n\treturn new;\n}"
  },
  {
    "function_name": "nfsd4_remove_cld_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "860-870",
    "snippet": "static void\nnfsd4_remove_cld_pipe(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tnfsd4_cld_unregister_net(net, cn->cn_pipe);\n\trpc_destroy_pipe_data(cn->cn_pipe);\n\tkfree(nn->cld_net);\n\tnn->cld_net = NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->cld_net"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_destroy_pipe_data",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_unregister_net",
          "args": [
            "net",
            "cn->cn_pipe"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_unregister_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "803-813",
          "snippet": "static void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_remove_cld_pipe(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tnfsd4_cld_unregister_net(net, cn->cn_pipe);\n\trpc_destroy_pipe_data(cn->cn_pipe);\n\tkfree(nn->cld_net);\n\tnn->cld_net = NULL;\n}"
  },
  {
    "function_name": "nfsd4_init_cld_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "816-858",
    "snippet": "static int\nnfsd4_init_cld_pipe(struct net *net)\n{\n\tint ret;\n\tstruct dentry *dentry;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn;\n\n\tif (nn->cld_net)\n\t\treturn 0;\n\n\tcn = kzalloc(sizeof(*cn), GFP_KERNEL);\n\tif (!cn) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tcn->cn_pipe = rpc_mkpipe_data(&cld_upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\n\tif (IS_ERR(cn->cn_pipe)) {\n\t\tret = PTR_ERR(cn->cn_pipe);\n\t\tgoto err;\n\t}\n\tspin_lock_init(&cn->cn_lock);\n\tINIT_LIST_HEAD(&cn->cn_list);\n\n\tdentry = nfsd4_cld_register_net(net, cn->cn_pipe);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err_destroy_data;\n\t}\n\n\tcn->cn_pipe->dentry = dentry;\n\tnn->cld_net = cn;\n\treturn 0;\n\nerr_destroy_data:\n\trpc_destroy_pipe_data(cn->cn_pipe);\nerr:\n\tkfree(cn);\n\tprintk(KERN_ERR \"NFSD: unable to create nfsdcld upcall pipe (%d)\\n\",\n\t\t\tret);\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct rpc_pipe_ops cld_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= cld_pipe_downcall,\n\t.destroy_msg\t= cld_pipe_destroy_msg,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: unable to create nfsdcld upcall pipe (%d)\\n\"",
            "ret"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cn"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_destroy_pipe_data",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_register_net",
          "args": [
            "net",
            "cn->cn_pipe"
          ],
          "line": 841
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_register_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "789-801",
          "snippet": "static struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&cn->cn_list"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cn->cn_pipe"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_mkpipe_data",
          "args": [
            "&cld_upcall_ops",
            "RPC_PIPE_WAIT_FOR_OPEN"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*cn)",
            "GFP_KERNEL"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic const struct rpc_pipe_ops cld_upcall_ops = {\n\t.upcall\t\t= rpc_pipe_generic_upcall,\n\t.downcall\t= cld_pipe_downcall,\n\t.destroy_msg\t= cld_pipe_destroy_msg,\n};\n\nstatic int\nnfsd4_init_cld_pipe(struct net *net)\n{\n\tint ret;\n\tstruct dentry *dentry;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn;\n\n\tif (nn->cld_net)\n\t\treturn 0;\n\n\tcn = kzalloc(sizeof(*cn), GFP_KERNEL);\n\tif (!cn) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tcn->cn_pipe = rpc_mkpipe_data(&cld_upcall_ops, RPC_PIPE_WAIT_FOR_OPEN);\n\tif (IS_ERR(cn->cn_pipe)) {\n\t\tret = PTR_ERR(cn->cn_pipe);\n\t\tgoto err;\n\t}\n\tspin_lock_init(&cn->cn_lock);\n\tINIT_LIST_HEAD(&cn->cn_list);\n\n\tdentry = nfsd4_cld_register_net(net, cn->cn_pipe);\n\tif (IS_ERR(dentry)) {\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err_destroy_data;\n\t}\n\n\tcn->cn_pipe->dentry = dentry;\n\tnn->cld_net = cn;\n\treturn 0;\n\nerr_destroy_data:\n\trpc_destroy_pipe_data(cn->cn_pipe);\nerr:\n\tkfree(cn);\n\tprintk(KERN_ERR \"NFSD: unable to create nfsdcld upcall pipe (%d)\\n\",\n\t\t\tret);\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_cld_unregister_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "803-813",
    "snippet": "static void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_sb_net",
          "args": [
            "net"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_unregister_sb",
          "args": [
            "pipe"
          ],
          "line": 810
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_unregister_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "782-787",
          "snippet": "static void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_get_sb_net",
          "args": [
            "net"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cld_unregister_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\n\tsb = rpc_get_sb_net(net);\n\tif (sb) {\n\t\tnfsd4_cld_unregister_sb(pipe);\n\t\trpc_put_sb_net(net);\n\t}\n}"
  },
  {
    "function_name": "nfsd4_cld_register_net",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "789-801",
    "snippet": "static struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_put_sb_net",
          "args": [
            "net"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfsd4_cld_register_sb",
          "args": [
            "sb",
            "pipe"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_cld_register_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "769-780",
          "snippet": "static struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define NFSD_CLD_PIPE\t\t\"cld\"",
            "#define NFSD_PIPE_DIR\t\t\"nfsd\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define NFSD_CLD_PIPE\t\t\"cld\"\n#define NFSD_PIPE_DIR\t\t\"nfsd\"\n\nstatic struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_get_sb_net",
          "args": [
            "net"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic struct dentry *\nnfsd4_cld_register_net(struct net *net, struct rpc_pipe *pipe)\n{\n\tstruct super_block *sb;\n\tstruct dentry *dentry;\n\n\tsb = rpc_get_sb_net(net);\n\tif (!sb)\n\t\treturn NULL;\n\tdentry = nfsd4_cld_register_sb(sb, pipe);\n\trpc_put_sb_net(net);\n\treturn dentry;\n}"
  },
  {
    "function_name": "nfsd4_cld_unregister_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "782-787",
    "snippet": "static void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rpc_unlink",
          "args": [
            "pipe->dentry"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_cld_unregister_sb(struct rpc_pipe *pipe)\n{\n\tif (pipe->dentry)\n\t\trpc_unlink(pipe->dentry);\n}"
  },
  {
    "function_name": "nfsd4_cld_register_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "769-780",
    "snippet": "static struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [
      "#define NFSD_CLD_PIPE\t\t\"cld\"",
      "#define NFSD_PIPE_DIR\t\t\"nfsd\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dir"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rpc_mkpipe_dentry",
          "args": [
            "dir",
            "NFSD_CLD_PIPE",
            "NULL",
            "pipe"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_d_lookup_sb",
          "args": [
            "sb",
            "NFSD_PIPE_DIR"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\n#define NFSD_CLD_PIPE\t\t\"cld\"\n#define NFSD_PIPE_DIR\t\t\"nfsd\"\n\nstatic struct dentry *\nnfsd4_cld_register_sb(struct super_block *sb, struct rpc_pipe *pipe)\n{\n\tstruct dentry *dir, *dentry;\n\n\tdir = rpc_d_lookup_sb(sb, NFSD_PIPE_DIR);\n\tif (dir == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\tdentry = rpc_mkpipe_dentry(dir, NFSD_CLD_PIPE, NULL, pipe);\n\tdput(dir);\n\treturn dentry;\n}"
  },
  {
    "function_name": "cld_pipe_destroy_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "749-761",
    "snippet": "static void\ncld_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct cld_msg *cmsg = msg->data;\n\tstruct cld_upcall *cup = container_of(cmsg, struct cld_upcall,\n\t\t\t\t\t\t cu_msg);\n\n\t/* errno >= 0 means we got a downcall */\n\tif (msg->errno >= 0)\n\t\treturn;\n\n\twake_up_process(cup->cu_task);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "cup->cu_task"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "cmsg",
            "structcld_upcall",
            "cu_msg"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\ncld_pipe_destroy_msg(struct rpc_pipe_msg *msg)\n{\n\tstruct cld_msg *cmsg = msg->data;\n\tstruct cld_upcall *cup = container_of(cmsg, struct cld_upcall,\n\t\t\t\t\t\t cu_msg);\n\n\t/* errno >= 0 means we got a downcall */\n\tif (msg->errno >= 0)\n\t\treturn;\n\n\twake_up_process(cup->cu_task);\n}"
  },
  {
    "function_name": "cld_pipe_downcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "702-747",
    "snippet": "static ssize_t\ncld_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct cld_upcall *tmp, *cup;\n\tstruct cld_msg __user *cmsg = (struct cld_msg __user *)src;\n\tuint32_t xid;\n\tstruct nfsd_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\n\t\t\t\t\t\tnfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tif (mlen != sizeof(*cmsg)) {\n\t\tdprintk(\"%s: got %zu bytes, expected %zu\\n\", __func__, mlen,\n\t\t\tsizeof(*cmsg));\n\t\treturn -EINVAL;\n\t}\n\n\t/* copy just the xid so we can try to find that */\n\tif (copy_from_user(&xid, &cmsg->cm_xid, sizeof(xid)) != 0) {\n\t\tdprintk(\"%s: error when copying xid from userspace\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* walk the list and find corresponding xid */\n\tcup = NULL;\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (get_unaligned(&tmp->cu_msg.cm_xid) == xid) {\n\t\t\tcup = tmp;\n\t\t\tlist_del_init(&cup->cu_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cn->cn_lock);\n\n\t/* couldn't find upcall? */\n\tif (!cup) {\n\t\tdprintk(\"%s: couldn't find upcall -- xid=%u\\n\", __func__, xid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&cup->cu_msg, src, mlen) != 0)\n\t\treturn -EFAULT;\n\n\twake_up_process(cup->cu_task);\n\treturn mlen;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "cup->cu_task"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&cup->cu_msg",
            "src",
            "mlen"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: couldn't find upcall -- xid=%u\\n\"",
            "__func__",
            "xid"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&cup->cu_list"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_unaligned",
          "args": [
            "&tmp->cu_msg.cm_xid"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "get_unaligned_le8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/struct-funcs.c",
          "lines": "24-27",
          "snippet": "static inline u8 get_unaligned_le8(const void *p)\n{\n       return *(u8 *)p;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/highmem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/highmem.h>\n\nstatic inline u8 get_unaligned_le8(const void *p)\n{\n       return *(u8 *)p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp",
            "&cn->cn_list",
            "cu_list"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&cn->cn_lock"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: error when copying xid from userspace\"",
            "__func__"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: got %zu bytes, expected %zu\\n\"",
            "__func__",
            "mlen",
            "sizeof(*cmsg)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "file_inode(filp)->i_sb->s_fs_info",
            "nfsd_net_id"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "filp"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic ssize_t\ncld_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)\n{\n\tstruct cld_upcall *tmp, *cup;\n\tstruct cld_msg __user *cmsg = (struct cld_msg __user *)src;\n\tuint32_t xid;\n\tstruct nfsd_net *nn = net_generic(file_inode(filp)->i_sb->s_fs_info,\n\t\t\t\t\t\tnfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\n\tif (mlen != sizeof(*cmsg)) {\n\t\tdprintk(\"%s: got %zu bytes, expected %zu\\n\", __func__, mlen,\n\t\t\tsizeof(*cmsg));\n\t\treturn -EINVAL;\n\t}\n\n\t/* copy just the xid so we can try to find that */\n\tif (copy_from_user(&xid, &cmsg->cm_xid, sizeof(xid)) != 0) {\n\t\tdprintk(\"%s: error when copying xid from userspace\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\t/* walk the list and find corresponding xid */\n\tcup = NULL;\n\tspin_lock(&cn->cn_lock);\n\tlist_for_each_entry(tmp, &cn->cn_list, cu_list) {\n\t\tif (get_unaligned(&tmp->cu_msg.cm_xid) == xid) {\n\t\t\tcup = tmp;\n\t\t\tlist_del_init(&cup->cu_list);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&cn->cn_lock);\n\n\t/* couldn't find upcall? */\n\tif (!cup) {\n\t\tdprintk(\"%s: couldn't find upcall -- xid=%u\\n\", __func__, xid);\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&cup->cu_msg, src, mlen) != 0)\n\t\treturn -EFAULT;\n\n\twake_up_process(cup->cu_task);\n\treturn mlen;\n}"
  },
  {
    "function_name": "cld_pipe_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "686-700",
    "snippet": "static int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__cld_pipe_upcall",
          "args": [
            "pipe",
            "cmsg"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "__cld_pipe_upcall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "657-684",
          "snippet": "static int\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = sizeof(*cmsg);\n\n\t/*\n\t * Set task state before we queue the upcall. That prevents\n\t * wake_up_process in the downcall from racing with schedule.\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tgoto out;\n\t}\n\n\tschedule();\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = sizeof(*cmsg);\n\n\t/*\n\t * Set task state before we queue the upcall. That prevents\n\t * wake_up_process in the downcall from racing with schedule.\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tgoto out;\n\t}\n\n\tschedule();\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\ncld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\n\t/*\n\t * -EAGAIN occurs when pipe is closed and reopened while there are\n\t *  upcalls queued.\n\t */\n\tdo {\n\t\tret = __cld_pipe_upcall(pipe, cmsg);\n\t} while (ret == -EAGAIN);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__cld_pipe_upcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "657-684",
    "snippet": "static int\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = sizeof(*cmsg);\n\n\t/*\n\t * Set task state before we queue the upcall. That prevents\n\t * wake_up_process in the downcall from racing with schedule.\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tgoto out;\n\t}\n\n\tschedule();\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_queue_upcall",
          "args": [
            "pipe",
            "&msg"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg",
            "0",
            "sizeof(msg)"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\n__cld_pipe_upcall(struct rpc_pipe *pipe, struct cld_msg *cmsg)\n{\n\tint ret;\n\tstruct rpc_pipe_msg msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.data = cmsg;\n\tmsg.len = sizeof(*cmsg);\n\n\t/*\n\t * Set task state before we queue the upcall. That prevents\n\t * wake_up_process in the downcall from racing with schedule.\n\t */\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tret = rpc_queue_upcall(pipe, &msg);\n\tif (ret < 0) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tgoto out;\n\t}\n\n\tschedule();\n\n\tif (msg.errno < 0)\n\t\tret = msg.errno;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "nfsd4_check_legacy_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "600-627",
    "snippet": "static int\nnfsd4_check_legacy_client(struct nfs4_client *clp)\n{\n\tint status;\n\tchar dname[HEXDIR_LEN];\n\tstruct nfs4_client_reclaim *crp;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t/* did we already find that this client is stable? */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status) {\n\t\tlegacy_recdir_name_error(clp, status);\n\t\treturn status;\n\t}\n\n\t/* look for it in the reclaim hashtable otherwise */\n\tcrp = nfsd4_find_reclaim_client(dname, nn);\n\tif (crp) {\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t\tcrp->cr_clp = clp;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_find_reclaim_client",
          "args": [
            "dname",
            "nn"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_reclaim_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5698-5713",
          "snippet": "struct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "legacy_recdir_name_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "legacy_recdir_name_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "148-164",
          "snippet": "static void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_make_rec_clidname",
          "args": [
            "dname",
            "&clp->cl_name"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_make_rec_clidname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "103-141",
          "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_check_legacy_client(struct nfs4_client *clp)\n{\n\tint status;\n\tchar dname[HEXDIR_LEN];\n\tstruct nfs4_client_reclaim *crp;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\t/* did we already find that this client is stable? */\n\tif (test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn 0;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status) {\n\t\tlegacy_recdir_name_error(clp, status);\n\t\treturn status;\n\t}\n\n\t/* look for it in the reclaim hashtable otherwise */\n\tcrp = nfsd4_find_reclaim_client(dname, nn);\n\tif (crp) {\n\t\tset_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\t\tcrp->cr_clp = clp;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "nfs4_recoverydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "594-598",
    "snippet": "char *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nchar *\nnfs4_recoverydir(void)\n{\n\treturn user_recovery_dirname;\n}"
  },
  {
    "function_name": "nfs4_reset_recoverydir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "576-592",
    "snippet": "int\nnfs4_reset_recoverydir(char *recdir)\n{\n\tint status;\n\tstruct path path;\n\n\tstatus = kern_path(recdir, LOOKUP_FOLLOW, &path);\n\tif (status)\n\t\treturn status;\n\tstatus = -ENOTDIR;\n\tif (d_is_dir(path.dentry)) {\n\t\tstrcpy(user_recovery_dirname, recdir);\n\t\tstatus = 0;\n\t}\n\tpath_put(&path);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "user_recovery_dirname",
            "recdir"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "path.dentry"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "recdir",
            "LOOKUP_FOLLOW",
            "&path"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "kern_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2089-2096",
          "snippet": "int kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nint kern_path(const char *name, unsigned int flags, struct path *path)\n{\n\tstruct nameidata nd;\n\tint res = do_path_lookup(AT_FDCWD, name, flags, &nd);\n\tif (!res)\n\t\t*path = nd.path;\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nint\nnfs4_reset_recoverydir(char *recdir)\n{\n\tint status;\n\tstruct path path;\n\n\tstatus = kern_path(recdir, LOOKUP_FOLLOW, &path);\n\tif (status)\n\t\treturn status;\n\tstatus = -ENOTDIR;\n\tif (d_is_dir(path.dentry)) {\n\t\tstrcpy(user_recovery_dirname, recdir);\n\t\tstatus = 0;\n\t}\n\tpath_put(&path);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_legacy_tracking_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "563-571",
    "snippet": "static void\nnfsd4_legacy_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_release_reclaim(nn);\n\tnfsd4_shutdown_recdir(net);\n\tnfs4_legacy_state_shutdown(net);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_legacy_state_shutdown",
          "args": [
            "net"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_legacy_state_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "513-519",
          "snippet": "static void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_shutdown_recdir",
          "args": [
            "net"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_shutdown_recdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "484-493",
          "snippet": "static void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_release_reclaim",
          "args": [
            "nn"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_release_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5680-5694",
          "snippet": "void\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_legacy_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tnfs4_release_reclaim(nn);\n\tnfsd4_shutdown_recdir(net);\n\tnfs4_legacy_state_shutdown(net);\n}"
  },
  {
    "function_name": "nfsd4_legacy_tracking_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "537-561",
    "snippet": "static int\nnfsd4_legacy_tracking_init(struct net *net)\n{\n\tint status;\n\n\t/* XXX: The legacy code won't work in a container */\n\tif (net != &init_net) {\n\t\tWARN(1, KERN_ERR \"NFSD: attempt to initialize legacy client \"\n\t\t\t\"tracking in a container!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = nfs4_legacy_state_init(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_load_reboot_recovery_data(net);\n\tif (status)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tnfs4_legacy_state_shutdown(net);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_legacy_state_shutdown",
          "args": [
            "net"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_legacy_state_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "513-519",
          "snippet": "static void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_load_reboot_recovery_data",
          "args": [
            "net"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_load_reboot_recovery_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "521-535",
          "snippet": "static int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_legacy_state_init",
          "args": [
            "net"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_legacy_state_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "495-511",
          "snippet": "static int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_ERR \"NFSD: attempt to initialize legacy client \"\n\t\t\t\"tracking in a container!\\n\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_legacy_tracking_init(struct net *net)\n{\n\tint status;\n\n\t/* XXX: The legacy code won't work in a container */\n\tif (net != &init_net) {\n\t\tWARN(1, KERN_ERR \"NFSD: attempt to initialize legacy client \"\n\t\t\t\"tracking in a container!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tstatus = nfs4_legacy_state_init(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_load_reboot_recovery_data(net);\n\tif (status)\n\t\tgoto err;\n\treturn 0;\n\nerr:\n\tnfs4_legacy_state_shutdown(net);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_load_reboot_recovery_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "521-535",
    "snippet": "static int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_shutdown_recdir",
          "args": [
            "net"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_shutdown_recdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "484-493",
          "snippet": "static void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_recdir_load",
          "args": [
            "net"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_recdir_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "431-444",
          "snippet": "static int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_init_recdir",
          "args": [
            "net"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_init_recdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "450-482",
          "snippet": "static int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nstatic int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_load_reboot_recovery_data(struct net *net)\n{\n\tint status;\n\n\tstatus = nfsd4_init_recdir(net);\n\tif (status)\n\t\treturn status;\n\n\tstatus = nfsd4_recdir_load(net);\n\tif (status)\n\t\tnfsd4_shutdown_recdir(net);\n\n\treturn status;\n}"
  },
  {
    "function_name": "nfs4_legacy_state_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "513-519",
    "snippet": "static void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "nn->reclaim_str_hashtbl"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_legacy_state_shutdown(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tkfree(nn->reclaim_str_hashtbl);\n}"
  },
  {
    "function_name": "nfs4_legacy_state_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "495-511",
    "snippet": "static int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&nn->reclaim_str_hashtbl[i]"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE",
            "GFP_KERNEL"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_legacy_state_init(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tint i;\n\n\tnn->reclaim_str_hashtbl = kmalloc(sizeof(struct list_head) *\n\t\t\t\t\t  CLIENT_HASH_SIZE, GFP_KERNEL);\n\tif (!nn->reclaim_str_hashtbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&nn->reclaim_str_hashtbl[i]);\n\tnn->reclaim_str_hashtbl_size = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_shutdown_recdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "484-493",
    "snippet": "static void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "nn->rec_file"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_shutdown_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn;\n\tfput(nn->rec_file);\n\tnn->rec_file = NULL;\n}"
  },
  {
    "function_name": "nfsd4_init_recdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "450-482",
    "snippet": "static int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_reset_creds",
          "args": [
            "original_cred"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "83-87",
          "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "nn->rec_file"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NFSD: unable to find recovery directory %s\\n\"",
            "user_recovery_dirname"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "nn->rec_file"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filp_open",
          "args": [
            "user_recovery_dirname",
            "O_RDONLY | O_DIRECTORY",
            "0"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/open.c",
          "lines": "969-979",
          "snippet": "struct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/ima.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/falloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/personality.h>",
            "#include <linux/fs.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/securebits.h>",
            "#include <linux/capability.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/namei.h>",
            "#include <linux/tty.h>",
            "#include <linux/module.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/dnotify.h>\n#include <linux/ima.h>\n#include <linux/fs_struct.h>\n#include <linux/falloc.h>\n#include <linux/audit.h>\n#include <linux/rcupdate.h>\n#include <linux/syscalls.h>\n#include <linux/pagemap.h>\n#include <linux/personality.h>\n#include <linux/fs.h>\n#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/securebits.h>\n#include <linux/capability.h>\n#include <linux/backing-dev.h>\n#include <linux/namei.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/fsnotify.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n\nstruct file *filp_open(const char *filename, int flags, umode_t mode)\n{\n\tstruct filename *name = getname_kernel(filename);\n\tstruct file *file = ERR_CAST(name);\n\t\n\tif (!IS_ERR(name)) {\n\t\tfile = file_open_name(name, flags, mode);\n\t\tputname(name);\n\t}\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_save_creds",
          "args": [
            "&original_cred"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_save_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "67-81",
          "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nn->rec_file"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nstatic int\nnfsd4_init_recdir(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tconst struct cred *original_cred;\n\tint status;\n\n\tprintk(\"NFSD: Using %s as the NFSv4 state recovery directory\\n\",\n\t\t\tuser_recovery_dirname);\n\n\tBUG_ON(nn->rec_file);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0) {\n\t\tprintk(\"NFSD: Unable to change credentials to find recovery\"\n\t\t       \" directory: error %d\\n\",\n\t\t       status);\n\t\treturn status;\n\t}\n\n\tnn->rec_file = filp_open(user_recovery_dirname, O_RDONLY | O_DIRECTORY, 0);\n\tif (IS_ERR(nn->rec_file)) {\n\t\tprintk(\"NFSD: unable to find recovery directory %s\\n\",\n\t\t\t\tuser_recovery_dirname);\n\t\tstatus = PTR_ERR(nn->rec_file);\n\t\tnn->rec_file = NULL;\n\t}\n\n\tnfs4_reset_creds(original_cred);\n\tif (!status)\n\t\tnn->in_grace = true;\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_recdir_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "431-444",
    "snippet": "static int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\"",
            "nn->rec_file"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_list_rec_dir",
          "args": [
            "load_recdir",
            "nn"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_list_rec_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "266-308",
          "snippet": "static int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\twhile (!list_empty(&ctx.names)) {\n\t\tstruct name_list *entry;\n\t\tentry = list_entry(ctx.names.next, struct name_list, list);\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tnfs4_reset_creds(original_cred);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\twhile (!list_empty(&ctx.names)) {\n\t\tstruct name_list *entry;\n\t\tentry = list_entry(ctx.names.next, struct name_list, list);\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tnfs4_reset_creds(original_cred);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "net",
            "nfsd_net_id"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_recdir_load(struct net *net) {\n\tint status;\n\tstruct nfsd_net *nn =  net_generic(net, nfsd_net_id);\n\n\tif (!nn->rec_file)\n\t\treturn 0;\n\n\tstatus = nfsd4_list_rec_dir(load_recdir, nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed loading clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n\treturn status;\n}"
  },
  {
    "function_name": "load_recdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "418-429",
    "snippet": "static int\nload_recdir(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tif (child->d_name.len != HEXDIR_LEN - 1) {\n\t\tprintk(\"nfsd4: illegal name %pd in recovery directory\\n\",\n\t\t\t\tchild);\n\t\t/* Keep trying; maybe the others are OK: */\n\t\treturn 0;\n\t}\n\tnfs4_client_to_reclaim(child->d_name.name, nn);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_client_to_reclaim",
          "args": [
            "child->d_name.name",
            "nn"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_client_to_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5653-5670",
          "snippet": "struct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd4: illegal name %pd in recovery directory\\n\"",
            "child"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nload_recdir(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tif (child->d_name.len != HEXDIR_LEN - 1) {\n\t\tprintk(\"nfsd4: illegal name %pd in recovery directory\\n\",\n\t\t\t\tchild);\n\t\t/* Keep trying; maybe the others are OK: */\n\t\treturn 0;\n\t}\n\tnfs4_client_to_reclaim(child->d_name.name, nn);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_recdir_purge_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "396-416",
    "snippet": "static void\nnfsd4_recdir_purge_old(struct nfsd_net *nn)\n{\n\tint status;\n\n\tnn->in_grace = false;\n\tif (!nn->rec_file)\n\t\treturn;\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd4_list_rec_dir(purge_old, nn);\n\tif (status == 0)\n\t\tvfs_fsync(nn->rec_file, 0);\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tnfs4_release_reclaim(nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed to purge old clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"nfsd4: failed to purge old clients from recovery\"\n\t\t\t\" directory %pD\\n\"",
            "nn->rec_file"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_release_reclaim",
          "args": [
            "nn"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_release_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5680-5694",
          "snippet": "void\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_release_reclaim(struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp = NULL;\n\tint i;\n\n\tfor (i = 0; i < CLIENT_HASH_SIZE; i++) {\n\t\twhile (!list_empty(&nn->reclaim_str_hashtbl[i])) {\n\t\t\tcrp = list_entry(nn->reclaim_str_hashtbl[i].next,\n\t\t\t                struct nfs4_client_reclaim, cr_strhash);\n\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\n\tWARN_ON_ONCE(nn->reclaim_str_hashtbl_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "nn->rec_file",
            "0"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "202-205",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_list_rec_dir",
          "args": [
            "purge_old",
            "nn"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_list_rec_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "266-308",
          "snippet": "static int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\twhile (!list_empty(&ctx.names)) {\n\t\tstruct name_list *entry;\n\t\tentry = list_entry(ctx.names.next, struct name_list, list);\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tnfs4_reset_creds(original_cred);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\twhile (!list_empty(&ctx.names)) {\n\t\tstruct name_list *entry;\n\t\tentry = list_entry(ctx.names.next, struct name_list, list);\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tnfs4_reset_creds(original_cred);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_recdir_purge_old(struct nfsd_net *nn)\n{\n\tint status;\n\n\tnn->in_grace = false;\n\tif (!nn->rec_file)\n\t\treturn;\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tstatus = nfsd4_list_rec_dir(purge_old, nn);\n\tif (status == 0)\n\t\tvfs_fsync(nn->rec_file, 0);\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tnfs4_release_reclaim(nn);\n\tif (status)\n\t\tprintk(\"nfsd4: failed to purge old clients from recovery\"\n\t\t\t\" directory %pD\\n\", nn->rec_file);\n}"
  },
  {
    "function_name": "purge_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "380-394",
    "snippet": "static int\npurge_old(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tint status;\n\n\tif (nfs4_has_reclaimed_state(child->d_name.name, nn))\n\t\treturn 0;\n\n\tstatus = vfs_rmdir(parent->d_inode, child);\n\tif (status)\n\t\tprintk(\"failed to remove client recovery directory %pd\\n\",\n\t\t\t\tchild);\n\t/* Keep trying, success or failure: */\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"failed to remove client recovery directory %pd\\n\"",
            "child"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_rmdir",
          "args": [
            "parent->d_inode",
            "child"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3596-3632",
          "snippet": "int vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_has_reclaimed_state",
          "args": [
            "child->d_name.name",
            "nn"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_has_reclaimed_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5641-5648",
          "snippet": "bool\nnfs4_has_reclaimed_state(const char *name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nbool\nnfs4_has_reclaimed_state(const char *name, struct nfsd_net *nn)\n{\n\tstruct nfs4_client_reclaim *crp;\n\n\tcrp = nfsd4_find_reclaim_client(name, nn);\n\treturn (crp && crp->cr_clp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\npurge_old(struct dentry *parent, struct dentry *child, struct nfsd_net *nn)\n{\n\tint status;\n\n\tif (nfs4_has_reclaimed_state(child->d_name.name, nn))\n\t\treturn 0;\n\n\tstatus = vfs_rmdir(parent->d_inode, child);\n\tif (status)\n\t\tprintk(\"failed to remove client recovery directory %pd\\n\",\n\t\t\t\tchild);\n\t/* Keep trying, success or failure: */\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_remove_clid_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "336-378",
    "snippet": "static void\nnfsd4_remove_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tstruct nfs4_client_reclaim *crp;\n\tchar dname[HEXDIR_LEN];\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!nn->rec_file || !test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\tgoto out_drop_write;\n\n\tstatus = nfsd4_unlink_clid_dir(dname, HEXDIR_LEN-1, nn);\n\tnfs4_reset_creds(original_cred);\n\tif (status == 0) {\n\t\tvfs_fsync(nn->rec_file, 0);\n\t\tif (nn->in_grace) {\n\t\t\t/* remove reclaim record */\n\t\t\tcrp = nfsd4_find_reclaim_client(dname, nn);\n\t\t\tif (crp)\n\t\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\nout_drop_write:\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tif (status)\n\t\tprintk(\"NFSD: Failed to remove expired client state directory\"\n\t\t\t\t\" %.*s\\n\", HEXDIR_LEN, dname);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"NFSD: Failed to remove expired client state directory\"\n\t\t\t\t\" %.*s\\n\"",
            "HEXDIR_LEN",
            "dname"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_remove_reclaim_record",
          "args": [
            "crp",
            "nn"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_remove_reclaim_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5672-5678",
          "snippet": "void\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nvoid\nnfs4_remove_reclaim_record(struct nfs4_client_reclaim *crp, struct nfsd_net *nn)\n{\n\tlist_del(&crp->cr_strhash);\n\tkfree(crp);\n\tnn->reclaim_str_hashtbl_size--;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_find_reclaim_client",
          "args": [
            "dname",
            "nn"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_find_reclaim_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5698-5713",
          "snippet": "struct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfsd4_find_reclaim_client(const char *recdir, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp = NULL;\n\n\tdprintk(\"NFSD: nfs4_find_reclaim_client for recdir %s\\n\", recdir);\n\n\tstrhashval = clientstr_hashval(recdir);\n\tlist_for_each_entry(crp, &nn->reclaim_str_hashtbl[strhashval], cr_strhash) {\n\t\tif (same_name(crp->cr_recdir, recdir)) {\n\t\t\treturn crp;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "nn->rec_file",
            "0"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "202-205",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_reset_creds",
          "args": [
            "original_cred"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "83-87",
          "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfsd4_unlink_clid_dir",
          "args": [
            "dname",
            "HEXDIR_LEN-1",
            "nn"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_unlink_clid_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "310-334",
          "snippet": "static int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (!dentry->d_inode)\n\t\tgoto out;\n\tstatus = vfs_rmdir(dir->d_inode, dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (!dentry->d_inode)\n\t\tgoto out;\n\tstatus = vfs_rmdir(dir->d_inode, dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_save_creds",
          "args": [
            "&original_cred"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_save_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "67-81",
          "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "legacy_recdir_name_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "legacy_recdir_name_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "148-164",
          "snippet": "static void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_make_rec_clidname",
          "args": [
            "dname",
            "&clp->cl_name"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_make_rec_clidname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "103-141",
          "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfsd4_remove_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tstruct nfs4_client_reclaim *crp;\n\tchar dname[HEXDIR_LEN];\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (!nn->rec_file || !test_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out;\n\tclear_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\tgoto out_drop_write;\n\n\tstatus = nfsd4_unlink_clid_dir(dname, HEXDIR_LEN-1, nn);\n\tnfs4_reset_creds(original_cred);\n\tif (status == 0) {\n\t\tvfs_fsync(nn->rec_file, 0);\n\t\tif (nn->in_grace) {\n\t\t\t/* remove reclaim record */\n\t\t\tcrp = nfsd4_find_reclaim_client(dname, nn);\n\t\t\tif (crp)\n\t\t\t\tnfs4_remove_reclaim_record(crp, nn);\n\t\t}\n\t}\nout_drop_write:\n\tmnt_drop_write_file(nn->rec_file);\nout:\n\tif (status)\n\t\tprintk(\"NFSD: Failed to remove expired client state directory\"\n\t\t\t\t\" %.*s\\n\", HEXDIR_LEN, dname);\n}"
  },
  {
    "function_name": "nfsd4_unlink_clid_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "310-334",
    "snippet": "static int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (!dentry->d_inode)\n\t\tgoto out;\n\tstatus = vfs_rmdir(dir->d_inode, dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_rmdir",
          "args": [
            "dir->d_inode",
            "dentry"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_rmdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3596-3632",
          "snippet": "int vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tint error = may_delete(dir, dentry, 1);\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->rmdir)\n\t\treturn -EPERM;\n\n\tdget(dentry);\n\tmutex_lock(&dentry->d_inode->i_mutex);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(dentry))\n\t\tgoto out;\n\n\terror = security_inode_rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tshrink_dcache_parent(dentry);\n\terror = dir->i_op->rmdir(dir, dentry);\n\tif (error)\n\t\tgoto out;\n\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tdetach_mounts(dentry);\n\nout:\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\tdput(dentry);\n\tif (!error)\n\t\td_delete(dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "dir",
            "namlen"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_inode->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\"",
            "namlen",
            "name"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_unlink_clid_dir(char *name, int namlen, struct nfsd_net *nn)\n{\n\tstruct dentry *dir, *dentry;\n\tint status;\n\n\tdprintk(\"NFSD: nfsd4_unlink_clid_dir. name %.*s\\n\", namlen, name);\n\n\tdir = nn->rec_file->f_path.dentry;\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\tdentry = lookup_one_len(name, dir, namlen);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tstatus = -ENOENT;\n\tif (!dentry->d_inode)\n\t\tgoto out;\n\tstatus = vfs_rmdir(dir->d_inode, dentry);\nout:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_list_rec_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "266-308",
    "snippet": "static int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\twhile (!list_empty(&ctx.names)) {\n\t\tstruct name_list *entry;\n\t\tentry = list_entry(ctx.names.next, struct name_list, list);\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tnfs4_reset_creds(original_cred);\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_reset_creds",
          "args": [
            "original_cred"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "83-87",
          "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f",
          "args": [
            "dir",
            "dentry",
            "nn"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "rpc_pipefs_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1498-1535",
          "snippet": "static int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nrpc_pipefs_event(struct notifier_block *nb, unsigned long event, void *ptr)\n{\n\tstruct super_block *sb = ptr;\n\tstruct net *net = sb->s_fs_info;\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\tstruct cld_net *cn = nn->cld_net;\n\tstruct dentry *dentry;\n\tint ret = 0;\n\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn 0;\n\n\tif (!cn) {\n\t\tmodule_put(THIS_MODULE);\n\t\treturn 0;\n\t}\n\n\tswitch (event) {\n\tcase RPC_PIPEFS_MOUNT:\n\t\tdentry = nfsd4_cld_register_sb(sb, cn->cn_pipe);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tcn->cn_pipe->dentry = dentry;\n\t\tbreak;\n\tcase RPC_PIPEFS_UMOUNT:\n\t\tif (cn->cn_pipe->dentry)\n\t\t\tnfsd4_cld_unregister_sb(cn->cn_pipe);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\tmodule_put(THIS_MODULE);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "entry->name",
            "dir",
            "HEXDIR_LEN-1"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "ctx.names.next",
            "structname_list",
            "list"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ctx.names"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&dir->d_inode->i_mutex",
            "I_MUTEX_PARENT"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_dir",
          "args": [
            "nn->rec_file",
            "&ctx.ctx"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "iterate_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/readdir.c",
          "lines": "24-50",
          "snippet": "int iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/dirent.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/stat.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/dirent.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/stat.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint iterate_dir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tint res = -ENOTDIR;\n\tif (!file->f_op->iterate)\n\t\tgoto out;\n\n\tres = security_file_permission(file, MAY_READ);\n\tif (res)\n\t\tgoto out;\n\n\tres = mutex_lock_killable(&inode->i_mutex);\n\tif (res)\n\t\tgoto out;\n\n\tres = -ENOENT;\n\tif (!IS_DEADDIR(inode)) {\n\t\tctx->pos = file->f_pos;\n\t\tres = file->f_op->iterate(file, ctx);\n\t\tfile->f_pos = ctx->pos;\n\t\tfsnotify_access(file);\n\t\tfile_accessed(file);\n\t}\n\tmutex_unlock(&inode->i_mutex);\nout:\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_llseek",
          "args": [
            "nn->rec_file",
            "0",
            "SEEK_SET"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_llseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "255-265",
          "snippet": "loff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nloff_t vfs_llseek(struct file *file, loff_t offset, int whence)\n{\n\tloff_t (*fn)(struct file *, loff_t, int);\n\n\tfn = no_llseek;\n\tif (file->f_mode & FMODE_LSEEK) {\n\t\tif (file->f_op->llseek)\n\t\t\tfn = file->f_op->llseek;\n\t}\n\treturn fn(file, offset, whence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_save_creds",
          "args": [
            "&original_cred"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_save_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "67-81",
          "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD_INIT",
          "args": [
            "ctx.names"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_list_rec_dir(recdir_func *f, struct nfsd_net *nn)\n{\n\tconst struct cred *original_cred;\n\tstruct dentry *dir = nn->rec_file->f_path.dentry;\n\tstruct nfs4_dir_ctx ctx = {\n\t\t.ctx.actor = nfsd4_build_namelist,\n\t\t.names = LIST_HEAD_INIT(ctx.names)\n\t};\n\tint status;\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = vfs_llseek(nn->rec_file, 0, SEEK_SET);\n\tif (status < 0) {\n\t\tnfs4_reset_creds(original_cred);\n\t\treturn status;\n\t}\n\n\tstatus = iterate_dir(nn->rec_file, &ctx.ctx);\n\tmutex_lock_nested(&dir->d_inode->i_mutex, I_MUTEX_PARENT);\n\twhile (!list_empty(&ctx.names)) {\n\t\tstruct name_list *entry;\n\t\tentry = list_entry(ctx.names.next, struct name_list, list);\n\t\tif (!status) {\n\t\t\tstruct dentry *dentry;\n\t\t\tdentry = lookup_one_len(entry->name, dir, HEXDIR_LEN-1);\n\t\t\tif (IS_ERR(dentry)) {\n\t\t\t\tstatus = PTR_ERR(dentry);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = f(dir, dentry, nn);\n\t\t\tdput(dentry);\n\t\t}\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tnfs4_reset_creds(original_cred);\n\treturn status;\n}"
  },
  {
    "function_name": "nfsd4_build_namelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "247-264",
    "snippet": "static int\nnfsd4_build_namelist(struct dir_context *__ctx, const char *name, int namlen,\n\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct nfs4_dir_ctx *ctx =\n\t\tcontainer_of(__ctx, struct nfs4_dir_ctx, ctx);\n\tstruct name_list *entry;\n\n\tif (namlen != HEXDIR_LEN - 1)\n\t\treturn 0;\n\tentry = kmalloc(sizeof(struct name_list), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\tmemcpy(entry->name, name, HEXDIR_LEN - 1);\n\tentry->name[HEXDIR_LEN - 1] = '\\0';\n\tlist_add(&entry->list, &ctx->names);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&entry->list",
            "&ctx->names"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->name",
            "name",
            "HEXDIR_LEN - 1"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct name_list)",
            "GFP_KERNEL"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "__ctx",
            "structnfs4_dir_ctx",
            "ctx"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfsd4_build_namelist(struct dir_context *__ctx, const char *name, int namlen,\n\t\tloff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct nfs4_dir_ctx *ctx =\n\t\tcontainer_of(__ctx, struct nfs4_dir_ctx, ctx);\n\tstruct name_list *entry;\n\n\tif (namlen != HEXDIR_LEN - 1)\n\t\treturn 0;\n\tentry = kmalloc(sizeof(struct name_list), GFP_KERNEL);\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\tmemcpy(entry->name, name, HEXDIR_LEN - 1);\n\tentry->name[HEXDIR_LEN - 1] = '\\0';\n\tlist_add(&entry->list, &ctx->names);\n\treturn 0;\n}"
  },
  {
    "function_name": "nfsd4_create_clid_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "166-233",
    "snippet": "static void\nnfsd4_create_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tchar dname[HEXDIR_LEN];\n\tstruct dentry *dir, *dentry;\n\tstruct nfs4_client_reclaim *crp;\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (test_and_set_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\tif (!nn->rec_file)\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn;\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out_creds;\n\n\tdir = nn->rec_file->f_path.dentry;\n\t/* lock the parent */\n\tmutex_lock(&dir->d_inode->i_mutex);\n\n\tdentry = lookup_one_len(dname, dir, HEXDIR_LEN-1);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (dentry->d_inode)\n\t\t/*\n\t\t * In the 4.1 case, where we're called from\n\t\t * reclaim_complete(), records from the previous reboot\n\t\t * may still be left, so this is OK.\n\t\t *\n\t\t * In the 4.0 case, we should never get here; but we may\n\t\t * as well be forgiving and just succeed silently.\n\t\t */\n\t\tgoto out_put;\n\tstatus = vfs_mkdir(dir->d_inode, dentry, S_IRWXU);\nout_put:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tif (status == 0) {\n\t\tif (nn->in_grace) {\n\t\t\tcrp = nfs4_client_to_reclaim(dname, nn);\n\t\t\tif (crp)\n\t\t\t\tcrp->cr_clp = clp;\n\t\t}\n\t\tvfs_fsync(nn->rec_file, 0);\n\t} else {\n\t\tprintk(KERN_ERR \"NFSD: failed to write recovery record\"\n\t\t\t\t\" (err %d); please check that %s exists\"\n\t\t\t\t\" and is writeable\", status,\n\t\t\t\tuser_recovery_dirname);\n\t}\n\tmnt_drop_write_file(nn->rec_file);\nout_creds:\n\tnfs4_reset_creds(original_cred);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfs4_reset_creds",
          "args": [
            "original_cred"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_reset_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "83-87",
          "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mnt_drop_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_drop_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "487-490",
          "snippet": "void mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid mnt_drop_write_file(struct file *file)\n{\n\tmnt_drop_write(file->f_path.mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: failed to write recovery record\"\n\t\t\t\t\" (err %d); please check that %s exists\"\n\t\t\t\t\" and is writeable\"",
            "status",
            "user_recovery_dirname"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_fsync",
          "args": [
            "nn->rec_file",
            "0"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_fsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "202-205",
          "snippet": "int vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint vfs_fsync(struct file *file, int datasync)\n{\n\treturn vfs_fsync_range(file, 0, LLONG_MAX, datasync);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_client_to_reclaim",
          "args": [
            "dname",
            "nn"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_client_to_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4state.c",
          "lines": "5653-5670",
          "snippet": "struct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"current_stateid.h\"",
            "#include \"vfs.h\"",
            "#include \"xdr4cb.h\"",
            "#include \"xdr4.h\"",
            "#include <linux/jhash.h>",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sunrpc/svcauth_gss.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/swap.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"current_stateid.h\"\n#include \"vfs.h\"\n#include \"xdr4cb.h\"\n#include \"xdr4.h\"\n#include <linux/jhash.h>\n#include <linux/sunrpc/addr.h>\n#include <linux/sunrpc/svcauth_gss.h>\n#include <linux/ratelimit.h>\n#include <linux/pagemap.h>\n#include <linux/swap.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n\nstruct nfs4_client_reclaim *\nnfs4_client_to_reclaim(const char *name, struct nfsd_net *nn)\n{\n\tunsigned int strhashval;\n\tstruct nfs4_client_reclaim *crp;\n\n\tdprintk(\"NFSD nfs4_client_to_reclaim NAME: %.*s\\n\", HEXDIR_LEN, name);\n\tcrp = alloc_reclaim();\n\tif (crp) {\n\t\tstrhashval = clientstr_hashval(name);\n\t\tINIT_LIST_HEAD(&crp->cr_strhash);\n\t\tlist_add(&crp->cr_strhash, &nn->reclaim_str_hashtbl[strhashval]);\n\t\tmemcpy(crp->cr_recdir, name, HEXDIR_LEN);\n\t\tcrp->cr_clp = NULL;\n\t\tnn->reclaim_str_hashtbl_size++;\n\t}\n\treturn crp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfs_mkdir",
          "args": [
            "dir->d_inode",
            "dentry",
            "S_IRWXU"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3515-3538",
          "snippet": "int vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint vfs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tint error = may_create(dir, dentry);\n\tunsigned max_links = dir->i_sb->s_max_links;\n\n\tif (error)\n\t\treturn error;\n\n\tif (!dir->i_op->mkdir)\n\t\treturn -EPERM;\n\n\tmode &= (S_IRWXUGO|S_ISVTX);\n\terror = security_inode_mkdir(dir, dentry, mode);\n\tif (error)\n\t\treturn error;\n\n\tif (max_links && dir->i_nlink >= max_links)\n\t\treturn -EMLINK;\n\n\terror = dir->i_op->mkdir(dir, dentry, mode);\n\tif (!error)\n\t\tfsnotify_mkdir(dir, dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dentry"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "dname",
            "dir",
            "HEXDIR_LEN-1"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_one_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2145-2184",
          "snippet": "struct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *lookup_one_len(const char *name, struct dentry *base, int len)\n{\n\tstruct qstr this;\n\tunsigned int c;\n\tint err;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&base->d_inode->i_mutex));\n\n\tthis.name = name;\n\tthis.len = len;\n\tthis.hash = full_name_hash(name, len);\n\tif (!len)\n\t\treturn ERR_PTR(-EACCES);\n\n\tif (unlikely(name[0] == '.')) {\n\t\tif (len < 2 || (len == 2 && name[1] == '.'))\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\n\twhile (len--) {\n\t\tc = *(const unsigned char *)name++;\n\t\tif (c == '/' || c == '\\0')\n\t\t\treturn ERR_PTR(-EACCES);\n\t}\n\t/*\n\t * See if the low-level filesystem might want\n\t * to use its own hash..\n\t */\n\tif (base->d_flags & DCACHE_OP_HASH) {\n\t\tint err = base->d_op->d_hash(base, &this);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\terr = inode_permission(base->d_inode, MAY_EXEC);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn __lookup_hash(&this, base, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&dir->d_inode->i_mutex"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mnt_want_write_file",
          "args": [
            "nn->rec_file"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "mnt_want_write_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "440-449",
          "snippet": "int mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint mnt_want_write_file(struct file *file)\n{\n\tint ret;\n\n\tsb_start_write(file->f_path.mnt->mnt_sb);\n\tret = __mnt_want_write_file(file);\n\tif (ret)\n\t\tsb_end_write(file->f_path.mnt->mnt_sb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_save_creds",
          "args": [
            "&original_cred"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_save_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "67-81",
          "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "legacy_recdir_name_error",
          "args": [
            "clp",
            "status"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "legacy_recdir_name_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "148-164",
          "snippet": "static void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nfs4_make_rec_clidname",
          "args": [
            "dname",
            "&clp->cl_name"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_make_rec_clidname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "103-141",
          "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "NFSD4_CLIENT_STABLE",
            "&clp->cl_flags"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "net_generic",
          "args": [
            "clp->net",
            "nfsd_net_id"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic char user_recovery_dirname[PATH_MAX] = \"/var/lib/nfs/v4recovery\";\n\nstatic void\nnfsd4_create_clid_dir(struct nfs4_client *clp)\n{\n\tconst struct cred *original_cred;\n\tchar dname[HEXDIR_LEN];\n\tstruct dentry *dir, *dentry;\n\tstruct nfs4_client_reclaim *crp;\n\tint status;\n\tstruct nfsd_net *nn = net_generic(clp->net, nfsd_net_id);\n\n\tif (test_and_set_bit(NFSD4_CLIENT_STABLE, &clp->cl_flags))\n\t\treturn;\n\tif (!nn->rec_file)\n\t\treturn;\n\n\tstatus = nfs4_make_rec_clidname(dname, &clp->cl_name);\n\tif (status)\n\t\treturn legacy_recdir_name_error(clp, status);\n\n\tstatus = nfs4_save_creds(&original_cred);\n\tif (status < 0)\n\t\treturn;\n\n\tstatus = mnt_want_write_file(nn->rec_file);\n\tif (status)\n\t\tgoto out_creds;\n\n\tdir = nn->rec_file->f_path.dentry;\n\t/* lock the parent */\n\tmutex_lock(&dir->d_inode->i_mutex);\n\n\tdentry = lookup_one_len(dname, dir, HEXDIR_LEN-1);\n\tif (IS_ERR(dentry)) {\n\t\tstatus = PTR_ERR(dentry);\n\t\tgoto out_unlock;\n\t}\n\tif (dentry->d_inode)\n\t\t/*\n\t\t * In the 4.1 case, where we're called from\n\t\t * reclaim_complete(), records from the previous reboot\n\t\t * may still be left, so this is OK.\n\t\t *\n\t\t * In the 4.0 case, we should never get here; but we may\n\t\t * as well be forgiving and just succeed silently.\n\t\t */\n\t\tgoto out_put;\n\tstatus = vfs_mkdir(dir->d_inode, dentry, S_IRWXU);\nout_put:\n\tdput(dentry);\nout_unlock:\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\tif (status == 0) {\n\t\tif (nn->in_grace) {\n\t\t\tcrp = nfs4_client_to_reclaim(dname, nn);\n\t\t\tif (crp)\n\t\t\t\tcrp->cr_clp = clp;\n\t\t}\n\t\tvfs_fsync(nn->rec_file, 0);\n\t} else {\n\t\tprintk(KERN_ERR \"NFSD: failed to write recovery record\"\n\t\t\t\t\" (err %d); please check that %s exists\"\n\t\t\t\t\" and is writeable\", status,\n\t\t\t\tuser_recovery_dirname);\n\t}\n\tmnt_drop_write_file(nn->rec_file);\nout_creds:\n\tnfs4_reset_creds(original_cred);\n}"
  },
  {
    "function_name": "legacy_recdir_name_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "148-164",
    "snippet": "static void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nfsd4_client_tracking_exit",
          "args": [
            "clp->net"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_client_tracking_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "1450-1460",
          "snippet": "void\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nvoid\nnfsd4_client_tracking_exit(struct net *net)\n{\n\tstruct nfsd_net *nn = net_generic(net, nfsd_net_id);\n\n\tif (nn->client_tracking_ops) {\n\t\tif (nn->client_tracking_ops->exit)\n\t\t\tnn->client_tracking_ops->exit(net);\n\t\tnn->client_tracking_ops = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\""
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nlegacy_recdir_name_error(struct nfs4_client *clp, int error)\n{\n\tprintk(KERN_ERR \"NFSD: unable to generate recoverydir \"\n\t\t\t\"name (%d).\\n\", error);\n\n\t/*\n\t * if the algorithm just doesn't exist, then disable the recovery\n\t * tracker altogether. The crypto libs will generally return this if\n\t * FIPS is enabled as well.\n\t */\n\tif (error == -ENOENT) {\n\t\tprintk(KERN_ERR \"NFSD: disabling legacy clientid tracking. \"\n\t\t\t\"Reboot recovery will not function correctly!\\n\");\n\t\tnfsd4_client_tracking_exit(clp->net);\n\t}\n}"
  },
  {
    "function_name": "nfs4_make_rec_clidname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "103-141",
    "snippet": "static int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_hash",
          "args": [
            "desc.tfm"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cksum.data"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "md5_to_hex",
          "args": [
            "dname",
            "cksum.data"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "md5_to_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
          "lines": "89-101",
          "snippet": "static void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}",
          "includes": [
            "#include \"netns.h\"",
            "#include \"vfs.h\"",
            "#include \"state.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/nfsd/cld.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/sunrpc/rpc_pipe_fs.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/module.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/crypto.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_hash_digest",
          "args": [
            "&desc",
            "&sg",
            "sg.length",
            "cksum.data"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&sg",
            "clname->data",
            "clname->len"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "cksum.len",
            "GFP_KERNEL"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_hash_digestsize",
          "args": [
            "desc.tfm"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "desc.tfm"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "desc.tfm"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_hash",
          "args": [
            "\"md5\"",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFSD: nfs4_make_rec_clidname for %.*s\\n\"",
            "clname->len",
            "clname->data"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_make_rec_clidname(char *dname, const struct xdr_netobj *clname)\n{\n\tstruct xdr_netobj cksum;\n\tstruct hash_desc desc;\n\tstruct scatterlist sg;\n\tint status;\n\n\tdprintk(\"NFSD: nfs4_make_rec_clidname for %.*s\\n\",\n\t\t\tclname->len, clname->data);\n\tdesc.flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\tdesc.tfm = crypto_alloc_hash(\"md5\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(desc.tfm)) {\n\t\tstatus = PTR_ERR(desc.tfm);\n\t\tgoto out_no_tfm;\n\t}\n\n\tcksum.len = crypto_hash_digestsize(desc.tfm);\n\tcksum.data = kmalloc(cksum.len, GFP_KERNEL);\n\tif (cksum.data == NULL) {\n\t\tstatus = -ENOMEM;\n \t\tgoto out;\n\t}\n\n\tsg_init_one(&sg, clname->data, clname->len);\n\n\tstatus = crypto_hash_digest(&desc, &sg, sg.length, cksum.data);\n\tif (status)\n\t\tgoto out;\n\n\tmd5_to_hex(dname, cksum.data);\n\n\tstatus = 0;\nout:\n\tkfree(cksum.data);\n\tcrypto_free_hash(desc.tfm);\nout_no_tfm:\n\treturn status;\n}"
  },
  {
    "function_name": "md5_to_hex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "89-101",
    "snippet": "static void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nmd5_to_hex(char *out, char *md5)\n{\n\tint i;\n\n\tfor (i=0; i<16; i++) {\n\t\tunsigned char c = md5[i];\n\n\t\t*out++ = '0' + ((c&0xf0)>>4) + (c>=0xa0)*('a'-'9'-1);\n\t\t*out++ = '0' + (c&0x0f) + ((c&0x0f)>=0x0a)*('a'-'9'-1);\n\t}\n\t*out = '\\0';\n}"
  },
  {
    "function_name": "nfs4_reset_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "83-87",
    "snippet": "static void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "revert_creds",
          "args": [
            "original"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic void\nnfs4_reset_creds(const struct cred *original)\n{\n\trevert_creds(original);\n}"
  },
  {
    "function_name": "nfs4_save_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4recover.c",
    "lines": "67-81",
    "snippet": "static int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}",
    "includes": [
      "#include \"netns.h\"",
      "#include \"vfs.h\"",
      "#include \"state.h\"",
      "#include \"nfsd.h\"",
      "#include <linux/nfsd/cld.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/sunrpc/rpc_pipe_fs.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/module.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/crypto.h>",
      "#include <linux/namei.h>",
      "#include <linux/slab.h>",
      "#include <linux/file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "new"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "override_creds",
          "args": [
            "new"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netns.h\"\n#include \"vfs.h\"\n#include \"state.h\"\n#include \"nfsd.h\"\n#include <linux/nfsd/cld.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/sunrpc/rpc_pipe_fs.h>\n#include <net/net_namespace.h>\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/crypto.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n\nstatic int\nnfs4_save_creds(const struct cred **original_creds)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->fsuid = GLOBAL_ROOT_UID;\n\tnew->fsgid = GLOBAL_ROOT_GID;\n\t*original_creds = override_creds(new);\n\tput_cred(new);\n\treturn 0;\n}"
  }
]