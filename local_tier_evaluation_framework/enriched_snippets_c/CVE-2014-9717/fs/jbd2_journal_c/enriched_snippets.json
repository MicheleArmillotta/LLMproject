[
  {
    "function_name": "journal_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2657-2666",
    "snippet": "static void __exit journal_exit(void)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tint n = atomic_read(&nr_journal_heads);\n\tif (n)\n\t\tprintk(KERN_ERR \"JBD2: leaked %d journal_heads!\\n\", n);\n#endif\n\tjbd2_remove_jbd_stats_proc_entry();\n\tjbd2_journal_destroy_caches();\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_caches",
          "args": [],
          "line": 2665
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2633-2640",
          "snippet": "static void jbd2_journal_destroy_caches(void)\n{\n\tjbd2_journal_destroy_revoke_caches();\n\tjbd2_journal_destroy_journal_head_cache();\n\tjbd2_journal_destroy_handle_cache();\n\tjbd2_journal_destroy_transaction_cache();\n\tjbd2_journal_destroy_slabs();\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_journal_destroy_caches(void)\n{\n\tjbd2_journal_destroy_revoke_caches();\n\tjbd2_journal_destroy_journal_head_cache();\n\tjbd2_journal_destroy_handle_cache();\n\tjbd2_journal_destroy_transaction_cache();\n\tjbd2_journal_destroy_slabs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_remove_jbd_stats_proc_entry",
          "args": [],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_remove_jbd_stats_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2575-2579",
          "snippet": "static void __exit jbd2_remove_jbd_stats_proc_entry(void)\n{\n\tif (proc_jbd2_stats)\n\t\tremove_proc_entry(JBD2_STATS_PROC_NAME, NULL);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define JBD2_STATS_PROC_NAME \"fs/jbd2\""
          ],
          "globals_used": [
            "static struct proc_dir_entry *proc_jbd2_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_STATS_PROC_NAME \"fs/jbd2\"\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void __exit jbd2_remove_jbd_stats_proc_entry(void)\n{\n\tif (proc_jbd2_stats)\n\t\tremove_proc_entry(JBD2_STATS_PROC_NAME, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: leaked %d journal_heads!\\n\"",
            "n"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&nr_journal_heads"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __exit journal_exit(void)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tint n = atomic_read(&nr_journal_heads);\n\tif (n)\n\t\tprintk(KERN_ERR \"JBD2: leaked %d journal_heads!\\n\", n);\n#endif\n\tjbd2_remove_jbd_stats_proc_entry();\n\tjbd2_journal_destroy_caches();\n}"
  },
  {
    "function_name": "journal_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2642-2655",
    "snippet": "static int __init journal_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct journal_superblock_s) != 1024);\n\n\tret = journal_init_caches();\n\tif (ret == 0) {\n\t\tjbd2_create_jbd_stats_proc_entry();\n\t} else {\n\t\tjbd2_journal_destroy_caches();\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_caches",
          "args": [],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2633-2640",
          "snippet": "static void jbd2_journal_destroy_caches(void)\n{\n\tjbd2_journal_destroy_revoke_caches();\n\tjbd2_journal_destroy_journal_head_cache();\n\tjbd2_journal_destroy_handle_cache();\n\tjbd2_journal_destroy_transaction_cache();\n\tjbd2_journal_destroy_slabs();\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_journal_destroy_caches(void)\n{\n\tjbd2_journal_destroy_revoke_caches();\n\tjbd2_journal_destroy_journal_head_cache();\n\tjbd2_journal_destroy_handle_cache();\n\tjbd2_journal_destroy_transaction_cache();\n\tjbd2_journal_destroy_slabs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_create_jbd_stats_proc_entry",
          "args": [],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_create_jbd_stats_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2570-2573",
          "snippet": "static void __init jbd2_create_jbd_stats_proc_entry(void)\n{\n\tproc_jbd2_stats = proc_mkdir(JBD2_STATS_PROC_NAME, NULL);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define JBD2_STATS_PROC_NAME \"fs/jbd2\""
          ],
          "globals_used": [
            "static struct proc_dir_entry *proc_jbd2_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_STATS_PROC_NAME \"fs/jbd2\"\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void __init jbd2_create_jbd_stats_proc_entry(void)\n{\n\tproc_jbd2_stats = proc_mkdir(JBD2_STATS_PROC_NAME, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_init_caches",
          "args": [],
          "line": 2648
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2619-2631",
          "snippet": "static int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = jbd2_journal_init_revoke_caches();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_handle_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_transaction_cache();\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = jbd2_journal_init_revoke_caches();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_handle_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_transaction_cache();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct journal_superblock_s) != 1024"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __init journal_init(void)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(struct journal_superblock_s) != 1024);\n\n\tret = journal_init_caches();\n\tif (ret == 0) {\n\t\tjbd2_create_jbd_stats_proc_entry();\n\t} else {\n\t\tjbd2_journal_destroy_caches();\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_journal_destroy_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2633-2640",
    "snippet": "static void jbd2_journal_destroy_caches(void)\n{\n\tjbd2_journal_destroy_revoke_caches();\n\tjbd2_journal_destroy_journal_head_cache();\n\tjbd2_journal_destroy_handle_cache();\n\tjbd2_journal_destroy_transaction_cache();\n\tjbd2_journal_destroy_slabs();\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_slabs",
          "args": [],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_slabs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2220-2229",
          "snippet": "static void jbd2_journal_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < JBD2_MAX_SLABS; i++) {\n\t\tif (jbd2_slab[i])\n\t\t\tkmem_cache_destroy(jbd2_slab[i]);\n\t\tjbd2_slab[i] = NULL;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define JBD2_MAX_SLABS 8"
          ],
          "globals_used": [
            "static struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_MAX_SLABS 8\n\nstatic struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];\n\nstatic void jbd2_journal_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < JBD2_MAX_SLABS; i++) {\n\t\tif (jbd2_slab[i])\n\t\t\tkmem_cache_destroy(jbd2_slab[i]);\n\t\tjbd2_slab[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_transaction_cache",
          "args": [],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_transaction_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "52-58",
          "snippet": "void jbd2_journal_destroy_transaction_cache(void)\n{\n\tif (transaction_cache) {\n\t\tkmem_cache_destroy(transaction_cache);\n\t\ttransaction_cache = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *transaction_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *transaction_cache;\n\nvoid jbd2_journal_destroy_transaction_cache(void)\n{\n\tif (transaction_cache) {\n\t\tkmem_cache_destroy(transaction_cache);\n\t\ttransaction_cache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_handle_cache",
          "args": [],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_handle_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2606-2613",
          "snippet": "static void jbd2_journal_destroy_handle_cache(void)\n{\n\tif (jbd2_handle_cache)\n\t\tkmem_cache_destroy(jbd2_handle_cache);\n\tif (jbd2_inode_cache)\n\t\tkmem_cache_destroy(jbd2_inode_cache);\n\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;\n\nstatic void jbd2_journal_destroy_handle_cache(void)\n{\n\tif (jbd2_handle_cache)\n\t\tkmem_cache_destroy(jbd2_handle_cache);\n\tif (jbd2_inode_cache)\n\t\tkmem_cache_destroy(jbd2_inode_cache);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_journal_head_cache",
          "args": [],
          "line": 2636
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_journal_head_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2343-2349",
          "snippet": "static void jbd2_journal_destroy_journal_head_cache(void)\n{\n\tif (jbd2_journal_head_cache) {\n\t\tkmem_cache_destroy(jbd2_journal_head_cache);\n\t\tjbd2_journal_head_cache = NULL;\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic void jbd2_journal_destroy_journal_head_cache(void)\n{\n\tif (jbd2_journal_head_cache) {\n\t\tkmem_cache_destroy(jbd2_journal_head_cache);\n\t\tjbd2_journal_head_cache = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_revoke_caches",
          "args": [],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "189-199",
          "snippet": "void jbd2_journal_destroy_revoke_caches(void)\n{\n\tif (jbd2_revoke_record_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_record_cache);\n\t\tjbd2_revoke_record_cache = NULL;\n\t}\n\tif (jbd2_revoke_table_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_table_cache);\n\t\tjbd2_revoke_table_cache = NULL;\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_record_cache;",
            "static struct kmem_cache *jbd2_revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nvoid jbd2_journal_destroy_revoke_caches(void)\n{\n\tif (jbd2_revoke_record_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_record_cache);\n\t\tjbd2_revoke_record_cache = NULL;\n\t}\n\tif (jbd2_revoke_table_cache) {\n\t\tkmem_cache_destroy(jbd2_revoke_table_cache);\n\t\tjbd2_revoke_table_cache = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_journal_destroy_caches(void)\n{\n\tjbd2_journal_destroy_revoke_caches();\n\tjbd2_journal_destroy_journal_head_cache();\n\tjbd2_journal_destroy_handle_cache();\n\tjbd2_journal_destroy_transaction_cache();\n\tjbd2_journal_destroy_slabs();\n}"
  },
  {
    "function_name": "journal_init_caches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2619-2631",
    "snippet": "static int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = jbd2_journal_init_revoke_caches();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_handle_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_transaction_cache();\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_init_transaction_cache",
          "args": [],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_transaction_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "39-50",
          "snippet": "int __init jbd2_journal_init_transaction_cache(void)\n{\n\tJ_ASSERT(!transaction_cache);\n\ttransaction_cache = kmem_cache_create(\"jbd2_transaction_s\",\n\t\t\t\t\tsizeof(transaction_t),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\tNULL);\n\tif (transaction_cache)\n\t\treturn 0;\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *transaction_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic struct kmem_cache *transaction_cache;\n\nint __init jbd2_journal_init_transaction_cache(void)\n{\n\tJ_ASSERT(!transaction_cache);\n\ttransaction_cache = kmem_cache_create(\"jbd2_transaction_s\",\n\t\t\t\t\tsizeof(transaction_t),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY,\n\t\t\t\t\tNULL);\n\tif (transaction_cache)\n\t\treturn 0;\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_handle_cache",
          "args": [],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_handle_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2590-2604",
          "snippet": "static int __init jbd2_journal_init_handle_cache(void)\n{\n\tjbd2_handle_cache = KMEM_CACHE(jbd2_journal_handle, SLAB_TEMPORARY);\n\tif (jbd2_handle_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tjbd2_inode_cache = KMEM_CACHE(jbd2_inode, 0);\n\tif (jbd2_inode_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create inode cache\\n\");\n\t\tkmem_cache_destroy(jbd2_handle_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;\n\nstatic int __init jbd2_journal_init_handle_cache(void)\n{\n\tjbd2_handle_cache = KMEM_CACHE(jbd2_journal_handle, SLAB_TEMPORARY);\n\tif (jbd2_handle_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tjbd2_inode_cache = KMEM_CACHE(jbd2_inode, 0);\n\tif (jbd2_inode_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create inode cache\\n\");\n\t\tkmem_cache_destroy(jbd2_handle_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_journal_head_cache",
          "args": [],
          "line": 2625
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_journal_head_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2325-2341",
          "snippet": "static int jbd2_journal_init_journal_head_cache(void)\n{\n\tint retval;\n\n\tJ_ASSERT(jbd2_journal_head_cache == NULL);\n\tjbd2_journal_head_cache = kmem_cache_create(\"jbd2_journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tretval = 0;\n\tif (!jbd2_journal_head_cache) {\n\t\tretval = -ENOMEM;\n\t\tprintk(KERN_EMERG \"JBD2: no memory for journal_head cache\\n\");\n\t}\n\treturn retval;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic int jbd2_journal_init_journal_head_cache(void)\n{\n\tint retval;\n\n\tJ_ASSERT(jbd2_journal_head_cache == NULL);\n\tjbd2_journal_head_cache = kmem_cache_create(\"jbd2_journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tretval = 0;\n\tif (!jbd2_journal_head_cache) {\n\t\tretval = -ENOMEM;\n\t\tprintk(KERN_EMERG \"JBD2: no memory for journal_head cache\\n\");\n\t}\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_revoke_caches",
          "args": [],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_revoke_caches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "201-220",
          "snippet": "int __init jbd2_journal_init_revoke_caches(void)\n{\n\tJ_ASSERT(!jbd2_revoke_record_cache);\n\tJ_ASSERT(!jbd2_revoke_table_cache);\n\n\tjbd2_revoke_record_cache = KMEM_CACHE(jbd2_revoke_record_s,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY);\n\tif (!jbd2_revoke_record_cache)\n\t\tgoto record_cache_failure;\n\n\tjbd2_revoke_table_cache = KMEM_CACHE(jbd2_revoke_table_s,\n\t\t\t\t\t     SLAB_TEMPORARY);\n\tif (!jbd2_revoke_table_cache)\n\t\tgoto table_cache_failure;\n\treturn 0;\ntable_cache_failure:\n\tjbd2_journal_destroy_revoke_caches();\nrecord_cache_failure:\n\t\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_revoke_record_cache;",
            "static struct kmem_cache *jbd2_revoke_table_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *jbd2_revoke_record_cache;\nstatic struct kmem_cache *jbd2_revoke_table_cache;\n\nint __init jbd2_journal_init_revoke_caches(void)\n{\n\tJ_ASSERT(!jbd2_revoke_record_cache);\n\tJ_ASSERT(!jbd2_revoke_table_cache);\n\n\tjbd2_revoke_record_cache = KMEM_CACHE(jbd2_revoke_record_s,\n\t\t\t\t\tSLAB_HWCACHE_ALIGN|SLAB_TEMPORARY);\n\tif (!jbd2_revoke_record_cache)\n\t\tgoto record_cache_failure;\n\n\tjbd2_revoke_table_cache = KMEM_CACHE(jbd2_revoke_table_s,\n\t\t\t\t\t     SLAB_TEMPORARY);\n\tif (!jbd2_revoke_table_cache)\n\t\tgoto table_cache_failure;\n\treturn 0;\ntable_cache_failure:\n\tjbd2_journal_destroy_revoke_caches();\nrecord_cache_failure:\n\t\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __init journal_init_caches(void)\n{\n\tint ret;\n\n\tret = jbd2_journal_init_revoke_caches();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_journal_head_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_handle_cache();\n\tif (ret == 0)\n\t\tret = jbd2_journal_init_transaction_cache();\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_journal_destroy_handle_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2606-2613",
    "snippet": "static void jbd2_journal_destroy_handle_cache(void)\n{\n\tif (jbd2_handle_cache)\n\t\tkmem_cache_destroy(jbd2_handle_cache);\n\tif (jbd2_inode_cache)\n\t\tkmem_cache_destroy(jbd2_inode_cache);\n\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jbd2_inode_cache"
          ],
          "line": 2611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jbd2_handle_cache"
          ],
          "line": 2609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;\n\nstatic void jbd2_journal_destroy_handle_cache(void)\n{\n\tif (jbd2_handle_cache)\n\t\tkmem_cache_destroy(jbd2_handle_cache);\n\tif (jbd2_inode_cache)\n\t\tkmem_cache_destroy(jbd2_inode_cache);\n\n}"
  },
  {
    "function_name": "jbd2_journal_init_handle_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2590-2604",
    "snippet": "static int __init jbd2_journal_init_handle_cache(void)\n{\n\tjbd2_handle_cache = KMEM_CACHE(jbd2_journal_handle, SLAB_TEMPORARY);\n\tif (jbd2_handle_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tjbd2_inode_cache = KMEM_CACHE(jbd2_inode, 0);\n\tif (jbd2_inode_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create inode cache\\n\");\n\t\tkmem_cache_destroy(jbd2_handle_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jbd2_handle_cache"
          ],
          "line": 2600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"JBD2: failed to create inode cache\\n\""
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "jbd2_inode",
            "0"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "jbd2_journal_handle",
            "SLAB_TEMPORARY"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct kmem_cache *jbd2_handle_cache, *jbd2_inode_cache;\n\nstatic int __init jbd2_journal_init_handle_cache(void)\n{\n\tjbd2_handle_cache = KMEM_CACHE(jbd2_journal_handle, SLAB_TEMPORARY);\n\tif (jbd2_handle_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create handle cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tjbd2_inode_cache = KMEM_CACHE(jbd2_inode, 0);\n\tif (jbd2_inode_cache == NULL) {\n\t\tprintk(KERN_EMERG \"JBD2: failed to create inode cache\\n\");\n\t\tkmem_cache_destroy(jbd2_handle_cache);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_remove_jbd_stats_proc_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2575-2579",
    "snippet": "static void __exit jbd2_remove_jbd_stats_proc_entry(void)\n{\n\tif (proc_jbd2_stats)\n\t\tremove_proc_entry(JBD2_STATS_PROC_NAME, NULL);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define JBD2_STATS_PROC_NAME \"fs/jbd2\""
    ],
    "globals_used": [
      "static struct proc_dir_entry *proc_jbd2_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "JBD2_STATS_PROC_NAME",
            "NULL"
          ],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_STATS_PROC_NAME \"fs/jbd2\"\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void __exit jbd2_remove_jbd_stats_proc_entry(void)\n{\n\tif (proc_jbd2_stats)\n\t\tremove_proc_entry(JBD2_STATS_PROC_NAME, NULL);\n}"
  },
  {
    "function_name": "jbd2_create_jbd_stats_proc_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2570-2573",
    "snippet": "static void __init jbd2_create_jbd_stats_proc_entry(void)\n{\n\tproc_jbd2_stats = proc_mkdir(JBD2_STATS_PROC_NAME, NULL);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define JBD2_STATS_PROC_NAME \"fs/jbd2\""
    ],
    "globals_used": [
      "static struct proc_dir_entry *proc_jbd2_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "JBD2_STATS_PROC_NAME",
            "NULL"
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_STATS_PROC_NAME \"fs/jbd2\"\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void __init jbd2_create_jbd_stats_proc_entry(void)\n{\n\tproc_jbd2_stats = proc_mkdir(JBD2_STATS_PROC_NAME, NULL);\n}"
  },
  {
    "function_name": "jbd2_journal_release_jbd_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2539-2563",
    "snippet": "void jbd2_journal_release_jbd_inode(journal_t *journal,\n\t\t\t\t    struct jbd2_inode *jinode)\n{\n\tif (!journal)\n\t\treturn;\nrestart:\n\tspin_lock(&journal->j_list_lock);\n\t/* Is commit writing out inode - we have to wait */\n\tif (test_bit(__JI_COMMIT_RUNNING, &jinode->i_flags)) {\n\t\twait_queue_head_t *wq;\n\t\tDEFINE_WAIT_BIT(wait, &jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\twq = bit_waitqueue(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait.wait);\n\t\tgoto restart;\n\t}\n\n\tif (jinode->i_transaction) {\n\t\tlist_del(&jinode->i_list);\n\t\tjinode->i_transaction = NULL;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&jinode->i_list"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "wq",
            "&wait.wait"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "wq",
            "&wait.wait",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_waitqueue",
          "args": [
            "&jinode->i_flags",
            "__JI_COMMIT_RUNNING"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT_BIT",
          "args": [
            "wait",
            "&jinode->i_flags",
            "__JI_COMMIT_RUNNING"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "__JI_COMMIT_RUNNING",
            "&jinode->i_flags"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_release_jbd_inode(journal_t *journal,\n\t\t\t\t    struct jbd2_inode *jinode)\n{\n\tif (!journal)\n\t\treturn;\nrestart:\n\tspin_lock(&journal->j_list_lock);\n\t/* Is commit writing out inode - we have to wait */\n\tif (test_bit(__JI_COMMIT_RUNNING, &jinode->i_flags)) {\n\t\twait_queue_head_t *wq;\n\t\tDEFINE_WAIT_BIT(wait, &jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\twq = bit_waitqueue(&jinode->i_flags, __JI_COMMIT_RUNNING);\n\t\tprepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tschedule();\n\t\tfinish_wait(wq, &wait.wait);\n\t\tgoto restart;\n\t}\n\n\tif (jinode->i_transaction) {\n\t\tlist_del(&jinode->i_list);\n\t\tjinode->i_transaction = NULL;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n}"
  },
  {
    "function_name": "jbd2_journal_init_jbd_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2525-2532",
    "snippet": "void jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode)\n{\n\tjinode->i_transaction = NULL;\n\tjinode->i_next_transaction = NULL;\n\tjinode->i_vfs_inode = inode;\n\tjinode->i_flags = 0;\n\tINIT_LIST_HEAD(&jinode->i_list);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&jinode->i_list"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_init_jbd_inode(struct jbd2_inode *jinode, struct inode *inode)\n{\n\tjinode->i_transaction = NULL;\n\tjinode->i_next_transaction = NULL;\n\tjinode->i_vfs_inode = inode;\n\tjinode->i_flags = 0;\n\tINIT_LIST_HEAD(&jinode->i_list);\n}"
  },
  {
    "function_name": "jbd2_journal_put_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2507-2520",
    "snippet": "void jbd2_journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__brelse",
          "args": [
            "bh"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__journal_remove_journal_head",
          "args": [
            "bh"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_remove_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2477-2501",
          "snippet": "static void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_jcount >= 0);\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t}\n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t/* debug, really */\n\tclear_buffer_jbd(bh);\n\tjournal_free_journal_head(jh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_jcount >= 0);\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t}\n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t/* debug, really */\n\tclear_buffer_jbd(bh);\n\tjournal_free_journal_head(jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jcount > 0"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_put_journal_head(struct journal_head *jh)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tjbd_lock_bh_journal_head(bh);\n\tJ_ASSERT_JH(jh, jh->b_jcount > 0);\n\t--jh->b_jcount;\n\tif (!jh->b_jcount) {\n\t\t__journal_remove_journal_head(bh);\n\t\tjbd_unlock_bh_journal_head(bh);\n\t\t__brelse(bh);\n\t} else\n\t\tjbd_unlock_bh_journal_head(bh);\n}"
  },
  {
    "function_name": "__journal_remove_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2477-2501",
    "snippet": "static void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_jcount >= 0);\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t}\n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t/* debug, really */\n\tclear_buffer_jbd(bh);\n\tjournal_free_journal_head(jh);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_free_journal_head",
          "args": [
            "jh"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "journal_free_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2373-2380",
          "snippet": "static void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD2_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(jbd2_journal_head_cache, jh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD2_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(jbd2_journal_head_cache, jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_free",
          "args": [
            "jh->b_committed_data",
            "bh->b_size"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2299-2315",
          "snippet": "void jbd2_free(void *ptr, size_t size)\n{\n\tif (size == PAGE_SIZE) {\n\t\tfree_pages((unsigned long)ptr, 0);\n\t\treturn;\n\t}\n\tif (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tfree_pages((unsigned long)ptr, order);\n\t\telse\n\t\t\tvfree(ptr);\n\t\treturn;\n\t}\n\tkmem_cache_free(get_slab(size), ptr);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_free(void *ptr, size_t size)\n{\n\tif (size == PAGE_SIZE) {\n\t\tfree_pages((unsigned long)ptr, 0);\n\t\treturn;\n\t}\n\tif (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tfree_pages((unsigned long)ptr, order);\n\t\telse\n\t\t\tvfree(ptr);\n\t\treturn;\n\t}\n\tkmem_cache_free(get_slab(size), ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: freeing b_committed_data\\n\"",
            "__func__"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"remove journal_head\""
          ],
          "line": 2488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "jh2bh(jh) == bh"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "buffer_jbd(bh)"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jlist == BJ_None"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_cp_transaction == NULL"
          ],
          "line": 2484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_next_transaction == NULL"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_transaction == NULL"
          ],
          "line": 2482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_JH",
          "args": [
            "jh",
            "jh->b_jcount >= 0"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_remove_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = bh2jh(bh);\n\n\tJ_ASSERT_JH(jh, jh->b_jcount >= 0);\n\tJ_ASSERT_JH(jh, jh->b_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_next_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_cp_transaction == NULL);\n\tJ_ASSERT_JH(jh, jh->b_jlist == BJ_None);\n\tJ_ASSERT_BH(bh, buffer_jbd(bh));\n\tJ_ASSERT_BH(bh, jh2bh(jh) == bh);\n\tBUFFER_TRACE(bh, \"remove journal_head\");\n\tif (jh->b_frozen_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_frozen_data\\n\", __func__);\n\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t}\n\tif (jh->b_committed_data) {\n\t\tprintk(KERN_WARNING \"%s: freeing b_committed_data\\n\", __func__);\n\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t}\n\tbh->b_private = NULL;\n\tjh->b_bh = NULL;\t/* debug, really */\n\tclear_buffer_jbd(bh);\n\tjournal_free_journal_head(jh);\n}"
  },
  {
    "function_name": "jbd2_journal_grab_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2464-2475",
    "snippet": "struct journal_head *jbd2_journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *jbd2_journal_grab_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh = NULL;\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t\tjh->b_jcount++;\n\t}\n\tjbd_unlock_bh_journal_head(bh);\n\treturn jh;\n}"
  },
  {
    "function_name": "jbd2_journal_add_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2423-2458",
    "snippet": "struct journal_head *jbd2_journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_free_journal_head",
          "args": [
            "new_jh"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "journal_free_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2373-2380",
          "snippet": "static void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD2_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(jbd2_journal_head_cache, jh);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD2_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(jbd2_journal_head_cache, jh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"added journal_head\""
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh",
            "(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping)"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&bh->b_count"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bh2jh",
          "args": [
            "bh"
          ],
          "line": 2434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_journal_head",
          "args": [
            "bh"
          ],
          "line": 2432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_alloc_journal_head",
          "args": [],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "journal_alloc_journal_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2354-2371",
          "snippet": "static struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\tif (!ret) {\n\t\tjbd_debug(1, \"out of memory for journal_head\\n\");\n\t\tpr_notice_ratelimited(\"ENOMEM in %s, retrying.\\n\", __func__);\n\t\twhile (!ret) {\n\t\t\tyield();\n\t\t\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *jbd2_journal_head_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\tif (!ret) {\n\t\tjbd_debug(1, \"out of memory for journal_head\\n\");\n\t\tpr_notice_ratelimited(\"ENOMEM in %s, retrying.\\n\", __func__);\n\t\twhile (!ret) {\n\t\t\tyield();\n\t\t\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_jbd",
          "args": [
            "bh"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct journal_head *jbd2_journal_add_journal_head(struct buffer_head *bh)\n{\n\tstruct journal_head *jh;\n\tstruct journal_head *new_jh = NULL;\n\nrepeat:\n\tif (!buffer_jbd(bh))\n\t\tnew_jh = journal_alloc_journal_head();\n\n\tjbd_lock_bh_journal_head(bh);\n\tif (buffer_jbd(bh)) {\n\t\tjh = bh2jh(bh);\n\t} else {\n\t\tJ_ASSERT_BH(bh,\n\t\t\t(atomic_read(&bh->b_count) > 0) ||\n\t\t\t(bh->b_page && bh->b_page->mapping));\n\n\t\tif (!new_jh) {\n\t\t\tjbd_unlock_bh_journal_head(bh);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh = new_jh;\n\t\tnew_jh = NULL;\t\t/* We consumed it */\n\t\tset_buffer_jbd(bh);\n\t\tbh->b_private = jh;\n\t\tjh->b_bh = bh;\n\t\tget_bh(bh);\n\t\tBUFFER_TRACE(bh, \"added journal_head\");\n\t}\n\tjh->b_jcount++;\n\tjbd_unlock_bh_journal_head(bh);\n\tif (new_jh)\n\t\tjournal_free_journal_head(new_jh);\n\treturn bh->b_private;\n}"
  },
  {
    "function_name": "journal_free_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2373-2380",
    "snippet": "static void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD2_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(jbd2_journal_head_cache, jh);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_journal_head_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "jbd2_journal_head_cache",
            "jh"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "jh",
            "JBD2_POISON_FREE",
            "sizeof(*jh)"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&nr_journal_heads"
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic void journal_free_journal_head(struct journal_head *jh)\n{\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_dec(&nr_journal_heads);\n\tmemset(jh, JBD2_POISON_FREE, sizeof(*jh));\n#endif\n\tkmem_cache_free(jbd2_journal_head_cache, jh);\n}"
  },
  {
    "function_name": "journal_alloc_journal_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2354-2371",
    "snippet": "static struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\tif (!ret) {\n\t\tjbd_debug(1, \"out of memory for journal_head\\n\");\n\t\tpr_notice_ratelimited(\"ENOMEM in %s, retrying.\\n\", __func__);\n\t\twhile (!ret) {\n\t\t\tyield();\n\t\t\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_journal_head_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "jbd2_journal_head_cache",
            "GFP_NOFS"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "yield",
          "args": [],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice_ratelimited",
          "args": [
            "\"ENOMEM in %s, retrying.\\n\"",
            "__func__"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"out of memory for journal_head\\n\""
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "jbd2_journal_head_cache",
            "GFP_NOFS"
          ],
          "line": 2361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&nr_journal_heads"
          ],
          "line": 2359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic struct journal_head *journal_alloc_journal_head(void)\n{\n\tstruct journal_head *ret;\n\n#ifdef CONFIG_JBD2_DEBUG\n\tatomic_inc(&nr_journal_heads);\n#endif\n\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\tif (!ret) {\n\t\tjbd_debug(1, \"out of memory for journal_head\\n\");\n\t\tpr_notice_ratelimited(\"ENOMEM in %s, retrying.\\n\", __func__);\n\t\twhile (!ret) {\n\t\t\tyield();\n\t\t\tret = kmem_cache_zalloc(jbd2_journal_head_cache, GFP_NOFS);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_journal_destroy_journal_head_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2343-2349",
    "snippet": "static void jbd2_journal_destroy_journal_head_cache(void)\n{\n\tif (jbd2_journal_head_cache) {\n\t\tkmem_cache_destroy(jbd2_journal_head_cache);\n\t\tjbd2_journal_head_cache = NULL;\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_journal_head_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jbd2_journal_head_cache"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic void jbd2_journal_destroy_journal_head_cache(void)\n{\n\tif (jbd2_journal_head_cache) {\n\t\tkmem_cache_destroy(jbd2_journal_head_cache);\n\t\tjbd2_journal_head_cache = NULL;\n\t}\n}"
  },
  {
    "function_name": "jbd2_journal_init_journal_head_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2325-2341",
    "snippet": "static int jbd2_journal_init_journal_head_cache(void)\n{\n\tint retval;\n\n\tJ_ASSERT(jbd2_journal_head_cache == NULL);\n\tjbd2_journal_head_cache = kmem_cache_create(\"jbd2_journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tretval = 0;\n\tif (!jbd2_journal_head_cache) {\n\t\tretval = -ENOMEM;\n\t\tprintk(KERN_EMERG \"JBD2: no memory for journal_head cache\\n\");\n\t}\n\treturn retval;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *jbd2_journal_head_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"JBD2: no memory for journal_head cache\\n\""
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"jbd2_journal_head\"",
            "sizeof(struct journal_head)",
            "0",
            "/* offset */SLAB_TEMPORARY",
            "/* flags */NULL"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "jbd2_journal_head_cache == NULL"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct kmem_cache *jbd2_journal_head_cache;\n\nstatic int jbd2_journal_init_journal_head_cache(void)\n{\n\tint retval;\n\n\tJ_ASSERT(jbd2_journal_head_cache == NULL);\n\tjbd2_journal_head_cache = kmem_cache_create(\"jbd2_journal_head\",\n\t\t\t\tsizeof(struct journal_head),\n\t\t\t\t0,\t\t/* offset */\n\t\t\t\tSLAB_TEMPORARY,\t/* flags */\n\t\t\t\tNULL);\t\t/* ctor */\n\tretval = 0;\n\tif (!jbd2_journal_head_cache) {\n\t\tretval = -ENOMEM;\n\t\tprintk(KERN_EMERG \"JBD2: no memory for journal_head cache\\n\");\n\t}\n\treturn retval;\n}"
  },
  {
    "function_name": "jbd2_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2299-2315",
    "snippet": "void jbd2_free(void *ptr, size_t size)\n{\n\tif (size == PAGE_SIZE) {\n\t\tfree_pages((unsigned long)ptr, 0);\n\t\treturn;\n\t}\n\tif (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tfree_pages((unsigned long)ptr, order);\n\t\telse\n\t\t\tvfree(ptr);\n\t\treturn;\n\t}\n\tkmem_cache_free(get_slab(size), ptr);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "get_slab(size)",
            "ptr"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_slab",
          "args": [
            "size"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "get_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2262-2271",
          "snippet": "static struct kmem_cache *get_slab(size_t size)\n{\n\tint i = order_base_2(size) - 10;\n\n\tBUG_ON(i >= JBD2_MAX_SLABS);\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tBUG_ON(jbd2_slab[i] == NULL);\n\treturn jbd2_slab[i];\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define JBD2_MAX_SLABS 8"
          ],
          "globals_used": [
            "static struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_MAX_SLABS 8\n\nstatic struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];\n\nstatic struct kmem_cache *get_slab(size_t size)\n{\n\tint i = order_base_2(size) - 10;\n\n\tBUG_ON(i >= JBD2_MAX_SLABS);\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tBUG_ON(jbd2_slab[i] == NULL);\n\treturn jbd2_slab[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "ptr"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)ptr",
            "order"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_and_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1114-1125",
          "snippet": "void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)\n{\n\tint i;\n\n\tfor(i = 0; i < num_pages; i++) {\n\t\tif (pages[i]) {\n\t\t\tunlock_page(pages[i]);\n\t\t\tmark_page_accessed(pages[i]);\n\t\t\tpage_cache_release(pages[i]);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_free(void *ptr, size_t size)\n{\n\tif (size == PAGE_SIZE) {\n\t\tfree_pages((unsigned long)ptr, 0);\n\t\treturn;\n\t}\n\tif (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tfree_pages((unsigned long)ptr, order);\n\t\telse\n\t\t\tvfree(ptr);\n\t\treturn;\n\t}\n\tkmem_cache_free(get_slab(size), ptr);\n}"
  },
  {
    "function_name": "jbd2_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2273-2297",
    "snippet": "void *jbd2_alloc(size_t size, gfp_t flags)\n{\n\tvoid *ptr;\n\n\tBUG_ON(size & (size-1)); /* Must be a power of 2 */\n\n\tflags |= __GFP_REPEAT;\n\tif (size == PAGE_SIZE)\n\t\tptr = (void *)__get_free_pages(flags, 0);\n\telse if (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tptr = (void *)__get_free_pages(flags, order);\n\t\telse\n\t\t\tptr = vmalloc(size);\n\t} else\n\t\tptr = kmem_cache_alloc(get_slab(size), flags);\n\n\t/* Check alignment; SLUB has gotten this wrong in the past,\n\t * and this can lead to user data corruption! */\n\tBUG_ON(((unsigned long) ptr) & (size-1));\n\n\treturn ptr;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "((unsigned long) ptr) & (size-1)"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "get_slab(size)",
            "flags"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_slab",
          "args": [
            "size"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "get_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2262-2271",
          "snippet": "static struct kmem_cache *get_slab(size_t size)\n{\n\tint i = order_base_2(size) - 10;\n\n\tBUG_ON(i >= JBD2_MAX_SLABS);\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tBUG_ON(jbd2_slab[i] == NULL);\n\treturn jbd2_slab[i];\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define JBD2_MAX_SLABS 8"
          ],
          "globals_used": [
            "static struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_MAX_SLABS 8\n\nstatic struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];\n\nstatic struct kmem_cache *get_slab(size_t size)\n{\n\tint i = order_base_2(size) - 10;\n\n\tBUG_ON(i >= JBD2_MAX_SLABS);\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tBUG_ON(jbd2_slab[i] == NULL);\n\treturn jbd2_slab[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "size"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "ffs2_blocks_use_vmalloc(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jffs2/nodelist.h",
          "lines": "292-295",
          "snippet": "tatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}",
          "includes": [
            "include \"debug.h\"",
            "include \"os-linux.h\"\n#",
            "include \"os-ecos.h\"\n#",
            "include \"summary.h\"",
            "include \"acl.h\"\n#",
            "include \"xattr.h\"\n#",
            "include \"jffs2_fs_i.h\"\n#",
            "include \"jffs2_fs_sb.h\"\n#",
            "include <linux/jffs2.h>\n#",
            "include <linux/types.h>\n#",
            "include <linux/fs.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "include \"debug.h\"\ninclude \"os-linux.h\"\n#\ninclude \"os-ecos.h\"\n#\ninclude \"summary.h\"\ninclude \"acl.h\"\n#\ninclude \"xattr.h\"\n#\ninclude \"jffs2_fs_i.h\"\n#\ninclude \"jffs2_fs_sb.h\"\n#\ninclude <linux/jffs2.h>\n#\ninclude <linux/types.h>\n#\ninclude <linux/fs.h>\n#\n\ntatic inline int jffs2_blocks_use_vmalloc(struct jffs2_sb_info *c)\n{\n\treturn ((c->flash_size / c->sector_size) * sizeof (struct jffs2_eraseblock)) > (128 * 1024);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "flags",
            "order"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "flags",
            "0"
          ],
          "line": 2281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "size & (size-1)"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid *jbd2_alloc(size_t size, gfp_t flags)\n{\n\tvoid *ptr;\n\n\tBUG_ON(size & (size-1)); /* Must be a power of 2 */\n\n\tflags |= __GFP_REPEAT;\n\tif (size == PAGE_SIZE)\n\t\tptr = (void *)__get_free_pages(flags, 0);\n\telse if (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tptr = (void *)__get_free_pages(flags, order);\n\t\telse\n\t\t\tptr = vmalloc(size);\n\t} else\n\t\tptr = kmem_cache_alloc(get_slab(size), flags);\n\n\t/* Check alignment; SLUB has gotten this wrong in the past,\n\t * and this can lead to user data corruption! */\n\tBUG_ON(((unsigned long) ptr) & (size-1));\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "get_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2262-2271",
    "snippet": "static struct kmem_cache *get_slab(size_t size)\n{\n\tint i = order_base_2(size) - 10;\n\n\tBUG_ON(i >= JBD2_MAX_SLABS);\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tBUG_ON(jbd2_slab[i] == NULL);\n\treturn jbd2_slab[i];\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define JBD2_MAX_SLABS 8"
    ],
    "globals_used": [
      "static struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "jbd2_slab[i] == NULL"
          ],
          "line": 2269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i < 0"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i >= JBD2_MAX_SLABS"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_base_2",
          "args": [
            "size"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_MAX_SLABS 8\n\nstatic struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];\n\nstatic struct kmem_cache *get_slab(size_t size)\n{\n\tint i = order_base_2(size) - 10;\n\n\tBUG_ON(i >= JBD2_MAX_SLABS);\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tBUG_ON(jbd2_slab[i] == NULL);\n\treturn jbd2_slab[i];\n}"
  },
  {
    "function_name": "jbd2_journal_create_slab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2231-2260",
    "snippet": "static int jbd2_journal_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(jbd2_slab_create_mutex);\n\tint i = order_base_2(size) - 10;\n\tsize_t slab_size;\n\n\tif (size == PAGE_SIZE)\n\t\treturn 0;\n\n\tif (i >= JBD2_MAX_SLABS)\n\t\treturn -EINVAL;\n\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tmutex_lock(&jbd2_slab_create_mutex);\n\tif (jbd2_slab[i]) {\n\t\tmutex_unlock(&jbd2_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = 1 << (i+10);\n\tjbd2_slab[i] = kmem_cache_create(jbd2_slab_names[i], slab_size,\n\t\t\t\t\t slab_size, 0, NULL);\n\tmutex_unlock(&jbd2_slab_create_mutex);\n\tif (!jbd2_slab[i]) {\n\t\tprintk(KERN_EMERG \"JBD2: no memory for jbd2_slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define JBD2_MAX_SLABS 8"
    ],
    "globals_used": [
      "static int jbd2_journal_create_slab(size_t slab_size);",
      "static struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];",
      "static const char *jbd2_slab_names[JBD2_MAX_SLABS] = {\n\t\"jbd2_1k\", \"jbd2_2k\", \"jbd2_4k\", \"jbd2_8k\",\n\t\"jbd2_16k\", \"jbd2_32k\", \"jbd2_64k\", \"jbd2_128k\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"JBD2: no memory for jbd2_slab cache\\n\""
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jbd2_slab_create_mutex"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "jbd2_slab_names[i]",
            "slab_size",
            "slab_size",
            "0",
            "NULL"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jbd2_slab_create_mutex"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&jbd2_slab_create_mutex"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i < 0"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "order_base_2",
          "args": [
            "size"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_MAX_SLABS 8\n\nstatic int jbd2_journal_create_slab(size_t slab_size);\nstatic struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];\nstatic const char *jbd2_slab_names[JBD2_MAX_SLABS] = {\n\t\"jbd2_1k\", \"jbd2_2k\", \"jbd2_4k\", \"jbd2_8k\",\n\t\"jbd2_16k\", \"jbd2_32k\", \"jbd2_64k\", \"jbd2_128k\"\n};\n\nstatic int jbd2_journal_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(jbd2_slab_create_mutex);\n\tint i = order_base_2(size) - 10;\n\tsize_t slab_size;\n\n\tif (size == PAGE_SIZE)\n\t\treturn 0;\n\n\tif (i >= JBD2_MAX_SLABS)\n\t\treturn -EINVAL;\n\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tmutex_lock(&jbd2_slab_create_mutex);\n\tif (jbd2_slab[i]) {\n\t\tmutex_unlock(&jbd2_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = 1 << (i+10);\n\tjbd2_slab[i] = kmem_cache_create(jbd2_slab_names[i], slab_size,\n\t\t\t\t\t slab_size, 0, NULL);\n\tmutex_unlock(&jbd2_slab_create_mutex);\n\tif (!jbd2_slab[i]) {\n\t\tprintk(KERN_EMERG \"JBD2: no memory for jbd2_slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_journal_destroy_slabs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2220-2229",
    "snippet": "static void jbd2_journal_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < JBD2_MAX_SLABS; i++) {\n\t\tif (jbd2_slab[i])\n\t\t\tkmem_cache_destroy(jbd2_slab[i]);\n\t\tjbd2_slab[i] = NULL;\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define JBD2_MAX_SLABS 8"
    ],
    "globals_used": [
      "static struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "jbd2_slab[i]"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_MAX_SLABS 8\n\nstatic struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];\n\nstatic void jbd2_journal_destroy_slabs(void)\n{\n\tint i;\n\n\tfor (i = 0; i < JBD2_MAX_SLABS; i++) {\n\t\tif (jbd2_slab[i])\n\t\t\tkmem_cache_destroy(jbd2_slab[i]);\n\t\tjbd2_slab[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "journal_tag_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2178-2194",
    "snippet": "size_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2))\n\t\tsz += sizeof(__u16);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_64BIT"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_CSUM_V2"
          ],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_CSUM_V3"
          ],
          "line": 2182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nsize_t journal_tag_bytes(journal_t *journal)\n{\n\tsize_t sz;\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3))\n\t\treturn sizeof(journal_block_tag3_t);\n\n\tsz = sizeof(journal_block_tag_t);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2))\n\t\tsz += sizeof(__u16);\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))\n\t\treturn sz;\n\telse\n\t\treturn sz - sizeof(__u32);\n}"
  },
  {
    "function_name": "jbd2_journal_blocks_per_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2170-2173",
    "snippet": "int jbd2_journal_blocks_per_page(struct inode *inode)\n{\n\treturn 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_blocks_per_page(struct inode *inode)\n{\n\treturn 1 << (PAGE_CACHE_SHIFT - inode->i_sb->s_blocksize_bits);\n}"
  },
  {
    "function_name": "jbd2_journal_ack_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2162-2168",
    "snippet": "void jbd2_journal_ack_err(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_errno)\n\t\tjournal->j_flags |= JBD2_ACK_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2167
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_ack_err(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_errno)\n\t\tjournal->j_flags |= JBD2_ACK_ERR;\n\twrite_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "jbd2_journal_clear_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2142-2153",
    "snippet": "int jbd2_journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\twrite_unlock(&journal->j_state_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2151
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_clear_err(journal_t *journal)\n{\n\tint err = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\tjournal->j_errno = 0;\n\twrite_unlock(&journal->j_state_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_journal_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2122-2133",
    "snippet": "int jbd2_journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tread_unlock(&journal->j_state_lock);\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2126
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_errno(journal_t *journal)\n{\n\tint err;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_flags & JBD2_ABORT)\n\t\terr = -EROFS;\n\telse\n\t\terr = journal->j_errno;\n\tread_unlock(&journal->j_state_lock);\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_journal_abort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2106-2109",
    "snippet": "void jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_abort_soft (journal_t *journal, int errno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__journal_abort_soft",
          "args": [
            "journal",
            "errno"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_abort_soft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2046-2058",
          "snippet": "static void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__jbd2_journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjbd2_journal_update_sb_errno(journal);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__jbd2_journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjbd2_journal_update_sb_errno(journal);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_abort(journal_t *journal, int errno)\n{\n\t__journal_abort_soft(journal, errno);\n}"
  },
  {
    "function_name": "__journal_abort_soft",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2046-2058",
    "snippet": "static void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__jbd2_journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjbd2_journal_update_sb_errno(journal);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_abort_soft (journal_t *journal, int errno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_update_sb_errno",
          "args": [
            "journal"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_update_sb_errno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1448-1459",
          "snippet": "void jbd2_journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tread_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD2: updating superblock error (errno %d)\\n\",\n\t\t  journal->j_errno);\n\tsb->s_errno    = cpu_to_be32(journal->j_errno);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_SYNC);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tread_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD2: updating superblock error (errno %d)\\n\",\n\t\t  journal->j_errno);\n\tsb->s_errno    = cpu_to_be32(journal->j_errno);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_abort_hard",
          "args": [
            "journal"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_abort_hard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2026-2042",
          "snippet": "void __jbd2_journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t       journal->j_devname);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd2_journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t       journal->j_devname);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__jbd2_journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjbd2_journal_update_sb_errno(journal);\n}"
  },
  {
    "function_name": "__jbd2_journal_abort_hard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "2026-2042",
    "snippet": "void __jbd2_journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t       journal->j_devname);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\twrite_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_log_start_commit",
          "args": [
            "journal",
            "transaction->t_tid"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "503-538",
          "snippet": "int __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 2036
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Aborting journal on device %s.\\n\"",
            "journal->j_devname"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd2_journal_abort_hard(journal_t *journal)\n{\n\ttransaction_t *transaction;\n\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tprintk(KERN_ERR \"Aborting journal on device %s.\\n\",\n\t       journal->j_devname);\n\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_ABORT;\n\ttransaction = journal->j_running_transaction;\n\tif (transaction)\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\twrite_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "jbd2_journal_wipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1985-2011",
    "snippet": "int jbd2_journal_wipe(journal_t *journal, int write)\n{\n\tint err = 0;\n\n\tJ_ASSERT (!(journal->j_flags & JBD2_LOADED));\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tif (!journal->j_tail)\n\t\tgoto no_recovery;\n\n\tprintk(KERN_WARNING \"JBD2: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = jbd2_journal_skip_recovery(journal);\n\tif (write) {\n\t\t/* Lock to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_mark_journal_empty(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n no_recovery:\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_mark_journal_empty",
          "args": [
            "journal"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_mark_journal_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1414-1438",
          "snippet": "static void jbd2_mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tread_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD2: Marking journal as empty (seq %d)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_FUA);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tread_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD2: Marking journal as empty (seq %d)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_FUA);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_skip_recovery",
          "args": [
            "journal"
          ],
          "line": 2001
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_skip_recovery",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "313-339",
          "snippet": "int jbd2_journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t} else {\n#ifdef CONFIG_JBD2_DEBUG\n\t\tint dropped = info.end_transaction - \n\t\t\tbe32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd_debug(1,\n\t\t\t  \"JBD2: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nint jbd2_journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD2: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t} else {\n#ifdef CONFIG_JBD2_DEBUG\n\t\tint dropped = info.end_transaction - \n\t\t\tbe32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd_debug(1,\n\t\t\t  \"JBD2: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"JBD2: %s recovery information on journal\\n\"",
            "write ? \"Clearing\" : \"Ignoring\""
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "load_superblock",
          "args": [
            "journal"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "load_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1582-1600",
          "snippet": "static int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!(journal->j_flags & JBD2_LOADED)"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_wipe(journal_t *journal, int write)\n{\n\tint err = 0;\n\n\tJ_ASSERT (!(journal->j_flags & JBD2_LOADED));\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tif (!journal->j_tail)\n\t\tgoto no_recovery;\n\n\tprintk(KERN_WARNING \"JBD2: %s recovery information on journal\\n\",\n\t\twrite ? \"Clearing\" : \"Ignoring\");\n\n\terr = jbd2_journal_skip_recovery(journal);\n\tif (write) {\n\t\t/* Lock to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_mark_journal_empty(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\n no_recovery:\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_journal_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1914-1970",
    "snippet": "int jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1968
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_tail_sequence == journal->j_transaction_sequence"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_head == journal->j_tail"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!journal->j_checkpoint_transactions"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!journal->j_committing_transaction"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!journal->j_running_transaction"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_mark_journal_empty",
          "args": [
            "journal"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_mark_journal_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1414-1438",
          "snippet": "static void jbd2_mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tread_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD2: Marking journal as empty (seq %d)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_FUA);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tread_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD2: Marking journal as empty (seq %d)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_FUA);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_cleanup_journal_tail",
          "args": [
            "journal"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_cleanup_journal_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "387-412",
          "snippet": "int jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n\t * we drop the transactions from the journal. It's unlikely this will\n\t * be necessary, especially with an appropriately sized journal, but we\n\t * need this to guarantee correctness.  Fortunately\n\t * jbd2_cleanup_journal_tail() doesn't get called all that often.\n\t */\n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\n\t__jbd2_update_log_tail(journal, first_tid, blocknr);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_cleanup_journal_tail(journal_t *journal)\n{\n\ttid_t\t\tfirst_tid;\n\tunsigned long\tblocknr;\n\n\tif (is_journal_aborted(journal))\n\t\treturn 1;\n\n\tif (!jbd2_journal_get_log_tail(journal, &first_tid, &blocknr))\n\t\treturn 1;\n\tJ_ASSERT(blocknr != 0);\n\n\t/*\n\t * We need to make sure that any blocks that were recently written out\n\t * --- perhaps by jbd2_log_do_checkpoint() --- are flushed out before\n\t * we drop the transactions from the journal. It's unlikely this will\n\t * be necessary, especially with an appropriately sized journal, but we\n\t * need this to guarantee correctness.  Fortunately\n\t * jbd2_cleanup_journal_tail() doesn't get called all that often.\n\t */\n\tif (journal->j_flags & JBD2_BARRIER)\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\n\t__jbd2_update_log_tail(journal, first_tid, blocknr);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1945
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_log_do_checkpoint",
          "args": [
            "journal"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_do_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "208-367",
          "snippet": "int jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t/* checkpoint all of the transaction's buffers */\n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t/*\n\t\t\t\t * The journal thread is dead; so\n\t\t\t\t * starting and waiting for a commit\n\t\t\t\t * to finish will cause us to wait for\n\t\t\t\t * a _very_ long time.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!buffer_dirty(bh)) {\n\t\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\t\tresult = -EIO;\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\t\t/* The transaction was released; we're done */\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal\n\t\t * lock.  We cannot afford to let the transaction\n\t\t * logic start messing around with this buffer before\n\t\t * we write it to disk, as that would break\n\t\t * recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t__buffer_relink_io(jh);\n\t\ttransaction->t_chp_stats.cs_written++;\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() ||\n\t\t    spin_needbreak(&journal->j_list_lock))\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Now we issued all of the transaction's buffers, let's deal\n\t * with the buffers that are out for I/O.\n\t */\nrestart2:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\twhile (transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart2;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\tresult = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we\n\t\t * know that it has been written out and so we can\n\t\t * drop it from the list\n\t\t */\n\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjbd2_journal_abort(journal, result);\n\telse\n\t\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t/* checkpoint all of the transaction's buffers */\n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t/*\n\t\t\t\t * The journal thread is dead; so\n\t\t\t\t * starting and waiting for a commit\n\t\t\t\t * to finish will cause us to wait for\n\t\t\t\t * a _very_ long time.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!buffer_dirty(bh)) {\n\t\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\t\tresult = -EIO;\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\t\t/* The transaction was released; we're done */\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal\n\t\t * lock.  We cannot afford to let the transaction\n\t\t * logic start messing around with this buffer before\n\t\t * we write it to disk, as that would break\n\t\t * recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t__buffer_relink_io(jh);\n\t\ttransaction->t_chp_stats.cs_written++;\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() ||\n\t\t    spin_needbreak(&journal->j_list_lock))\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Now we issued all of the transaction's buffers, let's deal\n\t * with the buffers that are out for I/O.\n\t */\nrestart2:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\twhile (transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart2;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\tresult = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we\n\t\t * know that it has been written out and so we can\n\t\t * drop it from the list\n\t\t */\n\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjbd2_journal_abort(journal, result);\n\telse\n\t\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "698-724",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_log_start_commit",
          "args": [
            "journal",
            "transaction->t_tid"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "503-538",
          "snippet": "int __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_flush(journal_t *journal)\n{\n\tint err = 0;\n\ttransaction_t *transaction = NULL;\n\n\twrite_lock(&journal->j_state_lock);\n\n\t/* Force everything buffered to the log... */\n\tif (journal->j_running_transaction) {\n\t\ttransaction = journal->j_running_transaction;\n\t\t__jbd2_log_start_commit(journal, transaction->t_tid);\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\t/* Wait for the log commit to complete... */\n\tif (transaction) {\n\t\ttid_t tid = transaction->t_tid;\n\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tjbd2_log_wait_commit(journal, tid);\n\t} else {\n\t\twrite_unlock(&journal->j_state_lock);\n\t}\n\n\t/* ...and flush everything in the log out to disk. */\n\tspin_lock(&journal->j_list_lock);\n\twhile (!err && journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\terr = jbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (is_journal_aborted(journal))\n\t\treturn -EIO;\n\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tjbd2_cleanup_journal_tail(journal);\n\n\t/* Finally, mark the journal as really needing no recovery.\n\t * This sets s_start==0 in the underlying superblock, which is\n\t * the magic code for a fully-recovered superblock.  Any future\n\t * commits of data to the journal will restore the current\n\t * s_start value. */\n\tjbd2_mark_journal_empty(journal);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(!journal->j_running_transaction);\n\tJ_ASSERT(!journal->j_committing_transaction);\n\tJ_ASSERT(!journal->j_checkpoint_transactions);\n\tJ_ASSERT(journal->j_head == journal->j_tail);\n\tJ_ASSERT(journal->j_tail_sequence == journal->j_transaction_sequence);\n\twrite_unlock(&journal->j_state_lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_journal_clear_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1889-1902",
    "snippet": "void jbd2_journal_clear_features(journal_t *journal, unsigned long compat,\n\t\t\t\tunsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tjbd_debug(1, \"Clear features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    &= ~cpu_to_be32(compat);\n\tsb->s_feature_ro_compat &= ~cpu_to_be32(ro);\n\tsb->s_feature_incompat  &= ~cpu_to_be32(incompat);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "incompat"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ro"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "compat"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Clear features 0x%lx/0x%lx/0x%lx\\n\"",
            "compat",
            "ro",
            "incompat"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_clear_features(journal_t *journal, unsigned long compat,\n\t\t\t\tunsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tjbd_debug(1, \"Clear features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\tsb->s_feature_compat    &= ~cpu_to_be32(compat);\n\tsb->s_feature_ro_compat &= ~cpu_to_be32(ro);\n\tsb->s_feature_incompat  &= ~cpu_to_be32(incompat);\n}"
  },
  {
    "function_name": "jbd2_journal_set_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1808-1876",
    "snippet": "int jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "incompat"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "ro"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "compat"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "COMPAT_FEATURE_ON",
          "args": [
            "JBD2_FEATURE_COMPAT_CHECKSUM"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "journal",
            "~0",
            "sb->s_uuid",
            "sizeof(sb->s_uuid)"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\""
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "journal->j_chksum_driver"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "\"crc32c\"",
            "0",
            "0"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_FEATURE_COMPAT_CHECKSUM"
          ],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INCOMPAT_FEATURE_ON",
          "args": [
            "JBD2_FEATURE_INCOMPAT_CSUM_V3"
          ],
          "line": 1840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Setting new features 0x%lx/0x%lx/0x%lx\\n\"",
            "compat",
            "ro",
            "incompat"
          ],
          "line": 1834
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_check_available_features",
          "args": [
            "journal",
            "compat",
            "ro",
            "incompat"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_check_available_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1775-1794",
          "snippet": "int jbd2_journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JBD2_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JBD2_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JBD2_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JBD2_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JBD2_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JBD2_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_check_used_features",
          "args": [
            "journal",
            "compat",
            "ro",
            "incompat"
          ],
          "line": 1817
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_check_used_features",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1740-1762",
          "snippet": "int jbd2_journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\t/* Load journal superblock if it is not loaded yet. */\n\tif (journal->j_format_version == 0 &&\n\t    journal_get_superblock(journal) != 0)\n\t\treturn 0;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\t/* Load journal superblock if it is not loaded yet. */\n\tif (journal->j_format_version == 0 &&\n\t    journal_get_superblock(journal) != 0)\n\t\treturn 0;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_set_features (journal_t *journal, unsigned long compat,\n\t\t\t  unsigned long ro, unsigned long incompat)\n{\n#define INCOMPAT_FEATURE_ON(f) \\\n\t\t((incompat & (f)) && !(sb->s_feature_incompat & cpu_to_be32(f)))\n#define COMPAT_FEATURE_ON(f) \\\n\t\t((compat & (f)) && !(sb->s_feature_compat & cpu_to_be32(f)))\n\tjournal_superblock_t *sb;\n\n\tif (jbd2_journal_check_used_features(journal, compat, ro, incompat))\n\t\treturn 1;\n\n\tif (!jbd2_journal_check_available_features(journal, compat, ro, incompat))\n\t\treturn 0;\n\n\t/* If enabling v2 checksums, turn on v3 instead */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V2) {\n\t\tincompat &= ~JBD2_FEATURE_INCOMPAT_CSUM_V2;\n\t\tincompat |= JBD2_FEATURE_INCOMPAT_CSUM_V3;\n\t}\n\n\t/* Asking for checksumming v3 and v1?  Only give them v3. */\n\tif (incompat & JBD2_FEATURE_INCOMPAT_CSUM_V3 &&\n\t    compat & JBD2_FEATURE_COMPAT_CHECKSUM)\n\t\tcompat &= ~JBD2_FEATURE_COMPAT_CHECKSUM;\n\n\tjbd_debug(1, \"Setting new features 0x%lx/0x%lx/0x%lx\\n\",\n\t\t  compat, ro, incompat);\n\n\tsb = journal->j_superblock;\n\n\t/* If enabling v3 checksums, update superblock */\n\tif (INCOMPAT_FEATURE_ON(JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\tsb->s_checksum_type = JBD2_CRC32C_CHKSUM;\n\t\tsb->s_feature_compat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_COMPAT_CHECKSUM);\n\n\t\t/* Load the checksum driver */\n\t\tif (journal->j_chksum_driver == NULL) {\n\t\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\",\n\t\t\t\t\t\t\t\t      0, 0);\n\t\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c \"\n\t\t\t\t       \"driver.\\n\");\n\t\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Precompute checksum seed for all metadata */\n\t\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0,\n\t\t\t\t\t\t\t   sb->s_uuid,\n\t\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\t\t}\n\t}\n\n\t/* If enabling v1 checksums, downgrade superblock */\n\tif (COMPAT_FEATURE_ON(JBD2_FEATURE_COMPAT_CHECKSUM))\n\t\tsb->s_feature_incompat &=\n\t\t\t~cpu_to_be32(JBD2_FEATURE_INCOMPAT_CSUM_V2 |\n\t\t\t\t     JBD2_FEATURE_INCOMPAT_CSUM_V3);\n\n\tsb->s_feature_compat    |= cpu_to_be32(compat);\n\tsb->s_feature_ro_compat |= cpu_to_be32(ro);\n\tsb->s_feature_incompat  |= cpu_to_be32(incompat);\n\n\treturn 1;\n#undef COMPAT_FEATURE_ON\n#undef INCOMPAT_FEATURE_ON\n}"
  },
  {
    "function_name": "jbd2_journal_check_available_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1775-1794",
    "snippet": "int jbd2_journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JBD2_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JBD2_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JBD2_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_check_available_features (journal_t *journal, unsigned long compat,\n\t\t\t\t      unsigned long ro, unsigned long incompat)\n{\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\n\t/* We can support any known requested features iff the\n\t * superblock is in version 2.  Otherwise we fail to support any\n\t * extended sb features. */\n\n\tif (journal->j_format_version != 2)\n\t\treturn 0;\n\n\tif ((compat   & JBD2_KNOWN_COMPAT_FEATURES) == compat &&\n\t    (ro       & JBD2_KNOWN_ROCOMPAT_FEATURES) == ro &&\n\t    (incompat & JBD2_KNOWN_INCOMPAT_FEATURES) == incompat)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_journal_check_used_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1740-1762",
    "snippet": "int jbd2_journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\t/* Load journal superblock if it is not loaded yet. */\n\tif (journal->j_format_version == 0 &&\n\t    journal_get_superblock(journal) != 0)\n\t\treturn 0;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_feature_incompat"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_feature_ro_compat"
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_feature_compat"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_get_superblock",
          "args": [
            "journal"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1466-1575",
          "snippet": "static int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"JBD2: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD2: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JBD2_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JBD2_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD2: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk(KERN_WARNING \"JBD2: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2) &&\n\t    JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\t/* Can't have checksum v2 and v3 at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v2 and v3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_has_csum_v2or3(journal) &&\n\t    JBD2_HAS_COMPAT_FEATURE(journal, JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t/* Can't have checksum v1 and v2 on at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v1 and v2/3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!jbd2_verify_csum_type(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: Unknown checksum type\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Load the checksum driver */\n\tif (jbd2_journal_has_csum_v2or3(journal)) {\n\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c driver.\\n\");\n\t\t\terr = PTR_ERR(journal->j_chksum_driver);\n\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!jbd2_superblock_csum_verify(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: journal checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0, sb->s_uuid,\n\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\n\tset_buffer_verified(bh);\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"JBD2: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD2: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JBD2_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JBD2_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD2: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk(KERN_WARNING \"JBD2: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2) &&\n\t    JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\t/* Can't have checksum v2 and v3 at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v2 and v3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_has_csum_v2or3(journal) &&\n\t    JBD2_HAS_COMPAT_FEATURE(journal, JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t/* Can't have checksum v1 and v2 on at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v1 and v2/3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!jbd2_verify_csum_type(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: Unknown checksum type\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Load the checksum driver */\n\tif (jbd2_journal_has_csum_v2or3(journal)) {\n\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c driver.\\n\");\n\t\t\terr = PTR_ERR(journal->j_chksum_driver);\n\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!jbd2_superblock_csum_verify(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: journal checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0, sb->s_uuid,\n\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\n\tset_buffer_verified(bh);\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_check_used_features (journal_t *journal, unsigned long compat,\n\t\t\t\t unsigned long ro, unsigned long incompat)\n{\n\tjournal_superblock_t *sb;\n\n\tif (!compat && !ro && !incompat)\n\t\treturn 1;\n\t/* Load journal superblock if it is not loaded yet. */\n\tif (journal->j_format_version == 0 &&\n\t    journal_get_superblock(journal) != 0)\n\t\treturn 0;\n\tif (journal->j_format_version == 1)\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\tif (((be32_to_cpu(sb->s_feature_compat) & compat) == compat) &&\n\t    ((be32_to_cpu(sb->s_feature_ro_compat) & ro) == ro) &&\n\t    ((be32_to_cpu(sb->s_feature_incompat) & incompat) == incompat))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_journal_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1677-1726",
    "snippet": "int jbd2_journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t/* Wait for the commit thread to wake up and die. */\n\tjournal_kill_thread(journal);\n\n\t/* Force a final log commit */\n\tif (journal->j_running_transaction)\n\t\tjbd2_journal_commit_transaction(journal);\n\n\t/* Force any old transactions to disk */\n\n\t/* Totally anal locking here... */\n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t\tjbd2_mark_journal_empty(journal);\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\n\tif (journal->j_proc_entry)\n\t\tjbd2_stats_proc_exit(journal);\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjbd2_journal_destroy_revoke(journal);\n\tif (journal->j_chksum_driver)\n\t\tcrypto_free_shash(journal->j_chksum_driver);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal->j_wbuf"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "journal->j_chksum_driver"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_destroy_revoke",
          "args": [
            "journal"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_destroy_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "293-300",
          "snippet": "void jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nvoid jbd2_journal_destroy_revoke(journal_t *journal)\n{\n\tjournal->j_revoke = NULL;\n\tif (journal->j_revoke_table[0])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\n\tif (journal->j_revoke_table[1])\n\t\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[1]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "journal->j_inode"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_stats_proc_exit",
          "args": [
            "journal"
          ],
          "line": 1716
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_stats_proc_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1056-1060",
          "snippet": "static void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct proc_dir_entry *proc_jbd2_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "journal->j_sb_buffer"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_mark_journal_empty",
          "args": [
            "journal"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_mark_journal_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1414-1438",
          "snippet": "static void jbd2_mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tread_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD2: Marking journal as empty (seq %d)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_FUA);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tread_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD2: Marking journal as empty (seq %d)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_FUA);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_checkpoint_transactions == NULL"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_committing_transaction == NULL"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_running_transaction == NULL"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_log_do_checkpoint",
          "args": [
            "journal"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_do_checkpoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/checkpoint.c",
          "lines": "208-367",
          "snippet": "int jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t/* checkpoint all of the transaction's buffers */\n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t/*\n\t\t\t\t * The journal thread is dead; so\n\t\t\t\t * starting and waiting for a commit\n\t\t\t\t * to finish will cause us to wait for\n\t\t\t\t * a _very_ long time.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!buffer_dirty(bh)) {\n\t\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\t\tresult = -EIO;\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\t\t/* The transaction was released; we're done */\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal\n\t\t * lock.  We cannot afford to let the transaction\n\t\t * logic start messing around with this buffer before\n\t\t * we write it to disk, as that would break\n\t\t * recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t__buffer_relink_io(jh);\n\t\ttransaction->t_chp_stats.cs_written++;\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() ||\n\t\t    spin_needbreak(&journal->j_list_lock))\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Now we issued all of the transaction's buffers, let's deal\n\t * with the buffers that are out for I/O.\n\t */\nrestart2:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\twhile (transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart2;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\tresult = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we\n\t\t * know that it has been written out and so we can\n\t\t * drop it from the list\n\t\t */\n\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjbd2_journal_abort(journal, result);\n\telse\n\t\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nint jbd2_log_do_checkpoint(journal_t *journal)\n{\n\tstruct journal_head\t*jh;\n\tstruct buffer_head\t*bh;\n\ttransaction_t\t\t*transaction;\n\ttid_t\t\t\tthis_tid;\n\tint\t\t\tresult, batch_count = 0;\n\n\tjbd_debug(1, \"Start checkpoint\\n\");\n\n\t/*\n\t * First thing: if there are any transactions in the log which\n\t * don't need checkpointing, just eliminate them from the\n\t * journal straight away.\n\t */\n\tresult = jbd2_cleanup_journal_tail(journal);\n\ttrace_jbd2_checkpoint(journal, result);\n\tjbd_debug(1, \"cleanup_journal_tail returned %d\\n\", result);\n\tif (result <= 0)\n\t\treturn result;\n\n\t/*\n\t * OK, we need to start writing disk blocks.  Take one transaction\n\t * and write it.\n\t */\n\tresult = 0;\n\tspin_lock(&journal->j_list_lock);\n\tif (!journal->j_checkpoint_transactions)\n\t\tgoto out;\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction->t_chp_stats.cs_chp_time == 0)\n\t\ttransaction->t_chp_stats.cs_chp_time = jiffies;\n\tthis_tid = transaction->t_tid;\nrestart:\n\t/*\n\t * If someone cleaned up this transaction while we slept, we're\n\t * done (maybe it's a new transaction, but it fell at the same\n\t * address).\n\t */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\t/* checkpoint all of the transaction's buffers */\n\twhile (transaction->t_checkpoint_list) {\n\t\tjh = transaction->t_checkpoint_list;\n\t\tbh = jh2bh(jh);\n\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (jh->b_transaction != NULL) {\n\t\t\ttransaction_t *t = jh->b_transaction;\n\t\t\ttid_t tid = t->t_tid;\n\n\t\t\ttransaction->t_chp_stats.cs_forced_to_close++;\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tif (unlikely(journal->j_flags & JBD2_UNMOUNT))\n\t\t\t\t/*\n\t\t\t\t * The journal thread is dead; so\n\t\t\t\t * starting and waiting for a commit\n\t\t\t\t * to finish will cause us to wait for\n\t\t\t\t * a _very_ long time.\n\t\t\t\t */\n\t\t\t\tprintk(KERN_ERR\n\t\t\"JBD2: %s: Waiting for Godot: block %llu\\n\",\n\t\tjournal->j_devname, (unsigned long long) bh->b_blocknr);\n\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tjbd2_log_wait_commit(journal, tid);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!buffer_dirty(bh)) {\n\t\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\t\tresult = -EIO;\n\t\t\tBUFFER_TRACE(bh, \"remove from checkpoint\");\n\t\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\t\t/* The transaction was released; we're done */\n\t\t\t\tgoto out;\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Important: we are about to write the buffer, and\n\t\t * possibly block, while still holding the journal\n\t\t * lock.  We cannot afford to let the transaction\n\t\t * logic start messing around with this buffer before\n\t\t * we write it to disk, as that would break\n\t\t * recoverability.\n\t\t */\n\t\tBUFFER_TRACE(bh, \"queue\");\n\t\tget_bh(bh);\n\t\tJ_ASSERT_BH(bh, !buffer_jwrite(bh));\n\t\tjournal->j_chkpt_bhs[batch_count++] = bh;\n\t\t__buffer_relink_io(jh);\n\t\ttransaction->t_chp_stats.cs_written++;\n\t\tif ((batch_count == JBD2_NR_BATCH) ||\n\t\t    need_resched() ||\n\t\t    spin_needbreak(&journal->j_list_lock))\n\t\t\tgoto unlock_and_flush;\n\t}\n\n\tif (batch_count) {\n\t\tunlock_and_flush:\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\tretry:\n\t\t\tif (batch_count)\n\t\t\t\t__flush_batch(journal, &batch_count);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart;\n\t}\n\n\t/*\n\t * Now we issued all of the transaction's buffers, let's deal\n\t * with the buffers that are out for I/O.\n\t */\nrestart2:\n\t/* Did somebody clean up the transaction in the meanwhile? */\n\tif (journal->j_checkpoint_transactions != transaction ||\n\t    transaction->t_tid != this_tid)\n\t\tgoto out;\n\n\twhile (transaction->t_checkpoint_io_list) {\n\t\tjh = transaction->t_checkpoint_io_list;\n\t\tbh = jh2bh(jh);\n\t\tif (buffer_locked(bh)) {\n\t\t\tspin_unlock(&journal->j_list_lock);\n\t\t\tget_bh(bh);\n\t\t\twait_on_buffer(bh);\n\t\t\t/* the journal_head may have gone by now */\n\t\t\tBUFFER_TRACE(bh, \"brelse\");\n\t\t\t__brelse(bh);\n\t\t\tspin_lock(&journal->j_list_lock);\n\t\t\tgoto restart2;\n\t\t}\n\t\tif (unlikely(buffer_write_io_error(bh)) && !result)\n\t\t\tresult = -EIO;\n\n\t\t/*\n\t\t * Now in whatever state the buffer currently is, we\n\t\t * know that it has been written out and so we can\n\t\t * drop it from the list\n\t\t */\n\t\tif (__jbd2_journal_remove_checkpoint(jh))\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock(&journal->j_list_lock);\n\tif (result < 0)\n\t\tjbd2_journal_abort(journal, result);\n\telse\n\t\tresult = jbd2_cleanup_journal_tail(journal);\n\n\treturn (result < 0) ? result : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_commit_transaction",
          "args": [
            "journal"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "370-1164",
          "snippet": "void jbd2_journal_commit_transaction(journal_t *journal)\n{\n\tstruct transaction_stats_s stats;\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh;\n\tstruct buffer_head *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned long long blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tint tag_bytes = journal_tag_bytes(journal);\n\tstruct buffer_head *cbh = NULL; /* For transactional checksums */\n\t__u32 crc32_sum = ~0;\n\tstruct blk_plug plug;\n\t/* Tail of the journal */\n\tunsigned long first_block;\n\ttid_t first_tid;\n\tint update_tail;\n\tint csum_size = 0;\n\tLIST_HEAD(io_bufs);\n\tLIST_HEAD(log_bufs);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior jbd2_journal_flush? */\n\tif (journal->j_flags & JBD2_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd2_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd2_commit_locking(journal, commit_transaction);\n\tstats.run.rs_wait = commit_transaction->t_max_wait;\n\tstats.run.rs_request_delay = 0;\n\tstats.run.rs_locked = jiffies;\n\tif (commit_transaction->t_requested)\n\t\tstats.run.rs_request_delay =\n\t\t\tjbd2_time_diff(commit_transaction->t_requested,\n\t\t\t\t       stats.run.rs_locked);\n\tstats.run.rs_running = jbd2_time_diff(commit_transaction->t_start,\n\t\t\t\t\t      stats.run.rs_locked);\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a jbd2_journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple jbd2_journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A jbd2_journal_get_undo_access()+jbd2_journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjbd2_journal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjbd2_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjbd2_journal_switch_revoke_table(journal);\n\n\t/*\n\t * Reserved credits cannot be claimed anymore, free them\n\t */\n\tatomic_sub(atomic_read(&journal->j_reserved_credits),\n\t\t   &commit_transaction->t_outstanding_credits);\n\n\ttrace_jbd2_commit_flushing(journal, commit_transaction);\n\tstats.run.rs_flushing = jiffies;\n\tstats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,\n\t\t\t\t\t     stats.run.rs_flushing);\n\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\twrite_unlock(&journal->j_state_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 2a\\n\");\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\terr = journal_submit_data_buffers(journal, commit_transaction);\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tblk_start_plug(&plug);\n\tjbd2_journal_write_revoke_records(journal, commit_transaction,\n\t\t\t\t\t  &log_bufs, WRITE_SYNC);\n\n\tjbd_debug(3, \"JBD2: commit phase 2b\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\twrite_unlock(&journal->j_state_lock);\n\n\ttrace_jbd2_commit_logging(journal, commit_transaction);\n\tstats.run.rs_logging = jiffies;\n\tstats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,\n\t\t\t\t\t       stats.run.rs_logging);\n\tstats.run.rs_blocks =\n\t\tatomic_read(&commit_transaction->t_outstanding_credits);\n\tstats.run.rs_blocks_logged = 0;\n\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t atomic_read(&commit_transaction->t_outstanding_credits));\n\n\terr = 0;\n\tbufs = 0;\n\tdescriptor = NULL;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjbd2_buffer_abort_trigger(jh,\n\t\t\t\t\t\t  jh->b_frozen_data ?\n\t\t\t\t\t\t  jh->b_frozen_triggers :\n\t\t\t\t\t\t  jh->b_triggers);\n\t\t\tjbd2_journal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD2: get descriptor\\n\");\n\n\t\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjbd2_journal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tjbd_debug(4, \"JBD2: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)descriptor->b_blocknr,\n\t\t\t\tdescriptor->b_data);\n\t\t\theader = (journal_header_t *)descriptor->b_data;\n\t\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JBD2_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &descriptor->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = descriptor->b_size -\n\t\t\t\t\t\tsizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(descriptor);\n\t\t\tset_buffer_dirty(descriptor);\n\t\t\twbuf[bufs++] = descriptor;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(descriptor, \"ph3: file as descriptor\");\n\t\t\tjbd2_file_log_bh(&log_bufs, descriptor);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjbd2_journal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by jbd2_journal_next_log_block() also.\n\t\t */\n\t\tatomic_dec(&commit_transaction->t_outstanding_credits);\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the shadow pairing of buffers. */\n\t\tatomic_inc(&jh2bh(jh)->b_count);\n\n\t\t/*\n\t\t * Make a temporary IO buffer with which to write it out\n\t\t * (this will requeue the metadata buffer to BJ_Shadow).\n\t\t */\n\t\tset_bit(BH_JWrite, &jh2bh(jh)->b_state);\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = jbd2_journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\tjh, &wbuf[bufs], blocknr);\n\t\tif (flags < 0) {\n\t\t\tjbd2_journal_abort(journal, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tjbd2_file_log_bh(&io_bufs, wbuf[bufs]);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JBD2_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JBD2_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\twrite_tag_block(journal, tag, jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be16(tag_flag);\n\t\tjbd2_block_tag_csum_set(journal, tag, wbuf[bufs],\n\t\t\t\t\tcommit_transaction->t_tid);\n\t\ttagp += tag_bytes;\n\t\tspace_left -= tag_bytes;\n\t\tbufs++;\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < tag_bytes + 16 + csum_size) {\n\n\t\t\tjbd_debug(4, \"JBD2: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be16(JBD2_FLAG_LAST_TAG);\n\n\t\t\tjbd2_descr_block_csum_set(journal, descriptor);\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\t/*\n\t\t\t\t * Compute checksum.\n\t\t\t\t */\n\t\t\t\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\t\tcrc32_sum =\n\t\t\t\t\t    jbd2_checksum_data(crc32_sum, bh);\n\t\t\t\t}\n\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\tsubmit_bh(WRITE_SYNC, bh);\n\t\t\t}\n\t\t\tcond_resched();\n\t\t\tstats.run.rs_blocks_logged += bufs;\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\terr = journal_finish_inode_data_buffers(journal, commit_transaction);\n\tif (err) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Detected IO errors while flushing file data \"\n\t\t       \"on %s\\n\", journal->j_devname);\n\t\tif (journal->j_flags & JBD2_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjbd2_journal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\t/*\n\t * Get current oldest transaction in the log before we issue flush\n\t * to the filesystem device. After the flush we can be sure that\n\t * blocks of all older transactions are checkpointed to persistent\n\t * storage and we will be safe to update journal start in the\n\t * superblock with the numbers we get here.\n\t */\n\tupdate_tail =\n\t\tjbd2_journal_get_log_tail(journal, &first_tid, &first_block);\n\n\twrite_lock(&journal->j_state_lock);\n\tif (update_tail) {\n\t\tlong freed = first_block - journal->j_tail;\n\n\t\tif (first_block < journal->j_tail)\n\t\t\tfreed += journal->j_last - journal->j_first;\n\t\t/* Update tail only if we free significant amount of space */\n\t\tif (freed < journal->j_maxlen / 4)\n\t\t\tupdate_tail = 0;\n\t}\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_DFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\t/* \n\t * If the journal is not located on the file system device,\n\t * then we must flush the file system device before we issue\n\t * the commit record\n\t */\n\tif (commit_transaction->t_need_data_flush &&\n\t    (journal->j_fs_dev != journal->j_dev) &&\n\t    (journal->j_flags & JBD2_BARRIER))\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\n\n\t/* Done it all: now write the commit record asynchronously. */\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t &cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the io_bufs list.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD2: commit phase 3\\n\");\n\n\twhile (!list_empty(&io_bufs)) {\n\t\tstruct buffer_head *bh = list_entry(io_bufs.prev,\n\t\t\t\t\t\t    struct buffer_head,\n\t\t\t\t\t\t    b_assoc_buffers);\n\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\t\tjbd2_unfile_log_bh(bh);\n\n\t\t/*\n\t\t * The list contains temporary buffer heads created by\n\t\t * jbd2_journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to refile the corresponding shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\t\tJ_ASSERT_BH(bh, !buffer_shadow(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjbd2_journal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD2: commit phase 4\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n\twhile (!list_empty(&log_bufs)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjbd2_unfile_log_bh(bh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD2: commit phase 5\\n\");\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_DFLUSH);\n\tcommit_transaction->t_state = T_COMMIT_JFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t&cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\tif (cbh)\n\t\terr = journal_wait_on_commit_record(journal, cbh);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT) &&\n\t    journal->j_flags & JBD2_BARRIER) {\n\t\tblkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\t/*\n\t * Now disk caches for filesystem device are flushed so we are safe to\n\t * erase checkpointed transactions from the log by updating journal\n\t * superblock.\n\t */\n\tif (update_tail)\n\t\tjbd2_update_log_tail(journal, first_tid, first_block);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD2: commit phase 6\\n\");\n\n\tJ_ASSERT(list_empty(&commit_transaction->t_inode_list));\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t *\n\t\t * We also know that the frozen data has already fired\n\t\t * its triggers if they exist, so we can clear that too.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t\tjh->b_frozen_triggers = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t\tjh->b_frozen_triggers = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\tcp_transaction->t_chp_stats.cs_dropped++;\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by jbd2_journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t* A buffer which has been freed while still being journaled by\n\t\t* a previous transaction.\n\t\t*/\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather through in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__jbd2_journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile buffer\");\n\t\t__jbd2_journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\t/* Drops bh reference */\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __jbd2_journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Add the transaction to the checkpoint list\n\t * __journal_remove_checkpoint() can not destroy transaction\n\t * under us because it is not marked as T_FINISHED yet */\n\tif (journal->j_checkpoint_transactions == NULL) {\n\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t} else {\n\t\tcommit_transaction->t_cpnext =\n\t\t\tjournal->j_checkpoint_transactions;\n\t\tcommit_transaction->t_cpprev =\n\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\tcommit_transaction;\n\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD2: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_JFLUSH);\n\n\tcommit_transaction->t_start = jiffies;\n\tstats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,\n\t\t\t\t\t      commit_transaction->t_start);\n\n\t/*\n\t * File the transaction statistics\n\t */\n\tstats.ts_tid = commit_transaction->t_tid;\n\tstats.run.rs_handle_count =\n\t\tatomic_read(&commit_transaction->t_handle_count);\n\ttrace_jbd2_run_stats(journal->j_fs_dev->bd_dev,\n\t\t\t     commit_transaction->t_tid, &stats.run);\n\tstats.ts_requested = (commit_transaction->t_requested) ? 1 : 0;\n\n\tcommit_transaction->t_state = T_COMMIT_CALLBACK;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in the commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time +\n\t\t\t\tjournal->j_average_commit_time*3) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (journal->j_commit_callback)\n\t\tjournal->j_commit_callback(journal, commit_transaction);\n\n\ttrace_jbd2_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tcommit_transaction->t_state = T_FINISHED;\n\t/* Check if the transaction can be dropped now that we are finished */\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__jbd2_journal_drop_transaction(journal, commit_transaction);\n\t\tjbd2_journal_free_transaction(commit_transaction);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * Calculate overall stats\n\t */\n\tspin_lock(&journal->j_history_lock);\n\tjournal->j_stats.ts_tid++;\n\tjournal->j_stats.ts_requested += stats.ts_requested;\n\tjournal->j_stats.run.rs_wait += stats.run.rs_wait;\n\tjournal->j_stats.run.rs_request_delay += stats.run.rs_request_delay;\n\tjournal->j_stats.run.rs_running += stats.run.rs_running;\n\tjournal->j_stats.run.rs_locked += stats.run.rs_locked;\n\tjournal->j_stats.run.rs_flushing += stats.run.rs_flushing;\n\tjournal->j_stats.run.rs_logging += stats.run.rs_logging;\n\tjournal->j_stats.run.rs_handle_count += stats.run.rs_handle_count;\n\tjournal->j_stats.run.rs_blocks += stats.run.rs_blocks;\n\tjournal->j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;\n\tspin_unlock(&journal->j_history_lock);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_commit_transaction(journal_t *journal)\n{\n\tstruct transaction_stats_s stats;\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh;\n\tstruct buffer_head *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned long long blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tint tag_bytes = journal_tag_bytes(journal);\n\tstruct buffer_head *cbh = NULL; /* For transactional checksums */\n\t__u32 crc32_sum = ~0;\n\tstruct blk_plug plug;\n\t/* Tail of the journal */\n\tunsigned long first_block;\n\ttid_t first_tid;\n\tint update_tail;\n\tint csum_size = 0;\n\tLIST_HEAD(io_bufs);\n\tLIST_HEAD(log_bufs);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior jbd2_journal_flush? */\n\tif (journal->j_flags & JBD2_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd2_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd2_commit_locking(journal, commit_transaction);\n\tstats.run.rs_wait = commit_transaction->t_max_wait;\n\tstats.run.rs_request_delay = 0;\n\tstats.run.rs_locked = jiffies;\n\tif (commit_transaction->t_requested)\n\t\tstats.run.rs_request_delay =\n\t\t\tjbd2_time_diff(commit_transaction->t_requested,\n\t\t\t\t       stats.run.rs_locked);\n\tstats.run.rs_running = jbd2_time_diff(commit_transaction->t_start,\n\t\t\t\t\t      stats.run.rs_locked);\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a jbd2_journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple jbd2_journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A jbd2_journal_get_undo_access()+jbd2_journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjbd2_journal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjbd2_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjbd2_journal_switch_revoke_table(journal);\n\n\t/*\n\t * Reserved credits cannot be claimed anymore, free them\n\t */\n\tatomic_sub(atomic_read(&journal->j_reserved_credits),\n\t\t   &commit_transaction->t_outstanding_credits);\n\n\ttrace_jbd2_commit_flushing(journal, commit_transaction);\n\tstats.run.rs_flushing = jiffies;\n\tstats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,\n\t\t\t\t\t     stats.run.rs_flushing);\n\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\twrite_unlock(&journal->j_state_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 2a\\n\");\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\terr = journal_submit_data_buffers(journal, commit_transaction);\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tblk_start_plug(&plug);\n\tjbd2_journal_write_revoke_records(journal, commit_transaction,\n\t\t\t\t\t  &log_bufs, WRITE_SYNC);\n\n\tjbd_debug(3, \"JBD2: commit phase 2b\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\twrite_unlock(&journal->j_state_lock);\n\n\ttrace_jbd2_commit_logging(journal, commit_transaction);\n\tstats.run.rs_logging = jiffies;\n\tstats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,\n\t\t\t\t\t       stats.run.rs_logging);\n\tstats.run.rs_blocks =\n\t\tatomic_read(&commit_transaction->t_outstanding_credits);\n\tstats.run.rs_blocks_logged = 0;\n\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t atomic_read(&commit_transaction->t_outstanding_credits));\n\n\terr = 0;\n\tbufs = 0;\n\tdescriptor = NULL;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjbd2_buffer_abort_trigger(jh,\n\t\t\t\t\t\t  jh->b_frozen_data ?\n\t\t\t\t\t\t  jh->b_frozen_triggers :\n\t\t\t\t\t\t  jh->b_triggers);\n\t\t\tjbd2_journal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD2: get descriptor\\n\");\n\n\t\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjbd2_journal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tjbd_debug(4, \"JBD2: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)descriptor->b_blocknr,\n\t\t\t\tdescriptor->b_data);\n\t\t\theader = (journal_header_t *)descriptor->b_data;\n\t\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JBD2_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &descriptor->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = descriptor->b_size -\n\t\t\t\t\t\tsizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(descriptor);\n\t\t\tset_buffer_dirty(descriptor);\n\t\t\twbuf[bufs++] = descriptor;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(descriptor, \"ph3: file as descriptor\");\n\t\t\tjbd2_file_log_bh(&log_bufs, descriptor);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjbd2_journal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by jbd2_journal_next_log_block() also.\n\t\t */\n\t\tatomic_dec(&commit_transaction->t_outstanding_credits);\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the shadow pairing of buffers. */\n\t\tatomic_inc(&jh2bh(jh)->b_count);\n\n\t\t/*\n\t\t * Make a temporary IO buffer with which to write it out\n\t\t * (this will requeue the metadata buffer to BJ_Shadow).\n\t\t */\n\t\tset_bit(BH_JWrite, &jh2bh(jh)->b_state);\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = jbd2_journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\tjh, &wbuf[bufs], blocknr);\n\t\tif (flags < 0) {\n\t\t\tjbd2_journal_abort(journal, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tjbd2_file_log_bh(&io_bufs, wbuf[bufs]);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JBD2_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JBD2_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\twrite_tag_block(journal, tag, jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be16(tag_flag);\n\t\tjbd2_block_tag_csum_set(journal, tag, wbuf[bufs],\n\t\t\t\t\tcommit_transaction->t_tid);\n\t\ttagp += tag_bytes;\n\t\tspace_left -= tag_bytes;\n\t\tbufs++;\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < tag_bytes + 16 + csum_size) {\n\n\t\t\tjbd_debug(4, \"JBD2: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be16(JBD2_FLAG_LAST_TAG);\n\n\t\t\tjbd2_descr_block_csum_set(journal, descriptor);\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\t/*\n\t\t\t\t * Compute checksum.\n\t\t\t\t */\n\t\t\t\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\t\tcrc32_sum =\n\t\t\t\t\t    jbd2_checksum_data(crc32_sum, bh);\n\t\t\t\t}\n\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\tsubmit_bh(WRITE_SYNC, bh);\n\t\t\t}\n\t\t\tcond_resched();\n\t\t\tstats.run.rs_blocks_logged += bufs;\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\terr = journal_finish_inode_data_buffers(journal, commit_transaction);\n\tif (err) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Detected IO errors while flushing file data \"\n\t\t       \"on %s\\n\", journal->j_devname);\n\t\tif (journal->j_flags & JBD2_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjbd2_journal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\t/*\n\t * Get current oldest transaction in the log before we issue flush\n\t * to the filesystem device. After the flush we can be sure that\n\t * blocks of all older transactions are checkpointed to persistent\n\t * storage and we will be safe to update journal start in the\n\t * superblock with the numbers we get here.\n\t */\n\tupdate_tail =\n\t\tjbd2_journal_get_log_tail(journal, &first_tid, &first_block);\n\n\twrite_lock(&journal->j_state_lock);\n\tif (update_tail) {\n\t\tlong freed = first_block - journal->j_tail;\n\n\t\tif (first_block < journal->j_tail)\n\t\t\tfreed += journal->j_last - journal->j_first;\n\t\t/* Update tail only if we free significant amount of space */\n\t\tif (freed < journal->j_maxlen / 4)\n\t\t\tupdate_tail = 0;\n\t}\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_DFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\t/* \n\t * If the journal is not located on the file system device,\n\t * then we must flush the file system device before we issue\n\t * the commit record\n\t */\n\tif (commit_transaction->t_need_data_flush &&\n\t    (journal->j_fs_dev != journal->j_dev) &&\n\t    (journal->j_flags & JBD2_BARRIER))\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\n\n\t/* Done it all: now write the commit record asynchronously. */\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t &cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the io_bufs list.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD2: commit phase 3\\n\");\n\n\twhile (!list_empty(&io_bufs)) {\n\t\tstruct buffer_head *bh = list_entry(io_bufs.prev,\n\t\t\t\t\t\t    struct buffer_head,\n\t\t\t\t\t\t    b_assoc_buffers);\n\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\t\tjbd2_unfile_log_bh(bh);\n\n\t\t/*\n\t\t * The list contains temporary buffer heads created by\n\t\t * jbd2_journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to refile the corresponding shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\t\tJ_ASSERT_BH(bh, !buffer_shadow(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjbd2_journal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD2: commit phase 4\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n\twhile (!list_empty(&log_bufs)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjbd2_unfile_log_bh(bh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD2: commit phase 5\\n\");\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_DFLUSH);\n\tcommit_transaction->t_state = T_COMMIT_JFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t&cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\tif (cbh)\n\t\terr = journal_wait_on_commit_record(journal, cbh);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT) &&\n\t    journal->j_flags & JBD2_BARRIER) {\n\t\tblkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\t/*\n\t * Now disk caches for filesystem device are flushed so we are safe to\n\t * erase checkpointed transactions from the log by updating journal\n\t * superblock.\n\t */\n\tif (update_tail)\n\t\tjbd2_update_log_tail(journal, first_tid, first_block);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD2: commit phase 6\\n\");\n\n\tJ_ASSERT(list_empty(&commit_transaction->t_inode_list));\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t *\n\t\t * We also know that the frozen data has already fired\n\t\t * its triggers if they exist, so we can clear that too.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t\tjh->b_frozen_triggers = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t\tjh->b_frozen_triggers = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\tcp_transaction->t_chp_stats.cs_dropped++;\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by jbd2_journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t* A buffer which has been freed while still being journaled by\n\t\t* a previous transaction.\n\t\t*/\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather through in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__jbd2_journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile buffer\");\n\t\t__jbd2_journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\t/* Drops bh reference */\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __jbd2_journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Add the transaction to the checkpoint list\n\t * __journal_remove_checkpoint() can not destroy transaction\n\t * under us because it is not marked as T_FINISHED yet */\n\tif (journal->j_checkpoint_transactions == NULL) {\n\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t} else {\n\t\tcommit_transaction->t_cpnext =\n\t\t\tjournal->j_checkpoint_transactions;\n\t\tcommit_transaction->t_cpprev =\n\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\tcommit_transaction;\n\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD2: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_JFLUSH);\n\n\tcommit_transaction->t_start = jiffies;\n\tstats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,\n\t\t\t\t\t      commit_transaction->t_start);\n\n\t/*\n\t * File the transaction statistics\n\t */\n\tstats.ts_tid = commit_transaction->t_tid;\n\tstats.run.rs_handle_count =\n\t\tatomic_read(&commit_transaction->t_handle_count);\n\ttrace_jbd2_run_stats(journal->j_fs_dev->bd_dev,\n\t\t\t     commit_transaction->t_tid, &stats.run);\n\tstats.ts_requested = (commit_transaction->t_requested) ? 1 : 0;\n\n\tcommit_transaction->t_state = T_COMMIT_CALLBACK;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in the commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time +\n\t\t\t\tjournal->j_average_commit_time*3) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (journal->j_commit_callback)\n\t\tjournal->j_commit_callback(journal, commit_transaction);\n\n\ttrace_jbd2_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tcommit_transaction->t_state = T_FINISHED;\n\t/* Check if the transaction can be dropped now that we are finished */\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__jbd2_journal_drop_transaction(journal, commit_transaction);\n\t\tjbd2_journal_free_transaction(commit_transaction);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * Calculate overall stats\n\t */\n\tspin_lock(&journal->j_history_lock);\n\tjournal->j_stats.ts_tid++;\n\tjournal->j_stats.ts_requested += stats.ts_requested;\n\tjournal->j_stats.run.rs_wait += stats.run.rs_wait;\n\tjournal->j_stats.run.rs_request_delay += stats.run.rs_request_delay;\n\tjournal->j_stats.run.rs_running += stats.run.rs_running;\n\tjournal->j_stats.run.rs_locked += stats.run.rs_locked;\n\tjournal->j_stats.run.rs_flushing += stats.run.rs_flushing;\n\tjournal->j_stats.run.rs_logging += stats.run.rs_logging;\n\tjournal->j_stats.run.rs_handle_count += stats.run.rs_handle_count;\n\tjournal->j_stats.run.rs_blocks += stats.run.rs_blocks;\n\tjournal->j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;\n\tspin_unlock(&journal->j_history_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_kill_thread",
          "args": [
            "journal"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "journal_kill_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "299-311",
          "snippet": "static void journal_kill_thread(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit, journal->j_task == NULL);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_kill_thread(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit, journal->j_task == NULL);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_destroy(journal_t *journal)\n{\n\tint err = 0;\n\n\t/* Wait for the commit thread to wake up and die. */\n\tjournal_kill_thread(journal);\n\n\t/* Force a final log commit */\n\tif (journal->j_running_transaction)\n\t\tjbd2_journal_commit_transaction(journal);\n\n\t/* Force any old transactions to disk */\n\n\t/* Totally anal locking here... */\n\tspin_lock(&journal->j_list_lock);\n\twhile (journal->j_checkpoint_transactions != NULL) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\tjbd2_log_do_checkpoint(journal);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\tspin_lock(&journal->j_list_lock);\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction == NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\tJ_ASSERT(journal->j_checkpoint_transactions == NULL);\n\tspin_unlock(&journal->j_list_lock);\n\n\tif (journal->j_sb_buffer) {\n\t\tif (!is_journal_aborted(journal)) {\n\t\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t\tjbd2_mark_journal_empty(journal);\n\t\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t\t} else\n\t\t\terr = -EIO;\n\t\tbrelse(journal->j_sb_buffer);\n\t}\n\n\tif (journal->j_proc_entry)\n\t\tjbd2_stats_proc_exit(journal);\n\tiput(journal->j_inode);\n\tif (journal->j_revoke)\n\t\tjbd2_journal_destroy_revoke(journal);\n\tif (journal->j_chksum_driver)\n\t\tcrypto_free_shash(journal->j_chksum_driver);\n\tkfree(journal->j_wbuf);\n\tkfree(journal);\n\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_journal_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1611-1667",
    "snippet": "int jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"JBD2: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Create a slab for this blocksize\n\t */\n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (jbd2_journal_recover(journal))\n\t\tgoto recovery_error;\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EIO;\n\t}\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JBD2_ABORT;\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk(KERN_WARNING \"JBD2: recovery failed\\n\");\n\treturn -EIO;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"JBD2: recovery failed\\n\""
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_reset",
          "args": [
            "journal"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "journal_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1277-1332",
          "snippet": "static int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned long long first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JBD2_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD2: Journal too short (blocks %llu-%llu).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JBD2_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1, \"JBD2: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %ld, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JBD2_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn jbd2_journal_start_thread(journal);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned long long first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JBD2_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD2: Journal too short (blocks %llu-%llu).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JBD2_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1, \"JBD2: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %ld, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JBD2_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn jbd2_journal_start_thread(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_recover",
          "args": [
            "journal"
          ],
          "line": 1644
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/recovery.c",
          "lines": "248-298",
          "snippet": "int jbd2_journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t/*\n\t * The journal superblock's s_start field (the current log head)\n\t * is always zero if, and only if, the journal was cleanly\n\t * unmounted.\n\t */\n\n\tif (!sb->s_start) {\n\t\tjbd_debug(1, \"No recovery required, last transaction %d\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\treturn 0;\n\t}\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd_debug(1, \"JBD2: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd_debug(1, \"JBD2: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t/* Restart the log at the next transaction ID, thus invalidating\n\t * any existing commit records in the log. */\n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\n\tjbd2_journal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\t/* Make sure all replayed data is on permanent storage */\n\tif (journal->j_flags & JBD2_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/crc32.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nint jbd2_journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t/*\n\t * The journal superblock's s_start field (the current log head)\n\t * is always zero if, and only if, the journal was cleanly\n\t * unmounted.\n\t */\n\n\tif (!sb->s_start) {\n\t\tjbd_debug(1, \"No recovery required, last transaction %d\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\treturn 0;\n\t}\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd_debug(1, \"JBD2: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd_debug(1, \"JBD2: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t/* Restart the log at the next transaction ID, thus invalidating\n\t * any existing commit records in the log. */\n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\n\tjbd2_journal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\t/* Make sure all replayed data is on permanent storage */\n\tif (journal->j_flags & JBD2_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_create_slab",
          "args": [
            "be32_to_cpu(sb->s_blocksize)"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_create_slab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2231-2260",
          "snippet": "static int jbd2_journal_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(jbd2_slab_create_mutex);\n\tint i = order_base_2(size) - 10;\n\tsize_t slab_size;\n\n\tif (size == PAGE_SIZE)\n\t\treturn 0;\n\n\tif (i >= JBD2_MAX_SLABS)\n\t\treturn -EINVAL;\n\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tmutex_lock(&jbd2_slab_create_mutex);\n\tif (jbd2_slab[i]) {\n\t\tmutex_unlock(&jbd2_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = 1 << (i+10);\n\tjbd2_slab[i] = kmem_cache_create(jbd2_slab_names[i], slab_size,\n\t\t\t\t\t slab_size, 0, NULL);\n\tmutex_unlock(&jbd2_slab_create_mutex);\n\tif (!jbd2_slab[i]) {\n\t\tprintk(KERN_EMERG \"JBD2: no memory for jbd2_slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define JBD2_MAX_SLABS 8"
          ],
          "globals_used": [
            "static int jbd2_journal_create_slab(size_t slab_size);",
            "static struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];",
            "static const char *jbd2_slab_names[JBD2_MAX_SLABS] = {\n\t\"jbd2_1k\", \"jbd2_2k\", \"jbd2_4k\", \"jbd2_8k\",\n\t\"jbd2_16k\", \"jbd2_32k\", \"jbd2_64k\", \"jbd2_128k\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\n#define JBD2_MAX_SLABS 8\n\nstatic int jbd2_journal_create_slab(size_t slab_size);\nstatic struct kmem_cache *jbd2_slab[JBD2_MAX_SLABS];\nstatic const char *jbd2_slab_names[JBD2_MAX_SLABS] = {\n\t\"jbd2_1k\", \"jbd2_2k\", \"jbd2_4k\", \"jbd2_8k\",\n\t\"jbd2_16k\", \"jbd2_32k\", \"jbd2_64k\", \"jbd2_128k\"\n};\n\nstatic int jbd2_journal_create_slab(size_t size)\n{\n\tstatic DEFINE_MUTEX(jbd2_slab_create_mutex);\n\tint i = order_base_2(size) - 10;\n\tsize_t slab_size;\n\n\tif (size == PAGE_SIZE)\n\t\treturn 0;\n\n\tif (i >= JBD2_MAX_SLABS)\n\t\treturn -EINVAL;\n\n\tif (unlikely(i < 0))\n\t\ti = 0;\n\tmutex_lock(&jbd2_slab_create_mutex);\n\tif (jbd2_slab[i]) {\n\t\tmutex_unlock(&jbd2_slab_create_mutex);\n\t\treturn 0;\t/* Already created */\n\t}\n\n\tslab_size = 1 << (i+10);\n\tjbd2_slab[i] = kmem_cache_create(jbd2_slab_names[i], slab_size,\n\t\t\t\t\t slab_size, 0, NULL);\n\tmutex_unlock(&jbd2_slab_create_mutex);\n\tif (!jbd2_slab[i]) {\n\t\tprintk(KERN_EMERG \"JBD2: no memory for jbd2_slab cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_blocksize"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_KNOWN_INCOMPAT_FEATURES"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_KNOWN_ROCOMPAT_FEATURES"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_superblock",
          "args": [
            "journal"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "load_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1582-1600",
          "snippet": "static int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_load(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = load_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\t/* If this is a V2 superblock, then we have to check the\n\t * features flags on it. */\n\n\tif (journal->j_format_version >= 2) {\n\t\tif ((sb->s_feature_ro_compat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_ROCOMPAT_FEATURES)) ||\n\t\t    (sb->s_feature_incompat &\n\t\t     ~cpu_to_be32(JBD2_KNOWN_INCOMPAT_FEATURES))) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"JBD2: Unrecognised features on journal\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t/*\n\t * Create a slab for this blocksize\n\t */\n\terr = jbd2_journal_create_slab(be32_to_cpu(sb->s_blocksize));\n\tif (err)\n\t\treturn err;\n\n\t/* Let the recovery code check whether it needs to recover any\n\t * data from the journal. */\n\tif (jbd2_journal_recover(journal))\n\t\tgoto recovery_error;\n\n\tif (journal->j_failed_commit) {\n\t\tprintk(KERN_ERR \"JBD2: journal transaction %u on %s \"\n\t\t       \"is corrupt.\\n\", journal->j_failed_commit,\n\t\t       journal->j_devname);\n\t\treturn -EIO;\n\t}\n\n\t/* OK, we've finished with the dynamic journal bits:\n\t * reinitialise the dynamic contents of the superblock in memory\n\t * and reset them on disk. */\n\tif (journal_reset(journal))\n\t\tgoto recovery_error;\n\n\tjournal->j_flags &= ~JBD2_ABORT;\n\tjournal->j_flags |= JBD2_LOADED;\n\treturn 0;\n\nrecovery_error:\n\tprintk(KERN_WARNING \"JBD2: recovery failed\\n\");\n\treturn -EIO;\n}"
  },
  {
    "function_name": "load_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1582-1600",
    "snippet": "static int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_errno"
          ],
          "line": 1597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_start"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_sequence"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_get_superblock",
          "args": [
            "journal"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "journal_get_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1466-1575",
          "snippet": "static int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"JBD2: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD2: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JBD2_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JBD2_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD2: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk(KERN_WARNING \"JBD2: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2) &&\n\t    JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\t/* Can't have checksum v2 and v3 at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v2 and v3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_has_csum_v2or3(journal) &&\n\t    JBD2_HAS_COMPAT_FEATURE(journal, JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t/* Can't have checksum v1 and v2 on at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v1 and v2/3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!jbd2_verify_csum_type(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: Unknown checksum type\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Load the checksum driver */\n\tif (jbd2_journal_has_csum_v2or3(journal)) {\n\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c driver.\\n\");\n\t\t\terr = PTR_ERR(journal->j_chksum_driver);\n\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!jbd2_superblock_csum_verify(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: journal checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0, sb->s_uuid,\n\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\n\tset_buffer_verified(bh);\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"JBD2: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD2: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JBD2_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JBD2_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD2: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk(KERN_WARNING \"JBD2: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2) &&\n\t    JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\t/* Can't have checksum v2 and v3 at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v2 and v3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_has_csum_v2or3(journal) &&\n\t    JBD2_HAS_COMPAT_FEATURE(journal, JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t/* Can't have checksum v1 and v2 on at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v1 and v2/3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!jbd2_verify_csum_type(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: Unknown checksum type\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Load the checksum driver */\n\tif (jbd2_journal_has_csum_v2or3(journal)) {\n\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c driver.\\n\");\n\t\t\terr = PTR_ERR(journal->j_chksum_driver);\n\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!jbd2_superblock_csum_verify(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: journal checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0, sb->s_uuid,\n\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\n\tset_buffer_verified(bh);\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int load_superblock(journal_t *journal)\n{\n\tint err;\n\tjournal_superblock_t *sb;\n\n\terr = journal_get_superblock(journal);\n\tif (err)\n\t\treturn err;\n\n\tsb = journal->j_superblock;\n\n\tjournal->j_tail_sequence = be32_to_cpu(sb->s_sequence);\n\tjournal->j_tail = be32_to_cpu(sb->s_start);\n\tjournal->j_first = be32_to_cpu(sb->s_first);\n\tjournal->j_last = be32_to_cpu(sb->s_maxlen);\n\tjournal->j_errno = be32_to_cpu(sb->s_errno);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "journal_get_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1466-1575",
    "snippet": "static int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"JBD2: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD2: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JBD2_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JBD2_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD2: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk(KERN_WARNING \"JBD2: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2) &&\n\t    JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\t/* Can't have checksum v2 and v3 at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v2 and v3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_has_csum_v2or3(journal) &&\n\t    JBD2_HAS_COMPAT_FEATURE(journal, JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t/* Can't have checksum v1 and v2 on at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v1 and v2/3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!jbd2_verify_csum_type(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: Unknown checksum type\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Load the checksum driver */\n\tif (jbd2_journal_has_csum_v2or3(journal)) {\n\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c driver.\\n\");\n\t\t\terr = PTR_ERR(journal->j_chksum_driver);\n\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!jbd2_superblock_csum_verify(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: journal checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0, sb->s_uuid,\n\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\n\tset_buffer_verified(bh);\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_fail_superblock",
          "args": [
            "journal"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "journal_fail_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1263-1268",
          "snippet": "static void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_verified",
          "args": [
            "bh"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "journal",
            "~0",
            "sb->s_uuid",
            "sizeof(sb->s_uuid)"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "journal"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: journal checksum error\\n\""
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_superblock_csum_verify",
          "args": [
            "journal",
            "sb"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_superblock_csum_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "146-152",
          "snippet": "static int jbd2_superblock_csum_verify(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\treturn sb->s_checksum == jbd2_superblock_csum(j, sb);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int jbd2_superblock_csum_verify(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\treturn sb->s_checksum == jbd2_superblock_csum(j, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "journal->j_chksum_driver"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "journal->j_chksum_driver"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "\"crc32c\"",
            "0",
            "0"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "journal"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_verify_csum_type",
          "args": [
            "journal",
            "sb"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_verify_csum_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "125-131",
          "snippet": "static int jbd2_verify_csum_type(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\treturn sb->s_checksum_type == JBD2_CRC32C_CHKSUM;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int jbd2_verify_csum_type(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\treturn sb->s_checksum_type == JBD2_CRC32C_CHKSUM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_COMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_COMPAT_CHECKSUM"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "journal"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_CSUM_V3"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JBD2_HAS_INCOMPAT_FEATURE",
          "args": [
            "journal",
            "JBD2_FEATURE_INCOMPAT_CSUM_V2"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_header.h_blocktype"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "journal->j_blocksize"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_MAGIC_NUMBER"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_verified",
          "args": [
            "bh"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "bh != NULL"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int journal_get_superblock(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tjournal_superblock_t *sb;\n\tint err = -EIO;\n\n\tbh = journal->j_sb_buffer;\n\n\tJ_ASSERT(bh != NULL);\n\tif (!buffer_uptodate(bh)) {\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"JBD2: IO error reading journal superblock\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (buffer_verified(bh))\n\t\treturn 0;\n\n\tsb = journal->j_superblock;\n\n\terr = -EINVAL;\n\n\tif (sb->s_header.h_magic != cpu_to_be32(JBD2_MAGIC_NUMBER) ||\n\t    sb->s_blocksize != cpu_to_be32(journal->j_blocksize)) {\n\t\tprintk(KERN_WARNING \"JBD2: no valid journal superblock found\\n\");\n\t\tgoto out;\n\t}\n\n\tswitch(be32_to_cpu(sb->s_header.h_blocktype)) {\n\tcase JBD2_SUPERBLOCK_V1:\n\t\tjournal->j_format_version = 1;\n\t\tbreak;\n\tcase JBD2_SUPERBLOCK_V2:\n\t\tjournal->j_format_version = 2;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"JBD2: unrecognised superblock format ID\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_maxlen) < journal->j_maxlen)\n\t\tjournal->j_maxlen = be32_to_cpu(sb->s_maxlen);\n\telse if (be32_to_cpu(sb->s_maxlen) > journal->j_maxlen) {\n\t\tprintk(KERN_WARNING \"JBD2: journal file too short\\n\");\n\t\tgoto out;\n\t}\n\n\tif (be32_to_cpu(sb->s_first) == 0 ||\n\t    be32_to_cpu(sb->s_first) >= journal->j_maxlen) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Invalid start block of journal: %u\\n\",\n\t\t\tbe32_to_cpu(sb->s_first));\n\t\tgoto out;\n\t}\n\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V2) &&\n\t    JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_CSUM_V3)) {\n\t\t/* Can't have checksum v2 and v3 at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v2 and v3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (jbd2_journal_has_csum_v2or3(journal) &&\n\t    JBD2_HAS_COMPAT_FEATURE(journal, JBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t/* Can't have checksum v1 and v2 on at the same time! */\n\t\tprintk(KERN_ERR \"JBD2: Can't enable checksumming v1 and v2/3 \"\n\t\t       \"at the same time!\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!jbd2_verify_csum_type(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: Unknown checksum type\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Load the checksum driver */\n\tif (jbd2_journal_has_csum_v2or3(journal)) {\n\t\tjournal->j_chksum_driver = crypto_alloc_shash(\"crc32c\", 0, 0);\n\t\tif (IS_ERR(journal->j_chksum_driver)) {\n\t\t\tprintk(KERN_ERR \"JBD2: Cannot load crc32c driver.\\n\");\n\t\t\terr = PTR_ERR(journal->j_chksum_driver);\n\t\t\tjournal->j_chksum_driver = NULL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Check superblock checksum */\n\tif (!jbd2_superblock_csum_verify(journal, sb)) {\n\t\tprintk(KERN_ERR \"JBD2: journal checksum error\\n\");\n\t\tgoto out;\n\t}\n\n\t/* Precompute checksum seed for all metadata */\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tjournal->j_csum_seed = jbd2_chksum(journal, ~0, sb->s_uuid,\n\t\t\t\t\t\t   sizeof(sb->s_uuid));\n\n\tset_buffer_verified(bh);\n\n\treturn 0;\n\nout:\n\tjournal_fail_superblock(journal);\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_journal_update_sb_errno",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1448-1459",
    "snippet": "void jbd2_journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tread_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD2: updating superblock error (errno %d)\\n\",\n\t\t  journal->j_errno);\n\tsb->s_errno    = cpu_to_be32(journal->j_errno);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_SYNC);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_abort_soft (journal_t *journal, int errno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_write_superblock",
          "args": [
            "journal",
            "WRITE_SYNC"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_write_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1334-1374",
          "snippet": "static void jbd2_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\ttrace_jbd2_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tjbd2_superblock_csum_set(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\", ret,\n\t\t       journal->j_devname);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\ttrace_jbd2_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tjbd2_superblock_csum_set(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\", ret,\n\t\t       journal->j_devname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "journal->j_errno"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: updating superblock error (errno %d)\\n\"",
            "journal->j_errno"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1452
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nvoid jbd2_journal_update_sb_errno(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tread_lock(&journal->j_state_lock);\n\tjbd_debug(1, \"JBD2: updating superblock error (errno %d)\\n\",\n\t\t  journal->j_errno);\n\tsb->s_errno    = cpu_to_be32(journal->j_errno);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_SYNC);\n}"
  },
  {
    "function_name": "jbd2_mark_journal_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1414-1438",
    "snippet": "static void jbd2_mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tread_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD2: Marking journal as empty (seq %d)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_FUA);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_write_superblock",
          "args": [
            "journal",
            "WRITE_FUA"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_write_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1334-1374",
          "snippet": "static void jbd2_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\ttrace_jbd2_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tjbd2_superblock_csum_set(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\", ret,\n\t\t       journal->j_devname);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\ttrace_jbd2_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tjbd2_superblock_csum_set(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\", ret,\n\t\t       journal->j_devname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "0"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "journal->j_tail_sequence"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: Marking journal as empty (seq %d)\\n\"",
            "journal->j_tail_sequence"
          ],
          "line": 1425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&journal->j_checkpoint_mutex)"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_mark_journal_empty(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tread_lock(&journal->j_state_lock);\n\t/* Is it already empty? */\n\tif (sb->s_start == 0) {\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn;\n\t}\n\tjbd_debug(1, \"JBD2: Marking journal as empty (seq %d)\\n\",\n\t\t  journal->j_tail_sequence);\n\n\tsb->s_sequence = cpu_to_be32(journal->j_tail_sequence);\n\tsb->s_start    = cpu_to_be32(0);\n\tread_unlock(&journal->j_state_lock);\n\n\tjbd2_write_superblock(journal, WRITE_FUA);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "jbd2_journal_update_sb_log_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1386-1405",
    "snippet": "void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t     unsigned long tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjbd2_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sb->s_sequence"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_write_superblock",
          "args": [
            "journal",
            "write_op"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_write_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1334-1374",
          "snippet": "static void jbd2_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\ttrace_jbd2_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tjbd2_superblock_csum_set(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\", ret,\n\t\t       journal->j_devname);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\ttrace_jbd2_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tjbd2_superblock_csum_set(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\", ret,\n\t\t       journal->j_devname);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tail_block"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "tail_tid"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: updating superblock (start %lu, seq %u)\\n\"",
            "tail_block",
            "tail_tid"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&journal->j_checkpoint_mutex)"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t     unsigned long tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjbd2_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "jbd2_write_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1334-1374",
    "snippet": "static void jbd2_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\ttrace_jbd2_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tjbd2_superblock_csum_set(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\", ret,\n\t\t       journal->j_devname);\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\"",
            "ret",
            "journal->j_devname"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "submit_bh",
          "args": [
            "write_op",
            "bh"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "submit_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3055-3058",
          "snippet": "int submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint submit_bh(int rw, struct buffer_head *bh)\n{\n\treturn _submit_bh(rw, bh, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "bh"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_superblock_csum_set",
          "args": [
            "journal",
            "sb"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_superblock_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "154-160",
          "snippet": "static void jbd2_superblock_csum_set(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tsb->s_checksum = jbd2_superblock_csum(j, sb);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_superblock_csum_set(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tsb->s_checksum = jbd2_superblock_csum(j, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_write_io_error",
          "args": [
            "bh"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_buffer",
          "args": [
            "bh"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_jbd2_write_superblock",
          "args": [
            "journal",
            "write_op"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_write_superblock(journal_t *journal, int write_op)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tint ret;\n\n\ttrace_jbd2_write_superblock(journal, write_op);\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\twrite_op &= ~(REQ_FUA | REQ_FLUSH);\n\tlock_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\t/*\n\t\t * Oh, dear.  A previous attempt to write the journal\n\t\t * superblock failed.  This could happen because the\n\t\t * USB device was yanked out.  Or it could happen to\n\t\t * be a transient write error and maybe the block will\n\t\t * be remapped.  Nothing we can do but to retry the\n\t\t * write and hope for the best.\n\t\t */\n\t\tprintk(KERN_ERR \"JBD2: previous I/O error detected \"\n\t\t       \"for journal superblock update for %s.\\n\",\n\t\t       journal->j_devname);\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t}\n\tjbd2_superblock_csum_set(journal, sb);\n\tget_bh(bh);\n\tbh->b_end_io = end_buffer_write_sync;\n\tret = submit_bh(write_op, bh);\n\twait_on_buffer(bh);\n\tif (buffer_write_io_error(bh)) {\n\t\tclear_buffer_write_io_error(bh);\n\t\tset_buffer_uptodate(bh);\n\t\tret = -EIO;\n\t}\n\tif (ret) {\n\t\tprintk(KERN_ERR \"JBD2: Error %d detected when updating \"\n\t\t       \"journal superblock for %s.\\n\", ret,\n\t\t       journal->j_devname);\n\t}\n}"
  },
  {
    "function_name": "journal_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1277-1332",
    "snippet": "static int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned long long first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JBD2_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD2: Journal too short (blocks %llu-%llu).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JBD2_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1, \"JBD2: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %ld, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JBD2_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn jbd2_journal_start_thread(journal);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void __journal_abort_soft (journal_t *journal, int errno);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_start_thread",
          "args": [
            "journal"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_start_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "286-297",
          "snippet": "static int jbd2_journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald2, journal, \"jbd2/%s\",\n\t\t\tjournal->j_devname);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int jbd2_journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald2, journal, \"jbd2/%s\",\n\t\t\tjournal->j_devname);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_update_sb_log_tail",
          "args": [
            "journal",
            "journal->j_tail_sequence",
            "journal->j_tail",
            "WRITE_FUA"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_update_sb_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1386-1405",
          "snippet": "void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t     unsigned long tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjbd2_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t     unsigned long tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjbd2_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %ld, seq %d, errno %d)\\n\"",
            "journal->j_tail",
            "journal->j_tail_sequence",
            "journal->j_errno"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_fail_superblock",
          "args": [
            "journal"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "journal_fail_superblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1263-1268",
          "snippet": "static void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD2: Journal too short (blocks %llu-%llu).\\n\"",
            "first",
            "last"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_maxlen"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_first"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic int journal_reset(journal_t *journal)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\tunsigned long long first, last;\n\n\tfirst = be32_to_cpu(sb->s_first);\n\tlast = be32_to_cpu(sb->s_maxlen);\n\tif (first + JBD2_MIN_JOURNAL_BLOCKS > last + 1) {\n\t\tprintk(KERN_ERR \"JBD2: Journal too short (blocks %llu-%llu).\\n\",\n\t\t       first, last);\n\t\tjournal_fail_superblock(journal);\n\t\treturn -EINVAL;\n\t}\n\n\tjournal->j_first = first;\n\tjournal->j_last = last;\n\n\tjournal->j_head = first;\n\tjournal->j_tail = first;\n\tjournal->j_free = last - first;\n\n\tjournal->j_tail_sequence = journal->j_transaction_sequence;\n\tjournal->j_commit_sequence = journal->j_transaction_sequence - 1;\n\tjournal->j_commit_request = journal->j_commit_sequence;\n\n\tjournal->j_max_transaction_buffers = journal->j_maxlen / 4;\n\n\t/*\n\t * As a special case, if the on-disk copy is already marked as needing\n\t * no recovery (s_start == 0), then we can safely defer the superblock\n\t * update until the next commit by setting JBD2_FLUSHED.  This avoids\n\t * attempting a write to a potential-readonly device.\n\t */\n\tif (sb->s_start == 0) {\n\t\tjbd_debug(1, \"JBD2: Skipping superblock update on recovered sb \"\n\t\t\t\"(start %ld, seq %d, errno %d)\\n\",\n\t\t\tjournal->j_tail, journal->j_tail_sequence,\n\t\t\tjournal->j_errno);\n\t\tjournal->j_flags |= JBD2_FLUSHED;\n\t} else {\n\t\t/* Lock here to make assertions happy... */\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * Update log tail information. We use WRITE_FUA since new\n\t\t * transaction will start reusing journal space and so we\n\t\t * must make sure information about current log tail is on\n\t\t * disk before that.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_FUA);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t}\n\treturn jbd2_journal_start_thread(journal);\n}"
  },
  {
    "function_name": "journal_fail_superblock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1263-1268",
    "snippet": "static void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_fail_superblock (journal_t *journal)\n{\n\tstruct buffer_head *bh = journal->j_sb_buffer;\n\tbrelse(bh);\n\tjournal->j_sb_buffer = NULL;\n}"
  },
  {
    "function_name": "jbd2_journal_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1192-1256",
    "snippet": "journal_t * jbd2_journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tchar *p;\n\tint err;\n\tint n;\n\tunsigned long long blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tp = journal->j_devname + strlen(journal->j_devname);\n\tsprintf(p, \"-%lu\", journal->j_inode->i_ino);\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\tjbd2_stats_proc_init(journal);\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = jbd2_journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_stats_proc_exit",
          "args": [
            "journal"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_stats_proc_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1056-1060",
          "snippet": "static void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct proc_dir_entry *proc_jbd2_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal->j_wbuf"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\"",
            "__func__"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getblk_unmovable",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_bmap",
          "args": [
            "journal",
            "0",
            "&blocknr"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "784-805",
          "snippet": "int jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "n * sizeof(struct buffer_head*)",
            "GFP_KERNEL"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_stats_proc_init",
          "args": [
            "journal"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_stats_proc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1047-1054",
          "snippet": "static void jbd2_stats_proc_init(journal_t *journal)\n{\n\tjournal->j_proc_entry = proc_mkdir(journal->j_devname, proc_jbd2_stats);\n\tif (journal->j_proc_entry) {\n\t\tproc_create_data(\"info\", S_IRUGO, journal->j_proc_entry,\n\t\t\t\t &jbd2_seq_info_fops, journal);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations jbd2_seq_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = jbd2_seq_info_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = jbd2_seq_info_release,\n};",
            "static struct proc_dir_entry *proc_jbd2_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const struct file_operations jbd2_seq_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = jbd2_seq_info_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = jbd2_seq_info_release,\n};\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void jbd2_stats_proc_init(journal_t *journal)\n{\n\tjournal->j_proc_entry = proc_mkdir(journal->j_devname, proc_jbd2_stats);\n\tif (journal->j_proc_entry) {\n\t\tproc_create_data(\"info\", S_IRUGO, journal->j_proc_entry,\n\t\t\t\t &jbd2_seq_info_fops, journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\"",
            "journal",
            "inode->i_sb->s_id",
            "inode->i_ino",
            "(long long) inode->i_size",
            "inode->i_sb->s_blocksize_bits",
            "inode->i_sb->s_blocksize"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "p",
            "\"-%lu\"",
            "journal->j_inode->i_ino"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "journal->j_devname"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'/'"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "journal->j_dev",
            "journal->j_devname"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_init_common",
          "args": [],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1071-1109",
          "snippet": "static journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tinit_waitqueue_head(&journal->j_wait_reserved);\n\tmutex_init(&journal->j_barrier);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\trwlock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD2_DEFAULT_MAX_COMMIT_AGE);\n\tjournal->j_min_batch_time = 0;\n\tjournal->j_max_batch_time = 15000; /* 15ms */\n\tatomic_set(&journal->j_reserved_credits, 0);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JBD2_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = jbd2_journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&journal->j_history_lock);\n\n\treturn journal;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tinit_waitqueue_head(&journal->j_wait_reserved);\n\tmutex_init(&journal->j_barrier);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\trwlock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD2_DEFAULT_MAX_COMMIT_AGE);\n\tjournal->j_min_batch_time = 0;\n\tjournal->j_max_batch_time = 15000; /* 15ms */\n\tatomic_set(&journal->j_reserved_credits, 0);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JBD2_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = jbd2_journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&journal->j_history_lock);\n\n\treturn journal;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\njournal_t * jbd2_journal_init_inode (struct inode *inode)\n{\n\tstruct buffer_head *bh;\n\tjournal_t *journal = journal_init_common();\n\tchar *p;\n\tint err;\n\tint n;\n\tunsigned long long blocknr;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\tjournal->j_dev = journal->j_fs_dev = inode->i_sb->s_bdev;\n\tjournal->j_inode = inode;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tp = journal->j_devname + strlen(journal->j_devname);\n\tsprintf(p, \"-%lu\", journal->j_inode->i_ino);\n\tjbd_debug(1,\n\t\t  \"journal %p: inode %s/%ld, size %Ld, bits %d, blksize %ld\\n\",\n\t\t  journal, inode->i_sb->s_id, inode->i_ino,\n\t\t  (long long) inode->i_size,\n\t\t  inode->i_sb->s_blocksize_bits, inode->i_sb->s_blocksize);\n\n\tjournal->j_maxlen = inode->i_size >> inode->i_sb->s_blocksize_bits;\n\tjournal->j_blocksize = inode->i_sb->s_blocksize;\n\tjbd2_stats_proc_init(journal);\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\terr = jbd2_journal_bmap(journal, 0, &blocknr);\n\t/* If that failed, give up */\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s: Cannot locate journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = getblk_unmovable(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}"
  },
  {
    "function_name": "jbd2_journal_init_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1134-1182",
    "snippet": "journal_t * jbd2_journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tunsigned long long start, int len, int blocksize)\n{\n\tjournal_t *journal = journal_init_common();\n\tstruct buffer_head *bh;\n\tchar *p;\n\tint n;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tjournal->j_blocksize = blocksize;\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_maxlen = len;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tjbd2_stats_proc_init(journal);\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = __getblk(journal->j_dev, start, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_stats_proc_exit",
          "args": [
            "journal"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_stats_proc_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1056-1060",
          "snippet": "static void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct proc_dir_entry *proc_jbd2_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal->j_wbuf"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\"",
            "__func__"
          ],
          "line": 1168
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "start",
            "journal->j_blocksize"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "n * sizeof(struct buffer_head*)",
            "GFP_KERNEL"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_stats_proc_init",
          "args": [
            "journal"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_stats_proc_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1047-1054",
          "snippet": "static void jbd2_stats_proc_init(journal_t *journal)\n{\n\tjournal->j_proc_entry = proc_mkdir(journal->j_devname, proc_jbd2_stats);\n\tif (journal->j_proc_entry) {\n\t\tproc_create_data(\"info\", S_IRUGO, journal->j_proc_entry,\n\t\t\t\t &jbd2_seq_info_fops, journal);\n\t}\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations jbd2_seq_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = jbd2_seq_info_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = jbd2_seq_info_release,\n};",
            "static struct proc_dir_entry *proc_jbd2_stats;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const struct file_operations jbd2_seq_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = jbd2_seq_info_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = jbd2_seq_info_release,\n};\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void jbd2_stats_proc_init(journal_t *journal)\n{\n\tjournal->j_proc_entry = proc_mkdir(journal->j_devname, proc_jbd2_stats);\n\tif (journal->j_proc_entry) {\n\t\tproc_create_data(\"info\", S_IRUGO, journal->j_proc_entry,\n\t\t\t\t &jbd2_seq_info_fops, journal);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'/'"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "journal->j_dev",
            "journal->j_devname"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_init_common",
          "args": [],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "journal_init_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1071-1109",
          "snippet": "static journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tinit_waitqueue_head(&journal->j_wait_reserved);\n\tmutex_init(&journal->j_barrier);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\trwlock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD2_DEFAULT_MAX_COMMIT_AGE);\n\tjournal->j_min_batch_time = 0;\n\tjournal->j_max_batch_time = 15000; /* 15ms */\n\tatomic_set(&journal->j_reserved_credits, 0);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JBD2_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = jbd2_journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&journal->j_history_lock);\n\n\treturn journal;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tinit_waitqueue_head(&journal->j_wait_reserved);\n\tmutex_init(&journal->j_barrier);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\trwlock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD2_DEFAULT_MAX_COMMIT_AGE);\n\tjournal->j_min_batch_time = 0;\n\tjournal->j_max_batch_time = 15000; /* 15ms */\n\tatomic_set(&journal->j_reserved_credits, 0);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JBD2_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = jbd2_journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&journal->j_history_lock);\n\n\treturn journal;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\njournal_t * jbd2_journal_init_dev(struct block_device *bdev,\n\t\t\tstruct block_device *fs_dev,\n\t\t\tunsigned long long start, int len, int blocksize)\n{\n\tjournal_t *journal = journal_init_common();\n\tstruct buffer_head *bh;\n\tchar *p;\n\tint n;\n\n\tif (!journal)\n\t\treturn NULL;\n\n\t/* journal descriptor can store up to n blocks -bzzz */\n\tjournal->j_blocksize = blocksize;\n\tjournal->j_dev = bdev;\n\tjournal->j_fs_dev = fs_dev;\n\tjournal->j_blk_offset = start;\n\tjournal->j_maxlen = len;\n\tbdevname(journal->j_dev, journal->j_devname);\n\tp = journal->j_devname;\n\twhile ((p = strchr(p, '/')))\n\t\t*p = '!';\n\tjbd2_stats_proc_init(journal);\n\tn = journal->j_blocksize / sizeof(journal_block_tag_t);\n\tjournal->j_wbufsize = n;\n\tjournal->j_wbuf = kmalloc(n * sizeof(struct buffer_head*), GFP_KERNEL);\n\tif (!journal->j_wbuf) {\n\t\tprintk(KERN_ERR \"%s: Can't allocate bhs for commit thread\\n\",\n\t\t\t__func__);\n\t\tgoto out_err;\n\t}\n\n\tbh = __getblk(journal->j_dev, start, journal->j_blocksize);\n\tif (!bh) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: Cannot get buffer for journal superblock\\n\",\n\t\t       __func__);\n\t\tgoto out_err;\n\t}\n\tjournal->j_sb_buffer = bh;\n\tjournal->j_superblock = (journal_superblock_t *)bh->b_data;\n\n\treturn journal;\nout_err:\n\tkfree(journal->j_wbuf);\n\tjbd2_stats_proc_exit(journal);\n\tkfree(journal);\n\treturn NULL;\n}"
  },
  {
    "function_name": "journal_init_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1071-1109",
    "snippet": "static journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tinit_waitqueue_head(&journal->j_wait_reserved);\n\tmutex_init(&journal->j_barrier);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\trwlock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD2_DEFAULT_MAX_COMMIT_AGE);\n\tjournal->j_min_batch_time = 0;\n\tjournal->j_max_batch_time = 15000; /* 15ms */\n\tatomic_set(&journal->j_reserved_credits, 0);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JBD2_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = jbd2_journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&journal->j_history_lock);\n\n\treturn journal;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_history_lock"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "journal"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_init_revoke",
          "args": [
            "journal",
            "JOURNAL_REVOKE_DEFAULT_HASH"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_init_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/revoke.c",
          "lines": "267-290",
          "snippet": "int jbd2_journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\nfail0:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint jbd2_journal_init_revoke(journal_t *journal, int hash_size)\n{\n\tJ_ASSERT(journal->j_revoke_table[0] == NULL);\n\tJ_ASSERT(is_power_of_2(hash_size));\n\n\tjournal->j_revoke_table[0] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[0])\n\t\tgoto fail0;\n\n\tjournal->j_revoke_table[1] = jbd2_journal_init_revoke_table(hash_size);\n\tif (!journal->j_revoke_table[1])\n\t\tgoto fail1;\n\n\tjournal->j_revoke = journal->j_revoke_table[1];\n\n\tspin_lock_init(&journal->j_revoke_lock);\n\n\treturn 0;\n\nfail1:\n\tjbd2_journal_destroy_revoke_table(journal->j_revoke_table[0]);\nfail0:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&journal->j_reserved_credits",
            "0"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&journal->j_revoke_lock"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&journal->j_barrier"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_reserved"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_updates"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_commit"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_done_commit"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&journal->j_wait_transaction_locked"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*journal)",
            "GFP_KERNEL"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic journal_t * journal_init_common (void)\n{\n\tjournal_t *journal;\n\tint err;\n\n\tjournal = kzalloc(sizeof(*journal), GFP_KERNEL);\n\tif (!journal)\n\t\treturn NULL;\n\n\tinit_waitqueue_head(&journal->j_wait_transaction_locked);\n\tinit_waitqueue_head(&journal->j_wait_done_commit);\n\tinit_waitqueue_head(&journal->j_wait_commit);\n\tinit_waitqueue_head(&journal->j_wait_updates);\n\tinit_waitqueue_head(&journal->j_wait_reserved);\n\tmutex_init(&journal->j_barrier);\n\tmutex_init(&journal->j_checkpoint_mutex);\n\tspin_lock_init(&journal->j_revoke_lock);\n\tspin_lock_init(&journal->j_list_lock);\n\trwlock_init(&journal->j_state_lock);\n\n\tjournal->j_commit_interval = (HZ * JBD2_DEFAULT_MAX_COMMIT_AGE);\n\tjournal->j_min_batch_time = 0;\n\tjournal->j_max_batch_time = 15000; /* 15ms */\n\tatomic_set(&journal->j_reserved_credits, 0);\n\n\t/* The journal is marked for error until we succeed with recovery! */\n\tjournal->j_flags = JBD2_ABORT;\n\n\t/* Set up a default-sized revoke table for the new mount. */\n\terr = jbd2_journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);\n\tif (err) {\n\t\tkfree(journal);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&journal->j_history_lock);\n\n\treturn journal;\n}"
  },
  {
    "function_name": "jbd2_stats_proc_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1056-1060",
    "snippet": "static void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct proc_dir_entry *proc_jbd2_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "remove_proc_entry",
          "args": [
            "journal->j_devname",
            "proc_jbd2_stats"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "remove_proc_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "523-554",
          "snippet": "void remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(proc_subdir_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic DEFINE_SPINLOCK(proc_subdir_lock);\n\nvoid remove_proc_entry(const char *name, struct proc_dir_entry *parent)\n{\n\tstruct proc_dir_entry *de = NULL;\n\tconst char *fn = name;\n\tunsigned int len;\n\n\tspin_lock(&proc_subdir_lock);\n\tif (__xlate_proc_name(name, &parent, &fn) != 0) {\n\t\tspin_unlock(&proc_subdir_lock);\n\t\treturn;\n\t}\n\tlen = strlen(fn);\n\n\tde = pde_subdir_find(parent, fn, len);\n\tif (de)\n\t\trb_erase(&de->subdir_node, &parent->subdir);\n\tspin_unlock(&proc_subdir_lock);\n\tif (!de) {\n\t\tWARN(1, \"name '%s'\\n\", name);\n\t\treturn;\n\t}\n\n\tproc_entry_rundown(de);\n\n\tif (S_ISDIR(de->mode))\n\t\tparent->nlink--;\n\tde->nlink = 0;\n\tWARN(pde_subdir_first(de),\n\t     \"%s: removing non-empty directory '%s/%s', leaking at least '%s'\\n\",\n\t     __func__, de->parent->name, de->name, pde_subdir_first(de)->name);\n\tpde_put(de);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void jbd2_stats_proc_exit(journal_t *journal)\n{\n\tremove_proc_entry(\"info\", journal->j_proc_entry);\n\tremove_proc_entry(journal->j_devname, proc_jbd2_stats);\n}"
  },
  {
    "function_name": "jbd2_stats_proc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1047-1054",
    "snippet": "static void jbd2_stats_proc_init(journal_t *journal)\n{\n\tjournal->j_proc_entry = proc_mkdir(journal->j_devname, proc_jbd2_stats);\n\tif (journal->j_proc_entry) {\n\t\tproc_create_data(\"info\", S_IRUGO, journal->j_proc_entry,\n\t\t\t\t &jbd2_seq_info_fops, journal);\n\t}\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations jbd2_seq_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = jbd2_seq_info_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = jbd2_seq_info_release,\n};",
      "static struct proc_dir_entry *proc_jbd2_stats;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_create_data",
          "args": [
            "\"info\"",
            "S_IRUGO",
            "journal->j_proc_entry",
            "&jbd2_seq_info_fops",
            "journal"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "proc_create_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "458-489",
          "snippet": "struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstatic const struct inode_operations proc_file_inode_operations = {\n\t.setattr\t= proc_notify_change,\n};\n\nstruct proc_dir_entry *proc_create_data(const char *name, umode_t mode,\n\t\t\t\t\tstruct proc_dir_entry *parent,\n\t\t\t\t\tconst struct file_operations *proc_fops,\n\t\t\t\t\tvoid *data)\n{\n\tstruct proc_dir_entry *pde;\n\tif ((mode & S_IFMT) == 0)\n\t\tmode |= S_IFREG;\n\n\tif (!S_ISREG(mode)) {\n\t\tWARN_ON(1);\t/* use proc_mkdir() */\n\t\treturn NULL;\n\t}\n\n\tBUG_ON(proc_fops == NULL);\n\n\tif ((mode & S_IALLUGO) == 0)\n\t\tmode |= S_IRUGO;\n\tpde = __proc_create(&parent, name, mode, 1);\n\tif (!pde)\n\t\tgoto out;\n\tpde->proc_fops = proc_fops;\n\tpde->data = data;\n\tpde->proc_iops = &proc_file_inode_operations;\n\tif (proc_register(parent, pde) < 0)\n\t\tgoto out_free;\n\treturn pde;\nout_free:\n\tkfree(pde);\nout:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mkdir",
          "args": [
            "journal->j_devname",
            "proc_jbd2_stats"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mkdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/generic.c",
          "lines": "451-455",
          "snippet": "struct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/idr.h>",
            "#include <linux/init.h>",
            "#include <linux/mount.h>",
            "#include <linux/printk.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/mount.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n\nstruct proc_dir_entry *proc_mkdir(const char *name,\n\t\tstruct proc_dir_entry *parent)\n{\n\treturn proc_mkdir_data(name, 0, parent, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const struct file_operations jbd2_seq_info_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open           = jbd2_seq_info_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = jbd2_seq_info_release,\n};\nstatic struct proc_dir_entry *proc_jbd2_stats;\n\nstatic void jbd2_stats_proc_init(journal_t *journal)\n{\n\tjournal->j_proc_entry = proc_mkdir(journal->j_devname, proc_jbd2_stats);\n\tif (journal->j_proc_entry) {\n\t\tproc_create_data(\"info\", S_IRUGO, journal->j_proc_entry,\n\t\t\t\t &jbd2_seq_info_fops, journal);\n\t}\n}"
  },
  {
    "function_name": "jbd2_seq_info_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "1028-1035",
    "snippet": "static int jbd2_seq_info_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct jbd2_stats_proc_session *s = seq->private;\n\tkfree(s->stats);\n\tkfree(s);\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->stats"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int jbd2_seq_info_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct jbd2_stats_proc_session *s = seq->private;\n\tkfree(s->stats);\n\tkfree(s);\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "jbd2_seq_info_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "996-1026",
    "snippet": "static int jbd2_seq_info_open(struct inode *inode, struct file *file)\n{\n\tjournal_t *journal = PDE_DATA(inode);\n\tstruct jbd2_stats_proc_session *s;\n\tint rc, size;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn -ENOMEM;\n\tsize = sizeof(struct transaction_stats_s);\n\ts->stats = kmalloc(size, GFP_KERNEL);\n\tif (s->stats == NULL) {\n\t\tkfree(s);\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock(&journal->j_history_lock);\n\tmemcpy(s->stats, &journal->j_stats, size);\n\ts->journal = journal;\n\tspin_unlock(&journal->j_history_lock);\n\n\trc = seq_open(file, &jbd2_seq_info_ops);\n\tif (rc == 0) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = s;\n\t} else {\n\t\tkfree(s->stats);\n\t\tkfree(s);\n\t}\n\treturn rc;\n\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations jbd2_seq_info_ops = {\n\t.start  = jbd2_seq_info_start,\n\t.next   = jbd2_seq_info_next,\n\t.stop   = jbd2_seq_info_stop,\n\t.show   = jbd2_seq_info_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s->stats"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&jbd2_seq_info_ops"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_history_lock"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->stats",
            "&journal->j_stats",
            "size"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_history_lock"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PDE_DATA",
          "args": [
            "inode"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "__PDE_DATA",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "85-88",
          "snippet": "static inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline void *__PDE_DATA(const struct inode *inode)\n{\n\treturn PDE(inode)->data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic const struct seq_operations jbd2_seq_info_ops = {\n\t.start  = jbd2_seq_info_start,\n\t.next   = jbd2_seq_info_next,\n\t.stop   = jbd2_seq_info_stop,\n\t.show   = jbd2_seq_info_show,\n};\n\nstatic int jbd2_seq_info_open(struct inode *inode, struct file *file)\n{\n\tjournal_t *journal = PDE_DATA(inode);\n\tstruct jbd2_stats_proc_session *s;\n\tint rc, size;\n\n\ts = kmalloc(sizeof(*s), GFP_KERNEL);\n\tif (s == NULL)\n\t\treturn -ENOMEM;\n\tsize = sizeof(struct transaction_stats_s);\n\ts->stats = kmalloc(size, GFP_KERNEL);\n\tif (s->stats == NULL) {\n\t\tkfree(s);\n\t\treturn -ENOMEM;\n\t}\n\tspin_lock(&journal->j_history_lock);\n\tmemcpy(s->stats, &journal->j_stats, size);\n\ts->journal = journal;\n\tspin_unlock(&journal->j_history_lock);\n\n\trc = seq_open(file, &jbd2_seq_info_ops);\n\tif (rc == 0) {\n\t\tstruct seq_file *m = file->private_data;\n\t\tm->private = s;\n\t} else {\n\t\tkfree(s->stats);\n\t\tkfree(s);\n\t}\n\treturn rc;\n\n}"
  },
  {
    "function_name": "jbd2_seq_info_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "985-987",
    "snippet": "static void jbd2_seq_info_stop(struct seq_file *seq, void *v)\n{\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_seq_info_stop(struct seq_file *seq, void *v)\n{\n}"
  },
  {
    "function_name": "jbd2_seq_info_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "948-983",
    "snippet": "static int jbd2_seq_info_show(struct seq_file *seq, void *v)\n{\n\tstruct jbd2_stats_proc_session *s = seq->private;\n\n\tif (v != SEQ_START_TOKEN)\n\t\treturn 0;\n\tseq_printf(seq, \"%lu transactions (%lu requested), \"\n\t\t   \"each up to %u blocks\\n\",\n\t\t   s->stats->ts_tid, s->stats->ts_requested,\n\t\t   s->journal->j_max_transaction_buffers);\n\tif (s->stats->ts_tid == 0)\n\t\treturn 0;\n\tseq_printf(seq, \"average: \\n  %ums waiting for transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_wait / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums request delay\\n\",\n\t    (s->stats->ts_requested == 0) ? 0 :\n\t    jiffies_to_msecs(s->stats->run.rs_request_delay /\n\t\t\t     s->stats->ts_requested));\n\tseq_printf(seq, \"  %ums running transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_running / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums transaction was being locked\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_locked / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums flushing data (in ordered mode)\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_flushing / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums logging transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_logging / s->stats->ts_tid));\n\tseq_printf(seq, \"  %lluus average transaction commit time\\n\",\n\t\t   div_u64(s->journal->j_average_commit_time, 1000));\n\tseq_printf(seq, \"  %lu handles per transaction\\n\",\n\t    s->stats->run.rs_handle_count / s->stats->ts_tid);\n\tseq_printf(seq, \"  %lu blocks per transaction\\n\",\n\t    s->stats->run.rs_blocks / s->stats->ts_tid);\n\tseq_printf(seq, \"  %lu logged blocks per transaction\\n\",\n\t    s->stats->run.rs_blocks_logged / s->stats->ts_tid);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\"  %lu logged blocks per transaction\\n\"",
            "s->stats->run.rs_blocks_logged / s->stats->ts_tid"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "s->journal->j_average_commit_time",
            "1000"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "s->stats->run.rs_logging / s->stats->ts_tid"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "s->stats->run.rs_flushing / s->stats->ts_tid"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "s->stats->run.rs_locked / s->stats->ts_tid"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "s->stats->run.rs_running / s->stats->ts_tid"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "s->stats->run.rs_request_delay /\n\t\t\t     s->stats->ts_requested"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "s->stats->run.rs_wait / s->stats->ts_tid"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int jbd2_seq_info_show(struct seq_file *seq, void *v)\n{\n\tstruct jbd2_stats_proc_session *s = seq->private;\n\n\tif (v != SEQ_START_TOKEN)\n\t\treturn 0;\n\tseq_printf(seq, \"%lu transactions (%lu requested), \"\n\t\t   \"each up to %u blocks\\n\",\n\t\t   s->stats->ts_tid, s->stats->ts_requested,\n\t\t   s->journal->j_max_transaction_buffers);\n\tif (s->stats->ts_tid == 0)\n\t\treturn 0;\n\tseq_printf(seq, \"average: \\n  %ums waiting for transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_wait / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums request delay\\n\",\n\t    (s->stats->ts_requested == 0) ? 0 :\n\t    jiffies_to_msecs(s->stats->run.rs_request_delay /\n\t\t\t     s->stats->ts_requested));\n\tseq_printf(seq, \"  %ums running transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_running / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums transaction was being locked\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_locked / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums flushing data (in ordered mode)\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_flushing / s->stats->ts_tid));\n\tseq_printf(seq, \"  %ums logging transaction\\n\",\n\t    jiffies_to_msecs(s->stats->run.rs_logging / s->stats->ts_tid));\n\tseq_printf(seq, \"  %lluus average transaction commit time\\n\",\n\t\t   div_u64(s->journal->j_average_commit_time, 1000));\n\tseq_printf(seq, \"  %lu handles per transaction\\n\",\n\t    s->stats->run.rs_handle_count / s->stats->ts_tid);\n\tseq_printf(seq, \"  %lu blocks per transaction\\n\",\n\t    s->stats->run.rs_blocks / s->stats->ts_tid);\n\tseq_printf(seq, \"  %lu logged blocks per transaction\\n\",\n\t    s->stats->run.rs_blocks_logged / s->stats->ts_tid);\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_seq_info_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "943-946",
    "snippet": "static void *jbd2_seq_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void *jbd2_seq_info_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "jbd2_seq_info_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "938-941",
    "snippet": "static void *jbd2_seq_info_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? NULL : SEQ_START_TOKEN;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void *jbd2_seq_info_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos ? NULL : SEQ_START_TOKEN;\n}"
  },
  {
    "function_name": "jbd2_update_log_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "923-929",
    "snippet": "void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tif (tid_gt(tid, journal->j_tail_sequence))\n\t\t__jbd2_update_log_tail(journal, tid, block);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__jbd2_update_log_tail",
          "args": [
            "journal",
            "tid",
            "block"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_update_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "888-916",
          "snippet": "void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tunsigned long freed;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\n\t/*\n\t * We cannot afford for write to remain in drive's caches since as\n\t * soon as we update j_tail, next transaction can start reusing journal\n\t * space and if we lose sb update during power failure we'd replay\n\t * old transaction with possibly newly overwritten data.\n\t */\n\tjbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);\n\twrite_lock(&journal->j_state_lock);\n\tfreed = block - journal->j_tail;\n\tif (block < journal->j_tail)\n\t\tfreed += journal->j_last - journal->j_first;\n\n\ttrace_jbd2_update_log_tail(journal, tid, block, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %lu), \"\n\t\t  \"freeing %lu\\n\",\n\t\t  journal->j_tail_sequence, tid, block, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = tid;\n\tjournal->j_tail = block;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tunsigned long freed;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\n\t/*\n\t * We cannot afford for write to remain in drive's caches since as\n\t * soon as we update j_tail, next transaction can start reusing journal\n\t * space and if we lose sb update during power failure we'd replay\n\t * old transaction with possibly newly overwritten data.\n\t */\n\tjbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);\n\twrite_lock(&journal->j_state_lock);\n\tfreed = block - journal->j_tail;\n\tif (block < journal->j_tail)\n\t\tfreed += journal->j_last - journal->j_first;\n\n\ttrace_jbd2_update_log_tail(journal, tid, block, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %lu), \"\n\t\t  \"freeing %lu\\n\",\n\t\t  journal->j_tail_sequence, tid, block, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = tid;\n\tjournal->j_tail = block;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "tid",
            "journal->j_tail_sequence"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tmutex_lock(&journal->j_checkpoint_mutex);\n\tif (tid_gt(tid, journal->j_tail_sequence))\n\t\t__jbd2_update_log_tail(journal, tid, block);\n\tmutex_unlock(&journal->j_checkpoint_mutex);\n}"
  },
  {
    "function_name": "__jbd2_update_log_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "888-916",
    "snippet": "void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tunsigned long freed;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\n\t/*\n\t * We cannot afford for write to remain in drive's caches since as\n\t * soon as we update j_tail, next transaction can start reusing journal\n\t * space and if we lose sb update during power failure we'd replay\n\t * old transaction with possibly newly overwritten data.\n\t */\n\tjbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);\n\twrite_lock(&journal->j_state_lock);\n\tfreed = block - journal->j_tail;\n\tif (block < journal->j_tail)\n\t\tfreed += journal->j_last - journal->j_first;\n\n\ttrace_jbd2_update_log_tail(journal, tid, block, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %lu), \"\n\t\t  \"freeing %lu\\n\",\n\t\t  journal->j_tail_sequence, tid, block, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = tid;\n\tjournal->j_tail = block;\n\twrite_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Cleaning journal tail from %d to %d (offset %lu), \"\n\t\t  \"freeing %lu\\n\"",
            "journal->j_tail_sequence",
            "tid",
            "block",
            "freed"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_jbd2_update_log_tail",
          "args": [
            "journal",
            "tid",
            "block",
            "freed"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 901
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_update_sb_log_tail",
          "args": [
            "journal",
            "tid",
            "block",
            "WRITE_FUA"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_update_sb_log_tail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "1386-1405",
          "snippet": "void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t     unsigned long tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjbd2_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,\n\t\t\t\t     unsigned long tail_block, int write_op)\n{\n\tjournal_superblock_t *sb = journal->j_superblock;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\tjbd_debug(1, \"JBD2: updating superblock (start %lu, seq %u)\\n\",\n\t\t  tail_block, tail_tid);\n\n\tsb->s_sequence = cpu_to_be32(tail_tid);\n\tsb->s_start    = cpu_to_be32(tail_block);\n\n\tjbd2_write_superblock(journal, write_op);\n\n\t/* Log is no longer empty */\n\twrite_lock(&journal->j_state_lock);\n\tWARN_ON(!sb->s_sequence);\n\tjournal->j_flags &= ~JBD2_FLUSHED;\n\twrite_unlock(&journal->j_state_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mutex_is_locked(&journal->j_checkpoint_mutex)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&journal->j_checkpoint_mutex"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)\n{\n\tunsigned long freed;\n\n\tBUG_ON(!mutex_is_locked(&journal->j_checkpoint_mutex));\n\n\t/*\n\t * We cannot afford for write to remain in drive's caches since as\n\t * soon as we update j_tail, next transaction can start reusing journal\n\t * space and if we lose sb update during power failure we'd replay\n\t * old transaction with possibly newly overwritten data.\n\t */\n\tjbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);\n\twrite_lock(&journal->j_state_lock);\n\tfreed = block - journal->j_tail;\n\tif (block < journal->j_tail)\n\t\tfreed += journal->j_last - journal->j_first;\n\n\ttrace_jbd2_update_log_tail(journal, tid, block, freed);\n\tjbd_debug(1,\n\t\t  \"Cleaning journal tail from %d to %d (offset %lu), \"\n\t\t  \"freeing %lu\\n\",\n\t\t  journal->j_tail_sequence, tid, block, freed);\n\n\tjournal->j_free += freed;\n\tjournal->j_tail_sequence = tid;\n\tjournal->j_tail = block;\n\twrite_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "jbd2_journal_get_log_tail",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "849-876",
    "snippet": "int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block)\n{\n\ttransaction_t *transaction;\n\tint ret;\n\n\tread_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = journal->j_head;\n\t} else {\n\t\t*tid = journal->j_transaction_sequence;\n\t\t*block = journal->j_head;\n\t}\n\tret = tid_gt(*tid, journal->j_tail_sequence);\n\tspin_unlock(&journal->j_list_lock);\n\tread_unlock(&journal->j_state_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "*tid",
            "journal->j_tail_sequence"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,\n\t\t\t      unsigned long *block)\n{\n\ttransaction_t *transaction;\n\tint ret;\n\n\tread_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\ttransaction = journal->j_checkpoint_transactions;\n\tif (transaction) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_committing_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = transaction->t_log_start;\n\t} else if ((transaction = journal->j_running_transaction) != NULL) {\n\t\t*tid = transaction->t_tid;\n\t\t*block = journal->j_head;\n\t} else {\n\t\t*tid = journal->j_transaction_sequence;\n\t\t*block = journal->j_head;\n\t}\n\tret = tid_gt(*tid, journal->j_tail_sequence);\n\tspin_unlock(&journal->j_list_lock);\n\tread_unlock(&journal->j_state_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_journal_get_descriptor_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "817-837",
    "snippet": "struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "bh",
            "\"return this buffer\""
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "journal->j_blocksize"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_next_log_block",
          "args": [
            "journal",
            "&blocknr"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_next_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "761-775",
          "snippet": "int jbd2_journal_next_log_block(journal_t *journal, unsigned long long *retp)\n{\n\tunsigned long blocknr;\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\twrite_unlock(&journal->j_state_lock);\n\treturn jbd2_journal_bmap(journal, blocknr, retp);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_next_log_block(journal_t *journal, unsigned long long *retp)\n{\n\tunsigned long blocknr;\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\twrite_unlock(&journal->j_state_lock);\n\treturn jbd2_journal_bmap(journal, blocknr, retp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstruct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal)\n{\n\tstruct buffer_head *bh;\n\tunsigned long long blocknr;\n\tint err;\n\n\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\n\tif (err)\n\t\treturn NULL;\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn NULL;\n\tlock_buffer(bh);\n\tmemset(bh->b_data, 0, journal->j_blocksize);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\tBUFFER_TRACE(bh, \"return this buffer\");\n\treturn bh;\n}"
  },
  {
    "function_name": "jbd2_journal_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "784-805",
    "snippet": "int jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__journal_abort_soft",
          "args": [
            "journal",
            "err"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "__journal_abort_soft",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2046-2058",
          "snippet": "static void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__jbd2_journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjbd2_journal_update_sb_errno(journal);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __journal_abort_soft (journal_t *journal, int errno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void __journal_abort_soft (journal_t *journal, int errno);\n\nstatic void __journal_abort_soft (journal_t *journal, int errno)\n{\n\tif (journal->j_flags & JBD2_ABORT)\n\t\treturn;\n\n\tif (!journal->j_errno)\n\t\tjournal->j_errno = errno;\n\n\t__jbd2_journal_abort_hard(journal);\n\n\tif (errno)\n\t\tjbd2_journal_update_sb_errno(journal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\"",
            "__func__",
            "blocknr",
            "journal->j_devname"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bmap",
          "args": [
            "journal->j_inode",
            "blocknr"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ioctl_fibmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ioctl.c",
          "lines": "50-65",
          "snippet": "static int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}",
          "includes": [
            "#include <asm/ioctls.h>",
            "#include <linux/falloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/mm.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ioctls.h>\n#include <linux/falloc.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/uaccess.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/mm.h>\n#include <linux/syscalls.h>\n\nstatic int ioctl_fibmap(struct file *filp, int __user *p)\n{\n\tstruct address_space *mapping = filp->f_mapping;\n\tint res, block;\n\n\t/* do we support this mess? */\n\tif (!mapping->a_ops->bmap)\n\t\treturn -EINVAL;\n\tif (!capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\tres = get_user(block, p);\n\tif (res)\n\t\treturn res;\n\tres = mapping->a_ops->bmap(mapping, block);\n\treturn put_user(res, p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_journal_next_log_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "761-775",
    "snippet": "int jbd2_journal_next_log_block(journal_t *journal, unsigned long long *retp)\n{\n\tunsigned long blocknr;\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\twrite_unlock(&journal->j_state_lock);\n\treturn jbd2_journal_bmap(journal, blocknr, retp);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_bmap",
          "args": [
            "journal",
            "blocknr",
            "retp"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "784-805",
          "snippet": "int jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_bmap(journal_t *journal, unsigned long blocknr,\n\t\t unsigned long long *retp)\n{\n\tint err = 0;\n\tunsigned long long ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %lu on %s\\n\",\n\t\t\t       __func__, blocknr, journal->j_devname);\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "journal->j_free > 1"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 765
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_next_log_block(journal_t *journal, unsigned long long *retp)\n{\n\tunsigned long blocknr;\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(journal->j_free > 1);\n\n\tblocknr = journal->j_head;\n\tjournal->j_head++;\n\tjournal->j_free--;\n\tif (journal->j_head == journal->j_last)\n\t\tjournal->j_head = journal->j_first;\n\twrite_unlock(&journal->j_state_lock);\n\treturn jbd2_journal_bmap(journal, blocknr, retp);\n}"
  },
  {
    "function_name": "jbd2_complete_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "733-754",
    "snippet": "int jbd2_complete_transaction(journal_t *journal, tid_t tid)\n{\n\tint\tneed_to_wait = 1;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == tid) {\n\t\tif (journal->j_commit_request != tid) {\n\t\t\t/* transaction not yet started, so request it */\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tgoto wait_commit;\n\t\t}\n\t} else if (!(journal->j_committing_transaction &&\n\t\t     journal->j_committing_transaction->t_tid == tid))\n\t\tneed_to_wait = 0;\n\tread_unlock(&journal->j_state_lock);\n\tif (!need_to_wait)\n\t\treturn 0;\nwait_commit:\n\treturn jbd2_log_wait_commit(journal, tid);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "698-724",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_log_start_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "540-548",
          "snippet": "int jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_complete_transaction(journal_t *journal, tid_t tid)\n{\n\tint\tneed_to_wait = 1;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == tid) {\n\t\tif (journal->j_commit_request != tid) {\n\t\t\t/* transaction not yet started, so request it */\n\t\t\tread_unlock(&journal->j_state_lock);\n\t\t\tjbd2_log_start_commit(journal, tid);\n\t\t\tgoto wait_commit;\n\t\t}\n\t} else if (!(journal->j_committing_transaction &&\n\t\t     journal->j_committing_transaction->t_tid == tid))\n\t\tneed_to_wait = 0;\n\tread_unlock(&journal->j_state_lock);\n\tif (!need_to_wait)\n\t\treturn 0;\nwait_commit:\n\treturn jbd2_log_wait_commit(journal, tid);\n}"
  },
  {
    "function_name": "jbd2_log_wait_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "698-724",
    "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_journal_aborted(journal)"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_journal_aborted",
          "args": [
            "journal"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__reiserfs_is_journal_aborted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/reiserfs.h",
          "lines": "760-764",
          "snippet": "static inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/bitops.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/bug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/slab.h>",
            "#include <linux/reiserfs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include <linux/proc_fs.h>\n#include <linux/bitops.h>\n#include <asm/unaligned.h>\n#include <linux/workqueue.h>\n#include <linux/bug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/slab.h>\n#include <linux/reiserfs_fs.h>\n\nstatic inline int __reiserfs_is_journal_aborted(struct reiserfs_journal\n\t\t\t\t\t\t*journal)\n{\n\treturn test_bit(J_ABORTED, &journal->j_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_wait_done_commit",
            "!tid_gt(tid, journal->j_commit_sequence)"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "tid",
            "journal->j_commit_sequence"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_commit"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: want %d, j_commit_sequence=%d\\n\"",
            "tid",
            "journal->j_commit_sequence"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_gt",
          "args": [
            "tid",
            "journal->j_commit_sequence"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\"",
            "__func__",
            "journal->j_commit_request",
            "tid"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_request",
            "tid"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
  },
  {
    "function_name": "jbd2_trans_will_send_data_barrier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "659-691",
    "snippet": "int jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\treturn 0;\n\tread_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\tcommit_trans = journal->j_committing_transaction;\n\tif (!commit_trans || commit_trans->t_tid != tid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * submitting a flush to fs partition?\n\t */\n\tif (journal->j_fs_dev != journal->j_dev) {\n\t\tif (!commit_trans->t_need_data_flush ||\n\t\t    commit_trans->t_state >= T_COMMIT_DFLUSH)\n\t\t\tgoto out;\n\t} else {\n\t\tif (commit_trans->t_state >= T_COMMIT_JFLUSH)\n\t\t\tgoto out;\n\t}\n\tret = 1;\nout:\n\tread_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_sequence",
            "tid"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_trans_will_send_data_barrier(journal_t *journal, tid_t tid)\n{\n\tint ret = 0;\n\ttransaction_t *commit_trans;\n\n\tif (!(journal->j_flags & JBD2_BARRIER))\n\t\treturn 0;\n\tread_lock(&journal->j_state_lock);\n\t/* Transaction already committed? */\n\tif (tid_geq(journal->j_commit_sequence, tid))\n\t\tgoto out;\n\tcommit_trans = journal->j_committing_transaction;\n\tif (!commit_trans || commit_trans->t_tid != tid) {\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\t/*\n\t * Transaction is being committed and we already proceeded to\n\t * submitting a flush to fs partition?\n\t */\n\tif (journal->j_fs_dev != journal->j_dev) {\n\t\tif (!commit_trans->t_need_data_flush ||\n\t\t    commit_trans->t_state >= T_COMMIT_DFLUSH)\n\t\t\tgoto out;\n\t} else {\n\t\tif (commit_trans->t_state >= T_COMMIT_JFLUSH)\n\t\t\tgoto out;\n\t}\n\tret = 1;\nout:\n\tread_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_journal_start_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "626-651",
    "snippet": "int jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_log_start_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "503-538",
          "snippet": "int __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_start_commit(journal_t *journal, tid_t *ptid)\n{\n\tint ret = 0;\n\n\twrite_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction) {\n\t\ttid_t tid = journal->j_running_transaction->t_tid;\n\n\t\t__jbd2_log_start_commit(journal, tid);\n\t\t/* There's a running transaction and we've just made sure\n\t\t * it's commit has been scheduled. */\n\t\tif (ptid)\n\t\t\t*ptid = tid;\n\t\tret = 1;\n\t} else if (journal->j_committing_transaction) {\n\t\t/*\n\t\t * If commit has been started, then we have to wait for\n\t\t * completion of that transaction.\n\t\t */\n\t\tif (ptid)\n\t\t\t*ptid = journal->j_committing_transaction->t_tid;\n\t\tret = 1;\n\t}\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_journal_force_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "610-619",
    "snippet": "int jbd2_journal_force_commit(journal_t *journal)\n{\n\tint ret;\n\n\tJ_ASSERT(!current->journal_info);\n\tret = __jbd2_journal_force_commit(journal);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jbd2_journal_force_commit",
          "args": [
            "journal"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "557-585",
          "snippet": "static int __jbd2_journal_force_commit(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\tint need_to_start = 0, ret = 0;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (!tid_geq(journal->j_commit_request, transaction->t_tid))\n\t\t\tneed_to_start = 1;\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\t/* Nothing to commit */\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t}\n\ttid = transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tret = jbd2_log_wait_commit(journal, tid);\n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __jbd2_journal_force_commit(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\tint need_to_start = 0, ret = 0;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (!tid_geq(journal->j_commit_request, transaction->t_tid))\n\t\t\tneed_to_start = 1;\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\t/* Nothing to commit */\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t}\n\ttid = transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tret = jbd2_log_wait_commit(journal, tid);\n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "!current->journal_info"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_force_commit(journal_t *journal)\n{\n\tint ret;\n\n\tJ_ASSERT(!current->journal_info);\n\tret = __jbd2_journal_force_commit(journal);\n\tif (ret > 0)\n\t\tret = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_journal_force_commit_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "595-601",
    "snippet": "int jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jbd2_journal_force_commit",
          "args": [
            "journal"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_force_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "557-585",
          "snippet": "static int __jbd2_journal_force_commit(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\tint need_to_start = 0, ret = 0;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (!tid_geq(journal->j_commit_request, transaction->t_tid))\n\t\t\tneed_to_start = 1;\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\t/* Nothing to commit */\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t}\n\ttid = transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tret = jbd2_log_wait_commit(journal, tid);\n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __jbd2_journal_force_commit(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\tint need_to_start = 0, ret = 0;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (!tid_geq(journal->j_commit_request, transaction->t_tid))\n\t\t\tneed_to_start = 1;\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\t/* Nothing to commit */\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t}\n\ttid = transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tret = jbd2_log_wait_commit(journal, tid);\n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_force_commit_nested(journal_t *journal)\n{\n\tint ret;\n\n\tret = __jbd2_journal_force_commit(journal);\n\treturn ret > 0;\n}"
  },
  {
    "function_name": "__jbd2_journal_force_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "557-585",
    "snippet": "static int __jbd2_journal_force_commit(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\tint need_to_start = 0, ret = 0;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (!tid_geq(journal->j_commit_request, transaction->t_tid))\n\t\t\tneed_to_start = 1;\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\t/* Nothing to commit */\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t}\n\ttid = transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tret = jbd2_log_wait_commit(journal, tid);\n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_log_wait_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_wait_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "698-724",
          "snippet": "int jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_wait_commit(journal_t *journal, tid_t tid)\n{\n\tint err = 0;\n\n\tread_lock(&journal->j_state_lock);\n#ifdef CONFIG_JBD2_DEBUG\n\tif (!tid_geq(journal->j_commit_request, tid)) {\n\t\tprintk(KERN_ERR\n\t\t       \"%s: error: j_commit_request=%d, tid=%d\\n\",\n\t\t       __func__, journal->j_commit_request, tid);\n\t}\n#endif\n\twhile (tid_gt(tid, journal->j_commit_sequence)) {\n\t\tjbd_debug(1, \"JBD2: want %d, j_commit_sequence=%d\\n\",\n\t\t\t\t  tid, journal->j_commit_sequence);\n\t\tread_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit,\n\t\t\t\t!tid_gt(tid, journal->j_commit_sequence));\n\t\tread_lock(&journal->j_state_lock);\n\t}\n\tread_unlock(&journal->j_state_lock);\n\n\tif (unlikely(is_journal_aborted(journal)))\n\t\terr = -EIO;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_log_start_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "540-548",
          "snippet": "int jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_request",
            "transaction->t_tid"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int __jbd2_journal_force_commit(journal_t *journal)\n{\n\ttransaction_t *transaction = NULL;\n\ttid_t tid;\n\tint need_to_start = 0, ret = 0;\n\n\tread_lock(&journal->j_state_lock);\n\tif (journal->j_running_transaction && !current->journal_info) {\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (!tid_geq(journal->j_commit_request, transaction->t_tid))\n\t\t\tneed_to_start = 1;\n\t} else if (journal->j_committing_transaction)\n\t\ttransaction = journal->j_committing_transaction;\n\n\tif (!transaction) {\n\t\t/* Nothing to commit */\n\t\tread_unlock(&journal->j_state_lock);\n\t\treturn 0;\n\t}\n\ttid = transaction->t_tid;\n\tread_unlock(&journal->j_state_lock);\n\tif (need_to_start)\n\t\tjbd2_log_start_commit(journal, tid);\n\tret = jbd2_log_wait_commit(journal, tid);\n\tif (!ret)\n\t\tret = 1;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "jbd2_log_start_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "540-548",
    "snippet": "int jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_log_start_commit",
          "args": [
            "journal",
            "tid"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_log_start_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "503-538",
          "snippet": "int __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_log_start_commit(journal_t *journal, tid_t tid)\n{\n\tint ret;\n\n\twrite_lock(&journal->j_state_lock);\n\tret = __jbd2_log_start_commit(journal, tid);\n\twrite_unlock(&journal->j_state_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__jbd2_log_start_commit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "503-538",
    "snippet": "int __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"JBD2: bad log_start_commit: %u %u %u %u\\n\"",
            "journal->j_commit_request",
            "journal->j_commit_sequence",
            "target",
            "journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "journal->j_commit_request",
            "target"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_commit"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD2: requesting commit %d/%d\\n\"",
            "journal->j_commit_request",
            "journal->j_commit_sequence"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint __jbd2_log_start_commit(journal_t *journal, tid_t target)\n{\n\t/* Return if the txn has already requested to be committed */\n\tif (journal->j_commit_request == target)\n\t\treturn 0;\n\n\t/*\n\t * The only transaction we can possibly wait upon is the\n\t * currently running transaction (if it exists).  Otherwise,\n\t * the target tid must be an old one.\n\t */\n\tif (journal->j_running_transaction &&\n\t    journal->j_running_transaction->t_tid == target) {\n\t\t/*\n\t\t * We want a new commit: OK, mark the request and wakeup the\n\t\t * commit thread.  We do _not_ do the commit ourselves.\n\t\t */\n\n\t\tjournal->j_commit_request = target;\n\t\tjbd_debug(1, \"JBD2: requesting commit %d/%d\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence);\n\t\tjournal->j_running_transaction->t_requested = jiffies;\n\t\twake_up(&journal->j_wait_commit);\n\t\treturn 1;\n\t} else if (!tid_geq(journal->j_commit_request, target))\n\t\t/* This should never happen, but if it does, preserve\n\t\t   the evidence before kjournald goes into a loop and\n\t\t   increments j_commit_sequence beyond all recognition. */\n\t\tWARN_ONCE(1, \"JBD2: bad log_start_commit: %u %u %u %u\\n\",\n\t\t\t  journal->j_commit_request,\n\t\t\t  journal->j_commit_sequence,\n\t\t\t  target, journal->j_running_transaction ? \n\t\t\t  journal->j_running_transaction->t_tid : 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "jbd2_journal_write_metadata_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "348-492",
    "snippet": "int jbd2_journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct buffer_head **bh_out,\n\t\t\t\t  sector_t blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct page *new_page;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t/*\n\t * The buffer really shouldn't be locked: only the current committing\n\t * transaction is allowed to write it, so nobody else is allowed\n\t * to do any IO.\n\t *\n\t * akpm: except if we're journalling data, and write() output is\n\t * also part of a shared mapping, and another thread has\n\t * decided to launch a writepage() against this buffer.\n\t */\n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\nretry_alloc:\n\tnew_bh = alloc_buffer_head(GFP_NOFS);\n\tif (!new_bh) {\n\t\t/*\n\t\t * Failure is not an option, but __GFP_NOFAIL is going\n\t\t * away; so we retry ourselves here.\n\t\t */\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry_alloc;\n\t}\n\n\t/* keep subsequent assertions sane */\n\tatomic_set(&new_bh->b_count, 1);\n\n\tjbd_lock_bh_state(bh_in);\nrepeat:\n\t/*\n\t * If a new transaction has already done a buffer copy-out, then\n\t * we use that version of the data for the commit.\n\t */\n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_page = virt_to_page(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_page(jh_in->b_frozen_data);\n\t} else {\n\t\tnew_page = jh2bh(jh_in)->b_page;\n\t\tnew_offset = offset_in_page(jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_atomic(new_page);\n\t/*\n\t * Fire data frozen trigger if data already wasn't frozen.  Do this\n\t * before checking for escaping, as the trigger may modify the magic\n\t * offset.  If a copy-out happens afterwards, it will have the correct\n\t * data in the buffer.\n\t */\n\tif (!done_copy_out)\n\t\tjbd2_buffer_frozen_trigger(jh_in, mapped_data + new_offset,\n\t\t\t\t\t   jh_in->b_triggers);\n\n\t/*\n\t * Check for escaping\n\t */\n\tif (*((__be32 *)(mapped_data + new_offset)) ==\n\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_atomic(mapped_data);\n\n\t/*\n\t * Do we need to do a data copy?\n\t */\n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tjbd_unlock_bh_state(bh_in);\n\t\ttmp = jbd2_alloc(bh_in->b_size, GFP_NOFS);\n\t\tif (!tmp) {\n\t\t\tbrelse(new_bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tjbd_lock_bh_state(bh_in);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd2_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmapped_data = kmap_atomic(new_page);\n\t\tmemcpy(tmp, mapped_data + new_offset, bh_in->b_size);\n\t\tkunmap_atomic(mapped_data);\n\n\t\tnew_page = virt_to_page(tmp);\n\t\tnew_offset = offset_in_page(tmp);\n\t\tdone_copy_out = 1;\n\n\t\t/*\n\t\t * This isn't strictly necessary, as we're using frozen\n\t\t * data for the escaping, but it keeps consistency with\n\t\t * b_frozen_data usage.\n\t\t */\n\t\tjh_in->b_frozen_triggers = jh_in->b_triggers;\n\t}\n\n\t/*\n\t * Did we need to do an escaping?  Now we've done all the\n\t * copying, we can finally do so.\n\t */\n\tif (do_escape) {\n\t\tmapped_data = kmap_atomic(new_page);\n\t\t*((unsigned int *)(mapped_data + new_offset)) = 0;\n\t\tkunmap_atomic(mapped_data);\n\t}\n\n\tset_bh_page(new_bh, new_page, new_offset);\n\tnew_bh->b_size = bh_in->b_size;\n\tnew_bh->b_bdev = journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tnew_bh->b_private = bh_in;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*bh_out = new_bh;\n\n\t/*\n\t * The to-be-written buffer needs to get moved to the io queue,\n\t * and the original buffer whose contents we are shadowing or\n\t * copying is moved to the transaction's shadow queue.\n\t */\n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tset_buffer_shadow(bh_in);\n\tjbd_unlock_bh_state(bh_in);\n\n\treturn do_escape | (done_copy_out << 1);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh_in"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_shadow",
          "args": [
            "bh_in"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jbd2_journal_file_buffer",
          "args": [
            "jh_in",
            "transaction",
            "BJ_Shadow"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd2_journal_file_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "2219-2283",
          "snippet": "void __jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\telse\n\t\tjbd2_journal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nvoid __jbd2_journal_file_buffer(struct journal_head *jh,\n\t\t\ttransaction_t *transaction, int jlist)\n{\n\tstruct journal_head **list = NULL;\n\tint was_dirty = 0;\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tJ_ASSERT_JH(jh, jbd_is_locked_bh_state(bh));\n\tassert_spin_locked(&transaction->t_journal->j_list_lock);\n\n\tJ_ASSERT_JH(jh, jh->b_jlist < BJ_Types);\n\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_transaction == NULL);\n\n\tif (jh->b_transaction && jh->b_jlist == jlist)\n\t\treturn;\n\n\tif (jlist == BJ_Metadata || jlist == BJ_Reserved ||\n\t    jlist == BJ_Shadow || jlist == BJ_Forget) {\n\t\t/*\n\t\t * For metadata buffers, we track dirty bit in buffer_jbddirty\n\t\t * instead of buffer_dirty. We should not see a dirty bit set\n\t\t * here because we clear it in do_get_write_access but e.g.\n\t\t * tune2fs can modify the sb and set the dirty bit at any time\n\t\t * so we try to gracefully handle that.\n\t\t */\n\t\tif (buffer_dirty(bh))\n\t\t\twarn_dirty_buffer(bh);\n\t\tif (test_clear_buffer_dirty(bh) ||\n\t\t    test_clear_buffer_jbddirty(bh))\n\t\t\twas_dirty = 1;\n\t}\n\n\tif (jh->b_transaction)\n\t\t__jbd2_journal_temp_unlink_buffer(jh);\n\telse\n\t\tjbd2_journal_grab_journal_head(bh);\n\tjh->b_transaction = transaction;\n\n\tswitch (jlist) {\n\tcase BJ_None:\n\t\tJ_ASSERT_JH(jh, !jh->b_committed_data);\n\t\tJ_ASSERT_JH(jh, !jh->b_frozen_data);\n\t\treturn;\n\tcase BJ_Metadata:\n\t\ttransaction->t_nr_buffers++;\n\t\tlist = &transaction->t_buffers;\n\t\tbreak;\n\tcase BJ_Forget:\n\t\tlist = &transaction->t_forget;\n\t\tbreak;\n\tcase BJ_Shadow:\n\t\tlist = &transaction->t_shadow_list;\n\t\tbreak;\n\tcase BJ_Reserved:\n\t\tlist = &transaction->t_reserved_list;\n\t\tbreak;\n\t}\n\n\t__blist_add_buffer(list, jh);\n\tjh->b_jlist = jlist;\n\n\tif (was_dirty)\n\t\tset_buffer_jbddirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&journal->j_list_lock"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "JBUFFER_TRACE",
          "args": [
            "jh_in",
            "\"file as BJ_Shadow\""
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_dirty",
          "args": [
            "new_bh"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_buffer_mapped",
          "args": [
            "new_bh"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bh_page",
          "args": [
            "new_bh",
            "new_page",
            "new_offset"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "set_bh_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1451-1463",
          "snippet": "void set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid set_bh_page(struct buffer_head *bh,\n\t\tstruct page *page, unsigned long offset)\n{\n\tbh->b_page = page;\n\tBUG_ON(offset >= PAGE_SIZE);\n\tif (PageHighMem(page))\n\t\t/*\n\t\t * This catches illegal uses and preserves the offset:\n\t\t */\n\t\tbh->b_data = (char *)(0 + offset);\n\telse\n\t\tbh->b_data = page_address(page) + offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_data"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "new_page"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "tmp"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "tmp"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_data"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp",
            "mapped_data + new_offset",
            "bh_in->b_size"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "new_page"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_free",
          "args": [
            "tmp",
            "bh_in->b_size"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2299-2315",
          "snippet": "void jbd2_free(void *ptr, size_t size)\n{\n\tif (size == PAGE_SIZE) {\n\t\tfree_pages((unsigned long)ptr, 0);\n\t\treturn;\n\t}\n\tif (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tfree_pages((unsigned long)ptr, order);\n\t\telse\n\t\t\tvfree(ptr);\n\t\treturn;\n\t}\n\tkmem_cache_free(get_slab(size), ptr);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid jbd2_free(void *ptr, size_t size)\n{\n\tif (size == PAGE_SIZE) {\n\t\tfree_pages((unsigned long)ptr, 0);\n\t\treturn;\n\t}\n\tif (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tfree_pages((unsigned long)ptr, order);\n\t\telse\n\t\t\tvfree(ptr);\n\t\treturn;\n\t}\n\tkmem_cache_free(get_slab(size), ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh_in"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_alloc",
          "args": [
            "bh_in->b_size",
            "GFP_NOFS"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "2273-2297",
          "snippet": "void *jbd2_alloc(size_t size, gfp_t flags)\n{\n\tvoid *ptr;\n\n\tBUG_ON(size & (size-1)); /* Must be a power of 2 */\n\n\tflags |= __GFP_REPEAT;\n\tif (size == PAGE_SIZE)\n\t\tptr = (void *)__get_free_pages(flags, 0);\n\telse if (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tptr = (void *)__get_free_pages(flags, order);\n\t\telse\n\t\t\tptr = vmalloc(size);\n\t} else\n\t\tptr = kmem_cache_alloc(get_slab(size), flags);\n\n\t/* Check alignment; SLUB has gotten this wrong in the past,\n\t * and this can lead to user data corruption! */\n\tBUG_ON(((unsigned long) ptr) & (size-1));\n\n\treturn ptr;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid *jbd2_alloc(size_t size, gfp_t flags)\n{\n\tvoid *ptr;\n\n\tBUG_ON(size & (size-1)); /* Must be a power of 2 */\n\n\tflags |= __GFP_REPEAT;\n\tif (size == PAGE_SIZE)\n\t\tptr = (void *)__get_free_pages(flags, 0);\n\telse if (size > PAGE_SIZE) {\n\t\tint order = get_order(size);\n\n\t\tif (order < 3)\n\t\t\tptr = (void *)__get_free_pages(flags, order);\n\t\telse\n\t\t\tptr = vmalloc(size);\n\t} else\n\t\tptr = kmem_cache_alloc(get_slab(size), flags);\n\n\t/* Check alignment; SLUB has gotten this wrong in the past,\n\t * and this can lead to user data corruption! */\n\tBUG_ON(((unsigned long) ptr) & (size-1));\n\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_unlock_bh_state",
          "args": [
            "bh_in"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "mapped_data"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JBD2_MAGIC_NUMBER"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_buffer_frozen_trigger",
          "args": [
            "jh_in",
            "mapped_data + new_offset",
            "jh_in->b_triggers"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_buffer_frozen_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/transaction.c",
          "lines": "1217-1226",
          "snippet": "void jbd2_buffer_frozen_trigger(struct journal_head *jh, void *mapped_data,\n\t\t\t\tstruct jbd2_buffer_trigger_type *triggers)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (!triggers || !triggers->t_frozen)\n\t\treturn;\n\n\ttriggers->t_frozen(triggers, bh, mapped_data, bh->b_size);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/module.h>",
            "#include <linux/bug.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/timer.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);",
            "static void __jbd2_journal_unfile_buffer(struct journal_head *jh);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/module.h>\n#include <linux/bug.h>\n#include <linux/backing-dev.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh);\nstatic void __jbd2_journal_unfile_buffer(struct journal_head *jh);\n\nvoid jbd2_buffer_frozen_trigger(struct journal_head *jh, void *mapped_data,\n\t\t\t\tstruct jbd2_buffer_trigger_type *triggers)\n{\n\tstruct buffer_head *bh = jh2bh(jh);\n\n\tif (!triggers || !triggers->t_frozen)\n\t\treturn;\n\n\ttriggers->t_frozen(triggers, bh, mapped_data, bh->b_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "new_page"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "jh2bh(jh_in)->b_data"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh_in"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh_in"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "jh_in->b_frozen_data"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "jh_in->b_frozen_data"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_lock_bh_state",
          "args": [
            "bh_in"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new_bh->b_count",
            "1"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "congestion_wait",
          "args": [
            "BLK_RW_ASYNC",
            "HZ/50"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_buffer_head",
          "args": [
            "GFP_NOFS"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT_BH",
          "args": [
            "bh_in",
            "buffer_jbddirty(bh_in)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_jbddirty",
          "args": [
            "bh_in"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jh2bh",
          "args": [
            "jh_in"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint jbd2_journal_write_metadata_buffer(transaction_t *transaction,\n\t\t\t\t  struct journal_head  *jh_in,\n\t\t\t\t  struct buffer_head **bh_out,\n\t\t\t\t  sector_t blocknr)\n{\n\tint need_copy_out = 0;\n\tint done_copy_out = 0;\n\tint do_escape = 0;\n\tchar *mapped_data;\n\tstruct buffer_head *new_bh;\n\tstruct page *new_page;\n\tunsigned int new_offset;\n\tstruct buffer_head *bh_in = jh2bh(jh_in);\n\tjournal_t *journal = transaction->t_journal;\n\n\t/*\n\t * The buffer really shouldn't be locked: only the current committing\n\t * transaction is allowed to write it, so nobody else is allowed\n\t * to do any IO.\n\t *\n\t * akpm: except if we're journalling data, and write() output is\n\t * also part of a shared mapping, and another thread has\n\t * decided to launch a writepage() against this buffer.\n\t */\n\tJ_ASSERT_BH(bh_in, buffer_jbddirty(bh_in));\n\nretry_alloc:\n\tnew_bh = alloc_buffer_head(GFP_NOFS);\n\tif (!new_bh) {\n\t\t/*\n\t\t * Failure is not an option, but __GFP_NOFAIL is going\n\t\t * away; so we retry ourselves here.\n\t\t */\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t\tgoto retry_alloc;\n\t}\n\n\t/* keep subsequent assertions sane */\n\tatomic_set(&new_bh->b_count, 1);\n\n\tjbd_lock_bh_state(bh_in);\nrepeat:\n\t/*\n\t * If a new transaction has already done a buffer copy-out, then\n\t * we use that version of the data for the commit.\n\t */\n\tif (jh_in->b_frozen_data) {\n\t\tdone_copy_out = 1;\n\t\tnew_page = virt_to_page(jh_in->b_frozen_data);\n\t\tnew_offset = offset_in_page(jh_in->b_frozen_data);\n\t} else {\n\t\tnew_page = jh2bh(jh_in)->b_page;\n\t\tnew_offset = offset_in_page(jh2bh(jh_in)->b_data);\n\t}\n\n\tmapped_data = kmap_atomic(new_page);\n\t/*\n\t * Fire data frozen trigger if data already wasn't frozen.  Do this\n\t * before checking for escaping, as the trigger may modify the magic\n\t * offset.  If a copy-out happens afterwards, it will have the correct\n\t * data in the buffer.\n\t */\n\tif (!done_copy_out)\n\t\tjbd2_buffer_frozen_trigger(jh_in, mapped_data + new_offset,\n\t\t\t\t\t   jh_in->b_triggers);\n\n\t/*\n\t * Check for escaping\n\t */\n\tif (*((__be32 *)(mapped_data + new_offset)) ==\n\t\t\t\tcpu_to_be32(JBD2_MAGIC_NUMBER)) {\n\t\tneed_copy_out = 1;\n\t\tdo_escape = 1;\n\t}\n\tkunmap_atomic(mapped_data);\n\n\t/*\n\t * Do we need to do a data copy?\n\t */\n\tif (need_copy_out && !done_copy_out) {\n\t\tchar *tmp;\n\n\t\tjbd_unlock_bh_state(bh_in);\n\t\ttmp = jbd2_alloc(bh_in->b_size, GFP_NOFS);\n\t\tif (!tmp) {\n\t\t\tbrelse(new_bh);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tjbd_lock_bh_state(bh_in);\n\t\tif (jh_in->b_frozen_data) {\n\t\t\tjbd2_free(tmp, bh_in->b_size);\n\t\t\tgoto repeat;\n\t\t}\n\n\t\tjh_in->b_frozen_data = tmp;\n\t\tmapped_data = kmap_atomic(new_page);\n\t\tmemcpy(tmp, mapped_data + new_offset, bh_in->b_size);\n\t\tkunmap_atomic(mapped_data);\n\n\t\tnew_page = virt_to_page(tmp);\n\t\tnew_offset = offset_in_page(tmp);\n\t\tdone_copy_out = 1;\n\n\t\t/*\n\t\t * This isn't strictly necessary, as we're using frozen\n\t\t * data for the escaping, but it keeps consistency with\n\t\t * b_frozen_data usage.\n\t\t */\n\t\tjh_in->b_frozen_triggers = jh_in->b_triggers;\n\t}\n\n\t/*\n\t * Did we need to do an escaping?  Now we've done all the\n\t * copying, we can finally do so.\n\t */\n\tif (do_escape) {\n\t\tmapped_data = kmap_atomic(new_page);\n\t\t*((unsigned int *)(mapped_data + new_offset)) = 0;\n\t\tkunmap_atomic(mapped_data);\n\t}\n\n\tset_bh_page(new_bh, new_page, new_offset);\n\tnew_bh->b_size = bh_in->b_size;\n\tnew_bh->b_bdev = journal->j_dev;\n\tnew_bh->b_blocknr = blocknr;\n\tnew_bh->b_private = bh_in;\n\tset_buffer_mapped(new_bh);\n\tset_buffer_dirty(new_bh);\n\n\t*bh_out = new_bh;\n\n\t/*\n\t * The to-be-written buffer needs to get moved to the io queue,\n\t * and the original buffer whose contents we are shadowing or\n\t * copying is moved to the transaction's shadow queue.\n\t */\n\tJBUFFER_TRACE(jh_in, \"file as BJ_Shadow\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh_in, transaction, BJ_Shadow);\n\tspin_unlock(&journal->j_list_lock);\n\tset_buffer_shadow(bh_in);\n\tjbd_unlock_bh_state(bh_in);\n\n\treturn do_escape | (done_copy_out << 1);\n}"
  },
  {
    "function_name": "journal_kill_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "299-311",
    "snippet": "static void journal_kill_thread(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit, journal->j_task == NULL);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_wait_done_commit",
            "journal->j_task == NULL"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_commit"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void journal_kill_thread(journal_t *journal)\n{\n\twrite_lock(&journal->j_state_lock);\n\tjournal->j_flags |= JBD2_UNMOUNT;\n\n\twhile (journal->j_task) {\n\t\twrite_unlock(&journal->j_state_lock);\n\t\twake_up(&journal->j_wait_commit);\n\t\twait_event(journal->j_wait_done_commit, journal->j_task == NULL);\n\t\twrite_lock(&journal->j_state_lock);\n\t}\n\twrite_unlock(&journal->j_state_lock);\n}"
  },
  {
    "function_name": "jbd2_journal_start_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "286-297",
    "snippet": "static int jbd2_journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald2, journal, \"jbd2/%s\",\n\t\t\tjournal->j_devname);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "journal->j_wait_done_commit",
            "journal->j_task != NULL"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "t"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "t"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "kjournald2",
            "journal",
            "\"jbd2/%s\"",
            "journal->j_devname"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int jbd2_journal_start_thread(journal_t *journal)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_run(kjournald2, journal, \"jbd2/%s\",\n\t\t\tjournal->j_devname);\n\tif (IS_ERR(t))\n\t\treturn PTR_ERR(t);\n\n\twait_event(journal->j_wait_done_commit, journal->j_task != NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "kjournald2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "189-284",
    "snippet": "static int kjournald2(void *arg)\n{\n\tjournal_t *journal = arg;\n\ttransaction_t *transaction;\n\n\t/*\n\t * Set up an interval timer which can be used to trigger a commit wakeup\n\t * after the commit interval expires\n\t */\n\tsetup_timer(&journal->j_commit_timer, commit_timeout,\n\t\t\t(unsigned long)current);\n\n\tset_freezable();\n\n\t/* Record that the journal thread is running */\n\tjournal->j_task = current;\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * And now, wait forever for commit wakeup events.\n\t */\n\twrite_lock(&journal->j_state_lock);\n\nloop:\n\tif (journal->j_flags & JBD2_UNMOUNT)\n\t\tgoto end_loop;\n\n\tjbd_debug(1, \"commit_sequence=%d, commit_request=%d\\n\",\n\t\tjournal->j_commit_sequence, journal->j_commit_request);\n\n\tif (journal->j_commit_sequence != journal->j_commit_request) {\n\t\tjbd_debug(1, \"OK, requests differ\\n\");\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tdel_timer_sync(&journal->j_commit_timer);\n\t\tjbd2_journal_commit_transaction(journal);\n\t\twrite_lock(&journal->j_state_lock);\n\t\tgoto loop;\n\t}\n\n\twake_up(&journal->j_wait_done_commit);\n\tif (freezing(current)) {\n\t\t/*\n\t\t * The simpler the better. Flushing journal isn't a\n\t\t * good idea, because that depends on threads that may\n\t\t * be already stopped.\n\t\t */\n\t\tjbd_debug(1, \"Now suspending kjournald2\\n\");\n\t\twrite_unlock(&journal->j_state_lock);\n\t\ttry_to_freeze();\n\t\twrite_lock(&journal->j_state_lock);\n\t} else {\n\t\t/*\n\t\t * We assume on resume that commits are already there,\n\t\t * so we don't sleep\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\t\tint should_sleep = 1;\n\n\t\tprepare_to_wait(&journal->j_wait_commit, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (journal->j_commit_sequence != journal->j_commit_request)\n\t\t\tshould_sleep = 0;\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (transaction && time_after_eq(jiffies,\n\t\t\t\t\t\ttransaction->t_expires))\n\t\t\tshould_sleep = 0;\n\t\tif (journal->j_flags & JBD2_UNMOUNT)\n\t\t\tshould_sleep = 0;\n\t\tif (should_sleep) {\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_commit, &wait);\n\t}\n\n\tjbd_debug(1, \"kjournald2 wakes\\n\");\n\n\t/*\n\t * Were we woken up by a commit wakeup event?\n\t */\n\ttransaction = journal->j_running_transaction;\n\tif (transaction && time_after_eq(jiffies, transaction->t_expires)) {\n\t\tjournal->j_commit_request = transaction->t_tid;\n\t\tjbd_debug(1, \"woke because of timeout\\n\");\n\t}\n\tgoto loop;\n\nend_loop:\n\twrite_unlock(&journal->j_state_lock);\n\tdel_timer_sync(&journal->j_commit_timer);\n\tjournal->j_task = NULL;\n\twake_up(&journal->j_wait_done_commit);\n\tjbd_debug(1, \"Journal thread exiting.\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Journal thread exiting.\\n\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&journal->j_wait_done_commit"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&journal->j_commit_timer"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"woke because of timeout\\n\""
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "transaction->t_expires"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"kjournald2 wakes\\n\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "finish_wait",
          "args": [
            "&journal->j_wait_commit",
            "&wait"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&journal->j_state_lock"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "transaction->t_expires"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_to_wait",
          "args": [
            "&journal->j_wait_commit",
            "&wait",
            "TASK_INTERRUPTIBLE"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_WAIT",
          "args": [
            "wait"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Now suspending kjournald2\\n\""
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_journal_commit_transaction",
          "args": [
            "journal"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_journal_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/commit.c",
          "lines": "370-1164",
          "snippet": "void jbd2_journal_commit_transaction(journal_t *journal)\n{\n\tstruct transaction_stats_s stats;\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh;\n\tstruct buffer_head *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned long long blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tint tag_bytes = journal_tag_bytes(journal);\n\tstruct buffer_head *cbh = NULL; /* For transactional checksums */\n\t__u32 crc32_sum = ~0;\n\tstruct blk_plug plug;\n\t/* Tail of the journal */\n\tunsigned long first_block;\n\ttid_t first_tid;\n\tint update_tail;\n\tint csum_size = 0;\n\tLIST_HEAD(io_bufs);\n\tLIST_HEAD(log_bufs);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior jbd2_journal_flush? */\n\tif (journal->j_flags & JBD2_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd2_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd2_commit_locking(journal, commit_transaction);\n\tstats.run.rs_wait = commit_transaction->t_max_wait;\n\tstats.run.rs_request_delay = 0;\n\tstats.run.rs_locked = jiffies;\n\tif (commit_transaction->t_requested)\n\t\tstats.run.rs_request_delay =\n\t\t\tjbd2_time_diff(commit_transaction->t_requested,\n\t\t\t\t       stats.run.rs_locked);\n\tstats.run.rs_running = jbd2_time_diff(commit_transaction->t_start,\n\t\t\t\t\t      stats.run.rs_locked);\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a jbd2_journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple jbd2_journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A jbd2_journal_get_undo_access()+jbd2_journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjbd2_journal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjbd2_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjbd2_journal_switch_revoke_table(journal);\n\n\t/*\n\t * Reserved credits cannot be claimed anymore, free them\n\t */\n\tatomic_sub(atomic_read(&journal->j_reserved_credits),\n\t\t   &commit_transaction->t_outstanding_credits);\n\n\ttrace_jbd2_commit_flushing(journal, commit_transaction);\n\tstats.run.rs_flushing = jiffies;\n\tstats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,\n\t\t\t\t\t     stats.run.rs_flushing);\n\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\twrite_unlock(&journal->j_state_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 2a\\n\");\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\terr = journal_submit_data_buffers(journal, commit_transaction);\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tblk_start_plug(&plug);\n\tjbd2_journal_write_revoke_records(journal, commit_transaction,\n\t\t\t\t\t  &log_bufs, WRITE_SYNC);\n\n\tjbd_debug(3, \"JBD2: commit phase 2b\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\twrite_unlock(&journal->j_state_lock);\n\n\ttrace_jbd2_commit_logging(journal, commit_transaction);\n\tstats.run.rs_logging = jiffies;\n\tstats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,\n\t\t\t\t\t       stats.run.rs_logging);\n\tstats.run.rs_blocks =\n\t\tatomic_read(&commit_transaction->t_outstanding_credits);\n\tstats.run.rs_blocks_logged = 0;\n\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t atomic_read(&commit_transaction->t_outstanding_credits));\n\n\terr = 0;\n\tbufs = 0;\n\tdescriptor = NULL;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjbd2_buffer_abort_trigger(jh,\n\t\t\t\t\t\t  jh->b_frozen_data ?\n\t\t\t\t\t\t  jh->b_frozen_triggers :\n\t\t\t\t\t\t  jh->b_triggers);\n\t\t\tjbd2_journal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD2: get descriptor\\n\");\n\n\t\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjbd2_journal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tjbd_debug(4, \"JBD2: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)descriptor->b_blocknr,\n\t\t\t\tdescriptor->b_data);\n\t\t\theader = (journal_header_t *)descriptor->b_data;\n\t\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JBD2_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &descriptor->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = descriptor->b_size -\n\t\t\t\t\t\tsizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(descriptor);\n\t\t\tset_buffer_dirty(descriptor);\n\t\t\twbuf[bufs++] = descriptor;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(descriptor, \"ph3: file as descriptor\");\n\t\t\tjbd2_file_log_bh(&log_bufs, descriptor);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjbd2_journal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by jbd2_journal_next_log_block() also.\n\t\t */\n\t\tatomic_dec(&commit_transaction->t_outstanding_credits);\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the shadow pairing of buffers. */\n\t\tatomic_inc(&jh2bh(jh)->b_count);\n\n\t\t/*\n\t\t * Make a temporary IO buffer with which to write it out\n\t\t * (this will requeue the metadata buffer to BJ_Shadow).\n\t\t */\n\t\tset_bit(BH_JWrite, &jh2bh(jh)->b_state);\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = jbd2_journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\tjh, &wbuf[bufs], blocknr);\n\t\tif (flags < 0) {\n\t\t\tjbd2_journal_abort(journal, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tjbd2_file_log_bh(&io_bufs, wbuf[bufs]);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JBD2_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JBD2_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\twrite_tag_block(journal, tag, jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be16(tag_flag);\n\t\tjbd2_block_tag_csum_set(journal, tag, wbuf[bufs],\n\t\t\t\t\tcommit_transaction->t_tid);\n\t\ttagp += tag_bytes;\n\t\tspace_left -= tag_bytes;\n\t\tbufs++;\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < tag_bytes + 16 + csum_size) {\n\n\t\t\tjbd_debug(4, \"JBD2: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be16(JBD2_FLAG_LAST_TAG);\n\n\t\t\tjbd2_descr_block_csum_set(journal, descriptor);\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\t/*\n\t\t\t\t * Compute checksum.\n\t\t\t\t */\n\t\t\t\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\t\tcrc32_sum =\n\t\t\t\t\t    jbd2_checksum_data(crc32_sum, bh);\n\t\t\t\t}\n\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\tsubmit_bh(WRITE_SYNC, bh);\n\t\t\t}\n\t\t\tcond_resched();\n\t\t\tstats.run.rs_blocks_logged += bufs;\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\terr = journal_finish_inode_data_buffers(journal, commit_transaction);\n\tif (err) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Detected IO errors while flushing file data \"\n\t\t       \"on %s\\n\", journal->j_devname);\n\t\tif (journal->j_flags & JBD2_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjbd2_journal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\t/*\n\t * Get current oldest transaction in the log before we issue flush\n\t * to the filesystem device. After the flush we can be sure that\n\t * blocks of all older transactions are checkpointed to persistent\n\t * storage and we will be safe to update journal start in the\n\t * superblock with the numbers we get here.\n\t */\n\tupdate_tail =\n\t\tjbd2_journal_get_log_tail(journal, &first_tid, &first_block);\n\n\twrite_lock(&journal->j_state_lock);\n\tif (update_tail) {\n\t\tlong freed = first_block - journal->j_tail;\n\n\t\tif (first_block < journal->j_tail)\n\t\t\tfreed += journal->j_last - journal->j_first;\n\t\t/* Update tail only if we free significant amount of space */\n\t\tif (freed < journal->j_maxlen / 4)\n\t\t\tupdate_tail = 0;\n\t}\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_DFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\t/* \n\t * If the journal is not located on the file system device,\n\t * then we must flush the file system device before we issue\n\t * the commit record\n\t */\n\tif (commit_transaction->t_need_data_flush &&\n\t    (journal->j_fs_dev != journal->j_dev) &&\n\t    (journal->j_flags & JBD2_BARRIER))\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\n\n\t/* Done it all: now write the commit record asynchronously. */\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t &cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the io_bufs list.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD2: commit phase 3\\n\");\n\n\twhile (!list_empty(&io_bufs)) {\n\t\tstruct buffer_head *bh = list_entry(io_bufs.prev,\n\t\t\t\t\t\t    struct buffer_head,\n\t\t\t\t\t\t    b_assoc_buffers);\n\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\t\tjbd2_unfile_log_bh(bh);\n\n\t\t/*\n\t\t * The list contains temporary buffer heads created by\n\t\t * jbd2_journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to refile the corresponding shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\t\tJ_ASSERT_BH(bh, !buffer_shadow(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjbd2_journal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD2: commit phase 4\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n\twhile (!list_empty(&log_bufs)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjbd2_unfile_log_bh(bh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD2: commit phase 5\\n\");\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_DFLUSH);\n\tcommit_transaction->t_state = T_COMMIT_JFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t&cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\tif (cbh)\n\t\terr = journal_wait_on_commit_record(journal, cbh);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT) &&\n\t    journal->j_flags & JBD2_BARRIER) {\n\t\tblkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\t/*\n\t * Now disk caches for filesystem device are flushed so we are safe to\n\t * erase checkpointed transactions from the log by updating journal\n\t * superblock.\n\t */\n\tif (update_tail)\n\t\tjbd2_update_log_tail(journal, first_tid, first_block);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD2: commit phase 6\\n\");\n\n\tJ_ASSERT(list_empty(&commit_transaction->t_inode_list));\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t *\n\t\t * We also know that the frozen data has already fired\n\t\t * its triggers if they exist, so we can clear that too.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t\tjh->b_frozen_triggers = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t\tjh->b_frozen_triggers = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\tcp_transaction->t_chp_stats.cs_dropped++;\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by jbd2_journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t* A buffer which has been freed while still being journaled by\n\t\t* a previous transaction.\n\t\t*/\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather through in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__jbd2_journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile buffer\");\n\t\t__jbd2_journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\t/* Drops bh reference */\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __jbd2_journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Add the transaction to the checkpoint list\n\t * __journal_remove_checkpoint() can not destroy transaction\n\t * under us because it is not marked as T_FINISHED yet */\n\tif (journal->j_checkpoint_transactions == NULL) {\n\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t} else {\n\t\tcommit_transaction->t_cpnext =\n\t\t\tjournal->j_checkpoint_transactions;\n\t\tcommit_transaction->t_cpprev =\n\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\tcommit_transaction;\n\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD2: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_JFLUSH);\n\n\tcommit_transaction->t_start = jiffies;\n\tstats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,\n\t\t\t\t\t      commit_transaction->t_start);\n\n\t/*\n\t * File the transaction statistics\n\t */\n\tstats.ts_tid = commit_transaction->t_tid;\n\tstats.run.rs_handle_count =\n\t\tatomic_read(&commit_transaction->t_handle_count);\n\ttrace_jbd2_run_stats(journal->j_fs_dev->bd_dev,\n\t\t\t     commit_transaction->t_tid, &stats.run);\n\tstats.ts_requested = (commit_transaction->t_requested) ? 1 : 0;\n\n\tcommit_transaction->t_state = T_COMMIT_CALLBACK;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in the commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time +\n\t\t\t\tjournal->j_average_commit_time*3) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (journal->j_commit_callback)\n\t\tjournal->j_commit_callback(journal, commit_transaction);\n\n\ttrace_jbd2_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tcommit_transaction->t_state = T_FINISHED;\n\t/* Check if the transaction can be dropped now that we are finished */\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__jbd2_journal_drop_transaction(journal, commit_transaction);\n\t\tjbd2_journal_free_transaction(commit_transaction);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * Calculate overall stats\n\t */\n\tspin_lock(&journal->j_history_lock);\n\tjournal->j_stats.ts_tid++;\n\tjournal->j_stats.ts_requested += stats.ts_requested;\n\tjournal->j_stats.run.rs_wait += stats.run.rs_wait;\n\tjournal->j_stats.run.rs_request_delay += stats.run.rs_request_delay;\n\tjournal->j_stats.run.rs_running += stats.run.rs_running;\n\tjournal->j_stats.run.rs_locked += stats.run.rs_locked;\n\tjournal->j_stats.run.rs_flushing += stats.run.rs_flushing;\n\tjournal->j_stats.run.rs_logging += stats.run.rs_logging;\n\tjournal->j_stats.run.rs_handle_count += stats.run.rs_handle_count;\n\tjournal->j_stats.run.rs_blocks += stats.run.rs_blocks;\n\tjournal->j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;\n\tspin_unlock(&journal->j_history_lock);\n}",
          "includes": [
            "#include <trace/events/jbd2.h>",
            "#include <linux/bitops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/crc32.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/jbd2.h>\n#include <linux/bitops.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/crc32.h>\n#include <linux/jiffies.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n\nvoid jbd2_journal_commit_transaction(journal_t *journal)\n{\n\tstruct transaction_stats_s stats;\n\ttransaction_t *commit_transaction;\n\tstruct journal_head *jh;\n\tstruct buffer_head *descriptor;\n\tstruct buffer_head **wbuf = journal->j_wbuf;\n\tint bufs;\n\tint flags;\n\tint err;\n\tunsigned long long blocknr;\n\tktime_t start_time;\n\tu64 commit_time;\n\tchar *tagp = NULL;\n\tjournal_header_t *header;\n\tjournal_block_tag_t *tag = NULL;\n\tint space_left = 0;\n\tint first_tag = 0;\n\tint tag_flag;\n\tint i;\n\tint tag_bytes = journal_tag_bytes(journal);\n\tstruct buffer_head *cbh = NULL; /* For transactional checksums */\n\t__u32 crc32_sum = ~0;\n\tstruct blk_plug plug;\n\t/* Tail of the journal */\n\tunsigned long first_block;\n\ttid_t first_tid;\n\tint update_tail;\n\tint csum_size = 0;\n\tLIST_HEAD(io_bufs);\n\tLIST_HEAD(log_bufs);\n\n\tif (jbd2_journal_has_csum_v2or3(journal))\n\t\tcsum_size = sizeof(struct jbd2_journal_block_tail);\n\n\t/*\n\t * First job: lock down the current transaction and wait for\n\t * all outstanding updates to complete.\n\t */\n\n\t/* Do we need to erase the effects of a prior jbd2_journal_flush? */\n\tif (journal->j_flags & JBD2_FLUSHED) {\n\t\tjbd_debug(3, \"super block updated\\n\");\n\t\tmutex_lock(&journal->j_checkpoint_mutex);\n\t\t/*\n\t\t * We hold j_checkpoint_mutex so tail cannot change under us.\n\t\t * We don't need any special data guarantees for writing sb\n\t\t * since journal is empty and it is ok for write to be\n\t\t * flushed only with transaction commit.\n\t\t */\n\t\tjbd2_journal_update_sb_log_tail(journal,\n\t\t\t\t\t\tjournal->j_tail_sequence,\n\t\t\t\t\t\tjournal->j_tail,\n\t\t\t\t\t\tWRITE_SYNC);\n\t\tmutex_unlock(&journal->j_checkpoint_mutex);\n\t} else {\n\t\tjbd_debug(3, \"superblock not updated\\n\");\n\t}\n\n\tJ_ASSERT(journal->j_running_transaction != NULL);\n\tJ_ASSERT(journal->j_committing_transaction == NULL);\n\n\tcommit_transaction = journal->j_running_transaction;\n\n\ttrace_jbd2_start_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: starting commit of transaction %d\\n\",\n\t\t\tcommit_transaction->t_tid);\n\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_RUNNING);\n\tcommit_transaction->t_state = T_LOCKED;\n\n\ttrace_jbd2_commit_locking(journal, commit_transaction);\n\tstats.run.rs_wait = commit_transaction->t_max_wait;\n\tstats.run.rs_request_delay = 0;\n\tstats.run.rs_locked = jiffies;\n\tif (commit_transaction->t_requested)\n\t\tstats.run.rs_request_delay =\n\t\t\tjbd2_time_diff(commit_transaction->t_requested,\n\t\t\t\t       stats.run.rs_locked);\n\tstats.run.rs_running = jbd2_time_diff(commit_transaction->t_start,\n\t\t\t\t\t      stats.run.rs_locked);\n\n\tspin_lock(&commit_transaction->t_handle_lock);\n\twhile (atomic_read(&commit_transaction->t_updates)) {\n\t\tDEFINE_WAIT(wait);\n\n\t\tprepare_to_wait(&journal->j_wait_updates, &wait,\n\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (atomic_read(&commit_transaction->t_updates)) {\n\t\t\tspin_unlock(&commit_transaction->t_handle_lock);\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t\tspin_lock(&commit_transaction->t_handle_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_updates, &wait);\n\t}\n\tspin_unlock(&commit_transaction->t_handle_lock);\n\n\tJ_ASSERT (atomic_read(&commit_transaction->t_outstanding_credits) <=\n\t\t\tjournal->j_max_transaction_buffers);\n\n\t/*\n\t * First thing we are allowed to do is to discard any remaining\n\t * BJ_Reserved buffers.  Note, it is _not_ permissible to assume\n\t * that there are no such buffers: if a large filesystem\n\t * operation like a truncate needs to split itself over multiple\n\t * transactions, then it may try to do a jbd2_journal_restart() while\n\t * there are still BJ_Reserved buffers outstanding.  These must\n\t * be released cleanly from the current transaction.\n\t *\n\t * In this case, the filesystem must still reserve write access\n\t * again before modifying the buffer in the new transaction, but\n\t * we do not require it to remember exactly which old buffers it\n\t * has reserved.  This is consistent with the existing behaviour\n\t * that multiple jbd2_journal_get_write_access() calls to the same\n\t * buffer are perfectly permissible.\n\t */\n\twhile (commit_transaction->t_reserved_list) {\n\t\tjh = commit_transaction->t_reserved_list;\n\t\tJBUFFER_TRACE(jh, \"reserved, unused: refile\");\n\t\t/*\n\t\t * A jbd2_journal_get_undo_access()+jbd2_journal_release_buffer() may\n\t\t * leave undo-committed data.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tstruct buffer_head *bh = jh2bh(jh);\n\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tjbd2_journal_refile_buffer(journal, jh);\n\t}\n\n\t/*\n\t * Now try to drop any written-back buffers from the journal's\n\t * checkpoint lists.  We do this *before* commit because it potentially\n\t * frees some memory\n\t */\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_clean_checkpoint_list(journal);\n\tspin_unlock(&journal->j_list_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 1\\n\");\n\n\t/*\n\t * Clear revoked flag to reflect there is no revoked buffers\n\t * in the next transaction which is going to be started.\n\t */\n\tjbd2_clear_buffer_revoked_flags(journal);\n\n\t/*\n\t * Switch to a new revoke table.\n\t */\n\tjbd2_journal_switch_revoke_table(journal);\n\n\t/*\n\t * Reserved credits cannot be claimed anymore, free them\n\t */\n\tatomic_sub(atomic_read(&journal->j_reserved_credits),\n\t\t   &commit_transaction->t_outstanding_credits);\n\n\ttrace_jbd2_commit_flushing(journal, commit_transaction);\n\tstats.run.rs_flushing = jiffies;\n\tstats.run.rs_locked = jbd2_time_diff(stats.run.rs_locked,\n\t\t\t\t\t     stats.run.rs_flushing);\n\n\tcommit_transaction->t_state = T_FLUSH;\n\tjournal->j_committing_transaction = commit_transaction;\n\tjournal->j_running_transaction = NULL;\n\tstart_time = ktime_get();\n\tcommit_transaction->t_log_start = journal->j_head;\n\twake_up(&journal->j_wait_transaction_locked);\n\twrite_unlock(&journal->j_state_lock);\n\n\tjbd_debug(3, \"JBD2: commit phase 2a\\n\");\n\n\t/*\n\t * Now start flushing things to disk, in the order they appear\n\t * on the transaction lists.  Data blocks go first.\n\t */\n\terr = journal_submit_data_buffers(journal, commit_transaction);\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tblk_start_plug(&plug);\n\tjbd2_journal_write_revoke_records(journal, commit_transaction,\n\t\t\t\t\t  &log_bufs, WRITE_SYNC);\n\n\tjbd_debug(3, \"JBD2: commit phase 2b\\n\");\n\n\t/*\n\t * Way to go: we have now written out all of the data for a\n\t * transaction!  Now comes the tricky part: we need to write out\n\t * metadata.  Loop over the transaction's entire buffer list:\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tcommit_transaction->t_state = T_COMMIT;\n\twrite_unlock(&journal->j_state_lock);\n\n\ttrace_jbd2_commit_logging(journal, commit_transaction);\n\tstats.run.rs_logging = jiffies;\n\tstats.run.rs_flushing = jbd2_time_diff(stats.run.rs_flushing,\n\t\t\t\t\t       stats.run.rs_logging);\n\tstats.run.rs_blocks =\n\t\tatomic_read(&commit_transaction->t_outstanding_credits);\n\tstats.run.rs_blocks_logged = 0;\n\n\tJ_ASSERT(commit_transaction->t_nr_buffers <=\n\t\t atomic_read(&commit_transaction->t_outstanding_credits));\n\n\terr = 0;\n\tbufs = 0;\n\tdescriptor = NULL;\n\twhile (commit_transaction->t_buffers) {\n\n\t\t/* Find the next buffer to be journaled... */\n\n\t\tjh = commit_transaction->t_buffers;\n\n\t\t/* If we're in abort mode, we just un-journal the buffer and\n\t\t   release it. */\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tclear_buffer_jbddirty(jh2bh(jh));\n\t\t\tJBUFFER_TRACE(jh, \"journal is aborting: refile\");\n\t\t\tjbd2_buffer_abort_trigger(jh,\n\t\t\t\t\t\t  jh->b_frozen_data ?\n\t\t\t\t\t\t  jh->b_frozen_triggers :\n\t\t\t\t\t\t  jh->b_triggers);\n\t\t\tjbd2_journal_refile_buffer(journal, jh);\n\t\t\t/* If that was the last one, we need to clean up\n\t\t\t * any descriptor buffers which may have been\n\t\t\t * already allocated, even if we are now\n\t\t\t * aborting. */\n\t\t\tif (!commit_transaction->t_buffers)\n\t\t\t\tgoto start_journal_io;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Make sure we have a descriptor block in which to\n\t\t   record the metadata buffer. */\n\n\t\tif (!descriptor) {\n\t\t\tJ_ASSERT (bufs == 0);\n\n\t\t\tjbd_debug(4, \"JBD2: get descriptor\\n\");\n\n\t\t\tdescriptor = jbd2_journal_get_descriptor_buffer(journal);\n\t\t\tif (!descriptor) {\n\t\t\t\tjbd2_journal_abort(journal, -EIO);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tjbd_debug(4, \"JBD2: got buffer %llu (%p)\\n\",\n\t\t\t\t(unsigned long long)descriptor->b_blocknr,\n\t\t\t\tdescriptor->b_data);\n\t\t\theader = (journal_header_t *)descriptor->b_data;\n\t\t\theader->h_magic     = cpu_to_be32(JBD2_MAGIC_NUMBER);\n\t\t\theader->h_blocktype = cpu_to_be32(JBD2_DESCRIPTOR_BLOCK);\n\t\t\theader->h_sequence  = cpu_to_be32(commit_transaction->t_tid);\n\n\t\t\ttagp = &descriptor->b_data[sizeof(journal_header_t)];\n\t\t\tspace_left = descriptor->b_size -\n\t\t\t\t\t\tsizeof(journal_header_t);\n\t\t\tfirst_tag = 1;\n\t\t\tset_buffer_jwrite(descriptor);\n\t\t\tset_buffer_dirty(descriptor);\n\t\t\twbuf[bufs++] = descriptor;\n\n\t\t\t/* Record it so that we can wait for IO\n                           completion later */\n\t\t\tBUFFER_TRACE(descriptor, \"ph3: file as descriptor\");\n\t\t\tjbd2_file_log_bh(&log_bufs, descriptor);\n\t\t}\n\n\t\t/* Where is the buffer to be written? */\n\n\t\terr = jbd2_journal_next_log_block(journal, &blocknr);\n\t\t/* If the block mapping failed, just abandon the buffer\n\t\t   and repeat this loop: we'll fall into the\n\t\t   refile-on-abort condition above. */\n\t\tif (err) {\n\t\t\tjbd2_journal_abort(journal, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * start_this_handle() uses t_outstanding_credits to determine\n\t\t * the free space in the log, but this counter is changed\n\t\t * by jbd2_journal_next_log_block() also.\n\t\t */\n\t\tatomic_dec(&commit_transaction->t_outstanding_credits);\n\n\t\t/* Bump b_count to prevent truncate from stumbling over\n                   the shadowed buffer!  @@@ This can go if we ever get\n                   rid of the shadow pairing of buffers. */\n\t\tatomic_inc(&jh2bh(jh)->b_count);\n\n\t\t/*\n\t\t * Make a temporary IO buffer with which to write it out\n\t\t * (this will requeue the metadata buffer to BJ_Shadow).\n\t\t */\n\t\tset_bit(BH_JWrite, &jh2bh(jh)->b_state);\n\t\tJBUFFER_TRACE(jh, \"ph3: write metadata\");\n\t\tflags = jbd2_journal_write_metadata_buffer(commit_transaction,\n\t\t\t\t\t\tjh, &wbuf[bufs], blocknr);\n\t\tif (flags < 0) {\n\t\t\tjbd2_journal_abort(journal, flags);\n\t\t\tcontinue;\n\t\t}\n\t\tjbd2_file_log_bh(&io_bufs, wbuf[bufs]);\n\n\t\t/* Record the new block's tag in the current descriptor\n                   buffer */\n\n\t\ttag_flag = 0;\n\t\tif (flags & 1)\n\t\t\ttag_flag |= JBD2_FLAG_ESCAPE;\n\t\tif (!first_tag)\n\t\t\ttag_flag |= JBD2_FLAG_SAME_UUID;\n\n\t\ttag = (journal_block_tag_t *) tagp;\n\t\twrite_tag_block(journal, tag, jh2bh(jh)->b_blocknr);\n\t\ttag->t_flags = cpu_to_be16(tag_flag);\n\t\tjbd2_block_tag_csum_set(journal, tag, wbuf[bufs],\n\t\t\t\t\tcommit_transaction->t_tid);\n\t\ttagp += tag_bytes;\n\t\tspace_left -= tag_bytes;\n\t\tbufs++;\n\n\t\tif (first_tag) {\n\t\t\tmemcpy (tagp, journal->j_uuid, 16);\n\t\t\ttagp += 16;\n\t\t\tspace_left -= 16;\n\t\t\tfirst_tag = 0;\n\t\t}\n\n\t\t/* If there's no more to do, or if the descriptor is full,\n\t\t   let the IO rip! */\n\n\t\tif (bufs == journal->j_wbufsize ||\n\t\t    commit_transaction->t_buffers == NULL ||\n\t\t    space_left < tag_bytes + 16 + csum_size) {\n\n\t\t\tjbd_debug(4, \"JBD2: Submit %d IOs\\n\", bufs);\n\n\t\t\t/* Write an end-of-descriptor marker before\n                           submitting the IOs.  \"tag\" still points to\n                           the last tag we set up. */\n\n\t\t\ttag->t_flags |= cpu_to_be16(JBD2_FLAG_LAST_TAG);\n\n\t\t\tjbd2_descr_block_csum_set(journal, descriptor);\nstart_journal_io:\n\t\t\tfor (i = 0; i < bufs; i++) {\n\t\t\t\tstruct buffer_head *bh = wbuf[i];\n\t\t\t\t/*\n\t\t\t\t * Compute checksum.\n\t\t\t\t */\n\t\t\t\tif (JBD2_HAS_COMPAT_FEATURE(journal,\n\t\t\t\t\tJBD2_FEATURE_COMPAT_CHECKSUM)) {\n\t\t\t\t\tcrc32_sum =\n\t\t\t\t\t    jbd2_checksum_data(crc32_sum, bh);\n\t\t\t\t}\n\n\t\t\t\tlock_buffer(bh);\n\t\t\t\tclear_buffer_dirty(bh);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tbh->b_end_io = journal_end_buffer_io_sync;\n\t\t\t\tsubmit_bh(WRITE_SYNC, bh);\n\t\t\t}\n\t\t\tcond_resched();\n\t\t\tstats.run.rs_blocks_logged += bufs;\n\n\t\t\t/* Force a new descriptor to be generated next\n                           time round the loop. */\n\t\t\tdescriptor = NULL;\n\t\t\tbufs = 0;\n\t\t}\n\t}\n\n\terr = journal_finish_inode_data_buffers(journal, commit_transaction);\n\tif (err) {\n\t\tprintk(KERN_WARNING\n\t\t\t\"JBD2: Detected IO errors while flushing file data \"\n\t\t       \"on %s\\n\", journal->j_devname);\n\t\tif (journal->j_flags & JBD2_ABORT_ON_SYNCDATA_ERR)\n\t\t\tjbd2_journal_abort(journal, err);\n\t\terr = 0;\n\t}\n\n\t/*\n\t * Get current oldest transaction in the log before we issue flush\n\t * to the filesystem device. After the flush we can be sure that\n\t * blocks of all older transactions are checkpointed to persistent\n\t * storage and we will be safe to update journal start in the\n\t * superblock with the numbers we get here.\n\t */\n\tupdate_tail =\n\t\tjbd2_journal_get_log_tail(journal, &first_tid, &first_block);\n\n\twrite_lock(&journal->j_state_lock);\n\tif (update_tail) {\n\t\tlong freed = first_block - journal->j_tail;\n\n\t\tif (first_block < journal->j_tail)\n\t\t\tfreed += journal->j_last - journal->j_first;\n\t\t/* Update tail only if we free significant amount of space */\n\t\tif (freed < journal->j_maxlen / 4)\n\t\t\tupdate_tail = 0;\n\t}\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT);\n\tcommit_transaction->t_state = T_COMMIT_DFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\t/* \n\t * If the journal is not located on the file system device,\n\t * then we must flush the file system device before we issue\n\t * the commit record\n\t */\n\tif (commit_transaction->t_need_data_flush &&\n\t    (journal->j_fs_dev != journal->j_dev) &&\n\t    (journal->j_flags & JBD2_BARRIER))\n\t\tblkdev_issue_flush(journal->j_fs_dev, GFP_NOFS, NULL);\n\n\t/* Done it all: now write the commit record asynchronously. */\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t &cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\n\tblk_finish_plug(&plug);\n\n\t/* Lo and behold: we have just managed to send a transaction to\n           the log.  Before we can commit it, wait for the IO so far to\n           complete.  Control buffers being written are on the\n           transaction's t_log_list queue, and metadata buffers are on\n           the io_bufs list.\n\n\t   Wait for the buffers in reverse order.  That way we are\n\t   less likely to be woken up until all IOs have completed, and\n\t   so we incur less scheduling load.\n\t*/\n\n\tjbd_debug(3, \"JBD2: commit phase 3\\n\");\n\n\twhile (!list_empty(&io_bufs)) {\n\t\tstruct buffer_head *bh = list_entry(io_bufs.prev,\n\t\t\t\t\t\t    struct buffer_head,\n\t\t\t\t\t\t    b_assoc_buffers);\n\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\t\tjbd2_unfile_log_bh(bh);\n\n\t\t/*\n\t\t * The list contains temporary buffer heads created by\n\t\t * jbd2_journal_write_metadata_buffer().\n\t\t */\n\t\tBUFFER_TRACE(bh, \"dumping temporary bh\");\n\t\t__brelse(bh);\n\t\tJ_ASSERT_BH(bh, atomic_read(&bh->b_count) == 0);\n\t\tfree_buffer_head(bh);\n\n\t\t/* We also have to refile the corresponding shadowed buffer */\n\t\tjh = commit_transaction->t_shadow_list->b_tprev;\n\t\tbh = jh2bh(jh);\n\t\tclear_buffer_jwrite(bh);\n\t\tJ_ASSERT_BH(bh, buffer_jbddirty(bh));\n\t\tJ_ASSERT_BH(bh, !buffer_shadow(bh));\n\n\t\t/* The metadata is now released for reuse, but we need\n                   to remember it against this transaction so that when\n                   we finally commit, we can do any checkpointing\n                   required. */\n\t\tJBUFFER_TRACE(jh, \"file as BJ_Forget\");\n\t\tjbd2_journal_file_buffer(jh, commit_transaction, BJ_Forget);\n\t\tJBUFFER_TRACE(jh, \"brelse shadowed buffer\");\n\t\t__brelse(bh);\n\t}\n\n\tJ_ASSERT (commit_transaction->t_shadow_list == NULL);\n\n\tjbd_debug(3, \"JBD2: commit phase 4\\n\");\n\n\t/* Here we wait for the revoke record and descriptor record buffers */\n\twhile (!list_empty(&log_bufs)) {\n\t\tstruct buffer_head *bh;\n\n\t\tbh = list_entry(log_bufs.prev, struct buffer_head, b_assoc_buffers);\n\t\twait_on_buffer(bh);\n\t\tcond_resched();\n\n\t\tif (unlikely(!buffer_uptodate(bh)))\n\t\t\terr = -EIO;\n\n\t\tBUFFER_TRACE(bh, \"ph5: control buffer writeout done: unfile\");\n\t\tclear_buffer_jwrite(bh);\n\t\tjbd2_unfile_log_bh(bh);\n\t\t__brelse(bh);\t\t/* One for getblk */\n\t\t/* AKPM: bforget here */\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\tjbd_debug(3, \"JBD2: commit phase 5\\n\");\n\twrite_lock(&journal->j_state_lock);\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_DFLUSH);\n\tcommit_transaction->t_state = T_COMMIT_JFLUSH;\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (!JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t       JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT)) {\n\t\terr = journal_submit_commit_record(journal, commit_transaction,\n\t\t\t\t\t\t&cbh, crc32_sum);\n\t\tif (err)\n\t\t\t__jbd2_journal_abort_hard(journal);\n\t}\n\tif (cbh)\n\t\terr = journal_wait_on_commit_record(journal, cbh);\n\tif (JBD2_HAS_INCOMPAT_FEATURE(journal,\n\t\t\t\t      JBD2_FEATURE_INCOMPAT_ASYNC_COMMIT) &&\n\t    journal->j_flags & JBD2_BARRIER) {\n\t\tblkdev_issue_flush(journal->j_dev, GFP_NOFS, NULL);\n\t}\n\n\tif (err)\n\t\tjbd2_journal_abort(journal, err);\n\n\t/*\n\t * Now disk caches for filesystem device are flushed so we are safe to\n\t * erase checkpointed transactions from the log by updating journal\n\t * superblock.\n\t */\n\tif (update_tail)\n\t\tjbd2_update_log_tail(journal, first_tid, first_block);\n\n\t/* End of a transaction!  Finally, we can do checkpoint\n           processing: any buffers committed as a result of this\n           transaction can be removed from any checkpoint list it was on\n           before. */\n\n\tjbd_debug(3, \"JBD2: commit phase 6\\n\");\n\n\tJ_ASSERT(list_empty(&commit_transaction->t_inode_list));\n\tJ_ASSERT(commit_transaction->t_buffers == NULL);\n\tJ_ASSERT(commit_transaction->t_checkpoint_list == NULL);\n\tJ_ASSERT(commit_transaction->t_shadow_list == NULL);\n\nrestart_loop:\n\t/*\n\t * As there are other places (journal_unmap_buffer()) adding buffers\n\t * to this list we have to be careful and hold the j_list_lock.\n\t */\n\tspin_lock(&journal->j_list_lock);\n\twhile (commit_transaction->t_forget) {\n\t\ttransaction_t *cp_transaction;\n\t\tstruct buffer_head *bh;\n\t\tint try_to_free = 0;\n\n\t\tjh = commit_transaction->t_forget;\n\t\tspin_unlock(&journal->j_list_lock);\n\t\tbh = jh2bh(jh);\n\t\t/*\n\t\t * Get a reference so that bh cannot be freed before we are\n\t\t * done with it.\n\t\t */\n\t\tget_bh(bh);\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh,\tjh->b_transaction == commit_transaction);\n\n\t\t/*\n\t\t * If there is undo-protected committed data against\n\t\t * this buffer, then we can remove it now.  If it is a\n\t\t * buffer needing such protection, the old frozen_data\n\t\t * field now points to a committed version of the\n\t\t * buffer, so rotate that field to the new committed\n\t\t * data.\n\t\t *\n\t\t * Otherwise, we can just throw away the frozen data now.\n\t\t *\n\t\t * We also know that the frozen data has already fired\n\t\t * its triggers if they exist, so we can clear that too.\n\t\t */\n\t\tif (jh->b_committed_data) {\n\t\t\tjbd2_free(jh->b_committed_data, bh->b_size);\n\t\t\tjh->b_committed_data = NULL;\n\t\t\tif (jh->b_frozen_data) {\n\t\t\t\tjh->b_committed_data = jh->b_frozen_data;\n\t\t\t\tjh->b_frozen_data = NULL;\n\t\t\t\tjh->b_frozen_triggers = NULL;\n\t\t\t}\n\t\t} else if (jh->b_frozen_data) {\n\t\t\tjbd2_free(jh->b_frozen_data, bh->b_size);\n\t\t\tjh->b_frozen_data = NULL;\n\t\t\tjh->b_frozen_triggers = NULL;\n\t\t}\n\n\t\tspin_lock(&journal->j_list_lock);\n\t\tcp_transaction = jh->b_cp_transaction;\n\t\tif (cp_transaction) {\n\t\t\tJBUFFER_TRACE(jh, \"remove from old cp transaction\");\n\t\t\tcp_transaction->t_chp_stats.cs_dropped++;\n\t\t\t__jbd2_journal_remove_checkpoint(jh);\n\t\t}\n\n\t\t/* Only re-checkpoint the buffer_head if it is marked\n\t\t * dirty.  If the buffer was added to the BJ_Forget list\n\t\t * by jbd2_journal_forget, it may no longer be dirty and\n\t\t * there's no point in keeping a checkpoint record for\n\t\t * it. */\n\n\t\t/*\n\t\t* A buffer which has been freed while still being journaled by\n\t\t* a previous transaction.\n\t\t*/\n\t\tif (buffer_freed(bh)) {\n\t\t\t/*\n\t\t\t * If the running transaction is the one containing\n\t\t\t * \"add to orphan\" operation (b_next_transaction !=\n\t\t\t * NULL), we have to wait for that transaction to\n\t\t\t * commit before we can really get rid of the buffer.\n\t\t\t * So just clear b_modified to not confuse transaction\n\t\t\t * credit accounting and refile the buffer to\n\t\t\t * BJ_Forget of the running transaction. If the just\n\t\t\t * committed transaction contains \"add to orphan\"\n\t\t\t * operation, we can completely invalidate the buffer\n\t\t\t * now. We are rather through in that since the\n\t\t\t * buffer may be still accessible when blocksize <\n\t\t\t * pagesize and it is attached to the last partial\n\t\t\t * page.\n\t\t\t */\n\t\t\tjh->b_modified = 0;\n\t\t\tif (!jh->b_next_transaction) {\n\t\t\t\tclear_buffer_freed(bh);\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t\t\tclear_buffer_mapped(bh);\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t\tclear_buffer_req(bh);\n\t\t\t\tbh->b_bdev = NULL;\n\t\t\t}\n\t\t}\n\n\t\tif (buffer_jbddirty(bh)) {\n\t\t\tJBUFFER_TRACE(jh, \"add to new checkpointing trans\");\n\t\t\t__jbd2_journal_insert_checkpoint(jh, commit_transaction);\n\t\t\tif (is_journal_aborted(journal))\n\t\t\t\tclear_buffer_jbddirty(bh);\n\t\t} else {\n\t\t\tJ_ASSERT_BH(bh, !buffer_dirty(bh));\n\t\t\t/*\n\t\t\t * The buffer on BJ_Forget list and not jbddirty means\n\t\t\t * it has been freed by this transaction and hence it\n\t\t\t * could not have been reallocated until this\n\t\t\t * transaction has committed. *BUT* it could be\n\t\t\t * reallocated once we have written all the data to\n\t\t\t * disk and before we process the buffer on BJ_Forget\n\t\t\t * list.\n\t\t\t */\n\t\t\tif (!jh->b_next_transaction)\n\t\t\t\ttry_to_free = 1;\n\t\t}\n\t\tJBUFFER_TRACE(jh, \"refile or unfile buffer\");\n\t\t__jbd2_journal_refile_buffer(jh);\n\t\tjbd_unlock_bh_state(bh);\n\t\tif (try_to_free)\n\t\t\trelease_buffer_page(bh);\t/* Drops bh reference */\n\t\telse\n\t\t\t__brelse(bh);\n\t\tcond_resched_lock(&journal->j_list_lock);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\t/*\n\t * This is a bit sleazy.  We use j_list_lock to protect transition\n\t * of a transaction into T_FINISHED state and calling\n\t * __jbd2_journal_drop_transaction(). Otherwise we could race with\n\t * other checkpointing code processing the transaction...\n\t */\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\t/*\n\t * Now recheck if some buffers did not get attached to the transaction\n\t * while the lock was dropped...\n\t */\n\tif (commit_transaction->t_forget) {\n\t\tspin_unlock(&journal->j_list_lock);\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tgoto restart_loop;\n\t}\n\n\t/* Add the transaction to the checkpoint list\n\t * __journal_remove_checkpoint() can not destroy transaction\n\t * under us because it is not marked as T_FINISHED yet */\n\tif (journal->j_checkpoint_transactions == NULL) {\n\t\tjournal->j_checkpoint_transactions = commit_transaction;\n\t\tcommit_transaction->t_cpnext = commit_transaction;\n\t\tcommit_transaction->t_cpprev = commit_transaction;\n\t} else {\n\t\tcommit_transaction->t_cpnext =\n\t\t\tjournal->j_checkpoint_transactions;\n\t\tcommit_transaction->t_cpprev =\n\t\t\tcommit_transaction->t_cpnext->t_cpprev;\n\t\tcommit_transaction->t_cpnext->t_cpprev =\n\t\t\tcommit_transaction;\n\t\tcommit_transaction->t_cpprev->t_cpnext =\n\t\t\t\tcommit_transaction;\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\n\t/* Done with this transaction! */\n\n\tjbd_debug(3, \"JBD2: commit phase 7\\n\");\n\n\tJ_ASSERT(commit_transaction->t_state == T_COMMIT_JFLUSH);\n\n\tcommit_transaction->t_start = jiffies;\n\tstats.run.rs_logging = jbd2_time_diff(stats.run.rs_logging,\n\t\t\t\t\t      commit_transaction->t_start);\n\n\t/*\n\t * File the transaction statistics\n\t */\n\tstats.ts_tid = commit_transaction->t_tid;\n\tstats.run.rs_handle_count =\n\t\tatomic_read(&commit_transaction->t_handle_count);\n\ttrace_jbd2_run_stats(journal->j_fs_dev->bd_dev,\n\t\t\t     commit_transaction->t_tid, &stats.run);\n\tstats.ts_requested = (commit_transaction->t_requested) ? 1 : 0;\n\n\tcommit_transaction->t_state = T_COMMIT_CALLBACK;\n\tJ_ASSERT(commit_transaction == journal->j_committing_transaction);\n\tjournal->j_commit_sequence = commit_transaction->t_tid;\n\tjournal->j_committing_transaction = NULL;\n\tcommit_time = ktime_to_ns(ktime_sub(ktime_get(), start_time));\n\n\t/*\n\t * weight the commit time higher than the average time so we don't\n\t * react too strongly to vast changes in the commit time\n\t */\n\tif (likely(journal->j_average_commit_time))\n\t\tjournal->j_average_commit_time = (commit_time +\n\t\t\t\tjournal->j_average_commit_time*3) / 4;\n\telse\n\t\tjournal->j_average_commit_time = commit_time;\n\n\twrite_unlock(&journal->j_state_lock);\n\n\tif (journal->j_commit_callback)\n\t\tjournal->j_commit_callback(journal, commit_transaction);\n\n\ttrace_jbd2_end_commit(journal, commit_transaction);\n\tjbd_debug(1, \"JBD2: commit %d complete, head %d\\n\",\n\t\t  journal->j_commit_sequence, journal->j_tail_sequence);\n\n\twrite_lock(&journal->j_state_lock);\n\tspin_lock(&journal->j_list_lock);\n\tcommit_transaction->t_state = T_FINISHED;\n\t/* Check if the transaction can be dropped now that we are finished */\n\tif (commit_transaction->t_checkpoint_list == NULL &&\n\t    commit_transaction->t_checkpoint_io_list == NULL) {\n\t\t__jbd2_journal_drop_transaction(journal, commit_transaction);\n\t\tjbd2_journal_free_transaction(commit_transaction);\n\t}\n\tspin_unlock(&journal->j_list_lock);\n\twrite_unlock(&journal->j_state_lock);\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * Calculate overall stats\n\t */\n\tspin_lock(&journal->j_history_lock);\n\tjournal->j_stats.ts_tid++;\n\tjournal->j_stats.ts_requested += stats.ts_requested;\n\tjournal->j_stats.run.rs_wait += stats.run.rs_wait;\n\tjournal->j_stats.run.rs_request_delay += stats.run.rs_request_delay;\n\tjournal->j_stats.run.rs_running += stats.run.rs_running;\n\tjournal->j_stats.run.rs_locked += stats.run.rs_locked;\n\tjournal->j_stats.run.rs_flushing += stats.run.rs_flushing;\n\tjournal->j_stats.run.rs_logging += stats.run.rs_logging;\n\tjournal->j_stats.run.rs_handle_count += stats.run.rs_handle_count;\n\tjournal->j_stats.run.rs_blocks += stats.run.rs_blocks;\n\tjournal->j_stats.run.rs_blocks_logged += stats.run.rs_blocks_logged;\n\tspin_unlock(&journal->j_history_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "&journal->j_commit_timer"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"OK, requests differ\\n\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"commit_sequence=%d, commit_request=%d\\n\"",
            "journal->j_commit_sequence",
            "journal->j_commit_request"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_freezable",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_timer",
          "args": [
            "&journal->j_commit_timer",
            "commit_timeout",
            "(unsigned long)current"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int kjournald2(void *arg)\n{\n\tjournal_t *journal = arg;\n\ttransaction_t *transaction;\n\n\t/*\n\t * Set up an interval timer which can be used to trigger a commit wakeup\n\t * after the commit interval expires\n\t */\n\tsetup_timer(&journal->j_commit_timer, commit_timeout,\n\t\t\t(unsigned long)current);\n\n\tset_freezable();\n\n\t/* Record that the journal thread is running */\n\tjournal->j_task = current;\n\twake_up(&journal->j_wait_done_commit);\n\n\t/*\n\t * And now, wait forever for commit wakeup events.\n\t */\n\twrite_lock(&journal->j_state_lock);\n\nloop:\n\tif (journal->j_flags & JBD2_UNMOUNT)\n\t\tgoto end_loop;\n\n\tjbd_debug(1, \"commit_sequence=%d, commit_request=%d\\n\",\n\t\tjournal->j_commit_sequence, journal->j_commit_request);\n\n\tif (journal->j_commit_sequence != journal->j_commit_request) {\n\t\tjbd_debug(1, \"OK, requests differ\\n\");\n\t\twrite_unlock(&journal->j_state_lock);\n\t\tdel_timer_sync(&journal->j_commit_timer);\n\t\tjbd2_journal_commit_transaction(journal);\n\t\twrite_lock(&journal->j_state_lock);\n\t\tgoto loop;\n\t}\n\n\twake_up(&journal->j_wait_done_commit);\n\tif (freezing(current)) {\n\t\t/*\n\t\t * The simpler the better. Flushing journal isn't a\n\t\t * good idea, because that depends on threads that may\n\t\t * be already stopped.\n\t\t */\n\t\tjbd_debug(1, \"Now suspending kjournald2\\n\");\n\t\twrite_unlock(&journal->j_state_lock);\n\t\ttry_to_freeze();\n\t\twrite_lock(&journal->j_state_lock);\n\t} else {\n\t\t/*\n\t\t * We assume on resume that commits are already there,\n\t\t * so we don't sleep\n\t\t */\n\t\tDEFINE_WAIT(wait);\n\t\tint should_sleep = 1;\n\n\t\tprepare_to_wait(&journal->j_wait_commit, &wait,\n\t\t\t\tTASK_INTERRUPTIBLE);\n\t\tif (journal->j_commit_sequence != journal->j_commit_request)\n\t\t\tshould_sleep = 0;\n\t\ttransaction = journal->j_running_transaction;\n\t\tif (transaction && time_after_eq(jiffies,\n\t\t\t\t\t\ttransaction->t_expires))\n\t\t\tshould_sleep = 0;\n\t\tif (journal->j_flags & JBD2_UNMOUNT)\n\t\t\tshould_sleep = 0;\n\t\tif (should_sleep) {\n\t\t\twrite_unlock(&journal->j_state_lock);\n\t\t\tschedule();\n\t\t\twrite_lock(&journal->j_state_lock);\n\t\t}\n\t\tfinish_wait(&journal->j_wait_commit, &wait);\n\t}\n\n\tjbd_debug(1, \"kjournald2 wakes\\n\");\n\n\t/*\n\t * Were we woken up by a commit wakeup event?\n\t */\n\ttransaction = journal->j_running_transaction;\n\tif (transaction && time_after_eq(jiffies, transaction->t_expires)) {\n\t\tjournal->j_commit_request = transaction->t_tid;\n\t\tjbd_debug(1, \"woke because of timeout\\n\");\n\t}\n\tgoto loop;\n\nend_loop:\n\twrite_unlock(&journal->j_state_lock);\n\tdel_timer_sync(&journal->j_commit_timer);\n\tjournal->j_task = NULL;\n\twake_up(&journal->j_wait_done_commit);\n\tjbd_debug(1, \"Journal thread exiting.\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "commit_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "166-171",
    "snippet": "static void commit_timeout(unsigned long __data)\n{\n\tstruct task_struct * p = (struct task_struct *) __data;\n\n\twake_up_process(p);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "p"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void commit_timeout(unsigned long __data)\n{\n\tstruct task_struct * p = (struct task_struct *) __data;\n\n\twake_up_process(p);\n}"
  },
  {
    "function_name": "jbd2_superblock_csum_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "154-160",
    "snippet": "static void jbd2_superblock_csum_set(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tsb->s_checksum = jbd2_superblock_csum(j, sb);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_superblock_csum",
          "args": [
            "j",
            "sb"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_superblock_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "154-160",
          "snippet": "static void jbd2_superblock_csum_set(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tsb->s_checksum = jbd2_superblock_csum(j, sb);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_superblock_csum_set(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tsb->s_checksum = jbd2_superblock_csum(j, sb);\n}"
  },
  {
    "function_name": "jbd2_superblock_csum_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "146-152",
    "snippet": "static int jbd2_superblock_csum_verify(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\treturn sb->s_checksum == jbd2_superblock_csum(j, sb);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_superblock_csum",
          "args": [
            "j",
            "sb"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "jbd2_superblock_csum_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
          "lines": "154-160",
          "snippet": "static void jbd2_superblock_csum_set(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tsb->s_checksum = jbd2_superblock_csum(j, sb);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd2.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bitops.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/log2.h>",
            "#include <linux/hash.h>",
            "#include <linux/math64.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic void jbd2_superblock_csum_set(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn;\n\n\tsb->s_checksum = jbd2_superblock_csum(j, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int jbd2_superblock_csum_verify(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\treturn sb->s_checksum == jbd2_superblock_csum(j, sb);\n}"
  },
  {
    "function_name": "jbd2_superblock_csum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "133-144",
    "snippet": "static __be32 jbd2_superblock_csum(journal_t *j, journal_superblock_t *sb)\n{\n\t__u32 csum;\n\t__be32 old_csum;\n\n\told_csum = sb->s_checksum;\n\tsb->s_checksum = 0;\n\tcsum = jbd2_chksum(j, ~0, (char *)sb, sizeof(journal_superblock_t));\n\tsb->s_checksum = old_csum;\n\n\treturn cpu_to_be32(csum);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "csum"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd2_chksum",
          "args": [
            "j",
            "~0",
            "(char *)sb",
            "sizeof(journal_superblock_t)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic __be32 jbd2_superblock_csum(journal_t *j, journal_superblock_t *sb)\n{\n\t__u32 csum;\n\t__be32 old_csum;\n\n\told_csum = sb->s_checksum;\n\tsb->s_checksum = 0;\n\tcsum = jbd2_chksum(j, ~0, (char *)sb, sizeof(journal_superblock_t));\n\tsb->s_checksum = old_csum;\n\n\treturn cpu_to_be32(csum);\n}"
  },
  {
    "function_name": "jbd2_verify_csum_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "125-131",
    "snippet": "static int jbd2_verify_csum_type(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\treturn sb->s_checksum_type == JBD2_CRC32C_CHKSUM;\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd2_journal_has_csum_v2or3",
          "args": [
            "j"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nstatic int jbd2_verify_csum_type(journal_t *j, journal_superblock_t *sb)\n{\n\tif (!jbd2_journal_has_csum_v2or3(j))\n\t\treturn 1;\n\n\treturn sb->s_checksum_type == JBD2_CRC32C_CHKSUM;\n}"
  },
  {
    "function_name": "__jbd2_debug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd2/journal.c",
    "lines": "107-120",
    "snippet": "void __jbd2_debug(int level, const char *file, const char *func,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > jbd2_journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
    "includes": [
      "#include <asm/page.h>",
      "#include <asm/uaccess.h>",
      "#include <trace/events/jbd2.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/bitops.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/log2.h>",
      "#include <linux/hash.h>",
      "#include <linux/math64.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/poison.h>",
      "#include <linux/kthread.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/freezer.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd2.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"%s: (%s, %u): %pV\\n\"",
            "file",
            "func",
            "line",
            "&vaf"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd2.h>\n#include <linux/ratelimit.h>\n#include <linux/bitops.h>\n#include <linux/backing-dev.h>\n#include <linux/vmalloc.h>\n#include <linux/log2.h>\n#include <linux/hash.h>\n#include <linux/math64.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd2.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd2_debug(int level, const char *file, const char *func,\n\t\t  unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > jbd2_journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
  }
]