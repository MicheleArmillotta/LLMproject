[
  {
    "function_name": "scan_revoke_records",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
    "lines": "572-594",
    "snippet": "static int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjournal_revoke_header_t *header;\n\tint offset, max;\n\n\theader = (journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(journal_revoke_header_t);\n\tmax = be32_to_cpu(header->r_count);\n\n\twhile (offset < max) {\n\t\tunsigned int blocknr;\n\t\tint err;\n\n\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\toffset += 4;\n\t\terr = journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_set_revoke",
          "args": [
            "journal",
            "blocknr",
            "sequence"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "journal_set_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "673-688",
          "snippet": "int journal_set_revoke(journal_t *journal,\n\t\t       unsigned int blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t/* If we have multiple occurrences, only record the\n\t\t * latest sequence number in the hashed record */\n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint journal_set_revoke(journal_t *journal,\n\t\t       unsigned int blocknr,\n\t\t       tid_t sequence)\n{\n\tstruct jbd_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (record) {\n\t\t/* If we have multiple occurrences, only record the\n\t\t * latest sequence number in the hashed record */\n\t\tif (tid_gt(sequence, record->sequence))\n\t\t\trecord->sequence = sequence;\n\t\treturn 0;\n\t}\n\treturn insert_revoke_hash(journal, blocknr, sequence);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "* ((__be32 *) (bh->b_data+offset))"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "header->r_count"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjournal_revoke_header_t *header;\n\tint offset, max;\n\n\theader = (journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(journal_revoke_header_t);\n\tmax = be32_to_cpu(header->r_count);\n\n\twhile (offset < max) {\n\t\tunsigned int blocknr;\n\t\tint err;\n\n\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\toffset += 4;\n\t\terr = journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_one_pass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
    "lines": "317-567",
    "snippet": "static int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned int\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %u/%u\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD: checking block %u\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JFS_DESCRIPTOR_BLOCK:\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; otherwise, just skip over the\n\t\t\t * blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tnext_log_block +=\n\t\t\t\t\tcount_tags(bh, journal->j_blocksize);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data +sizeof(journal_block_tag_t))\n\t\t\t       <= journal->j_blocksize) {\n\t\t\t\tunsigned int io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be32_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk (KERN_ERR\n\t\t\t\t\t\t\"JBD: IO error %d recovering \"\n\t\t\t\t\t\t\"block %u in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = be32_to_cpu(tag->t_blocknr);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JFS_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += sizeof(journal_block_tag_t);\n\t\t\t\tif (!(flags & JFS_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JFS_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JFS_COMMIT_BLOCK:\n\t\t\t/* Found an expected commit block: not much to\n\t\t\t * do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JFS_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN)\n\t\tinfo->end_transaction = next_commit_ID;\n\telse {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk (KERN_ERR \"JBD: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\n\treturn success;\n\n failed:\n\treturn err;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);",
      "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\"",
            "pass",
            "next_commit_ID",
            "info->end_transaction"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"Unrecognised magic %d, end of scan.\\n\"",
            "blocktype"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scan_revoke_records",
          "args": [
            "journal",
            "bh",
            "next_commit_ID",
            "info"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "scan_revoke_records",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "572-594",
          "snippet": "static int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjournal_revoke_header_t *header;\n\tint offset, max;\n\n\theader = (journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(journal_revoke_header_t);\n\tmax = be32_to_cpu(header->r_count);\n\n\twhile (offset < max) {\n\t\tunsigned int blocknr;\n\t\tint err;\n\n\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\toffset += 4;\n\t\terr = journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int scan_revoke_records(journal_t *journal, struct buffer_head *bh,\n\t\t\t       tid_t sequence, struct recovery_info *info)\n{\n\tjournal_revoke_header_t *header;\n\tint offset, max;\n\n\theader = (journal_revoke_header_t *) bh->b_data;\n\toffset = sizeof(journal_revoke_header_t);\n\tmax = be32_to_cpu(header->r_count);\n\n\twhile (offset < max) {\n\t\tunsigned int blocknr;\n\t\tint err;\n\n\t\tblocknr = be32_to_cpu(* ((__be32 *) (bh->b_data+offset)));\n\t\toffset += 4;\n\t\terr = journal_set_revoke(journal, blocknr, sequence);\n\t\tif (err)\n\t\t\treturn err;\n\t\t++info->nr_revokes;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "nbh"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "nbh",
            "\"marking uptodate\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "nbh"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "nbh"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUFFER_TRACE",
          "args": [
            "nbh",
            "\"marking dirty\""
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_MAGIC_NUMBER"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nbh->b_data",
            "obh->b_data",
            "journal->j_blocksize"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_fs_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_test_revoke",
          "args": [
            "journal",
            "blocknr",
            "next_commit_ID"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "journal_test_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "697-709",
          "snippet": "int journal_test_revoke(journal_t *journal,\n\t\t\tunsigned int blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nint journal_test_revoke(journal_t *journal,\n\t\t\tunsigned int blocknr,\n\t\t\ttid_t sequence)\n{\n\tstruct jbd_revoke_record_s *record;\n\n\trecord = find_revoke_record(journal, blocknr);\n\tif (!record)\n\t\treturn 0;\n\tif (tid_gt(sequence, record->sequence))\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tag->t_blocknr"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "J_ASSERT",
          "args": [
            "obh != NULL"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jread",
          "args": [
            "&obh",
            "journal",
            "io_block"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "jread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "131-174",
          "snippet": "static int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk (KERN_ERR \"JBD: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk (KERN_ERR \"JBD: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk (KERN_ERR \"JBD: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk (KERN_ERR \"JBD: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrap",
          "args": [
            "journal",
            "next_log_block"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "fsdlm_blocking_ast_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stack_user.c",
          "lines": "689-694",
          "snippet": "static void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}",
          "includes": [
            "#include <linux/dlm_plock.h>",
            "#include \"stackglue.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/dlm_plock.h>\n#include \"stackglue.h\"\n#include <asm/uaccess.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/miscdevice.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void fsdlm_blocking_ast_wrapper(void *astarg, int level)\n{\n\tstruct ocfs2_dlm_lksb *lksb = astarg;\n\n\tlksb->lksb_conn->cc_proto->lp_blocking_ast(lksb, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tag->t_flags"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "count_tags",
          "args": [
            "bh",
            "journal->j_blocksize"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "count_tags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "181-202",
          "snippet": "static int count_tags(struct buffer_head *bh, int size)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0;\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + sizeof(journal_block_tag_t)) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tif (!(tag->t_flags & cpu_to_be32(JFS_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be32(JFS_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int count_tags(struct buffer_head *bh, int size)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0;\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + sizeof(journal_block_tag_t)) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tif (!(tag->t_flags & cpu_to_be32(JFS_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be32(JFS_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"Found magic %d, sequence %d\\n\"",
            "blocktype",
            "sequence"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp->h_sequence"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "tmp->h_blocktype"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_MAGIC_NUMBER"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "3",
            "\"JBD: checking block %u\\n\"",
            "next_log_block"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "2",
            "\"Scanning for sequence ID %u at %u/%u\\n\"",
            "next_commit_ID",
            "next_log_block",
            "journal->j_last"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tid_geq",
          "args": [
            "next_commit_ID",
            "info->end_transaction"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"Starting recovery pass %d\\n\"",
            "pass"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_start"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_sequence"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned int\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %u/%u\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD: checking block %u\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JFS_DESCRIPTOR_BLOCK:\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; otherwise, just skip over the\n\t\t\t * blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tnext_log_block +=\n\t\t\t\t\tcount_tags(bh, journal->j_blocksize);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data +sizeof(journal_block_tag_t))\n\t\t\t       <= journal->j_blocksize) {\n\t\t\t\tunsigned int io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be32_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk (KERN_ERR\n\t\t\t\t\t\t\"JBD: IO error %d recovering \"\n\t\t\t\t\t\t\"block %u in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = be32_to_cpu(tag->t_blocknr);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JFS_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += sizeof(journal_block_tag_t);\n\t\t\t\tif (!(flags & JFS_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JFS_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JFS_COMMIT_BLOCK:\n\t\t\t/* Found an expected commit block: not much to\n\t\t\t * do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JFS_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN)\n\t\tinfo->end_transaction = next_commit_ID;\n\telse {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk (KERN_ERR \"JBD: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\n\treturn success;\n\n failed:\n\treturn err;\n}"
  },
  {
    "function_name": "journal_skip_recovery",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
    "lines": "290-315",
    "snippet": "int journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t} else {\n#ifdef CONFIG_JBD_DEBUG\n\t\tint dropped = info.end_transaction -\n\t\t\t      be32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd_debug(1,\n\t\t\t  \"JBD: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: ignoring %d transaction%s from the journal.\\n\"",
            "dropped",
            "(dropped == 1) ? \"\" : \"s\""
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "journal->j_superblock->s_sequence"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD: error %d scanning journal\\n\"",
            "err"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_one_pass",
          "args": [
            "journal",
            "&info",
            "PASS_SCAN"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "do_one_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "317-567",
          "snippet": "static int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned int\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %u/%u\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD: checking block %u\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JFS_DESCRIPTOR_BLOCK:\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; otherwise, just skip over the\n\t\t\t * blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tnext_log_block +=\n\t\t\t\t\tcount_tags(bh, journal->j_blocksize);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data +sizeof(journal_block_tag_t))\n\t\t\t       <= journal->j_blocksize) {\n\t\t\t\tunsigned int io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be32_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk (KERN_ERR\n\t\t\t\t\t\t\"JBD: IO error %d recovering \"\n\t\t\t\t\t\t\"block %u in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = be32_to_cpu(tag->t_blocknr);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JFS_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += sizeof(journal_block_tag_t);\n\t\t\t\tif (!(flags & JFS_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JFS_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JFS_COMMIT_BLOCK:\n\t\t\t/* Found an expected commit block: not much to\n\t\t\t * do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JFS_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN)\n\t\tinfo->end_transaction = next_commit_ID;\n\telse {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk (KERN_ERR \"JBD: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\n\treturn success;\n\n failed:\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);",
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned int\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %u/%u\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD: checking block %u\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JFS_DESCRIPTOR_BLOCK:\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; otherwise, just skip over the\n\t\t\t * blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tnext_log_block +=\n\t\t\t\t\tcount_tags(bh, journal->j_blocksize);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data +sizeof(journal_block_tag_t))\n\t\t\t       <= journal->j_blocksize) {\n\t\t\t\tunsigned int io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be32_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk (KERN_ERR\n\t\t\t\t\t\t\"JBD: IO error %d recovering \"\n\t\t\t\t\t\t\"block %u in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = be32_to_cpu(tag->t_blocknr);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JFS_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += sizeof(journal_block_tag_t);\n\t\t\t\tif (!(flags & JFS_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JFS_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JFS_COMMIT_BLOCK:\n\t\t\t/* Found an expected commit block: not much to\n\t\t\t * do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JFS_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN)\n\t\tinfo->end_transaction = next_commit_ID;\n\telse {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk (KERN_ERR \"JBD: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\n\treturn success;\n\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nint journal_skip_recovery(journal_t *journal)\n{\n\tint\t\t\terr;\n\tstruct recovery_info\tinfo;\n\n\tmemset (&info, 0, sizeof(info));\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\n\tif (err) {\n\t\tprintk(KERN_ERR \"JBD: error %d scanning journal\\n\", err);\n\t\t++journal->j_transaction_sequence;\n\t} else {\n#ifdef CONFIG_JBD_DEBUG\n\t\tint dropped = info.end_transaction -\n\t\t\t      be32_to_cpu(journal->j_superblock->s_sequence);\n\t\tjbd_debug(1,\n\t\t\t  \"JBD: ignoring %d transaction%s from the journal.\\n\",\n\t\t\t  dropped, (dropped == 1) ? \"\" : \"s\");\n#endif\n\t\tjournal->j_transaction_sequence = ++info.end_transaction;\n\t}\n\n\tjournal->j_tail = 0;\n\treturn err;\n}"
  },
  {
    "function_name": "journal_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
    "lines": "224-275",
    "snippet": "int journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t/*\n\t * The journal superblock's s_start field (the current log head)\n\t * is always zero if, and only if, the journal was cleanly\n\t * unmounted.\n\t */\n\n\tif (!sb->s_start) {\n\t\tjbd_debug(1, \"No recovery required, last transaction %d\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\treturn 0;\n\t}\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd_debug(1, \"JBD: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd_debug(1, \"JBD: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t/* Restart the log at the next transaction ID, thus invalidating\n\t * any existing commit records in the log. */\n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\n\tjournal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\t/* Flush disk caches to get replayed data on the permanent storage */\n\tif (journal->j_flags & JFS_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_issue_flush",
          "args": [
            "journal->j_fs_dev",
            "GFP_KERNEL",
            "NULL"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_blockdev",
          "args": [
            "journal->j_fs_dev"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "sync_blockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "174-177",
          "snippet": "int sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sync_blockdev(struct block_device *bdev)\n{\n\treturn __sync_blockdev(bdev, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_clear_revoke",
          "args": [
            "journal"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "journal_clear_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/revoke.c",
          "lines": "716-733",
          "snippet": "void journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\tstruct jbd_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/hash.h>",
            "#include <linux/log2.h>",
            "#include <linux/bio.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *revoke_record_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/hash.h>\n#include <linux/log2.h>\n#include <linux/bio.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic struct kmem_cache *revoke_record_cache;\n\nvoid journal_clear_revoke(journal_t *journal)\n{\n\tint i;\n\tstruct list_head *hash_list;\n\tstruct jbd_revoke_record_s *record;\n\tstruct jbd_revoke_table_s *revoke;\n\n\trevoke = journal->j_revoke;\n\n\tfor (i = 0; i < revoke->hash_size; i++) {\n\t\thash_list = &revoke->hash_table[i];\n\t\twhile (!list_empty(hash_list)) {\n\t\t\trecord = (struct jbd_revoke_record_s*) hash_list->next;\n\t\t\tlist_del(&record->hash);\n\t\t\tkmem_cache_free(revoke_record_cache, record);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"JBD: Replayed %d and revoked %d/%d blocks\\n\"",
            "info.nr_replays",
            "info.nr_revoke_hits",
            "info.nr_revokes"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__jbd_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "94-107",
          "snippet": "void __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nvoid __jbd_debug(int level, const char *file, const char *func,\n\t\t unsigned int line, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (level > journal_enable_debug)\n\t\treturn;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tprintk(KERN_DEBUG \"%s: (%s, %u): %pV\\n\", file, func, line, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_one_pass",
          "args": [
            "journal",
            "&info",
            "PASS_REPLAY"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "do_one_pass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "317-567",
          "snippet": "static int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned int\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %u/%u\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD: checking block %u\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JFS_DESCRIPTOR_BLOCK:\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; otherwise, just skip over the\n\t\t\t * blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tnext_log_block +=\n\t\t\t\t\tcount_tags(bh, journal->j_blocksize);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data +sizeof(journal_block_tag_t))\n\t\t\t       <= journal->j_blocksize) {\n\t\t\t\tunsigned int io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be32_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk (KERN_ERR\n\t\t\t\t\t\t\"JBD: IO error %d recovering \"\n\t\t\t\t\t\t\"block %u in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = be32_to_cpu(tag->t_blocknr);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JFS_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += sizeof(journal_block_tag_t);\n\t\t\t\tif (!(flags & JFS_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JFS_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JFS_COMMIT_BLOCK:\n\t\t\t/* Found an expected commit block: not much to\n\t\t\t * do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JFS_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN)\n\t\tinfo->end_transaction = next_commit_ID;\n\telse {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk (KERN_ERR \"JBD: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\n\treturn success;\n\n failed:\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);",
            "static int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\t\tstruct recovery_info *info, enum passtype pass);\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nstatic int do_one_pass(journal_t *journal,\n\t\t\tstruct recovery_info *info, enum passtype pass)\n{\n\tunsigned int\t\tfirst_commit_ID, next_commit_ID;\n\tunsigned int\t\tnext_log_block;\n\tint\t\t\terr, success = 0;\n\tjournal_superblock_t *\tsb;\n\tjournal_header_t *\ttmp;\n\tstruct buffer_head *\tbh;\n\tunsigned int\t\tsequence;\n\tint\t\t\tblocktype;\n\n\t/*\n\t * First thing is to establish what we expect to find in the log\n\t * (in terms of transaction IDs), and where (in terms of log\n\t * block offsets): query the superblock.\n\t */\n\n\tsb = journal->j_superblock;\n\tnext_commit_ID = be32_to_cpu(sb->s_sequence);\n\tnext_log_block = be32_to_cpu(sb->s_start);\n\n\tfirst_commit_ID = next_commit_ID;\n\tif (pass == PASS_SCAN)\n\t\tinfo->start_transaction = first_commit_ID;\n\n\tjbd_debug(1, \"Starting recovery pass %d\\n\", pass);\n\n\t/*\n\t * Now we walk through the log, transaction by transaction,\n\t * making sure that each transaction has a commit block in the\n\t * expected place.  Each complete transaction gets replayed back\n\t * into the main filesystem.\n\t */\n\n\twhile (1) {\n\t\tint\t\t\tflags;\n\t\tchar *\t\t\ttagp;\n\t\tjournal_block_tag_t *\ttag;\n\t\tstruct buffer_head *\tobh;\n\t\tstruct buffer_head *\tnbh;\n\n\t\tcond_resched();\n\n\t\t/* If we already know where to stop the log traversal,\n\t\t * check right now that we haven't gone past the end of\n\t\t * the log. */\n\n\t\tif (pass != PASS_SCAN)\n\t\t\tif (tid_geq(next_commit_ID, info->end_transaction))\n\t\t\t\tbreak;\n\n\t\tjbd_debug(2, \"Scanning for sequence ID %u at %u/%u\\n\",\n\t\t\t  next_commit_ID, next_log_block, journal->j_last);\n\n\t\t/* Skip over each chunk of the transaction looking\n\t\t * either the next descriptor block or the final commit\n\t\t * record. */\n\n\t\tjbd_debug(3, \"JBD: checking block %u\\n\", next_log_block);\n\t\terr = jread(&bh, journal, next_log_block);\n\t\tif (err)\n\t\t\tgoto failed;\n\n\t\tnext_log_block++;\n\t\twrap(journal, next_log_block);\n\n\t\t/* What kind of buffer is it?\n\t\t *\n\t\t * If it is a descriptor block, check that it has the\n\t\t * expected sequence number.  Otherwise, we're all done\n\t\t * here. */\n\n\t\ttmp = (journal_header_t *)bh->b_data;\n\n\t\tif (tmp->h_magic != cpu_to_be32(JFS_MAGIC_NUMBER)) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\tblocktype = be32_to_cpu(tmp->h_blocktype);\n\t\tsequence = be32_to_cpu(tmp->h_sequence);\n\t\tjbd_debug(3, \"Found magic %d, sequence %d\\n\",\n\t\t\t  blocktype, sequence);\n\n\t\tif (sequence != next_commit_ID) {\n\t\t\tbrelse(bh);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* OK, we have a valid descriptor block which matches\n\t\t * all of the sequence number checks.  What are we going\n\t\t * to do with it?  That depends on the pass... */\n\n\t\tswitch(blocktype) {\n\t\tcase JFS_DESCRIPTOR_BLOCK:\n\t\t\t/* If it is a valid descriptor block, replay it\n\t\t\t * in pass REPLAY; otherwise, just skip over the\n\t\t\t * blocks it describes. */\n\t\t\tif (pass != PASS_REPLAY) {\n\t\t\t\tnext_log_block +=\n\t\t\t\t\tcount_tags(bh, journal->j_blocksize);\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A descriptor block: we can now write all of\n\t\t\t * the data blocks.  Yay, useful work is finally\n\t\t\t * getting done here! */\n\n\t\t\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\t\t\twhile ((tagp - bh->b_data +sizeof(journal_block_tag_t))\n\t\t\t       <= journal->j_blocksize) {\n\t\t\t\tunsigned int io_block;\n\n\t\t\t\ttag = (journal_block_tag_t *) tagp;\n\t\t\t\tflags = be32_to_cpu(tag->t_flags);\n\n\t\t\t\tio_block = next_log_block++;\n\t\t\t\twrap(journal, next_log_block);\n\t\t\t\terr = jread(&obh, journal, io_block);\n\t\t\t\tif (err) {\n\t\t\t\t\t/* Recover what we can, but\n\t\t\t\t\t * report failure at the end. */\n\t\t\t\t\tsuccess = err;\n\t\t\t\t\tprintk (KERN_ERR\n\t\t\t\t\t\t\"JBD: IO error %d recovering \"\n\t\t\t\t\t\t\"block %u in log\\n\",\n\t\t\t\t\t\terr, io_block);\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int blocknr;\n\n\t\t\t\t\tJ_ASSERT(obh != NULL);\n\t\t\t\t\tblocknr = be32_to_cpu(tag->t_blocknr);\n\n\t\t\t\t\t/* If the block has been\n\t\t\t\t\t * revoked, then we're all done\n\t\t\t\t\t * here. */\n\t\t\t\t\tif (journal_test_revoke\n\t\t\t\t\t    (journal, blocknr,\n\t\t\t\t\t     next_commit_ID)) {\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\t++info->nr_revoke_hits;\n\t\t\t\t\t\tgoto skip_write;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Find a buffer for the new\n\t\t\t\t\t * data being restored */\n\t\t\t\t\tnbh = __getblk(journal->j_fs_dev,\n\t\t\t\t\t\t\tblocknr,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (nbh == NULL) {\n\t\t\t\t\t\tprintk(KERN_ERR\n\t\t\t\t\t\t       \"JBD: Out of memory \"\n\t\t\t\t\t\t       \"during recovery.\\n\");\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\t\tbrelse(bh);\n\t\t\t\t\t\tbrelse(obh);\n\t\t\t\t\t\tgoto failed;\n\t\t\t\t\t}\n\n\t\t\t\t\tlock_buffer(nbh);\n\t\t\t\t\tmemcpy(nbh->b_data, obh->b_data,\n\t\t\t\t\t\t\tjournal->j_blocksize);\n\t\t\t\t\tif (flags & JFS_FLAG_ESCAPE) {\n\t\t\t\t\t\t*((__be32 *)nbh->b_data) =\n\t\t\t\t\t\tcpu_to_be32(JFS_MAGIC_NUMBER);\n\t\t\t\t\t}\n\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking dirty\");\n\t\t\t\t\tset_buffer_uptodate(nbh);\n\t\t\t\t\tmark_buffer_dirty(nbh);\n\t\t\t\t\tBUFFER_TRACE(nbh, \"marking uptodate\");\n\t\t\t\t\t++info->nr_replays;\n\t\t\t\t\t/* ll_rw_block(WRITE, 1, &nbh); */\n\t\t\t\t\tunlock_buffer(nbh);\n\t\t\t\t\tbrelse(obh);\n\t\t\t\t\tbrelse(nbh);\n\t\t\t\t}\n\n\t\t\tskip_write:\n\t\t\t\ttagp += sizeof(journal_block_tag_t);\n\t\t\t\tif (!(flags & JFS_FLAG_SAME_UUID))\n\t\t\t\t\ttagp += 16;\n\n\t\t\t\tif (flags & JFS_FLAG_LAST_TAG)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbrelse(bh);\n\t\t\tcontinue;\n\n\t\tcase JFS_COMMIT_BLOCK:\n\t\t\t/* Found an expected commit block: not much to\n\t\t\t * do other than move on to the next sequence\n\t\t\t * number. */\n\t\t\tbrelse(bh);\n\t\t\tnext_commit_ID++;\n\t\t\tcontinue;\n\n\t\tcase JFS_REVOKE_BLOCK:\n\t\t\t/* If we aren't in the REVOKE pass, then we can\n\t\t\t * just skip over this block. */\n\t\t\tif (pass != PASS_REVOKE) {\n\t\t\t\tbrelse(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\terr = scan_revoke_records(journal, bh,\n\t\t\t\t\t\t  next_commit_ID, info);\n\t\t\tbrelse(bh);\n\t\t\tif (err)\n\t\t\t\tgoto failed;\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tjbd_debug(3, \"Unrecognised magic %d, end of scan.\\n\",\n\t\t\t\t  blocktype);\n\t\t\tbrelse(bh);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n done:\n\t/*\n\t * We broke out of the log scan loop: either we came to the\n\t * known end of the log or we found an unexpected block in the\n\t * log.  If the latter happened, then we know that the \"current\"\n\t * transaction marks the end of the valid log.\n\t */\n\n\tif (pass == PASS_SCAN)\n\t\tinfo->end_transaction = next_commit_ID;\n\telse {\n\t\t/* It's really bad news if different passes end up at\n\t\t * different places (but possible due to IO errors). */\n\t\tif (info->end_transaction != next_commit_ID) {\n\t\t\tprintk (KERN_ERR \"JBD: recovery pass %d ended at \"\n\t\t\t\t\"transaction %u, expected %u\\n\",\n\t\t\t\tpass, next_commit_ID, info->end_transaction);\n\t\t\tif (!success)\n\t\t\t\tsuccess = -EIO;\n\t\t}\n\t}\n\n\treturn success;\n\n failed:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_sequence"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jbd_debug",
          "args": [
            "1",
            "\"No recovery required, last transaction %d\\n\"",
            "be32_to_cpu(sb->s_sequence)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "sb->s_sequence"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&info",
            "0",
            "sizeof(info)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int scan_revoke_records(journal_t *, struct buffer_head *,\n\t\t\t\ttid_t, struct recovery_info *);\n\nint journal_recover(journal_t *journal)\n{\n\tint\t\t\terr, err2;\n\tjournal_superblock_t *\tsb;\n\n\tstruct recovery_info\tinfo;\n\n\tmemset(&info, 0, sizeof(info));\n\tsb = journal->j_superblock;\n\n\t/*\n\t * The journal superblock's s_start field (the current log head)\n\t * is always zero if, and only if, the journal was cleanly\n\t * unmounted.\n\t */\n\n\tif (!sb->s_start) {\n\t\tjbd_debug(1, \"No recovery required, last transaction %d\\n\",\n\t\t\t  be32_to_cpu(sb->s_sequence));\n\t\tjournal->j_transaction_sequence = be32_to_cpu(sb->s_sequence) + 1;\n\t\treturn 0;\n\t}\n\n\terr = do_one_pass(journal, &info, PASS_SCAN);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REVOKE);\n\tif (!err)\n\t\terr = do_one_pass(journal, &info, PASS_REPLAY);\n\n\tjbd_debug(1, \"JBD: recovery, exit status %d, \"\n\t\t  \"recovered transactions %u to %u\\n\",\n\t\t  err, info.start_transaction, info.end_transaction);\n\tjbd_debug(1, \"JBD: Replayed %d and revoked %d/%d blocks\\n\",\n\t\t  info.nr_replays, info.nr_revoke_hits, info.nr_revokes);\n\n\t/* Restart the log at the next transaction ID, thus invalidating\n\t * any existing commit records in the log. */\n\tjournal->j_transaction_sequence = ++info.end_transaction;\n\n\tjournal_clear_revoke(journal);\n\terr2 = sync_blockdev(journal->j_fs_dev);\n\tif (!err)\n\t\terr = err2;\n\t/* Flush disk caches to get replayed data on the permanent storage */\n\tif (journal->j_flags & JFS_BARRIER) {\n\t\terr2 = blkdev_issue_flush(journal->j_fs_dev, GFP_KERNEL, NULL);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "count_tags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
    "lines": "181-202",
    "snippet": "static int count_tags(struct buffer_head *bh, int size)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0;\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + sizeof(journal_block_tag_t)) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tif (!(tag->t_flags & cpu_to_be32(JFS_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be32(JFS_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_FLAG_LAST_TAG"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "JFS_FLAG_SAME_UUID"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int count_tags(struct buffer_head *bh, int size)\n{\n\tchar *\t\t\ttagp;\n\tjournal_block_tag_t *\ttag;\n\tint\t\t\tnr = 0;\n\n\ttagp = &bh->b_data[sizeof(journal_header_t)];\n\n\twhile ((tagp - bh->b_data + sizeof(journal_block_tag_t)) <= size) {\n\t\ttag = (journal_block_tag_t *) tagp;\n\n\t\tnr++;\n\t\ttagp += sizeof(journal_block_tag_t);\n\t\tif (!(tag->t_flags & cpu_to_be32(JFS_FLAG_SAME_UUID)))\n\t\t\ttagp += 16;\n\n\t\tif (tag->t_flags & cpu_to_be32(JFS_FLAG_LAST_TAG))\n\t\t\tbreak;\n\t}\n\n\treturn nr;\n}"
  },
  {
    "function_name": "jread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
    "lines": "131-174",
    "snippet": "static int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk (KERN_ERR \"JBD: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk (KERN_ERR \"JBD: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD: Failed to read block at offset %u\\n\"",
            "offset"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_readahead",
          "args": [
            "journal",
            "offset"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "do_readahead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "69-122",
          "snippet": "static int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t/* Do up to 128K of readahead */\n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_maxlen)\n\t\tmax = journal->j_maxlen;\n\n\t/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at\n\t * a time to the block device IO layer. */\n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk (KERN_ERR \"JBD: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tll_rw_block(READ, nbufs, bufs);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tll_rw_block(READ, nbufs, bufs);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [
            "#define MAXBUF 8"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\n#define MAXBUF 8\n\nstatic int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t/* Do up to 128K of readahead */\n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_maxlen)\n\t\tmax = journal->j_maxlen;\n\n\t/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at\n\t * a time to the block device IO layer. */\n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk (KERN_ERR \"JBD: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tll_rw_block(READ, nbufs, bufs);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tll_rw_block(READ, nbufs, bufs);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "journal_bmap",
          "args": [
            "journal",
            "offset",
            "&blocknr"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "671-696",
          "snippet": "int journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic int jread(struct buffer_head **bhp, journal_t *journal,\n\t\t unsigned int offset)\n{\n\tint err;\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\n\t*bhp = NULL;\n\n\tif (offset >= journal->j_maxlen) {\n\t\tprintk(KERN_ERR \"JBD: corrupted journal superblock\\n\");\n\t\treturn -EIO;\n\t}\n\n\terr = journal_bmap(journal, offset, &blocknr);\n\n\tif (err) {\n\t\tprintk (KERN_ERR \"JBD: bad block at offset %u\\n\",\n\t\t\toffset);\n\t\treturn err;\n\t}\n\n\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\tif (!bh)\n\t\treturn -ENOMEM;\n\n\tif (!buffer_uptodate(bh)) {\n\t\t/* If this is a brand new buffer, start readahead.\n                   Otherwise, we assume we are already reading it.  */\n\t\tif (!buffer_req(bh))\n\t\t\tdo_readahead(journal, offset);\n\t\twait_on_buffer(bh);\n\t}\n\n\tif (!buffer_uptodate(bh)) {\n\t\tprintk (KERN_ERR \"JBD: Failed to read block at offset %u\\n\",\n\t\t\toffset);\n\t\tbrelse(bh);\n\t\treturn -EIO;\n\t}\n\n\t*bhp = bh;\n\treturn 0;\n}"
  },
  {
    "function_name": "do_readahead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
    "lines": "69-122",
    "snippet": "static int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t/* Do up to 128K of readahead */\n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_maxlen)\n\t\tmax = journal->j_maxlen;\n\n\t/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at\n\t * a time to the block device IO layer. */\n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk (KERN_ERR \"JBD: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tll_rw_block(READ, nbufs, bufs);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tll_rw_block(READ, nbufs, bufs);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [
      "#define MAXBUF 8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "journal_brelse_array",
          "args": [
            "bufs",
            "nbufs"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "journal_brelse_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
          "lines": "49-53",
          "snippet": "static void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}",
          "includes": [
            "#include <linux/blkdev.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include \"jfs_user.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "nbufs",
            "bufs"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_locked",
          "args": [
            "bh"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__getblk",
          "args": [
            "journal->j_dev",
            "blocknr",
            "journal->j_blocksize"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"JBD: bad block at offset %u\\n\"",
            "next"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "journal_bmap",
          "args": [
            "journal",
            "next",
            "&blocknr"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "journal_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/journal.c",
          "lines": "671-696",
          "snippet": "int journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/jbd.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poison.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/jbd.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <trace/events/jbd.h>\n#include <linux/ratelimit.h>\n#include <linux/debugfs.h>\n#include <linux/proc_fs.h>\n#include <linux/poison.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/freezer.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/module.h>\n\nint journal_bmap(journal_t *journal, unsigned int blocknr,\n\t\t unsigned int *retp)\n{\n\tint err = 0;\n\tunsigned int ret;\n\n\tif (journal->j_inode) {\n\t\tret = bmap(journal->j_inode, blocknr);\n\t\tif (ret)\n\t\t\t*retp = ret;\n\t\telse {\n\t\t\tchar b[BDEVNAME_SIZE];\n\n\t\t\tprintk(KERN_ALERT \"%s: journal block not found \"\n\t\t\t\t\t\"at offset %u on %s\\n\",\n\t\t\t\t__func__,\n\t\t\t\tblocknr,\n\t\t\t\tbdevname(journal->j_dev, b));\n\t\t\terr = -EIO;\n\t\t\t__journal_abort_soft(journal, err);\n\t\t}\n\t} else {\n\t\t*retp = blocknr; /* +journal->j_blk_offset */\n\t}\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\n#define MAXBUF 8\n\nstatic int do_readahead(journal_t *journal, unsigned int start)\n{\n\tint err;\n\tunsigned int max, nbufs, next;\n\tunsigned int blocknr;\n\tstruct buffer_head *bh;\n\n\tstruct buffer_head * bufs[MAXBUF];\n\n\t/* Do up to 128K of readahead */\n\tmax = start + (128 * 1024 / journal->j_blocksize);\n\tif (max > journal->j_maxlen)\n\t\tmax = journal->j_maxlen;\n\n\t/* Do the readahead itself.  We'll submit MAXBUF buffer_heads at\n\t * a time to the block device IO layer. */\n\n\tnbufs = 0;\n\n\tfor (next = start; next < max; next++) {\n\t\terr = journal_bmap(journal, next, &blocknr);\n\n\t\tif (err) {\n\t\t\tprintk (KERN_ERR \"JBD: bad block at offset %u\\n\",\n\t\t\t\tnext);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbh = __getblk(journal->j_dev, blocknr, journal->j_blocksize);\n\t\tif (!bh) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto failed;\n\t\t}\n\n\t\tif (!buffer_uptodate(bh) && !buffer_locked(bh)) {\n\t\t\tbufs[nbufs++] = bh;\n\t\t\tif (nbufs == MAXBUF) {\n\t\t\t\tll_rw_block(READ, nbufs, bufs);\n\t\t\t\tjournal_brelse_array(bufs, nbufs);\n\t\t\t\tnbufs = 0;\n\t\t\t}\n\t\t} else\n\t\t\tbrelse(bh);\n\t}\n\n\tif (nbufs)\n\t\tll_rw_block(READ, nbufs, bufs);\n\terr = 0;\n\nfailed:\n\tif (nbufs)\n\t\tjournal_brelse_array(bufs, nbufs);\n\treturn err;\n}"
  },
  {
    "function_name": "journal_brelse_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/jbd/recovery.c",
    "lines": "49-53",
    "snippet": "static void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}",
    "includes": [
      "#include <linux/blkdev.h>",
      "#include <linux/errno.h>",
      "#include <linux/jbd.h>",
      "#include <linux/fs.h>",
      "#include <linux/time.h>",
      "#include \"jfs_user.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "b[n]"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/blkdev.h>\n#include <linux/errno.h>\n#include <linux/jbd.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include \"jfs_user.h\"\n\nstatic void journal_brelse_array(struct buffer_head *b[], int n)\n{\n\twhile (--n >= 0)\n\t\tbrelse (b[n]);\n}"
  }
]