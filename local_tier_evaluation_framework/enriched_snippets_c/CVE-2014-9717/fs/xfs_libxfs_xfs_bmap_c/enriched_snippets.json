[
  {
    "function_name": "xfs_bmap_shift_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "5593-5698",
    "snippet": "int\nxfs_bmap_shift_extents(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\toffset_shift_fsb,\n\tint\t\t\t*done,\n\txfs_fileoff_t\t\t*next_fsb,\n\txfs_fsblock_t\t\t*firstblock,\n\tstruct xfs_bmap_free\t*flist,\n\tint\t\t\tnum_exts)\n{\n\tstruct xfs_btree_cur\t\t*cur = NULL;\n\tstruct xfs_bmbt_rec_host\t*gotp;\n\tstruct xfs_bmbt_irec            got;\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_extnum_t\t\t\tnexts = 0;\n\txfs_extnum_t\t\t\tcurrent_ext;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\twhichfork = XFS_DATA_FORK;\n\tint\t\t\t\tlogflags = 0;\n\tint\t\t\t\ttotal_extents;\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmap_shift_extents\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\t/* Read in all the extents */\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t}\n\n\t/*\n\t * Look up the extent index for the fsb where we start shifting. We can\n\t * henceforth iterate with current_ext as extent list changes are locked\n\t * out via ilock.\n\t *\n\t * gotp can be null in 2 cases: 1) if there are no extents or 2)\n\t * start_fsb lies in a hole beyond which there are no extents. Either\n\t * way, we are done.\n\t */\n\tgotp = xfs_iext_bno_to_ext(ifp, start_fsb, &current_ext);\n\tif (!gotp) {\n\t\t*done = 1;\n\t\tgoto del_cursor;\n\t}\n\n\t/*\n\t * There may be delalloc extents in the data fork before the range we\n\t * are collapsing out, so we cannot use the count of real extents here.\n\t * Instead we have to calculate it from the incore fork.\n\t */\n\ttotal_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\twhile (nexts++ < num_exts && current_ext < total_extents) {\n\t\terror = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,\n\t\t\t\t\t&current_ext, gotp, cur, &logflags);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\n\t\t/* update total extent count and grab the next record */\n\t\ttotal_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\t\tif (current_ext >= total_extents)\n\t\t\tbreak;\n\t\tgotp = xfs_iext_get_ext(ifp, current_ext);\n\t}\n\n\t/* Check if we are done */\n\tif (current_ext == total_extents) {\n\t\t*done = 1;\n\t} else if (next_fsb) {\n\t\txfs_bmbt_get_all(gotp, &got);\n\t\t*next_fsb = got.br_startoff;\n\t}\n\ndel_cursor:\n\tif (cur)\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "logflags"
          ],
          "line": 5695
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR"
          ],
          "line": 5691
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "gotp",
            "&got"
          ],
          "line": 5685
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "current_ext"
          ],
          "line": 5678
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmse_shift_one",
          "args": [
            "ip",
            "whichfork",
            "offset_shift_fsb",
            "&current_ext",
            "gotp",
            "cur",
            "&logflags"
          ],
          "line": 5669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmse_shift_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5513-5581",
          "snippet": "STATIC int\nxfs_bmse_shift_one(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\toffset_shift_fsb,\n\tint\t\t\t\t*current_ext,\n\tstruct xfs_bmbt_rec_host\t*gotp,\n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\n{\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_fileoff_t\t\t\tstartoff;\n\tstruct xfs_bmbt_rec_host\t*leftp;\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tleft;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\txfs_bmbt_get_all(gotp, &got);\n\tstartoff = got.br_startoff - offset_shift_fsb;\n\n\t/* delalloc extents should be prevented by caller */\n\tXFS_WANT_CORRUPTED_RETURN(!isnullstartblock(got.br_startblock));\n\n\t/*\n\t * Check for merge if we've got an extent to the left, otherwise make\n\t * sure there's enough room at the start of the file for the shift.\n\t */\n\tif (*current_ext) {\n\t\t/* grab the left extent and check for a large enough hole */\n\t\tleftp = xfs_iext_get_ext(ifp, *current_ext - 1);\n\t\txfs_bmbt_get_all(leftp, &left);\n\n\t\tif (startoff < left.br_startoff + left.br_blockcount)\n\t\t\treturn -EINVAL;\n\n\t\t/* check whether to merge the extent or shift it down */\n\t\tif (xfs_bmse_can_merge(&left, &got, offset_shift_fsb)) {\n\t\t\treturn xfs_bmse_merge(ip, whichfork, offset_shift_fsb,\n\t\t\t\t\t      *current_ext, gotp, leftp, cur,\n\t\t\t\t\t      logflags);\n\t\t}\n\t} else if (got.br_startoff < offset_shift_fsb)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Increment the extent index for the next iteration, update the start\n\t * offset of the in-core extent and update the btree if applicable.\n\t */\n\t(*current_ext)++;\n\txfs_bmbt_set_startoff(gotp, startoff);\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\treturn 0;\n\t}\n\n\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,\n\t\t\t\t   got.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\tgot.br_startoff = startoff;\n\treturn xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,\n\t\t\t\tgot.br_blockcount, got.br_state);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmse_shift_one(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\toffset_shift_fsb,\n\tint\t\t\t\t*current_ext,\n\tstruct xfs_bmbt_rec_host\t*gotp,\n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\n{\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_fileoff_t\t\t\tstartoff;\n\tstruct xfs_bmbt_rec_host\t*leftp;\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tleft;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\txfs_bmbt_get_all(gotp, &got);\n\tstartoff = got.br_startoff - offset_shift_fsb;\n\n\t/* delalloc extents should be prevented by caller */\n\tXFS_WANT_CORRUPTED_RETURN(!isnullstartblock(got.br_startblock));\n\n\t/*\n\t * Check for merge if we've got an extent to the left, otherwise make\n\t * sure there's enough room at the start of the file for the shift.\n\t */\n\tif (*current_ext) {\n\t\t/* grab the left extent and check for a large enough hole */\n\t\tleftp = xfs_iext_get_ext(ifp, *current_ext - 1);\n\t\txfs_bmbt_get_all(leftp, &left);\n\n\t\tif (startoff < left.br_startoff + left.br_blockcount)\n\t\t\treturn -EINVAL;\n\n\t\t/* check whether to merge the extent or shift it down */\n\t\tif (xfs_bmse_can_merge(&left, &got, offset_shift_fsb)) {\n\t\t\treturn xfs_bmse_merge(ip, whichfork, offset_shift_fsb,\n\t\t\t\t\t      *current_ext, gotp, leftp, cur,\n\t\t\t\t\t      logflags);\n\t\t}\n\t} else if (got.br_startoff < offset_shift_fsb)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Increment the extent index for the next iteration, update the start\n\t * offset of the in-core extent and update the btree if applicable.\n\t */\n\t(*current_ext)++;\n\txfs_bmbt_set_startoff(gotp, startoff);\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\treturn 0;\n\t}\n\n\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,\n\t\t\t\t   got.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\tgot.br_startoff = startoff;\n\treturn xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,\n\t\t\t\tgot.br_blockcount, got.br_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_bno_to_ext",
          "args": [
            "ifp",
            "start_fsb",
            "&current_ext"
          ],
          "line": 5656
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_bno_to_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1528-1592",
          "snippet": "xfs_bmbt_rec_host_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\txfs_extnum_t\t*idxp)\t\t/* index of target extent */\n{\n\txfs_bmbt_rec_host_t *base;\t/* pointer to first extent */\n\txfs_filblks_t\tblockcount = 0;\t/* number of blocks in extent */\n\txfs_bmbt_rec_host_t *ep = NULL;\t/* pointer to target extent */\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\tint\t\thigh;\t\t/* upper boundary in search */\n\txfs_extnum_t\tidx = 0;\t/* index of target extent */\n\tint\t\tlow;\t\t/* lower boundary in search */\n\txfs_extnum_t\tnextents;\t/* number of file extents */\n\txfs_fileoff_t\tstartoff = 0;\t/* start offset of extent */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*idxp = 0;\n\t\treturn NULL;\n\t}\n\tlow = 0;\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t/* Find target extent list */\n\t\tint\terp_idx = 0;\n\t\terp = xfs_iext_bno_to_irec(ifp, bno, &erp_idx);\n\t\tbase = erp->er_extbuf;\n\t\thigh = erp->er_extcount - 1;\n\t} else {\n\t\tbase = ifp->if_u1.if_extents;\n\t\thigh = nextents - 1;\n\t}\n\t/* Binary search extent records */\n\twhile (low <= high) {\n\t\tidx = (low + high) >> 1;\n\t\tep = base + idx;\n\t\tstartoff = xfs_bmbt_get_startoff(ep);\n\t\tblockcount = xfs_bmbt_get_blockcount(ep);\n\t\tif (bno < startoff) {\n\t\t\thigh = idx - 1;\n\t\t} else if (bno >= startoff + blockcount) {\n\t\t\tlow = idx + 1;\n\t\t} else {\n\t\t\t/* Convert back to file-based extent index */\n\t\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\t\tidx += erp->er_extoff;\n\t\t\t}\n\t\t\t*idxp = idx;\n\t\t\treturn ep;\n\t\t}\n\t}\n\t/* Convert back to file-based extent index */\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tidx += erp->er_extoff;\n\t}\n\tif (bno >= startoff + blockcount) {\n\t\tif (++idx == nextents) {\n\t\t\tep = NULL;\n\t\t} else {\n\t\t\tep = xfs_iext_get_ext(ifp, idx);\n\t\t}\n\t}\n\t*idxp = idx;\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\txfs_extnum_t\t*idxp)\t\t/* index of target extent */\n{\n\txfs_bmbt_rec_host_t *base;\t/* pointer to first extent */\n\txfs_filblks_t\tblockcount = 0;\t/* number of blocks in extent */\n\txfs_bmbt_rec_host_t *ep = NULL;\t/* pointer to target extent */\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\tint\t\thigh;\t\t/* upper boundary in search */\n\txfs_extnum_t\tidx = 0;\t/* index of target extent */\n\tint\t\tlow;\t\t/* lower boundary in search */\n\txfs_extnum_t\tnextents;\t/* number of file extents */\n\txfs_fileoff_t\tstartoff = 0;\t/* start offset of extent */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*idxp = 0;\n\t\treturn NULL;\n\t}\n\tlow = 0;\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t/* Find target extent list */\n\t\tint\terp_idx = 0;\n\t\terp = xfs_iext_bno_to_irec(ifp, bno, &erp_idx);\n\t\tbase = erp->er_extbuf;\n\t\thigh = erp->er_extcount - 1;\n\t} else {\n\t\tbase = ifp->if_u1.if_extents;\n\t\thigh = nextents - 1;\n\t}\n\t/* Binary search extent records */\n\twhile (low <= high) {\n\t\tidx = (low + high) >> 1;\n\t\tep = base + idx;\n\t\tstartoff = xfs_bmbt_get_startoff(ep);\n\t\tblockcount = xfs_bmbt_get_blockcount(ep);\n\t\tif (bno < startoff) {\n\t\t\thigh = idx - 1;\n\t\t} else if (bno >= startoff + blockcount) {\n\t\t\tlow = idx + 1;\n\t\t} else {\n\t\t\t/* Convert back to file-based extent index */\n\t\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\t\tidx += erp->er_extoff;\n\t\t\t}\n\t\t\t*idxp = idx;\n\t\t\treturn ep;\n\t\t}\n\t}\n\t/* Convert back to file-based extent index */\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tidx += erp->er_extoff;\n\t}\n\tif (bno >= startoff + blockcount) {\n\t\tif (++idx == nextents) {\n\t\t\tep = NULL;\n\t\t} else {\n\t\t\tep = xfs_iext_get_ext(ifp, idx);\n\t\t}\n\t}\n\t*idxp = idx;\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_init_cursor",
          "args": [
            "mp",
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 5641
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "776-808",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 5635
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 5630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 5630
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_IOLOCK_EXCL)"
          ],
          "line": 5629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 5626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_bmap_shift_extents\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 5621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT)"
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)",
            "mp",
            "XFS_ERRTAG_BMAPIFORMAT",
            "XFS_RANDOM_BMAPIFORMAT"
          ],
          "line": 5617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_shift_extents(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tstart_fsb,\n\txfs_fileoff_t\t\toffset_shift_fsb,\n\tint\t\t\t*done,\n\txfs_fileoff_t\t\t*next_fsb,\n\txfs_fsblock_t\t\t*firstblock,\n\tstruct xfs_bmap_free\t*flist,\n\tint\t\t\tnum_exts)\n{\n\tstruct xfs_btree_cur\t\t*cur = NULL;\n\tstruct xfs_bmbt_rec_host\t*gotp;\n\tstruct xfs_bmbt_irec            got;\n\tstruct xfs_mount\t\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_extnum_t\t\t\tnexts = 0;\n\txfs_extnum_t\t\t\tcurrent_ext;\n\tint\t\t\t\terror = 0;\n\tint\t\t\t\twhichfork = XFS_DATA_FORK;\n\tint\t\t\t\tlogflags = 0;\n\tint\t\t\t\ttotal_extents;\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmap_shift_extents\",\n\t\t\t\t XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\t/* Read in all the extents */\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t}\n\n\t/*\n\t * Look up the extent index for the fsb where we start shifting. We can\n\t * henceforth iterate with current_ext as extent list changes are locked\n\t * out via ilock.\n\t *\n\t * gotp can be null in 2 cases: 1) if there are no extents or 2)\n\t * start_fsb lies in a hole beyond which there are no extents. Either\n\t * way, we are done.\n\t */\n\tgotp = xfs_iext_bno_to_ext(ifp, start_fsb, &current_ext);\n\tif (!gotp) {\n\t\t*done = 1;\n\t\tgoto del_cursor;\n\t}\n\n\t/*\n\t * There may be delalloc extents in the data fork before the range we\n\t * are collapsing out, so we cannot use the count of real extents here.\n\t * Instead we have to calculate it from the incore fork.\n\t */\n\ttotal_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\twhile (nexts++ < num_exts && current_ext < total_extents) {\n\t\terror = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,\n\t\t\t\t\t&current_ext, gotp, cur, &logflags);\n\t\tif (error)\n\t\t\tgoto del_cursor;\n\n\t\t/* update total extent count and grab the next record */\n\t\ttotal_extents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\t\tif (current_ext >= total_extents)\n\t\t\tbreak;\n\t\tgotp = xfs_iext_get_ext(ifp, current_ext);\n\t}\n\n\t/* Check if we are done */\n\tif (current_ext == total_extents) {\n\t\t*done = 1;\n\t} else if (next_fsb) {\n\t\txfs_bmbt_get_all(gotp, &got);\n\t\t*next_fsb = got.br_startoff;\n\t}\n\ndel_cursor:\n\tif (cur)\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmse_shift_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "5513-5581",
    "snippet": "STATIC int\nxfs_bmse_shift_one(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\toffset_shift_fsb,\n\tint\t\t\t\t*current_ext,\n\tstruct xfs_bmbt_rec_host\t*gotp,\n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\n{\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_fileoff_t\t\t\tstartoff;\n\tstruct xfs_bmbt_rec_host\t*leftp;\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tleft;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\txfs_bmbt_get_all(gotp, &got);\n\tstartoff = got.br_startoff - offset_shift_fsb;\n\n\t/* delalloc extents should be prevented by caller */\n\tXFS_WANT_CORRUPTED_RETURN(!isnullstartblock(got.br_startblock));\n\n\t/*\n\t * Check for merge if we've got an extent to the left, otherwise make\n\t * sure there's enough room at the start of the file for the shift.\n\t */\n\tif (*current_ext) {\n\t\t/* grab the left extent and check for a large enough hole */\n\t\tleftp = xfs_iext_get_ext(ifp, *current_ext - 1);\n\t\txfs_bmbt_get_all(leftp, &left);\n\n\t\tif (startoff < left.br_startoff + left.br_blockcount)\n\t\t\treturn -EINVAL;\n\n\t\t/* check whether to merge the extent or shift it down */\n\t\tif (xfs_bmse_can_merge(&left, &got, offset_shift_fsb)) {\n\t\t\treturn xfs_bmse_merge(ip, whichfork, offset_shift_fsb,\n\t\t\t\t\t      *current_ext, gotp, leftp, cur,\n\t\t\t\t\t      logflags);\n\t\t}\n\t} else if (got.br_startoff < offset_shift_fsb)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Increment the extent index for the next iteration, update the start\n\t * offset of the in-core extent and update the btree if applicable.\n\t */\n\t(*current_ext)++;\n\txfs_bmbt_set_startoff(gotp, startoff);\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\treturn 0;\n\t}\n\n\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,\n\t\t\t\t   got.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\tgot.br_startoff = startoff;\n\treturn xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,\n\t\t\t\tgot.br_blockcount, got.br_state);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_update",
          "args": [
            "cur",
            "got.br_startoff",
            "got.br_startblock",
            "got.br_blockcount",
            "got.br_state"
          ],
          "line": 5579
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "160-172",
          "snippet": "STATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 5576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_lookup_eq",
          "args": [
            "cur",
            "got.br_startoff",
            "got.br_startblock",
            "got.br_blockcount",
            "&i"
          ],
          "line": 5572
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "107-119",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_startoff",
          "args": [
            "gotp",
            "startoff"
          ],
          "line": 5565
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "307-316",
          "snippet": "void\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmse_merge",
          "args": [
            "ip",
            "whichfork",
            "offset_shift_fsb",
            "*current_ext",
            "gotp",
            "leftp",
            "cur",
            "logflags"
          ],
          "line": 5553
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmse_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5441-5508",
          "snippet": "STATIC int\nxfs_bmse_merge(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\tshift,\t\t/* shift fsb */\n\tint\t\t\t\tcurrent_ext,\t/* idx of gotp */\n\tstruct xfs_bmbt_rec_host\t*gotp,\t\t/* extent to shift */\n\tstruct xfs_bmbt_rec_host\t*leftp,\t\t/* preceding extent */\n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\t/* output */\n{\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tleft;\n\txfs_filblks_t\t\t\tblockcount;\n\tint\t\t\t\terror, i;\n\n\txfs_bmbt_get_all(gotp, &got);\n\txfs_bmbt_get_all(leftp, &left);\n\tblockcount = left.br_blockcount + got.br_blockcount;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(xfs_bmse_can_merge(&left, &got, shift));\n\n\t/*\n\t * Merge the in-core extents. Note that the host record pointers and\n\t * current_ext index are invalid once the extent has been removed via\n\t * xfs_iext_remove().\n\t */\n\txfs_bmbt_set_blockcount(leftp, blockcount);\n\txfs_iext_remove(ip, current_ext, 1, 0);\n\n\t/*\n\t * Update the on-disk extent count, the btree if necessary and log the\n\t * inode.\n\t */\n\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t   XFS_IFORK_NEXTENTS(ip, whichfork) - 1);\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\treturn 0;\n\t}\n\n\t/* lookup and remove the extent to merge */\n\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,\n\t\t\t\t   got.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\t/* lookup and update size of the previous extent */\n\terror = xfs_bmbt_lookup_eq(cur, left.br_startoff, left.br_startblock,\n\t\t\t\t   left.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\tleft.br_blockcount = blockcount;\n\n\treturn xfs_bmbt_update(cur, left.br_startoff, left.br_startblock,\n\t\t\t       left.br_blockcount, left.br_state);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmse_merge(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\tshift,\t\t/* shift fsb */\n\tint\t\t\t\tcurrent_ext,\t/* idx of gotp */\n\tstruct xfs_bmbt_rec_host\t*gotp,\t\t/* extent to shift */\n\tstruct xfs_bmbt_rec_host\t*leftp,\t\t/* preceding extent */\n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\t/* output */\n{\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tleft;\n\txfs_filblks_t\t\t\tblockcount;\n\tint\t\t\t\terror, i;\n\n\txfs_bmbt_get_all(gotp, &got);\n\txfs_bmbt_get_all(leftp, &left);\n\tblockcount = left.br_blockcount + got.br_blockcount;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(xfs_bmse_can_merge(&left, &got, shift));\n\n\t/*\n\t * Merge the in-core extents. Note that the host record pointers and\n\t * current_ext index are invalid once the extent has been removed via\n\t * xfs_iext_remove().\n\t */\n\txfs_bmbt_set_blockcount(leftp, blockcount);\n\txfs_iext_remove(ip, current_ext, 1, 0);\n\n\t/*\n\t * Update the on-disk extent count, the btree if necessary and log the\n\t * inode.\n\t */\n\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t   XFS_IFORK_NEXTENTS(ip, whichfork) - 1);\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\treturn 0;\n\t}\n\n\t/* lookup and remove the extent to merge */\n\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,\n\t\t\t\t   got.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\t/* lookup and update size of the previous extent */\n\terror = xfs_bmbt_lookup_eq(cur, left.br_startoff, left.br_startblock,\n\t\t\t\t   left.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\tleft.br_blockcount = blockcount;\n\n\treturn xfs_bmbt_update(cur, left.br_startoff, left.br_startblock,\n\t\t\t       left.br_blockcount, left.br_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmse_can_merge",
          "args": [
            "&left",
            "&got",
            "offset_shift_fsb"
          ],
          "line": 5552
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmse_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5409-5430",
          "snippet": "STATIC bool\nxfs_bmse_can_merge(\n\tstruct xfs_bmbt_irec\t*left,\t/* preceding extent */\n\tstruct xfs_bmbt_irec\t*got,\t/* current extent to shift */\n\txfs_fileoff_t\t\tshift)\t/* shift fsb */\n{\n\txfs_fileoff_t\t\tstartoff;\n\n\tstartoff = got->br_startoff - shift;\n\n\t/*\n\t * The extent, once shifted, must be adjacent in-file and on-disk with\n\t * the preceding extent.\n\t */\n\tif ((left->br_startoff + left->br_blockcount != startoff) ||\n\t    (left->br_startblock + left->br_blockcount != got->br_startblock) ||\n\t    (left->br_state != got->br_state) ||\n\t    (left->br_blockcount + got->br_blockcount > MAXEXTLEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_bmse_can_merge(\n\tstruct xfs_bmbt_irec\t*left,\t/* preceding extent */\n\tstruct xfs_bmbt_irec\t*got,\t/* current extent to shift */\n\txfs_fileoff_t\t\tshift)\t/* shift fsb */\n{\n\txfs_fileoff_t\t\tstartoff;\n\n\tstartoff = got->br_startoff - shift;\n\n\t/*\n\t * The extent, once shifted, must be adjacent in-file and on-disk with\n\t * the preceding extent.\n\t */\n\tif ((left->br_startoff + left->br_blockcount != startoff) ||\n\t    (left->br_startblock + left->br_blockcount != got->br_startblock) ||\n\t    (left->br_state != got->br_state) ||\n\t    (left->br_blockcount + got->br_blockcount > MAXEXTLEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "leftp",
            "&left"
          ],
          "line": 5546
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "*current_ext - 1"
          ],
          "line": 5545
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "!isnullstartblock(got.br_startblock)"
          ],
          "line": 5537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "got.br_startblock"
          ],
          "line": 5537
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5531
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmse_shift_one(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\toffset_shift_fsb,\n\tint\t\t\t\t*current_ext,\n\tstruct xfs_bmbt_rec_host\t*gotp,\n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\n{\n\tstruct xfs_ifork\t\t*ifp;\n\txfs_fileoff_t\t\t\tstartoff;\n\tstruct xfs_bmbt_rec_host\t*leftp;\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tleft;\n\tint\t\t\t\terror;\n\tint\t\t\t\ti;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\txfs_bmbt_get_all(gotp, &got);\n\tstartoff = got.br_startoff - offset_shift_fsb;\n\n\t/* delalloc extents should be prevented by caller */\n\tXFS_WANT_CORRUPTED_RETURN(!isnullstartblock(got.br_startblock));\n\n\t/*\n\t * Check for merge if we've got an extent to the left, otherwise make\n\t * sure there's enough room at the start of the file for the shift.\n\t */\n\tif (*current_ext) {\n\t\t/* grab the left extent and check for a large enough hole */\n\t\tleftp = xfs_iext_get_ext(ifp, *current_ext - 1);\n\t\txfs_bmbt_get_all(leftp, &left);\n\n\t\tif (startoff < left.br_startoff + left.br_blockcount)\n\t\t\treturn -EINVAL;\n\n\t\t/* check whether to merge the extent or shift it down */\n\t\tif (xfs_bmse_can_merge(&left, &got, offset_shift_fsb)) {\n\t\t\treturn xfs_bmse_merge(ip, whichfork, offset_shift_fsb,\n\t\t\t\t\t      *current_ext, gotp, leftp, cur,\n\t\t\t\t\t      logflags);\n\t\t}\n\t} else if (got.br_startoff < offset_shift_fsb)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Increment the extent index for the next iteration, update the start\n\t * offset of the in-core extent and update the btree if applicable.\n\t */\n\t(*current_ext)++;\n\txfs_bmbt_set_startoff(gotp, startoff);\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\treturn 0;\n\t}\n\n\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,\n\t\t\t\t   got.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\tgot.br_startoff = startoff;\n\treturn xfs_bmbt_update(cur, got.br_startoff, got.br_startblock,\n\t\t\t\tgot.br_blockcount, got.br_state);\n}"
  },
  {
    "function_name": "xfs_bmse_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "5441-5508",
    "snippet": "STATIC int\nxfs_bmse_merge(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\tshift,\t\t/* shift fsb */\n\tint\t\t\t\tcurrent_ext,\t/* idx of gotp */\n\tstruct xfs_bmbt_rec_host\t*gotp,\t\t/* extent to shift */\n\tstruct xfs_bmbt_rec_host\t*leftp,\t\t/* preceding extent */\n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\t/* output */\n{\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tleft;\n\txfs_filblks_t\t\t\tblockcount;\n\tint\t\t\t\terror, i;\n\n\txfs_bmbt_get_all(gotp, &got);\n\txfs_bmbt_get_all(leftp, &left);\n\tblockcount = left.br_blockcount + got.br_blockcount;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(xfs_bmse_can_merge(&left, &got, shift));\n\n\t/*\n\t * Merge the in-core extents. Note that the host record pointers and\n\t * current_ext index are invalid once the extent has been removed via\n\t * xfs_iext_remove().\n\t */\n\txfs_bmbt_set_blockcount(leftp, blockcount);\n\txfs_iext_remove(ip, current_ext, 1, 0);\n\n\t/*\n\t * Update the on-disk extent count, the btree if necessary and log the\n\t * inode.\n\t */\n\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t   XFS_IFORK_NEXTENTS(ip, whichfork) - 1);\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\treturn 0;\n\t}\n\n\t/* lookup and remove the extent to merge */\n\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,\n\t\t\t\t   got.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\t/* lookup and update size of the previous extent */\n\terror = xfs_bmbt_lookup_eq(cur, left.br_startoff, left.br_startblock,\n\t\t\t\t   left.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\tleft.br_blockcount = blockcount;\n\n\treturn xfs_bmbt_update(cur, left.br_startoff, left.br_startblock,\n\t\t\t       left.br_blockcount, left.br_state);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_update",
          "args": [
            "cur",
            "left.br_startoff",
            "left.br_startblock",
            "left.br_blockcount",
            "left.br_state"
          ],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "160-172",
          "snippet": "STATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 5502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_lookup_eq",
          "args": [
            "cur",
            "left.br_startoff",
            "left.br_startblock",
            "left.br_blockcount",
            "&i"
          ],
          "line": 5498
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "107-119",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 5495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "cur",
            "&i"
          ],
          "line": 5492
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_RETURN",
          "args": [
            "i == 1"
          ],
          "line": 5490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXT_SET",
          "args": [
            "ip",
            "whichfork",
            "XFS_IFORK_NEXTENTS(ip, whichfork) - 1"
          ],
          "line": 5477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_remove",
          "args": [
            "ip",
            "current_ext",
            "1",
            "0"
          ],
          "line": 5471
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1160-1187",
          "snippet": "void\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_blockcount",
          "args": [
            "leftp",
            "blockcount"
          ],
          "line": 5470
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "279-287",
          "snippet": "void\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_bmse_can_merge(&left, &got, shift)"
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmse_can_merge",
          "args": [
            "&left",
            "&got",
            "shift"
          ],
          "line": 5463
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmse_can_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "5409-5430",
          "snippet": "STATIC bool\nxfs_bmse_can_merge(\n\tstruct xfs_bmbt_irec\t*left,\t/* preceding extent */\n\tstruct xfs_bmbt_irec\t*got,\t/* current extent to shift */\n\txfs_fileoff_t\t\tshift)\t/* shift fsb */\n{\n\txfs_fileoff_t\t\tstartoff;\n\n\tstartoff = got->br_startoff - shift;\n\n\t/*\n\t * The extent, once shifted, must be adjacent in-file and on-disk with\n\t * the preceding extent.\n\t */\n\tif ((left->br_startoff + left->br_blockcount != startoff) ||\n\t    (left->br_startblock + left->br_blockcount != got->br_startblock) ||\n\t    (left->br_state != got->br_state) ||\n\t    (left->br_blockcount + got->br_blockcount > MAXEXTLEN))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_bmse_can_merge(\n\tstruct xfs_bmbt_irec\t*left,\t/* preceding extent */\n\tstruct xfs_bmbt_irec\t*got,\t/* current extent to shift */\n\txfs_fileoff_t\t\tshift)\t/* shift fsb */\n{\n\txfs_fileoff_t\t\tstartoff;\n\n\tstartoff = got->br_startoff - shift;\n\n\t/*\n\t * The extent, once shifted, must be adjacent in-file and on-disk with\n\t * the preceding extent.\n\t */\n\tif ((left->br_startoff + left->br_blockcount != startoff) ||\n\t    (left->br_startblock + left->br_blockcount != got->br_startblock) ||\n\t    (left->br_state != got->br_state) ||\n\t    (left->br_blockcount + got->br_blockcount > MAXEXTLEN))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 5462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 5462
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_IOLOCK_EXCL)"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "leftp",
            "&left"
          ],
          "line": 5458
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmse_merge(\n\tstruct xfs_inode\t\t*ip,\n\tint\t\t\t\twhichfork,\n\txfs_fileoff_t\t\t\tshift,\t\t/* shift fsb */\n\tint\t\t\t\tcurrent_ext,\t/* idx of gotp */\n\tstruct xfs_bmbt_rec_host\t*gotp,\t\t/* extent to shift */\n\tstruct xfs_bmbt_rec_host\t*leftp,\t\t/* preceding extent */\n\tstruct xfs_btree_cur\t\t*cur,\n\tint\t\t\t\t*logflags)\t/* output */\n{\n\tstruct xfs_bmbt_irec\t\tgot;\n\tstruct xfs_bmbt_irec\t\tleft;\n\txfs_filblks_t\t\t\tblockcount;\n\tint\t\t\t\terror, i;\n\n\txfs_bmbt_get_all(gotp, &got);\n\txfs_bmbt_get_all(leftp, &left);\n\tblockcount = left.br_blockcount + got.br_blockcount;\n\n\tASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(xfs_bmse_can_merge(&left, &got, shift));\n\n\t/*\n\t * Merge the in-core extents. Note that the host record pointers and\n\t * current_ext index are invalid once the extent has been removed via\n\t * xfs_iext_remove().\n\t */\n\txfs_bmbt_set_blockcount(leftp, blockcount);\n\txfs_iext_remove(ip, current_ext, 1, 0);\n\n\t/*\n\t * Update the on-disk extent count, the btree if necessary and log the\n\t * inode.\n\t */\n\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t   XFS_IFORK_NEXTENTS(ip, whichfork) - 1);\n\t*logflags |= XFS_ILOG_CORE;\n\tif (!cur) {\n\t\t*logflags |= XFS_ILOG_DEXT;\n\t\treturn 0;\n\t}\n\n\t/* lookup and remove the extent to merge */\n\terror = xfs_bmbt_lookup_eq(cur, got.br_startoff, got.br_startblock,\n\t\t\t\t   got.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\terror = xfs_btree_delete(cur, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\t/* lookup and update size of the previous extent */\n\terror = xfs_bmbt_lookup_eq(cur, left.br_startoff, left.br_startblock,\n\t\t\t\t   left.br_blockcount, &i);\n\tif (error)\n\t\treturn error;\n\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\n\tleft.br_blockcount = blockcount;\n\n\treturn xfs_bmbt_update(cur, left.br_startoff, left.br_startblock,\n\t\t\t       left.br_blockcount, left.br_state);\n}"
  },
  {
    "function_name": "xfs_bmse_can_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "5409-5430",
    "snippet": "STATIC bool\nxfs_bmse_can_merge(\n\tstruct xfs_bmbt_irec\t*left,\t/* preceding extent */\n\tstruct xfs_bmbt_irec\t*got,\t/* current extent to shift */\n\txfs_fileoff_t\t\tshift)\t/* shift fsb */\n{\n\txfs_fileoff_t\t\tstartoff;\n\n\tstartoff = got->br_startoff - shift;\n\n\t/*\n\t * The extent, once shifted, must be adjacent in-file and on-disk with\n\t * the preceding extent.\n\t */\n\tif ((left->br_startoff + left->br_blockcount != startoff) ||\n\t    (left->br_startblock + left->br_blockcount != got->br_startblock) ||\n\t    (left->br_state != got->br_state) ||\n\t    (left->br_blockcount + got->br_blockcount > MAXEXTLEN))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC bool\nxfs_bmse_can_merge(\n\tstruct xfs_bmbt_irec\t*left,\t/* preceding extent */\n\tstruct xfs_bmbt_irec\t*got,\t/* current extent to shift */\n\txfs_fileoff_t\t\tshift)\t/* shift fsb */\n{\n\txfs_fileoff_t\t\tstartoff;\n\n\tstartoff = got->br_startoff - shift;\n\n\t/*\n\t * The extent, once shifted, must be adjacent in-file and on-disk with\n\t * the preceding extent.\n\t */\n\tif ((left->br_startoff + left->br_blockcount != startoff) ||\n\t    (left->br_startblock + left->br_blockcount != got->br_startblock) ||\n\t    (left->br_state != got->br_state) ||\n\t    (left->br_blockcount + got->br_blockcount > MAXEXTLEN))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "xfs_bunmapi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "5030-5403",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR"
          ],
          "line": 5399
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "logflags"
          ],
          "line": 5393
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fbroot",
          "args": [
            "whichfork"
          ],
          "line": 5387
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fbroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "336-339",
          "snippet": "static inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */",
            "#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */\n#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */\n\nstatic inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fext",
          "args": [
            "whichfork"
          ],
          "line": 5384
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "341-344",
          "snippet": "static inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */",
            "#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */\n#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */\n\nstatic inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_btree_to_extents",
          "args": [
            "tp",
            "ip",
            "cur",
            "&tmp_logflags",
            "whichfork"
          ],
          "line": 5367
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_btree_to_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "685-737",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_btree_to_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork)  /* data or attr fork */\n{\n\t/* REFERENCED */\n\tstruct xfs_btree_block\t*cblock;/* child btree block */\n\txfs_fsblock_t\t\tcbno;\t/* child block number */\n\txfs_buf_t\t\t*cbp;\t/* child block's buffer */\n\tint\t\t\terror;\t/* error return value */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork data */\n\txfs_mount_t\t\t*mp;\t/* mount point structure */\n\t__be64\t\t\t*pp;\t/* ptr to block address */\n\tstruct xfs_btree_block\t*rblock;/* root btree block */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\trblock = ifp->if_broot;\n\tASSERT(be16_to_cpu(rblock->bb_level) == 1);\n\tASSERT(be16_to_cpu(rblock->bb_numrecs) == 1);\n\tASSERT(xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0) == 1);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, ifp->if_broot_bytes);\n\tcbno = be64_to_cpu(*pp);\n\t*logflagsp = 0;\n#ifdef DEBUG\n\tif ((error = xfs_btree_check_lptr(cur, cbno, 1)))\n\t\treturn error;\n#endif\n\terror = xfs_btree_read_bufl(mp, tp, cbno, 0, &cbp, XFS_BMAP_BTREE_REF,\n\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\tcblock = XFS_BUF_TO_BLOCK(cbp);\n\tif ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))\n\t\treturn error;\n\txfs_bmap_add_free(cbno, 1, cur->bc_private.b.flist, mp);\n\tip->i_d.di_nblocks--;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, cbp);\n\tif (cur->bc_bufs[0] == cbp)\n\t\tcur->bc_bufs[0] = NULL;\n\txfs_iroot_realloc(ip, -1, whichfork);\n\tASSERT(ifp->if_broot == NULL);\n\tASSERT((ifp->if_flags & XFS_IFBROOT) == 0);\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_btree_to_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork)  /* data or attr fork */\n{\n\t/* REFERENCED */\n\tstruct xfs_btree_block\t*cblock;/* child btree block */\n\txfs_fsblock_t\t\tcbno;\t/* child block number */\n\txfs_buf_t\t\t*cbp;\t/* child block's buffer */\n\tint\t\t\terror;\t/* error return value */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork data */\n\txfs_mount_t\t\t*mp;\t/* mount point structure */\n\t__be64\t\t\t*pp;\t/* ptr to block address */\n\tstruct xfs_btree_block\t*rblock;/* root btree block */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\trblock = ifp->if_broot;\n\tASSERT(be16_to_cpu(rblock->bb_level) == 1);\n\tASSERT(be16_to_cpu(rblock->bb_numrecs) == 1);\n\tASSERT(xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0) == 1);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, ifp->if_broot_bytes);\n\tcbno = be64_to_cpu(*pp);\n\t*logflagsp = 0;\n#ifdef DEBUG\n\tif ((error = xfs_btree_check_lptr(cur, cbno, 1)))\n\t\treturn error;\n#endif\n\terror = xfs_btree_read_bufl(mp, tp, cbno, 0, &cbp, XFS_BMAP_BTREE_REF,\n\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\tcblock = XFS_BUF_TO_BLOCK(cbp);\n\tif ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))\n\t\treturn error;\n\txfs_bmap_add_free(cbno, 1, cur->bc_private.b.flist, mp);\n\tip->i_d.di_nblocks--;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, cbp);\n\tif (cur->bc_bufs[0] == cbp)\n\t\tcur->bc_bufs[0] = NULL;\n\txfs_iroot_realloc(ip, -1, whichfork);\n\tASSERT(ifp->if_broot == NULL);\n\tASSERT((ifp->if_flags & XFS_IFBROOT) == 0);\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur != NULL"
          ],
          "line": 5366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_wants_extents",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5365
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_wants_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "148-153",
          "snippet": "static inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_extents_to_btree",
          "args": [
            "tp",
            "ip",
            "firstblock",
            "flist",
            "&cur",
            "0",
            "&tmp_logflags",
            "whichfork"
          ],
          "line": 5356
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_extents_to_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "743-885",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur == NULL"
          ],
          "line": 5355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_needs_btree",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5354
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_needs_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "138-143",
          "snippet": "static inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "ep",
            "&got"
          ],
          "line": 5344
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "lastx"
          ],
          "line": 5341
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_startoff",
          "args": [
            "ep"
          ],
          "line": 5339
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "155-161",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_del_extent",
          "args": [
            "ip",
            "tp",
            "&lastx",
            "flist",
            "cur",
            "&del",
            "&tmp_logflags",
            "whichfork"
          ],
          "line": 5326
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_del_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4706-5022",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_del_extent(\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_trans_t\t\t*tp,\t/* current transaction pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/delete */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\txfs_btree_cur_t\t\t*cur,\t/* if null, not a btree */\n\txfs_bmbt_irec_t\t\t*del,\t/* data to remove from extents */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork) /* data or attr fork */\n{\n\txfs_filblks_t\t\tda_new;\t/* new delay-alloc indirect blocks */\n\txfs_filblks_t\t\tda_old;\t/* old delay-alloc indirect blocks */\n\txfs_fsblock_t\t\tdel_endblock=0;\t/* first block past del */\n\txfs_fileoff_t\t\tdel_endoff;\t/* first offset past del */\n\tint\t\t\tdelay;\t/* current block is delayed allocated */\n\tint\t\t\tdo_fx;\t/* free extent at end of routine */\n\txfs_bmbt_rec_host_t\t*ep;\t/* current extent entry pointer */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tflags;\t/* inode logging flags */\n\txfs_bmbt_irec_t\t\tgot;\t/* current extent entry */\n\txfs_fileoff_t\t\tgot_endoff;\t/* first offset past got */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_filblks_t\t\tnblks;\t/* quota/sb block count */\n\txfs_bmbt_irec_t\t\tnew;\t/* new record to be inserted */\n\t/* REFERENCED */\n\tuint\t\t\tqfield;\t/* quota field to update */\n\txfs_filblks_t\t\ttemp;\t/* for indirect length calculations */\n\txfs_filblks_t\t\ttemp2;\t/* for indirect length calculations */\n\tint\t\t\tstate = 0;\n\n\tXFS_STATS_INC(xs_del_exlist);\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT((*idx >= 0) && (*idx < ifp->if_bytes /\n\t\t(uint)sizeof(xfs_bmbt_rec_t)));\n\tASSERT(del->br_blockcount > 0);\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &got);\n\tASSERT(got.br_startoff <= del->br_startoff);\n\tdel_endoff = del->br_startoff + del->br_blockcount;\n\tgot_endoff = got.br_startoff + got.br_blockcount;\n\tASSERT(got_endoff >= del_endoff);\n\tdelay = isnullstartblock(got.br_startblock);\n\tASSERT(isnullstartblock(del->br_startblock) == delay);\n\tflags = 0;\n\tqfield = 0;\n\terror = 0;\n\t/*\n\t * If deleting a real allocation, must free up the disk space.\n\t */\n\tif (!delay) {\n\t\tflags = XFS_ILOG_CORE;\n\t\t/*\n\t\t * Realtime allocation.  Free it and record di_nblocks update.\n\t\t */\n\t\tif (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {\n\t\t\txfs_fsblock_t\tbno;\n\t\t\txfs_filblks_t\tlen;\n\n\t\t\tASSERT(do_mod(del->br_blockcount,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0);\n\t\t\tASSERT(do_mod(del->br_startblock,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0);\n\t\t\tbno = del->br_startblock;\n\t\t\tlen = del->br_blockcount;\n\t\t\tdo_div(bno, mp->m_sb.sb_rextsize);\n\t\t\tdo_div(len, mp->m_sb.sb_rextsize);\n\t\t\terror = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tdo_fx = 0;\n\t\t\tnblks = len * mp->m_sb.sb_rextsize;\n\t\t\tqfield = XFS_TRANS_DQ_RTBCOUNT;\n\t\t}\n\t\t/*\n\t\t * Ordinary allocation.\n\t\t */\n\t\telse {\n\t\t\tdo_fx = 1;\n\t\t\tnblks = del->br_blockcount;\n\t\t\tqfield = XFS_TRANS_DQ_BCOUNT;\n\t\t}\n\t\t/*\n\t\t * Set up del_endblock and cur for later.\n\t\t */\n\t\tdel_endblock = del->br_startblock + del->br_blockcount;\n\t\tif (cur) {\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, got.br_startoff,\n\t\t\t\t\tgot.br_startblock, got.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tda_old = da_new = 0;\n\t} else {\n\t\tda_old = startblockval(got.br_startblock);\n\t\tda_new = 0;\n\t\tnblks = 0;\n\t\tdo_fx = 0;\n\t}\n\t/*\n\t * Set flag value to use in switch statement.\n\t * Left-contig is 2, right-contig is 1.\n\t */\n\tswitch (((got.br_startoff == del->br_startoff) << 1) |\n\t\t(got_endoff == del_endoff)) {\n\tcase 3:\n\t\t/*\n\t\t * Matches the whole extent.  Delete the entry.\n\t\t */\n\t\txfs_iext_remove(ip, *idx, 1,\n\t\t\t\twhichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0);\n\t\t--*idx;\n\t\tif (delay)\n\t\t\tbreak;\n\n\t\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(ip, whichfork) - 1);\n\t\tflags |= XFS_ILOG_CORE;\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\tgoto done;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\tbreak;\n\n\tcase 2:\n\t\t/*\n\t\t * Deleting the first part of the extent.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startoff(ep, del_endoff);\n\t\ttemp = got.br_blockcount - del->br_blockcount;\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (delay) {\n\t\t\ttemp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\tda_old);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\t\tda_new = temp;\n\t\t\tbreak;\n\t\t}\n\t\txfs_bmbt_set_startblock(ep, del_endblock);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_bmbt_update(cur, del_endoff, del_endblock,\n\t\t\t\tgot.br_blockcount - del->br_blockcount,\n\t\t\t\tgot.br_state)))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 1:\n\t\t/*\n\t\t * Deleting the last part of the extent.\n\t\t */\n\t\ttemp = got.br_blockcount - del->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (delay) {\n\t\t\ttemp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\tda_old);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\t\tda_new = temp;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_bmbt_update(cur, got.br_startoff,\n\t\t\t\tgot.br_startblock,\n\t\t\t\tgot.br_blockcount - del->br_blockcount,\n\t\t\t\tgot.br_state)))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Deleting the middle of the extent.\n\t\t */\n\t\ttemp = del->br_startoff - got.br_startoff;\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tnew.br_startoff = del_endoff;\n\t\ttemp2 = got_endoff - del_endoff;\n\t\tnew.br_blockcount = temp2;\n\t\tnew.br_state = got.br_state;\n\t\tif (!delay) {\n\t\t\tnew.br_startblock = del_endblock;\n\t\t\tflags |= XFS_ILOG_CORE;\n\t\t\tif (cur) {\n\t\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\tgot.br_startblock, temp,\n\t\t\t\t\t\tgot.br_state)))\n\t\t\t\t\tgoto done;\n\t\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\t\tgoto done;\n\t\t\t\tcur->bc_rec.b = new;\n\t\t\t\terror = xfs_btree_insert(cur, &i);\n\t\t\t\tif (error && error != -ENOSPC)\n\t\t\t\t\tgoto done;\n\t\t\t\t/*\n\t\t\t\t * If get no-space back from btree insert,\n\t\t\t\t * it tried a split, and we have a zero\n\t\t\t\t * block reservation.\n\t\t\t\t * Fix up our state and return the error.\n\t\t\t\t */\n\t\t\t\tif (error == -ENOSPC) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Reset the cursor, don't trust\n\t\t\t\t\t * it after any insert operation.\n\t\t\t\t\t */\n\t\t\t\t\tif ((error = xfs_bmbt_lookup_eq(cur,\n\t\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\t\tgot.br_startblock,\n\t\t\t\t\t\t\ttemp, &i)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t\t\t/*\n\t\t\t\t\t * Update the btree record back\n\t\t\t\t\t * to the original value.\n\t\t\t\t\t */\n\t\t\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\t\tgot.br_startblock,\n\t\t\t\t\t\t\tgot.br_blockcount,\n\t\t\t\t\t\t\tgot.br_state)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t/*\n\t\t\t\t\t * Reset the extent record back\n\t\t\t\t\t * to the original value.\n\t\t\t\t\t */\n\t\t\t\t\txfs_bmbt_set_blockcount(ep,\n\t\t\t\t\t\tgot.br_blockcount);\n\t\t\t\t\tflags = 0;\n\t\t\t\t\terror = -ENOSPC;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t} else\n\t\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t\tXFS_IFORK_NEXTENTS(ip, whichfork) + 1);\n\t\t} else {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\ttemp = xfs_bmap_worst_indlen(ip, temp);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttemp2 = xfs_bmap_worst_indlen(ip, temp2);\n\t\t\tnew.br_startblock = nullstartblock((int)temp2);\n\t\t\tda_new = temp + temp2;\n\t\t\twhile (da_new > da_old) {\n\t\t\t\tif (temp) {\n\t\t\t\t\ttemp--;\n\t\t\t\t\tda_new--;\n\t\t\t\t\txfs_bmbt_set_startblock(ep,\n\t\t\t\t\t\tnullstartblock((int)temp));\n\t\t\t\t}\n\t\t\t\tif (da_new == da_old)\n\t\t\t\t\tbreak;\n\t\t\t\tif (temp2) {\n\t\t\t\t\ttemp2--;\n\t\t\t\t\tda_new--;\n\t\t\t\t\tnew.br_startblock =\n\t\t\t\t\t\tnullstartblock((int)temp2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_insert(ip, *idx + 1, 1, &new, state);\n\t\t++*idx;\n\t\tbreak;\n\t}\n\t/*\n\t * If we need to, add to list of extents to delete.\n\t */\n\tif (do_fx)\n\t\txfs_bmap_add_free(del->br_startblock, del->br_blockcount, flist,\n\t\t\tmp);\n\t/*\n\t * Adjust inode # blocks in the file.\n\t */\n\tif (nblks)\n\t\tip->i_d.di_nblocks -= nblks;\n\t/*\n\t * Adjust quota data.\n\t */\n\tif (qfield)\n\t\txfs_trans_mod_dquot_byino(tp, ip, qfield, (long)-nblks);\n\n\t/*\n\t * Account for change in delayed indirect blocks.\n\t * Nothing to do for disk quota accounting here.\n\t */\n\tASSERT(da_old >= da_new);\n\tif (da_old > da_new) {\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t(int64_t)(da_old - da_new), 0);\n\t}\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_del_extent(\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_trans_t\t\t*tp,\t/* current transaction pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/delete */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\txfs_btree_cur_t\t\t*cur,\t/* if null, not a btree */\n\txfs_bmbt_irec_t\t\t*del,\t/* data to remove from extents */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork) /* data or attr fork */\n{\n\txfs_filblks_t\t\tda_new;\t/* new delay-alloc indirect blocks */\n\txfs_filblks_t\t\tda_old;\t/* old delay-alloc indirect blocks */\n\txfs_fsblock_t\t\tdel_endblock=0;\t/* first block past del */\n\txfs_fileoff_t\t\tdel_endoff;\t/* first offset past del */\n\tint\t\t\tdelay;\t/* current block is delayed allocated */\n\tint\t\t\tdo_fx;\t/* free extent at end of routine */\n\txfs_bmbt_rec_host_t\t*ep;\t/* current extent entry pointer */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tflags;\t/* inode logging flags */\n\txfs_bmbt_irec_t\t\tgot;\t/* current extent entry */\n\txfs_fileoff_t\t\tgot_endoff;\t/* first offset past got */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_filblks_t\t\tnblks;\t/* quota/sb block count */\n\txfs_bmbt_irec_t\t\tnew;\t/* new record to be inserted */\n\t/* REFERENCED */\n\tuint\t\t\tqfield;\t/* quota field to update */\n\txfs_filblks_t\t\ttemp;\t/* for indirect length calculations */\n\txfs_filblks_t\t\ttemp2;\t/* for indirect length calculations */\n\tint\t\t\tstate = 0;\n\n\tXFS_STATS_INC(xs_del_exlist);\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT((*idx >= 0) && (*idx < ifp->if_bytes /\n\t\t(uint)sizeof(xfs_bmbt_rec_t)));\n\tASSERT(del->br_blockcount > 0);\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &got);\n\tASSERT(got.br_startoff <= del->br_startoff);\n\tdel_endoff = del->br_startoff + del->br_blockcount;\n\tgot_endoff = got.br_startoff + got.br_blockcount;\n\tASSERT(got_endoff >= del_endoff);\n\tdelay = isnullstartblock(got.br_startblock);\n\tASSERT(isnullstartblock(del->br_startblock) == delay);\n\tflags = 0;\n\tqfield = 0;\n\terror = 0;\n\t/*\n\t * If deleting a real allocation, must free up the disk space.\n\t */\n\tif (!delay) {\n\t\tflags = XFS_ILOG_CORE;\n\t\t/*\n\t\t * Realtime allocation.  Free it and record di_nblocks update.\n\t\t */\n\t\tif (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {\n\t\t\txfs_fsblock_t\tbno;\n\t\t\txfs_filblks_t\tlen;\n\n\t\t\tASSERT(do_mod(del->br_blockcount,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0);\n\t\t\tASSERT(do_mod(del->br_startblock,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0);\n\t\t\tbno = del->br_startblock;\n\t\t\tlen = del->br_blockcount;\n\t\t\tdo_div(bno, mp->m_sb.sb_rextsize);\n\t\t\tdo_div(len, mp->m_sb.sb_rextsize);\n\t\t\terror = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tdo_fx = 0;\n\t\t\tnblks = len * mp->m_sb.sb_rextsize;\n\t\t\tqfield = XFS_TRANS_DQ_RTBCOUNT;\n\t\t}\n\t\t/*\n\t\t * Ordinary allocation.\n\t\t */\n\t\telse {\n\t\t\tdo_fx = 1;\n\t\t\tnblks = del->br_blockcount;\n\t\t\tqfield = XFS_TRANS_DQ_BCOUNT;\n\t\t}\n\t\t/*\n\t\t * Set up del_endblock and cur for later.\n\t\t */\n\t\tdel_endblock = del->br_startblock + del->br_blockcount;\n\t\tif (cur) {\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, got.br_startoff,\n\t\t\t\t\tgot.br_startblock, got.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tda_old = da_new = 0;\n\t} else {\n\t\tda_old = startblockval(got.br_startblock);\n\t\tda_new = 0;\n\t\tnblks = 0;\n\t\tdo_fx = 0;\n\t}\n\t/*\n\t * Set flag value to use in switch statement.\n\t * Left-contig is 2, right-contig is 1.\n\t */\n\tswitch (((got.br_startoff == del->br_startoff) << 1) |\n\t\t(got_endoff == del_endoff)) {\n\tcase 3:\n\t\t/*\n\t\t * Matches the whole extent.  Delete the entry.\n\t\t */\n\t\txfs_iext_remove(ip, *idx, 1,\n\t\t\t\twhichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0);\n\t\t--*idx;\n\t\tif (delay)\n\t\t\tbreak;\n\n\t\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(ip, whichfork) - 1);\n\t\tflags |= XFS_ILOG_CORE;\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\tgoto done;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\tbreak;\n\n\tcase 2:\n\t\t/*\n\t\t * Deleting the first part of the extent.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startoff(ep, del_endoff);\n\t\ttemp = got.br_blockcount - del->br_blockcount;\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (delay) {\n\t\t\ttemp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\tda_old);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\t\tda_new = temp;\n\t\t\tbreak;\n\t\t}\n\t\txfs_bmbt_set_startblock(ep, del_endblock);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_bmbt_update(cur, del_endoff, del_endblock,\n\t\t\t\tgot.br_blockcount - del->br_blockcount,\n\t\t\t\tgot.br_state)))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 1:\n\t\t/*\n\t\t * Deleting the last part of the extent.\n\t\t */\n\t\ttemp = got.br_blockcount - del->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (delay) {\n\t\t\ttemp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\tda_old);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\t\tda_new = temp;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_bmbt_update(cur, got.br_startoff,\n\t\t\t\tgot.br_startblock,\n\t\t\t\tgot.br_blockcount - del->br_blockcount,\n\t\t\t\tgot.br_state)))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Deleting the middle of the extent.\n\t\t */\n\t\ttemp = del->br_startoff - got.br_startoff;\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tnew.br_startoff = del_endoff;\n\t\ttemp2 = got_endoff - del_endoff;\n\t\tnew.br_blockcount = temp2;\n\t\tnew.br_state = got.br_state;\n\t\tif (!delay) {\n\t\t\tnew.br_startblock = del_endblock;\n\t\t\tflags |= XFS_ILOG_CORE;\n\t\t\tif (cur) {\n\t\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\tgot.br_startblock, temp,\n\t\t\t\t\t\tgot.br_state)))\n\t\t\t\t\tgoto done;\n\t\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\t\tgoto done;\n\t\t\t\tcur->bc_rec.b = new;\n\t\t\t\terror = xfs_btree_insert(cur, &i);\n\t\t\t\tif (error && error != -ENOSPC)\n\t\t\t\t\tgoto done;\n\t\t\t\t/*\n\t\t\t\t * If get no-space back from btree insert,\n\t\t\t\t * it tried a split, and we have a zero\n\t\t\t\t * block reservation.\n\t\t\t\t * Fix up our state and return the error.\n\t\t\t\t */\n\t\t\t\tif (error == -ENOSPC) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Reset the cursor, don't trust\n\t\t\t\t\t * it after any insert operation.\n\t\t\t\t\t */\n\t\t\t\t\tif ((error = xfs_bmbt_lookup_eq(cur,\n\t\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\t\tgot.br_startblock,\n\t\t\t\t\t\t\ttemp, &i)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t\t\t/*\n\t\t\t\t\t * Update the btree record back\n\t\t\t\t\t * to the original value.\n\t\t\t\t\t */\n\t\t\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\t\tgot.br_startblock,\n\t\t\t\t\t\t\tgot.br_blockcount,\n\t\t\t\t\t\t\tgot.br_state)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t/*\n\t\t\t\t\t * Reset the extent record back\n\t\t\t\t\t * to the original value.\n\t\t\t\t\t */\n\t\t\t\t\txfs_bmbt_set_blockcount(ep,\n\t\t\t\t\t\tgot.br_blockcount);\n\t\t\t\t\tflags = 0;\n\t\t\t\t\terror = -ENOSPC;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t} else\n\t\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t\tXFS_IFORK_NEXTENTS(ip, whichfork) + 1);\n\t\t} else {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\ttemp = xfs_bmap_worst_indlen(ip, temp);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttemp2 = xfs_bmap_worst_indlen(ip, temp2);\n\t\t\tnew.br_startblock = nullstartblock((int)temp2);\n\t\t\tda_new = temp + temp2;\n\t\t\twhile (da_new > da_old) {\n\t\t\t\tif (temp) {\n\t\t\t\t\ttemp--;\n\t\t\t\t\tda_new--;\n\t\t\t\t\txfs_bmbt_set_startblock(ep,\n\t\t\t\t\t\tnullstartblock((int)temp));\n\t\t\t\t}\n\t\t\t\tif (da_new == da_old)\n\t\t\t\t\tbreak;\n\t\t\t\tif (temp2) {\n\t\t\t\t\ttemp2--;\n\t\t\t\t\tda_new--;\n\t\t\t\t\tnew.br_startblock =\n\t\t\t\t\t\tnullstartblock((int)temp2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_insert(ip, *idx + 1, 1, &new, state);\n\t\t++*idx;\n\t\tbreak;\n\t}\n\t/*\n\t * If we need to, add to list of extents to delete.\n\t */\n\tif (do_fx)\n\t\txfs_bmap_add_free(del->br_startblock, del->br_blockcount, flist,\n\t\t\tmp);\n\t/*\n\t * Adjust inode # blocks in the file.\n\t */\n\tif (nblks)\n\t\tip->i_d.di_nblocks -= nblks;\n\t/*\n\t * Adjust quota data.\n\t */\n\tif (qfield)\n\t\txfs_trans_mod_dquot_byino(tp, ip, qfield, (long)-nblks);\n\n\t/*\n\t * Account for change in delayed indirect blocks.\n\t * Nothing to do for disk quota accounting here.\n\t */\n\tASSERT(da_old >= da_new);\n\tif (da_old > da_new) {\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t(int64_t)(da_old - da_new), 0);\n\t}\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_block_res",
          "args": [
            "tp"
          ],
          "line": 5316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota_nblks",
          "args": [
            "NULL",
            "ip",
            "-((long)del.br_blockcount)",
            "0",
            "XFS_QMOPT_RES_REGBLKS"
          ],
          "line": 5295
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_nblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "802-832",
          "snippet": "int\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_modify_counters",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS",
            "(int64_t)del.br_blockcount",
            "0"
          ],
          "line": 5293
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_modify_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1846-1977",
          "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mod_incore_sb",
          "args": [
            "mp",
            "XFS_SBS_FREXTENTS",
            "(int64_t)rtexts",
            "0"
          ],
          "line": 5287
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mod_incore_sb_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1312-1349",
          "snippet": "int\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "rtexts",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 5286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_B",
          "args": [
            "mp",
            "del.br_blockcount"
          ],
          "line": 5285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "startblockval(del.br_startblock) > 0"
          ],
          "line": 5280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "startblockval",
          "args": [
            "del.br_startblock"
          ],
          "line": 5280
        },
        "resolved": true,
        "details": {
          "function_name": "startblockval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1389-1392",
          "snippet": "static inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_extent_unwritten_real",
          "args": [
            "tp",
            "ip",
            "&lastx",
            "&cur",
            "&del",
            "firstblock",
            "flist",
            "&logflags"
          ],
          "line": 5271
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_extent_unwritten_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "2289-2809",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_unwritten_real(\n\tstruct xfs_trans\t*tp,\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_btree_cur_t\t\t**curp,\t/* if *curp is null, not a btree */\n\txfs_bmbt_irec_t\t\t*new,\t/* new data to add to file extents */\n\txfs_fsblock_t\t\t*first,\t/* pointer to firstblock variable */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\tint\t\t\t*logflagsp) /* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_exntst_t\t\tnewext;\t/* new extent state */\n\txfs_exntst_t\t\toldext;\t/* old extent state */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\n\t*logflagsp = 0;\n\n\tcur = *curp;\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\n\tASSERT(*idx >= 0);\n\tASSERT(*idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\terror = 0;\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnewext = new->br_state;\n\toldext = (newext == XFS_EXT_UNWRITTEN) ?\n\t\tXFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\tASSERT(PREV.br_state == oldext);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\t/*\n\t * Set flags determining what part of the previous oldext allocation\n\t * extent is being replaced by a newext allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == newext &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx + 1), &RIGHT);\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    newext == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 2, state);\n\t\tip->i_d.di_nextents -= 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\t\tRIGHT.br_blockcount, LEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount,\n\t\t\t\tLEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx - 1, state, _THIS_IP_);\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t--*idx;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + new->br_blockcount,\n\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\tASSERT(ep && xfs_bmbt_get_state(ep) == oldext);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tcur->bc_rec.b = *new;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock,\n\t\t\t\t\tPREV.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tcur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Setting the middle part of a previous oldext extent to\n\t\t * newext.  Contiguity is impossible here.\n\t\t * One extent becomes three extents.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tnew->br_startoff - PREV.br_startoff);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tr[0] = *new;\n\t\tr[1].br_startoff = new_endoff;\n\t\tr[1].br_blockcount =\n\t\t\tPREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\tr[1].br_startblock = new->br_startblock + new->br_blockcount;\n\t\tr[1].br_state = oldext;\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 2, &r[0], state);\n\n\t\tip->i_d.di_nextents += 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/* new right extent - oldext */\n\t\t\tif ((error = xfs_bmbt_update(cur, r[1].br_startoff,\n\t\t\t\tr[1].br_startblock, r[1].br_blockcount,\n\t\t\t\tr[1].br_state)))\n\t\t\t\tgoto done;\n\t\t\t/* new left extent - oldext */\n\t\t\tcur->bc_rec.b = PREV;\n\t\t\tcur->bc_rec.b.br_blockcount =\n\t\t\t\tnew->br_startoff - PREV.br_startoff;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/*\n\t\t\t * Reset the cursor to the position of the new extent\n\t\t\t * we are about to insert as we can't trust it after\n\t\t\t * the previous insert.\n\t\t\t */\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\t/* new middle extent - newext */\n\t\t\tcur->bc_rec.b.br_state = new->br_state;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, first, flist, &cur,\n\t\t\t\t0, &tmp_logflags, XFS_DATA_FORK);\n\t\t*logflagsp |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\t*curp = cur;\n\t}\n\n\txfs_bmap_check_leaf_extents(*curp, ip, XFS_DATA_FORK);\ndone:\n\t*logflagsp |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tPREV\t\tr[2]",
            "#define\tRIGHT\t\tr[1]",
            "#define\tLEFT\t\tr[0]",
            "#define\tPREV\t\tr[2]",
            "#define\tRIGHT\t\tr[1]",
            "#define\tLEFT\t\tr[0]"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_unwritten_real(\n\tstruct xfs_trans\t*tp,\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_btree_cur_t\t\t**curp,\t/* if *curp is null, not a btree */\n\txfs_bmbt_irec_t\t\t*new,\t/* new data to add to file extents */\n\txfs_fsblock_t\t\t*first,\t/* pointer to firstblock variable */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\tint\t\t\t*logflagsp) /* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_exntst_t\t\tnewext;\t/* new extent state */\n\txfs_exntst_t\t\toldext;\t/* old extent state */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\n\t*logflagsp = 0;\n\n\tcur = *curp;\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\n\tASSERT(*idx >= 0);\n\tASSERT(*idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\terror = 0;\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnewext = new->br_state;\n\toldext = (newext == XFS_EXT_UNWRITTEN) ?\n\t\tXFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\tASSERT(PREV.br_state == oldext);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\t/*\n\t * Set flags determining what part of the previous oldext allocation\n\t * extent is being replaced by a newext allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == newext &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx + 1), &RIGHT);\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    newext == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 2, state);\n\t\tip->i_d.di_nextents -= 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\t\tRIGHT.br_blockcount, LEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount,\n\t\t\t\tLEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx - 1, state, _THIS_IP_);\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t--*idx;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + new->br_blockcount,\n\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\tASSERT(ep && xfs_bmbt_get_state(ep) == oldext);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tcur->bc_rec.b = *new;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock,\n\t\t\t\t\tPREV.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tcur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Setting the middle part of a previous oldext extent to\n\t\t * newext.  Contiguity is impossible here.\n\t\t * One extent becomes three extents.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tnew->br_startoff - PREV.br_startoff);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tr[0] = *new;\n\t\tr[1].br_startoff = new_endoff;\n\t\tr[1].br_blockcount =\n\t\t\tPREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\tr[1].br_startblock = new->br_startblock + new->br_blockcount;\n\t\tr[1].br_state = oldext;\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 2, &r[0], state);\n\n\t\tip->i_d.di_nextents += 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/* new right extent - oldext */\n\t\t\tif ((error = xfs_bmbt_update(cur, r[1].br_startoff,\n\t\t\t\tr[1].br_startblock, r[1].br_blockcount,\n\t\t\t\tr[1].br_state)))\n\t\t\t\tgoto done;\n\t\t\t/* new left extent - oldext */\n\t\t\tcur->bc_rec.b = PREV;\n\t\t\tcur->bc_rec.b.br_blockcount =\n\t\t\t\tnew->br_startoff - PREV.br_startoff;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/*\n\t\t\t * Reset the cursor to the position of the new extent\n\t\t\t * we are about to insert as we can't trust it after\n\t\t\t * the previous insert.\n\t\t\t */\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\t/* new middle extent - newext */\n\t\t\tcur->bc_rec.b.br_state = new->br_state;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, first, flist, &cur,\n\t\t\t\t0, &tmp_logflags, XFS_DATA_FORK);\n\t\t*logflagsp |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\t*curp = cur;\n\t}\n\n\txfs_bmap_check_leaf_extents(*curp, ip, XFS_DATA_FORK);\ndone:\n\t*logflagsp |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "del.br_state == XFS_EXT_NORM"
          ],
          "line": 5269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount"
          ],
          "line": 5252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!isnullstartblock(prev.br_startblock)"
          ],
          "line": 5251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "prev.br_startblock"
          ],
          "line": 5251
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "prev.br_state == XFS_EXT_NORM"
          ],
          "line": 5250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "lastx > 0"
          ],
          "line": 5247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno >= del.br_blockcount"
          ],
          "line": 5230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasextflgbit",
          "args": [
            "&mp->m_sb"
          ],
          "line": 5225
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasextflgbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "416-420",
          "snippet": "static inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_block_res",
          "args": [
            "tp"
          ],
          "line": 5224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "del.br_startblock",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 5211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_trans_get_block_res(tp) > 0"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_get_block_res",
          "args": [
            "tp"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "del.br_state == XFS_EXT_NORM"
          ],
          "line": 5192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno >= mod"
          ],
          "line": 5178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "sum",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 5164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ep != NULL"
          ],
          "line": 5151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILEOFF_MIN",
          "args": [
            "bno",
            "got.br_startoff + got.br_blockcount - 1"
          ],
          "line": 5143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "mp->m_rbmip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 5123
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "mp->m_rbmip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 5122
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_init_cursor",
          "args": [
            "mp",
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 5111
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "776-808",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE"
          ],
          "line": 5110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_search_extents",
          "args": [
            "ip",
            "bno",
            "whichfork",
            "&eof",
            "&lastx",
            "&got",
            "&prev"
          ],
          "line": 5096
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_search_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1459-1493",
          "snippet": "STATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 5093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_blk_unmap"
          ],
          "line": 5092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 5085
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nexts >= 0"
          ],
          "line": 5082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len > 0"
          ],
          "line": 5081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 5080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 5080
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 5077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_bunmapi\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount"
          ],
          "line": 5072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE"
          ],
          "line": 5069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 5068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bunmap",
          "args": [
            "ip",
            "bno",
            "len",
            "flags",
            "_RET_IP_"
          ],
          "line": 5064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bunmapi(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting offset to unmap */\n\txfs_filblks_t\t\tlen,\t\t/* length to unmap in file */\n\tint\t\t\tflags,\t\t/* misc flags */\n\txfs_extnum_t\t\tnexts,\t\t/* number of extents max */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*done)\t\t/* set if not done yet */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_irec_t\t\tdel;\t\t/* extent being deleted */\n\tint\t\t\teof;\t\t/* is deleting at eof */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\textno;\t\t/* extent number in list */\n\txfs_bmbt_irec_t\t\tgot;\t\t/* current extent record */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\t\tisrt;\t\t/* freeing in rt area */\n\txfs_extnum_t\t\tlastx;\t\t/* last extent index used */\n\tint\t\t\tlogflags;\t/* transaction logging flags */\n\txfs_extlen_t\t\tmod;\t\t/* rt extent offset */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_irec_t\t\tprev;\t\t/* previous extent record */\n\txfs_fileoff_t\t\tstart;\t\t/* first file offset deleted */\n\tint\t\t\ttmp_logflags;\t/* partial logging flags */\n\tint\t\t\twasdel;\t\t/* was a delayed alloc extent */\n\tint\t\t\twhichfork;\t/* data or attribute fork */\n\txfs_fsblock_t\t\tsum;\n\n\ttrace_xfs_bunmap(ip, bno, len, flags, _RET_IP_);\n\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (unlikely(\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_bunmapi\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tmp = ip->i_mount;\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT(len > 0);\n\tASSERT(nexts >= 0);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*done = 1;\n\t\treturn 0;\n\t}\n\tXFS_STATS_INC(xs_blk_unmap);\n\tisrt = (whichfork == XFS_DATA_FORK) && XFS_IS_REALTIME_INODE(ip);\n\tstart = bno;\n\tbno = start + len - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\n\t/*\n\t * Check to see if the given block number is past the end of the\n\t * file, back up to the last block if so...\n\t */\n\tif (eof) {\n\t\tep = xfs_iext_get_ext(ifp, --lastx);\n\t\txfs_bmbt_get_all(ep, &got);\n\t\tbno = got.br_startoff + got.br_blockcount - 1;\n\t}\n\tlogflags = 0;\n\tif (ifp->if_flags & XFS_IFBROOT) {\n\t\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.flags = 0;\n\t} else\n\t\tcur = NULL;\n\n\tif (isrt) {\n\t\t/*\n\t\t * Synchronize by locking the bitmap inode.\n\t\t */\n\t\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\t\txfs_trans_ijoin(tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\t}\n\n\textno = 0;\n\twhile (bno != (xfs_fileoff_t)-1 && bno >= start && lastx >= 0 &&\n\t       (nexts == 0 || extno < nexts)) {\n\t\t/*\n\t\t * Is the found extent after a hole in which bno lives?\n\t\t * Just back up to the previous extent, if so.\n\t\t */\n\t\tif (got.br_startoff > bno) {\n\t\t\tif (--lastx < 0)\n\t\t\t\tbreak;\n\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t}\n\t\t/*\n\t\t * Is the last block of this extent before the range\n\t\t * we're supposed to delete?  If so, we're done.\n\t\t */\n\t\tbno = XFS_FILEOFF_MIN(bno,\n\t\t\tgot.br_startoff + got.br_blockcount - 1);\n\t\tif (bno < start)\n\t\t\tbreak;\n\t\t/*\n\t\t * Then deal with the (possibly delayed) allocated space\n\t\t * we found.\n\t\t */\n\t\tASSERT(ep != NULL);\n\t\tdel = got;\n\t\twasdel = isnullstartblock(del.br_startblock);\n\t\tif (got.br_startoff < start) {\n\t\t\tdel.br_startoff = start;\n\t\t\tdel.br_blockcount -= start - got.br_startoff;\n\t\t\tif (!wasdel)\n\t\t\t\tdel.br_startblock += start - got.br_startoff;\n\t\t}\n\t\tif (del.br_startoff + del.br_blockcount > bno + 1)\n\t\t\tdel.br_blockcount = bno + 1 - del.br_startoff;\n\t\tsum = del.br_startblock + del.br_blockcount;\n\t\tif (isrt &&\n\t\t    (mod = do_mod(sum, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent not lined up at the end.\n\t\t\t * The extent could have been split into written\n\t\t\t * and unwritten pieces, or we could just be\n\t\t\t * unmapping part of it.  But we can't really\n\t\t\t * get rid of part of a realtime extent.\n\t\t\t */\n\t\t\tif (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t    !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * This piece is unwritten, or we're not\n\t\t\t\t * using unwritten extents.  Skip over it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= mod);\n\t\t\t\tbno -= mod > del.br_blockcount ?\n\t\t\t\t\tdel.br_blockcount : mod;\n\t\t\t\tif (bno < got.br_startoff) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(\n\t\t\t\t\t\t\tifp, lastx), &got);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * It's written, turn it unwritten.\n\t\t\t * This is better than zeroing it.\n\t\t\t */\n\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\tASSERT(xfs_trans_get_block_res(tp) > 0);\n\t\t\t/*\n\t\t\t * If this spans a realtime extent boundary,\n\t\t\t * chop it back to the start of the one we end at.\n\t\t\t */\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_startoff += del.br_blockcount - mod;\n\t\t\t\tdel.br_startblock += del.br_blockcount - mod;\n\t\t\t\tdel.br_blockcount = mod;\n\t\t\t}\n\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp, ip,\n\t\t\t\t\t&lastx, &cur, &del, firstblock, flist,\n\t\t\t\t\t&logflags);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tgoto nodelete;\n\t\t}\n\t\tif (isrt && (mod = do_mod(del.br_startblock, mp->m_sb.sb_rextsize))) {\n\t\t\t/*\n\t\t\t * Realtime extent is lined up at the end but not\n\t\t\t * at the front.  We'll get rid of full extents if\n\t\t\t * we can.\n\t\t\t */\n\t\t\tmod = mp->m_sb.sb_rextsize - mod;\n\t\t\tif (del.br_blockcount > mod) {\n\t\t\t\tdel.br_blockcount -= mod;\n\t\t\t\tdel.br_startoff += mod;\n\t\t\t\tdel.br_startblock += mod;\n\t\t\t} else if ((del.br_startoff == start &&\n\t\t\t\t    (del.br_state == XFS_EXT_UNWRITTEN ||\n\t\t\t\t     xfs_trans_get_block_res(tp) == 0)) ||\n\t\t\t\t   !xfs_sb_version_hasextflgbit(&mp->m_sb)) {\n\t\t\t\t/*\n\t\t\t\t * Can't make it unwritten.  There isn't\n\t\t\t\t * a full extent here so just skip it.\n\t\t\t\t */\n\t\t\t\tASSERT(bno >= del.br_blockcount);\n\t\t\t\tbno -= del.br_blockcount;\n\t\t\t\tif (got.br_startoff > bno) {\n\t\t\t\t\tif (--lastx >= 0) {\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (del.br_state == XFS_EXT_UNWRITTEN) {\n\t\t\t\t/*\n\t\t\t\t * This one is already unwritten.\n\t\t\t\t * It must have a written left neighbor.\n\t\t\t\t * Unwrite the killed part of that one and\n\t\t\t\t * try again.\n\t\t\t\t */\n\t\t\t\tASSERT(lastx > 0);\n\t\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp,\n\t\t\t\t\t\tlastx - 1), &prev);\n\t\t\t\tASSERT(prev.br_state == XFS_EXT_NORM);\n\t\t\t\tASSERT(!isnullstartblock(prev.br_startblock));\n\t\t\t\tASSERT(del.br_startblock ==\n\t\t\t\t       prev.br_startblock + prev.br_blockcount);\n\t\t\t\tif (prev.br_startoff < start) {\n\t\t\t\t\tmod = start - prev.br_startoff;\n\t\t\t\t\tprev.br_blockcount -= mod;\n\t\t\t\t\tprev.br_startblock += mod;\n\t\t\t\t\tprev.br_startoff = start;\n\t\t\t\t}\n\t\t\t\tprev.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\tlastx--;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &prev,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t} else {\n\t\t\t\tASSERT(del.br_state == XFS_EXT_NORM);\n\t\t\t\tdel.br_state = XFS_EXT_UNWRITTEN;\n\t\t\t\terror = xfs_bmap_add_extent_unwritten_real(tp,\n\t\t\t\t\t\tip, &lastx, &cur, &del,\n\t\t\t\t\t\tfirstblock, flist, &logflags);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tgoto nodelete;\n\t\t\t}\n\t\t}\n\t\tif (wasdel) {\n\t\t\tASSERT(startblockval(del.br_startblock) > 0);\n\t\t\t/* Update realtime/data freespace, unreserve quota */\n\t\t\tif (isrt) {\n\t\t\t\txfs_filblks_t rtexts;\n\n\t\t\t\trtexts = XFS_FSB_TO_B(mp, del.br_blockcount);\n\t\t\t\tdo_div(rtexts, mp->m_sb.sb_rextsize);\n\t\t\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t\t(int64_t)rtexts, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_RTBLKS);\n\t\t\t} else {\n\t\t\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t(int64_t)del.br_blockcount, 0);\n\t\t\t\t(void)xfs_trans_reserve_quota_nblks(NULL,\n\t\t\t\t\tip, -((long)del.br_blockcount), 0,\n\t\t\t\t\tXFS_QMOPT_RES_REGBLKS);\n\t\t\t}\n\t\t\tip->i_delayed_blks -= del.br_blockcount;\n\t\t\tif (cur)\n\t\t\t\tcur->bc_private.b.flags |=\n\t\t\t\t\tXFS_BTCUR_BPRV_WASDEL;\n\t\t} else if (cur)\n\t\t\tcur->bc_private.b.flags &= ~XFS_BTCUR_BPRV_WASDEL;\n\t\t/*\n\t\t * If it's the case where the directory code is running\n\t\t * with no block reservation, and the deleted block is in\n\t\t * the middle of its extent, and the resulting insert\n\t\t * of an extent would cause transformation to btree format,\n\t\t * then reject it.  The calling code will then swap\n\t\t * blocks around instead.\n\t\t * We have to do this now, rather than waiting for the\n\t\t * conversion to btree format, since the transaction\n\t\t * will be dirty.\n\t\t */\n\t\tif (!wasdel && xfs_trans_get_block_res(tp) == 0 &&\n\t\t    XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\t    XFS_IFORK_NEXTENTS(ip, whichfork) >= /* Note the >= */\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork) &&\n\t\t    del.br_startoff > got.br_startoff &&\n\t\t    del.br_startoff + del.br_blockcount <\n\t\t    got.br_startoff + got.br_blockcount) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto error0;\n\t\t}\n\t\terror = xfs_bmap_del_extent(ip, tp, &lastx, flist, cur, &del,\n\t\t\t\t&tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t\tbno = del.br_startoff - 1;\nnodelete:\n\t\t/*\n\t\t * If not done go on to the next (previous) record.\n\t\t */\n\t\tif (bno != (xfs_fileoff_t)-1 && bno >= start) {\n\t\t\tif (lastx >= 0) {\n\t\t\t\tep = xfs_iext_get_ext(ifp, lastx);\n\t\t\t\tif (xfs_bmbt_get_startoff(ep) > bno) {\n\t\t\t\t\tif (--lastx >= 0)\n\t\t\t\t\t\tep = xfs_iext_get_ext(ifp,\n\t\t\t\t\t\t\t\t      lastx);\n\t\t\t\t}\n\t\t\t\txfs_bmbt_get_all(ep, &got);\n\t\t\t}\n\t\t\textno++;\n\t\t}\n\t}\n\t*done = bno == (xfs_fileoff_t)-1 || bno < start || lastx < 0;\n\n\t/*\n\t * Convert to a btree if necessary.\n\t */\n\tif (xfs_bmap_needs_btree(ip, whichfork)) {\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist,\n\t\t\t&cur, 0, &tmp_logflags, whichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from btree to extents, give it cur\n\t */\n\telse if (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tASSERT(cur != NULL);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, cur, &tmp_logflags,\n\t\t\twhichfork);\n\t\tlogflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\t/*\n\t * transform from extents to local?\n\t */\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tlogflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tlogflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log inode even in the error case, if the transaction\n\t * is dirty we'll need to shut down the filesystem.\n\t */\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (cur) {\n\t\tif (!error) {\n\t\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\t\tcur->bc_private.b.allocated = 0;\n\t\t}\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmap_del_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "4706-5022",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_del_extent(\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_trans_t\t\t*tp,\t/* current transaction pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/delete */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\txfs_btree_cur_t\t\t*cur,\t/* if null, not a btree */\n\txfs_bmbt_irec_t\t\t*del,\t/* data to remove from extents */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork) /* data or attr fork */\n{\n\txfs_filblks_t\t\tda_new;\t/* new delay-alloc indirect blocks */\n\txfs_filblks_t\t\tda_old;\t/* old delay-alloc indirect blocks */\n\txfs_fsblock_t\t\tdel_endblock=0;\t/* first block past del */\n\txfs_fileoff_t\t\tdel_endoff;\t/* first offset past del */\n\tint\t\t\tdelay;\t/* current block is delayed allocated */\n\tint\t\t\tdo_fx;\t/* free extent at end of routine */\n\txfs_bmbt_rec_host_t\t*ep;\t/* current extent entry pointer */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tflags;\t/* inode logging flags */\n\txfs_bmbt_irec_t\t\tgot;\t/* current extent entry */\n\txfs_fileoff_t\t\tgot_endoff;\t/* first offset past got */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_filblks_t\t\tnblks;\t/* quota/sb block count */\n\txfs_bmbt_irec_t\t\tnew;\t/* new record to be inserted */\n\t/* REFERENCED */\n\tuint\t\t\tqfield;\t/* quota field to update */\n\txfs_filblks_t\t\ttemp;\t/* for indirect length calculations */\n\txfs_filblks_t\t\ttemp2;\t/* for indirect length calculations */\n\tint\t\t\tstate = 0;\n\n\tXFS_STATS_INC(xs_del_exlist);\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT((*idx >= 0) && (*idx < ifp->if_bytes /\n\t\t(uint)sizeof(xfs_bmbt_rec_t)));\n\tASSERT(del->br_blockcount > 0);\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &got);\n\tASSERT(got.br_startoff <= del->br_startoff);\n\tdel_endoff = del->br_startoff + del->br_blockcount;\n\tgot_endoff = got.br_startoff + got.br_blockcount;\n\tASSERT(got_endoff >= del_endoff);\n\tdelay = isnullstartblock(got.br_startblock);\n\tASSERT(isnullstartblock(del->br_startblock) == delay);\n\tflags = 0;\n\tqfield = 0;\n\terror = 0;\n\t/*\n\t * If deleting a real allocation, must free up the disk space.\n\t */\n\tif (!delay) {\n\t\tflags = XFS_ILOG_CORE;\n\t\t/*\n\t\t * Realtime allocation.  Free it and record di_nblocks update.\n\t\t */\n\t\tif (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {\n\t\t\txfs_fsblock_t\tbno;\n\t\t\txfs_filblks_t\tlen;\n\n\t\t\tASSERT(do_mod(del->br_blockcount,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0);\n\t\t\tASSERT(do_mod(del->br_startblock,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0);\n\t\t\tbno = del->br_startblock;\n\t\t\tlen = del->br_blockcount;\n\t\t\tdo_div(bno, mp->m_sb.sb_rextsize);\n\t\t\tdo_div(len, mp->m_sb.sb_rextsize);\n\t\t\terror = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tdo_fx = 0;\n\t\t\tnblks = len * mp->m_sb.sb_rextsize;\n\t\t\tqfield = XFS_TRANS_DQ_RTBCOUNT;\n\t\t}\n\t\t/*\n\t\t * Ordinary allocation.\n\t\t */\n\t\telse {\n\t\t\tdo_fx = 1;\n\t\t\tnblks = del->br_blockcount;\n\t\t\tqfield = XFS_TRANS_DQ_BCOUNT;\n\t\t}\n\t\t/*\n\t\t * Set up del_endblock and cur for later.\n\t\t */\n\t\tdel_endblock = del->br_startblock + del->br_blockcount;\n\t\tif (cur) {\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, got.br_startoff,\n\t\t\t\t\tgot.br_startblock, got.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tda_old = da_new = 0;\n\t} else {\n\t\tda_old = startblockval(got.br_startblock);\n\t\tda_new = 0;\n\t\tnblks = 0;\n\t\tdo_fx = 0;\n\t}\n\t/*\n\t * Set flag value to use in switch statement.\n\t * Left-contig is 2, right-contig is 1.\n\t */\n\tswitch (((got.br_startoff == del->br_startoff) << 1) |\n\t\t(got_endoff == del_endoff)) {\n\tcase 3:\n\t\t/*\n\t\t * Matches the whole extent.  Delete the entry.\n\t\t */\n\t\txfs_iext_remove(ip, *idx, 1,\n\t\t\t\twhichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0);\n\t\t--*idx;\n\t\tif (delay)\n\t\t\tbreak;\n\n\t\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(ip, whichfork) - 1);\n\t\tflags |= XFS_ILOG_CORE;\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\tgoto done;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\tbreak;\n\n\tcase 2:\n\t\t/*\n\t\t * Deleting the first part of the extent.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startoff(ep, del_endoff);\n\t\ttemp = got.br_blockcount - del->br_blockcount;\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (delay) {\n\t\t\ttemp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\tda_old);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\t\tda_new = temp;\n\t\t\tbreak;\n\t\t}\n\t\txfs_bmbt_set_startblock(ep, del_endblock);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_bmbt_update(cur, del_endoff, del_endblock,\n\t\t\t\tgot.br_blockcount - del->br_blockcount,\n\t\t\t\tgot.br_state)))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 1:\n\t\t/*\n\t\t * Deleting the last part of the extent.\n\t\t */\n\t\ttemp = got.br_blockcount - del->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (delay) {\n\t\t\ttemp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\tda_old);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\t\tda_new = temp;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_bmbt_update(cur, got.br_startoff,\n\t\t\t\tgot.br_startblock,\n\t\t\t\tgot.br_blockcount - del->br_blockcount,\n\t\t\t\tgot.br_state)))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Deleting the middle of the extent.\n\t\t */\n\t\ttemp = del->br_startoff - got.br_startoff;\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tnew.br_startoff = del_endoff;\n\t\ttemp2 = got_endoff - del_endoff;\n\t\tnew.br_blockcount = temp2;\n\t\tnew.br_state = got.br_state;\n\t\tif (!delay) {\n\t\t\tnew.br_startblock = del_endblock;\n\t\t\tflags |= XFS_ILOG_CORE;\n\t\t\tif (cur) {\n\t\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\tgot.br_startblock, temp,\n\t\t\t\t\t\tgot.br_state)))\n\t\t\t\t\tgoto done;\n\t\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\t\tgoto done;\n\t\t\t\tcur->bc_rec.b = new;\n\t\t\t\terror = xfs_btree_insert(cur, &i);\n\t\t\t\tif (error && error != -ENOSPC)\n\t\t\t\t\tgoto done;\n\t\t\t\t/*\n\t\t\t\t * If get no-space back from btree insert,\n\t\t\t\t * it tried a split, and we have a zero\n\t\t\t\t * block reservation.\n\t\t\t\t * Fix up our state and return the error.\n\t\t\t\t */\n\t\t\t\tif (error == -ENOSPC) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Reset the cursor, don't trust\n\t\t\t\t\t * it after any insert operation.\n\t\t\t\t\t */\n\t\t\t\t\tif ((error = xfs_bmbt_lookup_eq(cur,\n\t\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\t\tgot.br_startblock,\n\t\t\t\t\t\t\ttemp, &i)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t\t\t/*\n\t\t\t\t\t * Update the btree record back\n\t\t\t\t\t * to the original value.\n\t\t\t\t\t */\n\t\t\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\t\tgot.br_startblock,\n\t\t\t\t\t\t\tgot.br_blockcount,\n\t\t\t\t\t\t\tgot.br_state)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t/*\n\t\t\t\t\t * Reset the extent record back\n\t\t\t\t\t * to the original value.\n\t\t\t\t\t */\n\t\t\t\t\txfs_bmbt_set_blockcount(ep,\n\t\t\t\t\t\tgot.br_blockcount);\n\t\t\t\t\tflags = 0;\n\t\t\t\t\terror = -ENOSPC;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t} else\n\t\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t\tXFS_IFORK_NEXTENTS(ip, whichfork) + 1);\n\t\t} else {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\ttemp = xfs_bmap_worst_indlen(ip, temp);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttemp2 = xfs_bmap_worst_indlen(ip, temp2);\n\t\t\tnew.br_startblock = nullstartblock((int)temp2);\n\t\t\tda_new = temp + temp2;\n\t\t\twhile (da_new > da_old) {\n\t\t\t\tif (temp) {\n\t\t\t\t\ttemp--;\n\t\t\t\t\tda_new--;\n\t\t\t\t\txfs_bmbt_set_startblock(ep,\n\t\t\t\t\t\tnullstartblock((int)temp));\n\t\t\t\t}\n\t\t\t\tif (da_new == da_old)\n\t\t\t\t\tbreak;\n\t\t\t\tif (temp2) {\n\t\t\t\t\ttemp2--;\n\t\t\t\t\tda_new--;\n\t\t\t\t\tnew.br_startblock =\n\t\t\t\t\t\tnullstartblock((int)temp2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_insert(ip, *idx + 1, 1, &new, state);\n\t\t++*idx;\n\t\tbreak;\n\t}\n\t/*\n\t * If we need to, add to list of extents to delete.\n\t */\n\tif (do_fx)\n\t\txfs_bmap_add_free(del->br_startblock, del->br_blockcount, flist,\n\t\t\tmp);\n\t/*\n\t * Adjust inode # blocks in the file.\n\t */\n\tif (nblks)\n\t\tip->i_d.di_nblocks -= nblks;\n\t/*\n\t * Adjust quota data.\n\t */\n\tif (qfield)\n\t\txfs_trans_mod_dquot_byino(tp, ip, qfield, (long)-nblks);\n\n\t/*\n\t * Account for change in delayed indirect blocks.\n\t * Nothing to do for disk quota accounting here.\n\t */\n\tASSERT(da_old >= da_new);\n\tif (da_old > da_new) {\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t(int64_t)(da_old - da_new), 0);\n\t}\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_modify_counters",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS",
            "(int64_t)(da_old - da_new)",
            "0"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_modify_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1846-1977",
          "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "da_old >= da_new"
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "tp",
            "ip",
            "qfield",
            "(long)-nblks"
          ],
          "line": 5008
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_free",
          "args": [
            "del->br_startblock",
            "del->br_blockcount",
            "flist",
            "mp"
          ],
          "line": 4997
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "594-635",
          "snippet": "void\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t\t*xfs_bmap_free_item_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t\t*xfs_bmap_free_item_zone;\n\nvoid\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_insert",
          "args": [
            "ip",
            "*idx + 1",
            "1",
            "&new",
            "state"
          ],
          "line": 4989
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "909-926",
          "snippet": "void\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 4988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nullstartblock",
          "args": [
            "(int)temp2"
          ],
          "line": 4984
        },
        "resolved": true,
        "details": {
          "function_name": "nullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1383-1387",
          "snippet": "static inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)",
            "#define STARTBLOCKVALBITS\t17"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n#define STARTBLOCKVALBITS\t17\n\nstatic inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_startblock",
          "args": [
            "ep",
            "nullstartblock((int)temp)"
          ],
          "line": 4975
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_startblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "292-302",
          "snippet": "void\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_worst_indlen",
          "args": [
            "ip",
            "temp2"
          ],
          "line": 4968
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_worst_indlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "178-203",
          "snippet": "STATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "whichfork == XFS_DATA_FORK"
          ],
          "line": 4965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXT_SET",
          "args": [
            "ip",
            "whichfork",
            "XFS_IFORK_NEXTENTS(ip, whichfork) + 1"
          ],
          "line": 4962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fext",
          "args": [
            "whichfork"
          ],
          "line": 4961
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "341-344",
          "snippet": "static inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */",
            "#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */\n#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */\n\nstatic inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 4959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_blockcount",
          "args": [
            "ep",
            "got.br_blockcount"
          ],
          "line": 4953
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "279-287",
          "snippet": "void\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_update",
          "args": [
            "cur",
            "got.br_startoff",
            "got.br_startblock",
            "got.br_blockcount",
            "got.br_state"
          ],
          "line": 4943
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "160-172",
          "snippet": "STATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 4938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_lookup_eq",
          "args": [
            "cur",
            "got.br_startoff",
            "got.br_startblock",
            "temp",
            "&i"
          ],
          "line": 4933
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "107-119",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_insert",
          "args": [
            "cur",
            "&i"
          ],
          "line": 4919
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3104-3170",
          "snippet": "int\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 4916
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 4901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 4884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 4880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "xfs_bmap_worst_indlen(ip, temp)",
            "da_old"
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 4853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "xfs_bmap_worst_indlen(ip, temp)",
            "da_old"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_startoff",
          "args": [
            "ep",
            "del_endoff"
          ],
          "line": 4846
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "307-316",
          "snippet": "void\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 4845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 4838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "cur",
            "&i"
          ],
          "line": 4836
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXT_SET",
          "args": [
            "ip",
            "whichfork",
            "XFS_IFORK_NEXTENTS(ip, whichfork) - 1"
          ],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_remove",
          "args": [
            "ip",
            "*idx",
            "1",
            "whichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0"
          ],
          "line": 4823
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1160-1187",
          "snippet": "void\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "startblockval",
          "args": [
            "got.br_startblock"
          ],
          "line": 4808
        },
        "resolved": true,
        "details": {
          "function_name": "startblockval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1389-1392",
          "snippet": "static inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_rtfree_extent",
          "args": [
            "tp",
            "bno",
            "(xfs_extlen_t)len"
          ],
          "line": 4780
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_rtfree_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_rtbitmap.c",
          "lines": "947-990",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_rtfree_extent(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to free */\n\txfs_extlen_t\tlen)\t\t/* length of extent freed */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_mount_t\t*mp;\t\t/* file system mount structure */\n\txfs_fsblock_t\tsb;\t\t/* summary file block number */\n\txfs_buf_t\t*sumbp = NULL;\t/* summary file block buffer */\n\n\tmp = tp->t_mountp;\n\n\tASSERT(mp->m_rbmip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\n\terror = xfs_rtcheck_alloc_range(mp, tp, bno, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Free the range of realtime blocks.\n\t */\n\terror = xfs_rtfree_range(mp, tp, bno, len, &sumbp, &sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Mark more blocks free in the superblock.\n\t */\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS, (long)len);\n\t/*\n\t * If we've now freed all the blocks, reset the file sequence\n\t * number to 0.\n\t */\n\tif (tp->t_frextents_delta + mp->m_sb.sb_frextents ==\n\t    mp->m_sb.sb_rextents) {\n\t\tif (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM))\n\t\t\tmp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;\n\t\t*(__uint64_t *)&mp->m_rbmip->i_d.di_atime = 0;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_rtalloc.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_rtfree_extent(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_rtblock_t\tbno,\t\t/* starting block number to free */\n\txfs_extlen_t\tlen)\t\t/* length of extent freed */\n{\n\tint\t\terror;\t\t/* error value */\n\txfs_mount_t\t*mp;\t\t/* file system mount structure */\n\txfs_fsblock_t\tsb;\t\t/* summary file block number */\n\txfs_buf_t\t*sumbp = NULL;\t/* summary file block buffer */\n\n\tmp = tp->t_mountp;\n\n\tASSERT(mp->m_rbmip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(mp->m_rbmip, XFS_ILOCK_EXCL));\n\n\terror = xfs_rtcheck_alloc_range(mp, tp, bno, len);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Free the range of realtime blocks.\n\t */\n\terror = xfs_rtfree_range(mp, tp, bno, len, &sumbp, &sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\t/*\n\t * Mark more blocks free in the superblock.\n\t */\n\txfs_trans_mod_sb(tp, XFS_TRANS_SB_FREXTENTS, (long)len);\n\t/*\n\t * If we've now freed all the blocks, reset the file sequence\n\t * number to 0.\n\t */\n\tif (tp->t_frextents_delta + mp->m_sb.sb_frextents ==\n\t    mp->m_sb.sb_rextents) {\n\t\tif (!(mp->m_rbmip->i_d.di_flags & XFS_DIFLAG_NEWRTBM))\n\t\t\tmp->m_rbmip->i_d.di_flags |= XFS_DIFLAG_NEWRTBM;\n\t\t*(__uint64_t *)&mp->m_rbmip->i_d.di_atime = 0;\n\t\txfs_trans_log_inode(tp, mp->m_rbmip, XFS_ILOG_CORE);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "len",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 4779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "bno",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 4778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "do_mod(del->br_startblock,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "del->br_startblock",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 4774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "do_mod(del->br_blockcount,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "del->br_blockcount",
            "mp->m_sb.sb_rextsize"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 4768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "isnullstartblock(del->br_startblock) == delay"
          ],
          "line": 4756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "del->br_startblock"
          ],
          "line": 4756
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "got_endoff >= del_endoff"
          ],
          "line": 4754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "got.br_startoff <= del->br_startoff"
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "ep",
            "&got"
          ],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "*idx"
          ],
          "line": 4749
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "del->br_blockcount > 0"
          ],
          "line": 4748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(*idx >= 0) && (*idx < ifp->if_bytes /\n\t\t(uint)sizeof(xfs_bmbt_rec_t))"
          ],
          "line": 4746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_del_exlist"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_del_extent(\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_trans_t\t\t*tp,\t/* current transaction pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/delete */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\txfs_btree_cur_t\t\t*cur,\t/* if null, not a btree */\n\txfs_bmbt_irec_t\t\t*del,\t/* data to remove from extents */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork) /* data or attr fork */\n{\n\txfs_filblks_t\t\tda_new;\t/* new delay-alloc indirect blocks */\n\txfs_filblks_t\t\tda_old;\t/* old delay-alloc indirect blocks */\n\txfs_fsblock_t\t\tdel_endblock=0;\t/* first block past del */\n\txfs_fileoff_t\t\tdel_endoff;\t/* first offset past del */\n\tint\t\t\tdelay;\t/* current block is delayed allocated */\n\tint\t\t\tdo_fx;\t/* free extent at end of routine */\n\txfs_bmbt_rec_host_t\t*ep;\t/* current extent entry pointer */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tflags;\t/* inode logging flags */\n\txfs_bmbt_irec_t\t\tgot;\t/* current extent entry */\n\txfs_fileoff_t\t\tgot_endoff;\t/* first offset past got */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_mount_t\t\t*mp;\t/* mount structure */\n\txfs_filblks_t\t\tnblks;\t/* quota/sb block count */\n\txfs_bmbt_irec_t\t\tnew;\t/* new record to be inserted */\n\t/* REFERENCED */\n\tuint\t\t\tqfield;\t/* quota field to update */\n\txfs_filblks_t\t\ttemp;\t/* for indirect length calculations */\n\txfs_filblks_t\t\ttemp2;\t/* for indirect length calculations */\n\tint\t\t\tstate = 0;\n\n\tXFS_STATS_INC(xs_del_exlist);\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT((*idx >= 0) && (*idx < ifp->if_bytes /\n\t\t(uint)sizeof(xfs_bmbt_rec_t)));\n\tASSERT(del->br_blockcount > 0);\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &got);\n\tASSERT(got.br_startoff <= del->br_startoff);\n\tdel_endoff = del->br_startoff + del->br_blockcount;\n\tgot_endoff = got.br_startoff + got.br_blockcount;\n\tASSERT(got_endoff >= del_endoff);\n\tdelay = isnullstartblock(got.br_startblock);\n\tASSERT(isnullstartblock(del->br_startblock) == delay);\n\tflags = 0;\n\tqfield = 0;\n\terror = 0;\n\t/*\n\t * If deleting a real allocation, must free up the disk space.\n\t */\n\tif (!delay) {\n\t\tflags = XFS_ILOG_CORE;\n\t\t/*\n\t\t * Realtime allocation.  Free it and record di_nblocks update.\n\t\t */\n\t\tif (whichfork == XFS_DATA_FORK && XFS_IS_REALTIME_INODE(ip)) {\n\t\t\txfs_fsblock_t\tbno;\n\t\t\txfs_filblks_t\tlen;\n\n\t\t\tASSERT(do_mod(del->br_blockcount,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0);\n\t\t\tASSERT(do_mod(del->br_startblock,\n\t\t\t\t      mp->m_sb.sb_rextsize) == 0);\n\t\t\tbno = del->br_startblock;\n\t\t\tlen = del->br_blockcount;\n\t\t\tdo_div(bno, mp->m_sb.sb_rextsize);\n\t\t\tdo_div(len, mp->m_sb.sb_rextsize);\n\t\t\terror = xfs_rtfree_extent(tp, bno, (xfs_extlen_t)len);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tdo_fx = 0;\n\t\t\tnblks = len * mp->m_sb.sb_rextsize;\n\t\t\tqfield = XFS_TRANS_DQ_RTBCOUNT;\n\t\t}\n\t\t/*\n\t\t * Ordinary allocation.\n\t\t */\n\t\telse {\n\t\t\tdo_fx = 1;\n\t\t\tnblks = del->br_blockcount;\n\t\t\tqfield = XFS_TRANS_DQ_BCOUNT;\n\t\t}\n\t\t/*\n\t\t * Set up del_endblock and cur for later.\n\t\t */\n\t\tdel_endblock = del->br_startblock + del->br_blockcount;\n\t\tif (cur) {\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, got.br_startoff,\n\t\t\t\t\tgot.br_startblock, got.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tda_old = da_new = 0;\n\t} else {\n\t\tda_old = startblockval(got.br_startblock);\n\t\tda_new = 0;\n\t\tnblks = 0;\n\t\tdo_fx = 0;\n\t}\n\t/*\n\t * Set flag value to use in switch statement.\n\t * Left-contig is 2, right-contig is 1.\n\t */\n\tswitch (((got.br_startoff == del->br_startoff) << 1) |\n\t\t(got_endoff == del_endoff)) {\n\tcase 3:\n\t\t/*\n\t\t * Matches the whole extent.  Delete the entry.\n\t\t */\n\t\txfs_iext_remove(ip, *idx, 1,\n\t\t\t\twhichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0);\n\t\t--*idx;\n\t\tif (delay)\n\t\t\tbreak;\n\n\t\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(ip, whichfork) - 1);\n\t\tflags |= XFS_ILOG_CORE;\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\tgoto done;\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\tbreak;\n\n\tcase 2:\n\t\t/*\n\t\t * Deleting the first part of the extent.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startoff(ep, del_endoff);\n\t\ttemp = got.br_blockcount - del->br_blockcount;\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (delay) {\n\t\t\ttemp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\tda_old);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\t\tda_new = temp;\n\t\t\tbreak;\n\t\t}\n\t\txfs_bmbt_set_startblock(ep, del_endblock);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_bmbt_update(cur, del_endoff, del_endblock,\n\t\t\t\tgot.br_blockcount - del->br_blockcount,\n\t\t\t\tgot.br_state)))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 1:\n\t\t/*\n\t\t * Deleting the last part of the extent.\n\t\t */\n\t\ttemp = got.br_blockcount - del->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (delay) {\n\t\t\ttemp = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(ip, temp),\n\t\t\t\tda_old);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\t\tda_new = temp;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tif (!cur) {\n\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tbreak;\n\t\t}\n\t\tif ((error = xfs_bmbt_update(cur, got.br_startoff,\n\t\t\t\tgot.br_startblock,\n\t\t\t\tgot.br_blockcount - del->br_blockcount,\n\t\t\t\tgot.br_state)))\n\t\t\tgoto done;\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Deleting the middle of the extent.\n\t\t */\n\t\ttemp = del->br_startoff - got.br_startoff;\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tnew.br_startoff = del_endoff;\n\t\ttemp2 = got_endoff - del_endoff;\n\t\tnew.br_blockcount = temp2;\n\t\tnew.br_state = got.br_state;\n\t\tif (!delay) {\n\t\t\tnew.br_startblock = del_endblock;\n\t\t\tflags |= XFS_ILOG_CORE;\n\t\t\tif (cur) {\n\t\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\tgot.br_startblock, temp,\n\t\t\t\t\t\tgot.br_state)))\n\t\t\t\t\tgoto done;\n\t\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\t\tgoto done;\n\t\t\t\tcur->bc_rec.b = new;\n\t\t\t\terror = xfs_btree_insert(cur, &i);\n\t\t\t\tif (error && error != -ENOSPC)\n\t\t\t\t\tgoto done;\n\t\t\t\t/*\n\t\t\t\t * If get no-space back from btree insert,\n\t\t\t\t * it tried a split, and we have a zero\n\t\t\t\t * block reservation.\n\t\t\t\t * Fix up our state and return the error.\n\t\t\t\t */\n\t\t\t\tif (error == -ENOSPC) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Reset the cursor, don't trust\n\t\t\t\t\t * it after any insert operation.\n\t\t\t\t\t */\n\t\t\t\t\tif ((error = xfs_bmbt_lookup_eq(cur,\n\t\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\t\tgot.br_startblock,\n\t\t\t\t\t\t\ttemp, &i)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t\t\t/*\n\t\t\t\t\t * Update the btree record back\n\t\t\t\t\t * to the original value.\n\t\t\t\t\t */\n\t\t\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\t\t\t\tgot.br_startoff,\n\t\t\t\t\t\t\tgot.br_startblock,\n\t\t\t\t\t\t\tgot.br_blockcount,\n\t\t\t\t\t\t\tgot.br_state)))\n\t\t\t\t\t\tgoto done;\n\t\t\t\t\t/*\n\t\t\t\t\t * Reset the extent record back\n\t\t\t\t\t * to the original value.\n\t\t\t\t\t */\n\t\t\t\t\txfs_bmbt_set_blockcount(ep,\n\t\t\t\t\t\tgot.br_blockcount);\n\t\t\t\t\tflags = 0;\n\t\t\t\t\terror = -ENOSPC;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t} else\n\t\t\t\tflags |= xfs_ilog_fext(whichfork);\n\t\t\tXFS_IFORK_NEXT_SET(ip, whichfork,\n\t\t\t\tXFS_IFORK_NEXTENTS(ip, whichfork) + 1);\n\t\t} else {\n\t\t\tASSERT(whichfork == XFS_DATA_FORK);\n\t\t\ttemp = xfs_bmap_worst_indlen(ip, temp);\n\t\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\t\ttemp2 = xfs_bmap_worst_indlen(ip, temp2);\n\t\t\tnew.br_startblock = nullstartblock((int)temp2);\n\t\t\tda_new = temp + temp2;\n\t\t\twhile (da_new > da_old) {\n\t\t\t\tif (temp) {\n\t\t\t\t\ttemp--;\n\t\t\t\t\tda_new--;\n\t\t\t\t\txfs_bmbt_set_startblock(ep,\n\t\t\t\t\t\tnullstartblock((int)temp));\n\t\t\t\t}\n\t\t\t\tif (da_new == da_old)\n\t\t\t\t\tbreak;\n\t\t\t\tif (temp2) {\n\t\t\t\t\ttemp2--;\n\t\t\t\t\tda_new--;\n\t\t\t\t\tnew.br_startblock =\n\t\t\t\t\t\tnullstartblock((int)temp2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_insert(ip, *idx + 1, 1, &new, state);\n\t\t++*idx;\n\t\tbreak;\n\t}\n\t/*\n\t * If we need to, add to list of extents to delete.\n\t */\n\tif (do_fx)\n\t\txfs_bmap_add_free(del->br_startblock, del->br_blockcount, flist,\n\t\t\tmp);\n\t/*\n\t * Adjust inode # blocks in the file.\n\t */\n\tif (nblks)\n\t\tip->i_d.di_nblocks -= nblks;\n\t/*\n\t * Adjust quota data.\n\t */\n\tif (qfield)\n\t\txfs_trans_mod_dquot_byino(tp, ip, qfield, (long)-nblks);\n\n\t/*\n\t * Account for change in delayed indirect blocks.\n\t * Nothing to do for disk quota accounting here.\n\t */\n\tASSERT(da_old >= da_new);\n\tif (da_old > da_new) {\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t(int64_t)(da_old - da_new), 0);\n\t}\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmapi_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "4483-4700",
    "snippet": "int\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_validate_ret",
          "args": [
            "orig_bno",
            "orig_len",
            "orig_flags",
            "orig_mval",
            "orig_nmap",
            "*nmap"
          ],
          "line": 4697
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_validate_ret",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "546-579",
          "snippet": "STATIC void\nxfs_bmap_validate_ret(\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags,\n\txfs_bmbt_irec_t\t\t*mval,\n\tint\t\t\tnmap,\n\tint\t\t\tret_nmap)\n{\n\tint\t\t\ti;\t\t/* index to map values */\n\n\tASSERT(ret_nmap <= nmap);\n\n\tfor (i = 0; i < ret_nmap; i++) {\n\t\tASSERT(mval[i].br_blockcount > 0);\n\t\tif (!(flags & XFS_BMAPI_ENTIRE)) {\n\t\t\tASSERT(mval[i].br_startoff >= bno);\n\t\t\tASSERT(mval[i].br_blockcount <= len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount <=\n\t\t\t       bno + len);\n\t\t} else {\n\t\t\tASSERT(mval[i].br_startoff < bno + len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount >\n\t\t\t       bno);\n\t\t}\n\t\tASSERT(i == 0 ||\n\t\t       mval[i - 1].br_startoff + mval[i - 1].br_blockcount ==\n\t\t       mval[i].br_startoff);\n\t\tASSERT(mval[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       mval[i].br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(mval[i].br_state == XFS_EXT_NORM ||\n\t\t       mval[i].br_state == XFS_EXT_UNWRITTEN);\n\t}\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_validate_ret(\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags,\n\txfs_bmbt_irec_t\t\t*mval,\n\tint\t\t\tnmap,\n\tint\t\t\tret_nmap)\n{\n\tint\t\t\ti;\t\t/* index to map values */\n\n\tASSERT(ret_nmap <= nmap);\n\n\tfor (i = 0; i < ret_nmap; i++) {\n\t\tASSERT(mval[i].br_blockcount > 0);\n\t\tif (!(flags & XFS_BMAPI_ENTIRE)) {\n\t\t\tASSERT(mval[i].br_startoff >= bno);\n\t\t\tASSERT(mval[i].br_blockcount <= len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount <=\n\t\t\t       bno + len);\n\t\t} else {\n\t\t\tASSERT(mval[i].br_startoff < bno + len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount >\n\t\t\t       bno);\n\t\t}\n\t\tASSERT(i == 0 ||\n\t\t       mval[i - 1].br_startoff + mval[i - 1].br_blockcount ==\n\t\t       mval[i].br_startoff);\n\t\tASSERT(mval[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       mval[i].br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(mval[i].br_state == XFS_EXT_NORM ||\n\t\t       mval[i].br_state == XFS_EXT_UNWRITTEN);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "bma.cur",
            "error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR"
          ],
          "line": 4693
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock))"
          ],
          "line": 4683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "bma.cur->bc_private.b.firstblock"
          ],
          "line": 4689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "*firstblock"
          ],
          "line": 4688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "bma.cur->bc_private.b.firstblock"
          ],
          "line": 4685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "*firstblock"
          ],
          "line": 4684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "bma.logflags"
          ],
          "line": 4679
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fbroot",
          "args": [
            "whichfork"
          ],
          "line": 4672
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fbroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "336-339",
          "snippet": "static inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */",
            "#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */\n#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */\n\nstatic inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fext",
          "args": [
            "whichfork"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "341-344",
          "snippet": "static inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */",
            "#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */\n#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */\n\nstatic inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork)"
          ],
          "line": 4658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_btree_to_extents",
          "args": [
            "tp",
            "ip",
            "bma.cur",
            "&tmp_logflags",
            "whichfork"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_btree_to_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "685-737",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_btree_to_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork)  /* data or attr fork */\n{\n\t/* REFERENCED */\n\tstruct xfs_btree_block\t*cblock;/* child btree block */\n\txfs_fsblock_t\t\tcbno;\t/* child block number */\n\txfs_buf_t\t\t*cbp;\t/* child block's buffer */\n\tint\t\t\terror;\t/* error return value */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork data */\n\txfs_mount_t\t\t*mp;\t/* mount point structure */\n\t__be64\t\t\t*pp;\t/* ptr to block address */\n\tstruct xfs_btree_block\t*rblock;/* root btree block */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\trblock = ifp->if_broot;\n\tASSERT(be16_to_cpu(rblock->bb_level) == 1);\n\tASSERT(be16_to_cpu(rblock->bb_numrecs) == 1);\n\tASSERT(xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0) == 1);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, ifp->if_broot_bytes);\n\tcbno = be64_to_cpu(*pp);\n\t*logflagsp = 0;\n#ifdef DEBUG\n\tif ((error = xfs_btree_check_lptr(cur, cbno, 1)))\n\t\treturn error;\n#endif\n\terror = xfs_btree_read_bufl(mp, tp, cbno, 0, &cbp, XFS_BMAP_BTREE_REF,\n\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\tcblock = XFS_BUF_TO_BLOCK(cbp);\n\tif ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))\n\t\treturn error;\n\txfs_bmap_add_free(cbno, 1, cur->bc_private.b.flist, mp);\n\tip->i_d.di_nblocks--;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, cbp);\n\tif (cur->bc_bufs[0] == cbp)\n\t\tcur->bc_bufs[0] = NULL;\n\txfs_iroot_realloc(ip, -1, whichfork);\n\tASSERT(ifp->if_broot == NULL);\n\tASSERT((ifp->if_flags & XFS_IFBROOT) == 0);\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_btree_to_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork)  /* data or attr fork */\n{\n\t/* REFERENCED */\n\tstruct xfs_btree_block\t*cblock;/* child btree block */\n\txfs_fsblock_t\t\tcbno;\t/* child block number */\n\txfs_buf_t\t\t*cbp;\t/* child block's buffer */\n\tint\t\t\terror;\t/* error return value */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork data */\n\txfs_mount_t\t\t*mp;\t/* mount point structure */\n\t__be64\t\t\t*pp;\t/* ptr to block address */\n\tstruct xfs_btree_block\t*rblock;/* root btree block */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\trblock = ifp->if_broot;\n\tASSERT(be16_to_cpu(rblock->bb_level) == 1);\n\tASSERT(be16_to_cpu(rblock->bb_numrecs) == 1);\n\tASSERT(xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0) == 1);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, ifp->if_broot_bytes);\n\tcbno = be64_to_cpu(*pp);\n\t*logflagsp = 0;\n#ifdef DEBUG\n\tif ((error = xfs_btree_check_lptr(cur, cbno, 1)))\n\t\treturn error;\n#endif\n\terror = xfs_btree_read_bufl(mp, tp, cbno, 0, &cbp, XFS_BMAP_BTREE_REF,\n\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\tcblock = XFS_BUF_TO_BLOCK(cbp);\n\tif ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))\n\t\treturn error;\n\txfs_bmap_add_free(cbno, 1, cur->bc_private.b.flist, mp);\n\tip->i_d.di_nblocks--;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, cbp);\n\tif (cur->bc_bufs[0] == cbp)\n\t\tcur->bc_bufs[0] = NULL;\n\txfs_iroot_realloc(ip, -1, whichfork);\n\tASSERT(ifp->if_broot == NULL);\n\tASSERT((ifp->if_flags & XFS_IFBROOT) == 0);\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma.cur"
          ],
          "line": 4650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_wants_extents",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_wants_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "148-153",
          "snippet": "static inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, bma.idx)",
            "&bma.got"
          ],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "bma.idx"
          ],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_update_map",
          "args": [
            "&mval",
            "&bno",
            "&len",
            "obno",
            "end",
            "&n",
            "flags"
          ],
          "line": 4624
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_update_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3962-4012",
          "snippet": "STATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tint\t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t/* update previous map with new information */\n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   ((flags & XFS_BMAPI_IGSTATE) ||\n\t\t\tmval[-1].br_state == mval->br_state)) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tint\t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t/* update previous map with new information */\n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   ((flags & XFS_BMAPI_IGSTATE) ||\n\t\t\tmval[-1].br_state == mval->br_state)) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_convert_unwritten",
          "args": [
            "&bma",
            "mval",
            "len",
            "flags"
          ],
          "line": 4617
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_convert_unwritten",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4411-4469",
          "snippet": "STATIC int\nxfs_bmapi_convert_unwritten(\n\tstruct xfs_bmalloca\t*bma,\n\tstruct xfs_bmbt_irec\t*mval,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags)\n{\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\t/* check if we need to do unwritten->real conversion */\n\tif (mval->br_state == XFS_EXT_UNWRITTEN &&\n\t    (flags & XFS_BMAPI_PREALLOC))\n\t\treturn 0;\n\n\t/* check if we need to do real->unwritten conversion */\n\tif (mval->br_state == XFS_EXT_NORM &&\n\t    (flags & (XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT)) !=\n\t\t\t(XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT))\n\t\treturn 0;\n\n\t/*\n\t * Modify (by adding) the state flag, if writing.\n\t */\n\tASSERT(mval->br_blockcount <= len);\n\tif ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(bma->ip->i_mount, bma->tp,\n\t\t\t\t\tbma->ip, whichfork);\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\t\tbma->cur->bc_private.b.flist = bma->flist;\n\t}\n\tmval->br_state = (mval->br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\t? XFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\n\terror = xfs_bmap_add_extent_unwritten_real(bma->tp, bma->ip, &bma->idx,\n\t\t\t&bma->cur, mval, bma->firstblock, bma->flist,\n\t\t\t&tmp_logflags);\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Update our extent pointer, given that\n\t * xfs_bmap_add_extent_unwritten_real might have merged it into one\n\t * of the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &bma->got);\n\n\t/*\n\t * We may have combined previously unwritten space with written space,\n\t * so generate another request.\n\t */\n\tif (mval->br_blockcount < len)\n\t\treturn -EAGAIN;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmapi_convert_unwritten(\n\tstruct xfs_bmalloca\t*bma,\n\tstruct xfs_bmbt_irec\t*mval,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags)\n{\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\t/* check if we need to do unwritten->real conversion */\n\tif (mval->br_state == XFS_EXT_UNWRITTEN &&\n\t    (flags & XFS_BMAPI_PREALLOC))\n\t\treturn 0;\n\n\t/* check if we need to do real->unwritten conversion */\n\tif (mval->br_state == XFS_EXT_NORM &&\n\t    (flags & (XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT)) !=\n\t\t\t(XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT))\n\t\treturn 0;\n\n\t/*\n\t * Modify (by adding) the state flag, if writing.\n\t */\n\tASSERT(mval->br_blockcount <= len);\n\tif ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(bma->ip->i_mount, bma->tp,\n\t\t\t\t\tbma->ip, whichfork);\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\t\tbma->cur->bc_private.b.flist = bma->flist;\n\t}\n\tmval->br_state = (mval->br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\t? XFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\n\terror = xfs_bmap_add_extent_unwritten_real(bma->tp, bma->ip, &bma->idx,\n\t\t\t&bma->cur, mval, bma->firstblock, bma->flist,\n\t\t\t&tmp_logflags);\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Update our extent pointer, given that\n\t * xfs_bmap_add_extent_unwritten_real might have merged it into one\n\t * of the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &bma->got);\n\n\t/*\n\t * We may have combined previously unwritten space with written space,\n\t * so generate another request.\n\t */\n\tif (mval->br_blockcount < len)\n\t\treturn -EAGAIN;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_trim_map",
          "args": [
            "mval",
            "&bma.got",
            "&bno",
            "len",
            "obno",
            "end",
            "n",
            "flags"
          ],
          "line": 4613
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_trim_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3916-3957",
          "snippet": "STATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tint\t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t/*\n\t * Return the minimum of what we got and what we asked for for\n\t * the length.  We can use the len variable here because it is\n\t * modified below and we could have been there before coming\n\t * here if the first part of the allocation didn't overlap what\n\t * was asked for.\n\t */\n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tint\t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t/*\n\t * Return the minimum of what we got and what we asked for for\n\t * the length.  We can use the len variable here because it is\n\t * modified below and we could have been there before coming\n\t * here if the first part of the allocation didn't overlap what\n\t * was asked for.\n\t */\n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_allocate",
          "args": [
            "&bma"
          ],
          "line": 4605
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_allocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4296-4409",
          "snippet": "static int\nxfs_bmapi_allocate(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_mount\t*mp = bma->ip->i_mount;\n\tint\t\t\twhichfork = (bma->flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\tASSERT(bma->length > 0);\n\n\t/*\n\t * For the wasdelay case, we could also just allocate the stuff asked\n\t * for in this bmap call but that wouldn't be as good.\n\t */\n\tif (bma->wasdel) {\n\t\tbma->length = (xfs_extlen_t)bma->got.br_blockcount;\n\t\tbma->offset = bma->got.br_startoff;\n\t\tif (bma->idx != NULLEXTNUM && bma->idx) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1),\n\t\t\t\t\t &bma->prev);\n\t\t}\n\t} else {\n\t\tbma->length = XFS_FILBLKS_MIN(bma->length, MAXEXTLEN);\n\t\tif (!bma->eof)\n\t\t\tbma->length = XFS_FILBLKS_MIN(bma->length,\n\t\t\t\t\tbma->got.br_startoff - bma->offset);\n\t}\n\n\t/*\n\t * Indicate if this is the first user data in the file, or just any\n\t * user data.\n\t */\n\tif (!(bma->flags & XFS_BMAPI_METADATA)) {\n\t\tbma->userdata = (bma->offset == 0) ?\n\t\t\tXFS_ALLOC_INITIAL_USER_DATA : XFS_ALLOC_USERDATA;\n\t}\n\n\tbma->minlen = (bma->flags & XFS_BMAPI_CONTIG) ? bma->length : 1;\n\n\t/*\n\t * Only want to do the alignment at the eof if it is userdata and\n\t * allocation length is larger than a stripe unit.\n\t */\n\tif (mp->m_dalign && bma->length >= mp->m_dalign &&\n\t    !(bma->flags & XFS_BMAPI_METADATA) && whichfork == XFS_DATA_FORK) {\n\t\terror = xfs_bmap_isaeof(bma, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_bmap_alloc(bma);\n\tif (error)\n\t\treturn error;\n\n\tif (bma->flist->xbf_low)\n\t\tbma->minleft = 0;\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\tif (bma->blkno == NULLFSBLOCK)\n\t\treturn 0;\n\tif ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(mp, bma->tp, bma->ip, whichfork);\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\t\tbma->cur->bc_private.b.flist = bma->flist;\n\t}\n\t/*\n\t * Bump the number of extents we've allocated\n\t * in this call.\n\t */\n\tbma->nallocs++;\n\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.flags =\n\t\t\tbma->wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\n\tbma->got.br_startoff = bma->offset;\n\tbma->got.br_startblock = bma->blkno;\n\tbma->got.br_blockcount = bma->length;\n\tbma->got.br_state = XFS_EXT_NORM;\n\n\t/*\n\t * A wasdelay extent has been initialized, so shouldn't be flagged\n\t * as unwritten.\n\t */\n\tif (!bma->wasdel && (bma->flags & XFS_BMAPI_PREALLOC) &&\n\t    xfs_sb_version_hasextflgbit(&mp->m_sb))\n\t\tbma->got.br_state = XFS_EXT_UNWRITTEN;\n\n\tif (bma->wasdel)\n\t\terror = xfs_bmap_add_extent_delay_real(bma);\n\telse\n\t\terror = xfs_bmap_add_extent_hole_real(bma, whichfork);\n\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Update our extent pointer, given that xfs_bmap_add_extent_delay_real\n\t * or xfs_bmap_add_extent_hole_real might have merged it into one of\n\t * the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &bma->got);\n\n\tASSERT(bma->got.br_startoff <= bma->offset);\n\tASSERT(bma->got.br_startoff + bma->got.br_blockcount >=\n\t       bma->offset + bma->length);\n\tASSERT(bma->got.br_state == XFS_EXT_NORM ||\n\t       bma->got.br_state == XFS_EXT_UNWRITTEN);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_bmapi_allocate(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_mount\t*mp = bma->ip->i_mount;\n\tint\t\t\twhichfork = (bma->flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\tASSERT(bma->length > 0);\n\n\t/*\n\t * For the wasdelay case, we could also just allocate the stuff asked\n\t * for in this bmap call but that wouldn't be as good.\n\t */\n\tif (bma->wasdel) {\n\t\tbma->length = (xfs_extlen_t)bma->got.br_blockcount;\n\t\tbma->offset = bma->got.br_startoff;\n\t\tif (bma->idx != NULLEXTNUM && bma->idx) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1),\n\t\t\t\t\t &bma->prev);\n\t\t}\n\t} else {\n\t\tbma->length = XFS_FILBLKS_MIN(bma->length, MAXEXTLEN);\n\t\tif (!bma->eof)\n\t\t\tbma->length = XFS_FILBLKS_MIN(bma->length,\n\t\t\t\t\tbma->got.br_startoff - bma->offset);\n\t}\n\n\t/*\n\t * Indicate if this is the first user data in the file, or just any\n\t * user data.\n\t */\n\tif (!(bma->flags & XFS_BMAPI_METADATA)) {\n\t\tbma->userdata = (bma->offset == 0) ?\n\t\t\tXFS_ALLOC_INITIAL_USER_DATA : XFS_ALLOC_USERDATA;\n\t}\n\n\tbma->minlen = (bma->flags & XFS_BMAPI_CONTIG) ? bma->length : 1;\n\n\t/*\n\t * Only want to do the alignment at the eof if it is userdata and\n\t * allocation length is larger than a stripe unit.\n\t */\n\tif (mp->m_dalign && bma->length >= mp->m_dalign &&\n\t    !(bma->flags & XFS_BMAPI_METADATA) && whichfork == XFS_DATA_FORK) {\n\t\terror = xfs_bmap_isaeof(bma, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_bmap_alloc(bma);\n\tif (error)\n\t\treturn error;\n\n\tif (bma->flist->xbf_low)\n\t\tbma->minleft = 0;\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\tif (bma->blkno == NULLFSBLOCK)\n\t\treturn 0;\n\tif ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(mp, bma->tp, bma->ip, whichfork);\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\t\tbma->cur->bc_private.b.flist = bma->flist;\n\t}\n\t/*\n\t * Bump the number of extents we've allocated\n\t * in this call.\n\t */\n\tbma->nallocs++;\n\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.flags =\n\t\t\tbma->wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\n\tbma->got.br_startoff = bma->offset;\n\tbma->got.br_startblock = bma->blkno;\n\tbma->got.br_blockcount = bma->length;\n\tbma->got.br_state = XFS_EXT_NORM;\n\n\t/*\n\t * A wasdelay extent has been initialized, so shouldn't be flagged\n\t * as unwritten.\n\t */\n\tif (!bma->wasdel && (bma->flags & XFS_BMAPI_PREALLOC) &&\n\t    xfs_sb_version_hasextflgbit(&mp->m_sb))\n\t\tbma->got.br_state = XFS_EXT_UNWRITTEN;\n\n\tif (bma->wasdel)\n\t\terror = xfs_bmap_add_extent_delay_real(bma);\n\telse\n\t\terror = xfs_bmap_add_extent_hole_real(bma, whichfork);\n\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Update our extent pointer, given that xfs_bmap_add_extent_delay_real\n\t * or xfs_bmap_add_extent_hole_real might have merged it into one of\n\t * the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &bma->got);\n\n\tASSERT(bma->got.br_startoff <= bma->offset);\n\tASSERT(bma->got.br_startoff + bma->got.br_blockcount >=\n\t       bma->offset + bma->length);\n\tASSERT(bma->got.br_state == XFS_EXT_NORM ||\n\t       bma->got.br_state == XFS_EXT_UNWRITTEN);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma.length > 0"
          ],
          "line": 4604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len > 0"
          ],
          "line": 4603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "bma.got.br_startblock"
          ],
          "line": 4578
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_search_extents",
          "args": [
            "ip",
            "bno",
            "whichfork",
            "&eof",
            "&bma.idx",
            "&bma.got",
            "&bma.prev"
          ],
          "line": 4563
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_search_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1459-1493",
          "snippet": "STATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 4558
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ifp->if_broot->bb_level"
          ],
          "line": 4550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_blk_mapw"
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_bmapi_write\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 4537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT)"
          ],
          "line": 4533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)",
            "mp",
            "XFS_ERRTAG_BMAPIFORMAT",
            "XFS_RANDOM_BMAPIFORMAT"
          ],
          "line": 4533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 4531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 4531
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL"
          ],
          "line": 4530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len > 0"
          ],
          "line": 4529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "tp != NULL"
          ],
          "line": 4528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & XFS_BMAPI_IGSTATE)"
          ],
          "line": 4527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*nmap <= XFS_BMAP_MAX_NMAP"
          ],
          "line": 4526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*nmap >= 1"
          ],
          "line": 4525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_write(\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t\t/* length to map in file */\n\tint\t\t\tflags,\t\t/* XFS_BMAPI_... */\n\txfs_fsblock_t\t\t*firstblock,\t/* first allocated block\n\t\t\t\t\t\t   controls a.g. for allocs */\n\txfs_extlen_t\t\ttotal,\t\t/* total blocks needed */\n\tstruct xfs_bmbt_irec\t*mval,\t\t/* output: map values */\n\tint\t\t\t*nmap,\t\t/* i/o: mval size/count */\n\tstruct xfs_bmap_free\t*flist)\t\t/* i/o: list extents to free */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmalloca\tbma = { NULL };\t/* args for xfs_bmap_alloc */\n\txfs_fileoff_t\t\tend;\t\t/* end of mapped file region */\n\tint\t\t\teof;\t\t/* after the end of extents */\n\tint\t\t\terror;\t\t/* error return */\n\tint\t\t\tn;\t\t/* current extent index */\n\txfs_fileoff_t\t\tobno;\t\t/* old block number (offset) */\n\tint\t\t\twhichfork;\t/* data or attr fork */\n\tchar\t\t\tinhole;\t\t/* current location is hole in file */\n\tchar\t\t\twasdelay;\t/* old extent was delayed */\n\n#ifdef DEBUG\n\txfs_fileoff_t\t\torig_bno;\t/* original block number value */\n\tint\t\t\torig_flags;\t/* original flags arg value */\n\txfs_filblks_t\t\torig_len;\t/* original value of len arg */\n\tstruct xfs_bmbt_irec\t*orig_mval;\t/* original value of mval */\n\tint\t\t\torig_nmap;\t/* original value of *nmap */\n\n\torig_bno = bno;\n\torig_len = len;\n\torig_flags = flags;\n\torig_mval = mval;\n\torig_nmap = *nmap;\n#endif\n\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & XFS_BMAPI_IGSTATE));\n\tASSERT(tp != NULL);\n\tASSERT(len > 0);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_write\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (*firstblock == NULLFSBLOCK) {\n\t\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE)\n\t\t\tbma.minleft = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\t\telse\n\t\t\tbma.minleft = 1;\n\t} else {\n\t\tbma.minleft = 0;\n\t}\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &bma.idx, &bma.got,\n\t\t\t\t&bma.prev);\n\tn = 0;\n\tend = bno + len;\n\tobno = bno;\n\n\tbma.tp = tp;\n\tbma.ip = ip;\n\tbma.total = total;\n\tbma.userdata = 0;\n\tbma.flist = flist;\n\tbma.firstblock = firstblock;\n\n\twhile (bno < end && n < *nmap) {\n\t\tinhole = eof || bma.got.br_startoff > bno;\n\t\twasdelay = !inhole && isnullstartblock(bma.got.br_startblock);\n\n\t\t/*\n\t\t * First, deal with the hole before the allocated space\n\t\t * that we found, if any.\n\t\t */\n\t\tif (inhole || wasdelay) {\n\t\t\tbma.eof = eof;\n\t\t\tbma.conv = !!(flags & XFS_BMAPI_CONVERT);\n\t\t\tbma.wasdel = wasdelay;\n\t\t\tbma.offset = bno;\n\t\t\tbma.flags = flags;\n\n\t\t\t/*\n\t\t\t * There's a 32/64 bit type mismatch between the\n\t\t\t * allocation length request (which can be 64 bits in\n\t\t\t * length) and the bma length request, which is\n\t\t\t * xfs_extlen_t and therefore 32 bits. Hence we have to\n\t\t\t * check for 32-bit overflows and handle them here.\n\t\t\t */\n\t\t\tif (len > (xfs_filblks_t)MAXEXTLEN)\n\t\t\t\tbma.length = MAXEXTLEN;\n\t\t\telse\n\t\t\t\tbma.length = len;\n\n\t\t\tASSERT(len > 0);\n\t\t\tASSERT(bma.length > 0);\n\t\t\terror = xfs_bmapi_allocate(&bma);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tif (bma.blkno == NULLFSBLOCK)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Deal with the allocated space we found.  */\n\t\txfs_bmapi_trim_map(mval, &bma.got, &bno, len, obno,\n\t\t\t\t\t\t\tend, n, flags);\n\n\t\t/* Execute unwritten extent conversion if necessary */\n\t\terror = xfs_bmapi_convert_unwritten(&bma, mval, len, flags);\n\t\tif (error == -EAGAIN)\n\t\t\tcontinue;\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\t/* update the extent map to return */\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/*\n\t\t * If we're done, stop now.  Stop when we've allocated\n\t\t * XFS_BMAP_MAX_NMAP extents no matter what.  Otherwise\n\t\t * the transaction may get too big.\n\t\t */\n\t\tif (bno >= end || n >= *nmap || bma.nallocs >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tbma.prev = bma.got;\n\t\tif (++bma.idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t)) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma.idx),\n\t\t\t\t\t &bma.got);\n\t\t} else\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\n\t/*\n\t * Transform from btree to extents, give it cur.\n\t */\n\tif (xfs_bmap_wants_extents(ip, whichfork)) {\n\t\tint\t\ttmp_logflags = 0;\n\n\t\tASSERT(bma.cur);\n\t\terror = xfs_bmap_btree_to_extents(tp, ip, bma.cur,\n\t\t\t&tmp_logflags, whichfork);\n\t\tbma.logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\tXFS_IFORK_MAXEXT(ip, whichfork));\n\terror = 0;\nerror0:\n\t/*\n\t * Log everything.  Do this after conversion, there's no point in\n\t * logging the extent records if we've converted to btree format.\n\t */\n\tif ((bma.logflags & xfs_ilog_fext(whichfork)) &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\tbma.logflags &= ~xfs_ilog_fext(whichfork);\n\telse if ((bma.logflags & xfs_ilog_fbroot(whichfork)) &&\n\t\t XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)\n\t\tbma.logflags &= ~xfs_ilog_fbroot(whichfork);\n\t/*\n\t * Log whatever the flags say, even if error.  Otherwise we might miss\n\t * detecting a case where the data is changed, there's an error,\n\t * and it's not logged so we don't shutdown when we should.\n\t */\n\tif (bma.logflags)\n\t\txfs_trans_log_inode(tp, ip, bma.logflags);\n\n\tif (bma.cur) {\n\t\tif (!error) {\n\t\t\tASSERT(*firstblock == NULLFSBLOCK ||\n\t\t\t       XFS_FSB_TO_AGNO(mp, *firstblock) ==\n\t\t\t       XFS_FSB_TO_AGNO(mp,\n\t\t\t\t       bma.cur->bc_private.b.firstblock) ||\n\t\t\t       (flist->xbf_low &&\n\t\t\t\tXFS_FSB_TO_AGNO(mp, *firstblock) <\n\t\t\t\tXFS_FSB_TO_AGNO(mp,\n\t\t\t\t\tbma.cur->bc_private.b.firstblock)));\n\t\t\t*firstblock = bma.cur->bc_private.b.firstblock;\n\t\t}\n\t\txfs_btree_del_cursor(bma.cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\tif (!error)\n\t\txfs_bmap_validate_ret(orig_bno, orig_len, orig_flags, orig_mval,\n\t\t\torig_nmap, *nmap);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmapi_convert_unwritten",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "4411-4469",
    "snippet": "STATIC int\nxfs_bmapi_convert_unwritten(\n\tstruct xfs_bmalloca\t*bma,\n\tstruct xfs_bmbt_irec\t*mval,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags)\n{\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\t/* check if we need to do unwritten->real conversion */\n\tif (mval->br_state == XFS_EXT_UNWRITTEN &&\n\t    (flags & XFS_BMAPI_PREALLOC))\n\t\treturn 0;\n\n\t/* check if we need to do real->unwritten conversion */\n\tif (mval->br_state == XFS_EXT_NORM &&\n\t    (flags & (XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT)) !=\n\t\t\t(XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT))\n\t\treturn 0;\n\n\t/*\n\t * Modify (by adding) the state flag, if writing.\n\t */\n\tASSERT(mval->br_blockcount <= len);\n\tif ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(bma->ip->i_mount, bma->tp,\n\t\t\t\t\tbma->ip, whichfork);\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\t\tbma->cur->bc_private.b.flist = bma->flist;\n\t}\n\tmval->br_state = (mval->br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\t? XFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\n\terror = xfs_bmap_add_extent_unwritten_real(bma->tp, bma->ip, &bma->idx,\n\t\t\t&bma->cur, mval, bma->firstblock, bma->flist,\n\t\t\t&tmp_logflags);\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Update our extent pointer, given that\n\t * xfs_bmap_add_extent_unwritten_real might have merged it into one\n\t * of the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &bma->got);\n\n\t/*\n\t * We may have combined previously unwritten space with written space,\n\t * so generate another request.\n\t */\n\tif (mval->br_blockcount < len)\n\t\treturn -EAGAIN;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, bma->idx)",
            "&bma->got"
          ],
          "line": 4460
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "bma->idx"
          ],
          "line": 4460
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_extent_unwritten_real",
          "args": [
            "bma->tp",
            "bma->ip",
            "&bma->idx",
            "&bma->cur",
            "mval",
            "bma->firstblock",
            "bma->flist",
            "&tmp_logflags"
          ],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_extent_unwritten_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "2289-2809",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_unwritten_real(\n\tstruct xfs_trans\t*tp,\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_btree_cur_t\t\t**curp,\t/* if *curp is null, not a btree */\n\txfs_bmbt_irec_t\t\t*new,\t/* new data to add to file extents */\n\txfs_fsblock_t\t\t*first,\t/* pointer to firstblock variable */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\tint\t\t\t*logflagsp) /* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_exntst_t\t\tnewext;\t/* new extent state */\n\txfs_exntst_t\t\toldext;\t/* old extent state */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\n\t*logflagsp = 0;\n\n\tcur = *curp;\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\n\tASSERT(*idx >= 0);\n\tASSERT(*idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\terror = 0;\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnewext = new->br_state;\n\toldext = (newext == XFS_EXT_UNWRITTEN) ?\n\t\tXFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\tASSERT(PREV.br_state == oldext);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\t/*\n\t * Set flags determining what part of the previous oldext allocation\n\t * extent is being replaced by a newext allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == newext &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx + 1), &RIGHT);\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    newext == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 2, state);\n\t\tip->i_d.di_nextents -= 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\t\tRIGHT.br_blockcount, LEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount,\n\t\t\t\tLEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx - 1, state, _THIS_IP_);\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t--*idx;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + new->br_blockcount,\n\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\tASSERT(ep && xfs_bmbt_get_state(ep) == oldext);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tcur->bc_rec.b = *new;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock,\n\t\t\t\t\tPREV.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tcur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Setting the middle part of a previous oldext extent to\n\t\t * newext.  Contiguity is impossible here.\n\t\t * One extent becomes three extents.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tnew->br_startoff - PREV.br_startoff);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tr[0] = *new;\n\t\tr[1].br_startoff = new_endoff;\n\t\tr[1].br_blockcount =\n\t\t\tPREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\tr[1].br_startblock = new->br_startblock + new->br_blockcount;\n\t\tr[1].br_state = oldext;\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 2, &r[0], state);\n\n\t\tip->i_d.di_nextents += 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/* new right extent - oldext */\n\t\t\tif ((error = xfs_bmbt_update(cur, r[1].br_startoff,\n\t\t\t\tr[1].br_startblock, r[1].br_blockcount,\n\t\t\t\tr[1].br_state)))\n\t\t\t\tgoto done;\n\t\t\t/* new left extent - oldext */\n\t\t\tcur->bc_rec.b = PREV;\n\t\t\tcur->bc_rec.b.br_blockcount =\n\t\t\t\tnew->br_startoff - PREV.br_startoff;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/*\n\t\t\t * Reset the cursor to the position of the new extent\n\t\t\t * we are about to insert as we can't trust it after\n\t\t\t * the previous insert.\n\t\t\t */\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\t/* new middle extent - newext */\n\t\t\tcur->bc_rec.b.br_state = new->br_state;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, first, flist, &cur,\n\t\t\t\t0, &tmp_logflags, XFS_DATA_FORK);\n\t\t*logflagsp |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\t*curp = cur;\n\t}\n\n\txfs_bmap_check_leaf_extents(*curp, ip, XFS_DATA_FORK);\ndone:\n\t*logflagsp |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tPREV\t\tr[2]",
            "#define\tRIGHT\t\tr[1]",
            "#define\tLEFT\t\tr[0]",
            "#define\tPREV\t\tr[2]",
            "#define\tRIGHT\t\tr[1]",
            "#define\tLEFT\t\tr[0]"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_unwritten_real(\n\tstruct xfs_trans\t*tp,\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_btree_cur_t\t\t**curp,\t/* if *curp is null, not a btree */\n\txfs_bmbt_irec_t\t\t*new,\t/* new data to add to file extents */\n\txfs_fsblock_t\t\t*first,\t/* pointer to firstblock variable */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\tint\t\t\t*logflagsp) /* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_exntst_t\t\tnewext;\t/* new extent state */\n\txfs_exntst_t\t\toldext;\t/* old extent state */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\n\t*logflagsp = 0;\n\n\tcur = *curp;\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\n\tASSERT(*idx >= 0);\n\tASSERT(*idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\terror = 0;\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnewext = new->br_state;\n\toldext = (newext == XFS_EXT_UNWRITTEN) ?\n\t\tXFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\tASSERT(PREV.br_state == oldext);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\t/*\n\t * Set flags determining what part of the previous oldext allocation\n\t * extent is being replaced by a newext allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == newext &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx + 1), &RIGHT);\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    newext == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 2, state);\n\t\tip->i_d.di_nextents -= 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\t\tRIGHT.br_blockcount, LEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount,\n\t\t\t\tLEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx - 1, state, _THIS_IP_);\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t--*idx;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + new->br_blockcount,\n\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\tASSERT(ep && xfs_bmbt_get_state(ep) == oldext);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tcur->bc_rec.b = *new;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock,\n\t\t\t\t\tPREV.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tcur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Setting the middle part of a previous oldext extent to\n\t\t * newext.  Contiguity is impossible here.\n\t\t * One extent becomes three extents.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tnew->br_startoff - PREV.br_startoff);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tr[0] = *new;\n\t\tr[1].br_startoff = new_endoff;\n\t\tr[1].br_blockcount =\n\t\t\tPREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\tr[1].br_startblock = new->br_startblock + new->br_blockcount;\n\t\tr[1].br_state = oldext;\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 2, &r[0], state);\n\n\t\tip->i_d.di_nextents += 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/* new right extent - oldext */\n\t\t\tif ((error = xfs_bmbt_update(cur, r[1].br_startoff,\n\t\t\t\tr[1].br_startblock, r[1].br_blockcount,\n\t\t\t\tr[1].br_state)))\n\t\t\t\tgoto done;\n\t\t\t/* new left extent - oldext */\n\t\t\tcur->bc_rec.b = PREV;\n\t\t\tcur->bc_rec.b.br_blockcount =\n\t\t\t\tnew->br_startoff - PREV.br_startoff;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/*\n\t\t\t * Reset the cursor to the position of the new extent\n\t\t\t * we are about to insert as we can't trust it after\n\t\t\t * the previous insert.\n\t\t\t */\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\t/* new middle extent - newext */\n\t\t\tcur->bc_rec.b.br_state = new->br_state;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, first, flist, &cur,\n\t\t\t\t0, &tmp_logflags, XFS_DATA_FORK);\n\t\t*logflagsp |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\t*curp = cur;\n\t}\n\n\txfs_bmap_check_leaf_extents(*curp, ip, XFS_DATA_FORK);\ndone:\n\t*logflagsp |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_init_cursor",
          "args": [
            "bma->ip->i_mount",
            "bma->tp",
            "bma->ip",
            "whichfork"
          ],
          "line": 4440
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "776-808",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval->br_blockcount <= len"
          ],
          "line": 4438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "bma->ip",
            "whichfork"
          ],
          "line": 4420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmapi_convert_unwritten(\n\tstruct xfs_bmalloca\t*bma,\n\tstruct xfs_bmbt_irec\t*mval,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags)\n{\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\t/* check if we need to do unwritten->real conversion */\n\tif (mval->br_state == XFS_EXT_UNWRITTEN &&\n\t    (flags & XFS_BMAPI_PREALLOC))\n\t\treturn 0;\n\n\t/* check if we need to do real->unwritten conversion */\n\tif (mval->br_state == XFS_EXT_NORM &&\n\t    (flags & (XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT)) !=\n\t\t\t(XFS_BMAPI_PREALLOC | XFS_BMAPI_CONVERT))\n\t\treturn 0;\n\n\t/*\n\t * Modify (by adding) the state flag, if writing.\n\t */\n\tASSERT(mval->br_blockcount <= len);\n\tif ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(bma->ip->i_mount, bma->tp,\n\t\t\t\t\tbma->ip, whichfork);\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\t\tbma->cur->bc_private.b.flist = bma->flist;\n\t}\n\tmval->br_state = (mval->br_state == XFS_EXT_UNWRITTEN)\n\t\t\t\t? XFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\n\terror = xfs_bmap_add_extent_unwritten_real(bma->tp, bma->ip, &bma->idx,\n\t\t\t&bma->cur, mval, bma->firstblock, bma->flist,\n\t\t\t&tmp_logflags);\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Update our extent pointer, given that\n\t * xfs_bmap_add_extent_unwritten_real might have merged it into one\n\t * of the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &bma->got);\n\n\t/*\n\t * We may have combined previously unwritten space with written space,\n\t * so generate another request.\n\t */\n\tif (mval->br_blockcount < len)\n\t\treturn -EAGAIN;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmapi_allocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "4296-4409",
    "snippet": "static int\nxfs_bmapi_allocate(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_mount\t*mp = bma->ip->i_mount;\n\tint\t\t\twhichfork = (bma->flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\tASSERT(bma->length > 0);\n\n\t/*\n\t * For the wasdelay case, we could also just allocate the stuff asked\n\t * for in this bmap call but that wouldn't be as good.\n\t */\n\tif (bma->wasdel) {\n\t\tbma->length = (xfs_extlen_t)bma->got.br_blockcount;\n\t\tbma->offset = bma->got.br_startoff;\n\t\tif (bma->idx != NULLEXTNUM && bma->idx) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1),\n\t\t\t\t\t &bma->prev);\n\t\t}\n\t} else {\n\t\tbma->length = XFS_FILBLKS_MIN(bma->length, MAXEXTLEN);\n\t\tif (!bma->eof)\n\t\t\tbma->length = XFS_FILBLKS_MIN(bma->length,\n\t\t\t\t\tbma->got.br_startoff - bma->offset);\n\t}\n\n\t/*\n\t * Indicate if this is the first user data in the file, or just any\n\t * user data.\n\t */\n\tif (!(bma->flags & XFS_BMAPI_METADATA)) {\n\t\tbma->userdata = (bma->offset == 0) ?\n\t\t\tXFS_ALLOC_INITIAL_USER_DATA : XFS_ALLOC_USERDATA;\n\t}\n\n\tbma->minlen = (bma->flags & XFS_BMAPI_CONTIG) ? bma->length : 1;\n\n\t/*\n\t * Only want to do the alignment at the eof if it is userdata and\n\t * allocation length is larger than a stripe unit.\n\t */\n\tif (mp->m_dalign && bma->length >= mp->m_dalign &&\n\t    !(bma->flags & XFS_BMAPI_METADATA) && whichfork == XFS_DATA_FORK) {\n\t\terror = xfs_bmap_isaeof(bma, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_bmap_alloc(bma);\n\tif (error)\n\t\treturn error;\n\n\tif (bma->flist->xbf_low)\n\t\tbma->minleft = 0;\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\tif (bma->blkno == NULLFSBLOCK)\n\t\treturn 0;\n\tif ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(mp, bma->tp, bma->ip, whichfork);\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\t\tbma->cur->bc_private.b.flist = bma->flist;\n\t}\n\t/*\n\t * Bump the number of extents we've allocated\n\t * in this call.\n\t */\n\tbma->nallocs++;\n\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.flags =\n\t\t\tbma->wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\n\tbma->got.br_startoff = bma->offset;\n\tbma->got.br_startblock = bma->blkno;\n\tbma->got.br_blockcount = bma->length;\n\tbma->got.br_state = XFS_EXT_NORM;\n\n\t/*\n\t * A wasdelay extent has been initialized, so shouldn't be flagged\n\t * as unwritten.\n\t */\n\tif (!bma->wasdel && (bma->flags & XFS_BMAPI_PREALLOC) &&\n\t    xfs_sb_version_hasextflgbit(&mp->m_sb))\n\t\tbma->got.br_state = XFS_EXT_UNWRITTEN;\n\n\tif (bma->wasdel)\n\t\terror = xfs_bmap_add_extent_delay_real(bma);\n\telse\n\t\terror = xfs_bmap_add_extent_hole_real(bma, whichfork);\n\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Update our extent pointer, given that xfs_bmap_add_extent_delay_real\n\t * or xfs_bmap_add_extent_hole_real might have merged it into one of\n\t * the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &bma->got);\n\n\tASSERT(bma->got.br_startoff <= bma->offset);\n\tASSERT(bma->got.br_startoff + bma->got.br_blockcount >=\n\t       bma->offset + bma->length);\n\tASSERT(bma->got.br_state == XFS_EXT_NORM ||\n\t       bma->got.br_state == XFS_EXT_UNWRITTEN);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->got.br_state == XFS_EXT_NORM ||\n\t       bma->got.br_state == XFS_EXT_UNWRITTEN"
          ],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->got.br_startoff + bma->got.br_blockcount >=\n\t       bma->offset + bma->length"
          ],
          "line": 4404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->got.br_startoff <= bma->offset"
          ],
          "line": 4403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, bma->idx)",
            "&bma->got"
          ],
          "line": 4401
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "bma->idx"
          ],
          "line": 4401
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_extent_hole_real",
          "args": [
            "bma",
            "whichfork"
          ],
          "line": 4390
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_extent_hole_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "2958-3195",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_hole_real(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_bmbt_irec_t\t\tleft;\t/* left neighbor extent entry */\n\txfs_bmbt_irec_t\t\tright;\t/* right neighbor extent entry */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate;\t/* state bits, accessed thru macros */\n\n\tifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\n\tASSERT(bma->idx >= 0);\n\tASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       !(bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n\tstate = 0;\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t */\n\tif (bma->idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1), &left);\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t/*\n\t * Check and set flags if this segment has a current value.\n\t * Not true if we're inserting into the \"hole\" at eof.\n\t */\n\tif (bma->idx < ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &right);\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t/*\n\t * We're inserting a real allocation between \"left\" and \"right\".\n\t * Set the contiguity flags.  Don't let extents get too large.\n\t */\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_startblock + left.br_blockcount == new->br_startblock &&\n\t    left.br_state == new->br_state &&\n\t    left.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == right.br_startblock &&\n\t    new->br_state == right.br_state &&\n\t    new->br_blockcount + right.br_blockcount <= MAXEXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     left.br_blockcount + new->br_blockcount +\n\t     right.br_blockcount <= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t/*\n\t * Select which case we're in here, and implement it.\n\t */\n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with real allocations on the\n\t\t * left and on the right.\n\t\t * Merge all three into a single extent record.\n\t\t */\n\t\t--bma->idx;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tleft.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\n\t\tXFS_IFORK_NEXT_SET(bma->ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(bma->ip, whichfork) - 1);\n\t\tif (bma->cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, right.br_startoff,\n\t\t\t\t\tright.br_startblock, right.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock,\n\t\t\t\t\tleft.br_blockcount +\n\t\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount,\n\t\t\t\t\tleft.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a real allocation\n\t\t * on the left.\n\t\t * Merge the new allocation with the left neighbor.\n\t\t */\n\t\t--bma->idx;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tleft.br_blockcount + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tif (bma->cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock, left.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock,\n\t\t\t\t\tleft.br_blockcount +\n\t\t\t\t\t\tnew->br_blockcount,\n\t\t\t\t\tleft.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a real allocation\n\t\t * on the right.\n\t\t * Merge the new allocation with the right neighbor.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + right.br_blockcount,\n\t\t\tright.br_state);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tif (bma->cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur,\n\t\t\t\t\tright.br_startoff,\n\t\t\t\t\tright.br_startblock,\n\t\t\t\t\tright.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount,\n\t\t\t\t\tright.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * New allocation is not contiguous with another\n\t\t * real allocation.\n\t\t * Insert a new entry.\n\t\t */\n\t\txfs_iext_insert(bma->ip, bma->idx, 1, new, state);\n\t\tXFS_IFORK_NEXT_SET(bma->ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(bma->ip, whichfork) + 1);\n\t\tif (bma->cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur,\n\t\t\t\t\tnew->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = new->br_state;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(bma->ip, whichfork)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\t0, &tmp_logflags, whichfork);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, whichfork);\ndone:\n\tbma->logflags |= rval;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_hole_real(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_bmbt_irec_t\t\tleft;\t/* left neighbor extent entry */\n\txfs_bmbt_irec_t\t\tright;\t/* right neighbor extent entry */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate;\t/* state bits, accessed thru macros */\n\n\tifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\n\tASSERT(bma->idx >= 0);\n\tASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       !(bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n\tstate = 0;\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t */\n\tif (bma->idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1), &left);\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t/*\n\t * Check and set flags if this segment has a current value.\n\t * Not true if we're inserting into the \"hole\" at eof.\n\t */\n\tif (bma->idx < ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &right);\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t/*\n\t * We're inserting a real allocation between \"left\" and \"right\".\n\t * Set the contiguity flags.  Don't let extents get too large.\n\t */\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_startblock + left.br_blockcount == new->br_startblock &&\n\t    left.br_state == new->br_state &&\n\t    left.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == right.br_startblock &&\n\t    new->br_state == right.br_state &&\n\t    new->br_blockcount + right.br_blockcount <= MAXEXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     left.br_blockcount + new->br_blockcount +\n\t     right.br_blockcount <= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t/*\n\t * Select which case we're in here, and implement it.\n\t */\n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with real allocations on the\n\t\t * left and on the right.\n\t\t * Merge all three into a single extent record.\n\t\t */\n\t\t--bma->idx;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tleft.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\n\t\tXFS_IFORK_NEXT_SET(bma->ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(bma->ip, whichfork) - 1);\n\t\tif (bma->cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, right.br_startoff,\n\t\t\t\t\tright.br_startblock, right.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock,\n\t\t\t\t\tleft.br_blockcount +\n\t\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount,\n\t\t\t\t\tleft.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a real allocation\n\t\t * on the left.\n\t\t * Merge the new allocation with the left neighbor.\n\t\t */\n\t\t--bma->idx;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tleft.br_blockcount + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tif (bma->cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock, left.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock,\n\t\t\t\t\tleft.br_blockcount +\n\t\t\t\t\t\tnew->br_blockcount,\n\t\t\t\t\tleft.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a real allocation\n\t\t * on the right.\n\t\t * Merge the new allocation with the right neighbor.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + right.br_blockcount,\n\t\t\tright.br_state);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tif (bma->cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur,\n\t\t\t\t\tright.br_startoff,\n\t\t\t\t\tright.br_startblock,\n\t\t\t\t\tright.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount,\n\t\t\t\t\tright.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * New allocation is not contiguous with another\n\t\t * real allocation.\n\t\t * Insert a new entry.\n\t\t */\n\t\txfs_iext_insert(bma->ip, bma->idx, 1, new, state);\n\t\tXFS_IFORK_NEXT_SET(bma->ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(bma->ip, whichfork) + 1);\n\t\tif (bma->cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur,\n\t\t\t\t\tnew->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = new->br_state;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(bma->ip, whichfork)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\t0, &tmp_logflags, whichfork);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, whichfork);\ndone:\n\tbma->logflags |= rval;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_extent_delay_real",
          "args": [
            "bma"
          ],
          "line": 4388
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_extent_delay_real",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1738-2284",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_delay_real(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\tdiff;\t/* temp value */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\txfs_filblks_t\t\tda_new; /* new count del alloc blocks used */\n\txfs_filblks_t\t\tda_old; /* old count del alloc blocks used */\n\txfs_filblks_t\t\ttemp=0;\t/* value for da_new calculations */\n\txfs_filblks_t\t\ttemp2=0;/* value for da_new calculations */\n\tint\t\t\ttmp_rval;\t/* partial logging flags */\n\n\tifp = XFS_IFORK_PTR(bma->ip, XFS_DATA_FORK);\n\n\tASSERT(bma->idx >= 0);\n\tASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       (bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\tep = xfs_iext_get_ext(ifp, bma->idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\tda_old = startblockval(PREV.br_startblock);\n\tda_new = 0;\n\n\t/*\n\t * Set flags determining what part of the previous delayed allocation\n\t * extent is being replaced by a real allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (bma->idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == new->br_state &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (bma->idx < bma->ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx + 1), &RIGHT);\n\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    new->br_state == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\tbma->idx--;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 2, state);\n\t\tbma->ip->i_d.di_nextents--;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tPREV.br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount, LEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\tbma->idx--;\n\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock, LEFT.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tPREV.br_blockcount, LEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, new->br_startblock);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, PREV.br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tPREV.br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount, PREV.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, new->br_startblock);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Filling in the first part of a previous delayed allocation.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx - 1, state, _THIS_IP_);\n\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock, LEFT.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tnew->br_blockcount,\n\t\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx--;\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Filling in the first part of a previous delayed allocation.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_iext_insert(bma->ip, bma->idx, 1, new, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\tbma->firstblock, bma->flist,\n\t\t\t\t\t&bma->cur, 1, &tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tep = xfs_iext_get_ext(ifp, bma->idx + 1);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in the last part of a previous delayed allocation.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, bma->idx + 1),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\tRIGHT.br_state);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount,\n\t\t\t\t\tRIGHT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Filling in the last part of a previous delayed allocation.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_iext_insert(bma->ip, bma->idx + 1, 1, new, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur, 1,\n\t\t\t\t&tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tep = xfs_iext_get_ext(ifp, bma->idx);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Filling in the middle part of a previous delayed allocation.\n\t\t * Contiguity is impossible here.\n\t\t * This case is avoided almost all the time.\n\t\t *\n\t\t * We start with a delayed allocation:\n\t\t *\n\t\t * +ddddddddddddddddddddddddddddddddddddddddddddddddddddddd+\n\t\t *  PREV @ idx\n\t\t *\n\t         * and we are allocating:\n\t\t *                     +rrrrrrrrrrrrrrrrr+\n\t\t *\t\t\t      new\n\t\t *\n\t\t * and we set it up for insertion as:\n\t\t * +ddddddddddddddddddd+rrrrrrrrrrrrrrrrr+ddddddddddddddddd+\n\t\t *                            new\n\t\t *  PREV @ idx          LEFT              RIGHT\n\t\t *                      inserted at idx + 1\n\t\t */\n\t\ttemp = new->br_startoff - PREV.br_startoff;\n\t\ttemp2 = PREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, 0, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\t/* truncate PREV */\n\t\tLEFT = *new;\n\t\tRIGHT.br_state = PREV.br_state;\n\t\tRIGHT.br_startblock = nullstartblock(\n\t\t\t\t(int)xfs_bmap_worst_indlen(bma->ip, temp2));\n\t\tRIGHT.br_startoff = new_endoff;\n\t\tRIGHT.br_blockcount = temp2;\n\t\t/* insert LEFT (r[0]) and RIGHT (r[1]) at the same time */\n\t\txfs_iext_insert(bma->ip, bma->idx + 1, 2, &LEFT, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\t\t1, &tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\ttemp = xfs_bmap_worst_indlen(bma->ip, temp);\n\t\ttemp2 = xfs_bmap_worst_indlen(bma->ip, temp2);\n\t\tdiff = (int)(temp + temp2 - startblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tif (diff > 0) {\n\t\t\terror = xfs_icsb_modify_counters(bma->ip->i_mount,\n\t\t\t\t\tXFS_SBS_FDBLOCKS,\n\t\t\t\t\t-((int64_t)diff), 0);\n\t\t\tASSERT(!error);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tep = xfs_iext_get_ext(ifp, bma->idx);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx + 2, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, bma->idx + 2),\n\t\t\tnullstartblock((int)temp2));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 2, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tda_new = temp + temp2;\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\tda_old > 0, &tmp_logflags, XFS_DATA_FORK);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* adjust for changes in reserved delayed indirect blocks */\n\tif (da_old || da_new) {\n\t\ttemp = da_new;\n\t\tif (bma->cur)\n\t\t\ttemp += bma->cur->bc_private.b.allocated;\n\t\tASSERT(temp <= da_old);\n\t\tif (temp < da_old)\n\t\t\txfs_icsb_modify_counters(bma->ip->i_mount,\n\t\t\t\t\tXFS_SBS_FDBLOCKS,\n\t\t\t\t\t(int64_t)(da_old - temp), 0);\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, XFS_DATA_FORK);\ndone:\n\tbma->logflags |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define\tPREV\t\tr[2]",
            "#define\tRIGHT\t\tr[1]",
            "#define\tLEFT\t\tr[0]",
            "#define\tPREV\t\tr[2]",
            "#define\tRIGHT\t\tr[1]",
            "#define\tLEFT\t\tr[0]"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_delay_real(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\tdiff;\t/* temp value */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\txfs_filblks_t\t\tda_new; /* new count del alloc blocks used */\n\txfs_filblks_t\t\tda_old; /* old count del alloc blocks used */\n\txfs_filblks_t\t\ttemp=0;\t/* value for da_new calculations */\n\txfs_filblks_t\t\ttemp2=0;/* value for da_new calculations */\n\tint\t\t\ttmp_rval;\t/* partial logging flags */\n\n\tifp = XFS_IFORK_PTR(bma->ip, XFS_DATA_FORK);\n\n\tASSERT(bma->idx >= 0);\n\tASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       (bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\tep = xfs_iext_get_ext(ifp, bma->idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\tda_old = startblockval(PREV.br_startblock);\n\tda_new = 0;\n\n\t/*\n\t * Set flags determining what part of the previous delayed allocation\n\t * extent is being replaced by a real allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (bma->idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == new->br_state &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (bma->idx < bma->ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx + 1), &RIGHT);\n\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    new->br_state == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\tbma->idx--;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 2, state);\n\t\tbma->ip->i_d.di_nextents--;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tPREV.br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount, LEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\tbma->idx--;\n\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock, LEFT.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tPREV.br_blockcount, LEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, new->br_startblock);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, PREV.br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tPREV.br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount, PREV.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, new->br_startblock);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Filling in the first part of a previous delayed allocation.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx - 1, state, _THIS_IP_);\n\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock, LEFT.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tnew->br_blockcount,\n\t\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx--;\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Filling in the first part of a previous delayed allocation.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_iext_insert(bma->ip, bma->idx, 1, new, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\tbma->firstblock, bma->flist,\n\t\t\t\t\t&bma->cur, 1, &tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tep = xfs_iext_get_ext(ifp, bma->idx + 1);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in the last part of a previous delayed allocation.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, bma->idx + 1),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\tRIGHT.br_state);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount,\n\t\t\t\t\tRIGHT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Filling in the last part of a previous delayed allocation.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_iext_insert(bma->ip, bma->idx + 1, 1, new, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur, 1,\n\t\t\t\t&tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tep = xfs_iext_get_ext(ifp, bma->idx);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Filling in the middle part of a previous delayed allocation.\n\t\t * Contiguity is impossible here.\n\t\t * This case is avoided almost all the time.\n\t\t *\n\t\t * We start with a delayed allocation:\n\t\t *\n\t\t * +ddddddddddddddddddddddddddddddddddddddddddddddddddddddd+\n\t\t *  PREV @ idx\n\t\t *\n\t         * and we are allocating:\n\t\t *                     +rrrrrrrrrrrrrrrrr+\n\t\t *\t\t\t      new\n\t\t *\n\t\t * and we set it up for insertion as:\n\t\t * +ddddddddddddddddddd+rrrrrrrrrrrrrrrrr+ddddddddddddddddd+\n\t\t *                            new\n\t\t *  PREV @ idx          LEFT              RIGHT\n\t\t *                      inserted at idx + 1\n\t\t */\n\t\ttemp = new->br_startoff - PREV.br_startoff;\n\t\ttemp2 = PREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, 0, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\t/* truncate PREV */\n\t\tLEFT = *new;\n\t\tRIGHT.br_state = PREV.br_state;\n\t\tRIGHT.br_startblock = nullstartblock(\n\t\t\t\t(int)xfs_bmap_worst_indlen(bma->ip, temp2));\n\t\tRIGHT.br_startoff = new_endoff;\n\t\tRIGHT.br_blockcount = temp2;\n\t\t/* insert LEFT (r[0]) and RIGHT (r[1]) at the same time */\n\t\txfs_iext_insert(bma->ip, bma->idx + 1, 2, &LEFT, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\t\t1, &tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\ttemp = xfs_bmap_worst_indlen(bma->ip, temp);\n\t\ttemp2 = xfs_bmap_worst_indlen(bma->ip, temp2);\n\t\tdiff = (int)(temp + temp2 - startblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tif (diff > 0) {\n\t\t\terror = xfs_icsb_modify_counters(bma->ip->i_mount,\n\t\t\t\t\tXFS_SBS_FDBLOCKS,\n\t\t\t\t\t-((int64_t)diff), 0);\n\t\t\tASSERT(!error);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tep = xfs_iext_get_ext(ifp, bma->idx);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx + 2, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, bma->idx + 2),\n\t\t\tnullstartblock((int)temp2));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 2, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tda_new = temp + temp2;\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\tda_old > 0, &tmp_logflags, XFS_DATA_FORK);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* adjust for changes in reserved delayed indirect blocks */\n\tif (da_old || da_new) {\n\t\ttemp = da_new;\n\t\tif (bma->cur)\n\t\t\ttemp += bma->cur->bc_private.b.allocated;\n\t\tASSERT(temp <= da_old);\n\t\tif (temp < da_old)\n\t\t\txfs_icsb_modify_counters(bma->ip->i_mount,\n\t\t\t\t\tXFS_SBS_FDBLOCKS,\n\t\t\t\t\t(int64_t)(da_old - temp), 0);\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, XFS_DATA_FORK);\ndone:\n\tbma->logflags |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasextflgbit",
          "args": [
            "&mp->m_sb"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasextflgbit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "416-420",
          "snippet": "static inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_EXTFLGBIT\t0x1000\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasextflgbit(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5 ||\n\t       (sbp->sb_versionnum & XFS_SB_VERSION_EXTFLGBIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_init_cursor",
          "args": [
            "mp",
            "bma->tp",
            "bma->ip",
            "whichfork"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "776-808",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_alloc",
          "args": [
            "bma"
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3904-3911",
          "snippet": "STATIC int\nxfs_bmap_alloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\tif (XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata)\n\t\treturn xfs_bmap_rtalloc(ap);\n\treturn xfs_bmap_btalloc(ap);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_alloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\tif (XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata)\n\t\treturn xfs_bmap_rtalloc(ap);\n\treturn xfs_bmap_btalloc(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_isaeof",
          "args": [
            "bma",
            "whichfork"
          ],
          "line": 4344
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_isaeof",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1636-1664",
          "snippet": "STATIC int\nxfs_bmap_isaeof(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\tbma->aeof = 0;\n\terror = xfs_bmap_last_extent(NULL, bma->ip, whichfork, &rec,\n\t\t\t\t     &is_empty);\n\tif (error)\n\t\treturn error;\n\n\tif (is_empty) {\n\t\tbma->aeof = 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if we are allocation or past the last extent, or at least into\n\t * the last delayed allocated extent.\n\t */\n\tbma->aeof = bma->offset >= rec.br_startoff + rec.br_blockcount ||\n\t\t(bma->offset >= rec.br_startoff &&\n\t\t isnullstartblock(rec.br_startblock));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_isaeof(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\tbma->aeof = 0;\n\terror = xfs_bmap_last_extent(NULL, bma->ip, whichfork, &rec,\n\t\t\t\t     &is_empty);\n\tif (error)\n\t\treturn error;\n\n\tif (is_empty) {\n\t\tbma->aeof = 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if we are allocation or past the last extent, or at least into\n\t * the last delayed allocated extent.\n\t */\n\tbma->aeof = bma->offset >= rec.br_startoff + rec.br_blockcount ||\n\t\t(bma->offset >= rec.br_startoff &&\n\t\t isnullstartblock(rec.br_startblock));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "bma->length",
            "bma->got.br_startoff - bma->offset"
          ],
          "line": 4323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "bma->length",
            "MAXEXTLEN"
          ],
          "line": 4321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->length > 0"
          ],
          "line": 4307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "bma->ip",
            "whichfork"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_bmapi_allocate(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_mount\t*mp = bma->ip->i_mount;\n\tint\t\t\twhichfork = (bma->flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\tint\t\t\ttmp_logflags = 0;\n\tint\t\t\terror;\n\n\tASSERT(bma->length > 0);\n\n\t/*\n\t * For the wasdelay case, we could also just allocate the stuff asked\n\t * for in this bmap call but that wouldn't be as good.\n\t */\n\tif (bma->wasdel) {\n\t\tbma->length = (xfs_extlen_t)bma->got.br_blockcount;\n\t\tbma->offset = bma->got.br_startoff;\n\t\tif (bma->idx != NULLEXTNUM && bma->idx) {\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1),\n\t\t\t\t\t &bma->prev);\n\t\t}\n\t} else {\n\t\tbma->length = XFS_FILBLKS_MIN(bma->length, MAXEXTLEN);\n\t\tif (!bma->eof)\n\t\t\tbma->length = XFS_FILBLKS_MIN(bma->length,\n\t\t\t\t\tbma->got.br_startoff - bma->offset);\n\t}\n\n\t/*\n\t * Indicate if this is the first user data in the file, or just any\n\t * user data.\n\t */\n\tif (!(bma->flags & XFS_BMAPI_METADATA)) {\n\t\tbma->userdata = (bma->offset == 0) ?\n\t\t\tXFS_ALLOC_INITIAL_USER_DATA : XFS_ALLOC_USERDATA;\n\t}\n\n\tbma->minlen = (bma->flags & XFS_BMAPI_CONTIG) ? bma->length : 1;\n\n\t/*\n\t * Only want to do the alignment at the eof if it is userdata and\n\t * allocation length is larger than a stripe unit.\n\t */\n\tif (mp->m_dalign && bma->length >= mp->m_dalign &&\n\t    !(bma->flags & XFS_BMAPI_METADATA) && whichfork == XFS_DATA_FORK) {\n\t\terror = xfs_bmap_isaeof(bma, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\terror = xfs_bmap_alloc(bma);\n\tif (error)\n\t\treturn error;\n\n\tif (bma->flist->xbf_low)\n\t\tbma->minleft = 0;\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\tif (bma->blkno == NULLFSBLOCK)\n\t\treturn 0;\n\tif ((ifp->if_flags & XFS_IFBROOT) && !bma->cur) {\n\t\tbma->cur = xfs_bmbt_init_cursor(mp, bma->tp, bma->ip, whichfork);\n\t\tbma->cur->bc_private.b.firstblock = *bma->firstblock;\n\t\tbma->cur->bc_private.b.flist = bma->flist;\n\t}\n\t/*\n\t * Bump the number of extents we've allocated\n\t * in this call.\n\t */\n\tbma->nallocs++;\n\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.flags =\n\t\t\tbma->wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\n\tbma->got.br_startoff = bma->offset;\n\tbma->got.br_startblock = bma->blkno;\n\tbma->got.br_blockcount = bma->length;\n\tbma->got.br_state = XFS_EXT_NORM;\n\n\t/*\n\t * A wasdelay extent has been initialized, so shouldn't be flagged\n\t * as unwritten.\n\t */\n\tif (!bma->wasdel && (bma->flags & XFS_BMAPI_PREALLOC) &&\n\t    xfs_sb_version_hasextflgbit(&mp->m_sb))\n\t\tbma->got.br_state = XFS_EXT_UNWRITTEN;\n\n\tif (bma->wasdel)\n\t\terror = xfs_bmap_add_extent_delay_real(bma);\n\telse\n\t\terror = xfs_bmap_add_extent_hole_real(bma, whichfork);\n\n\tbma->logflags |= tmp_logflags;\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Update our extent pointer, given that xfs_bmap_add_extent_delay_real\n\t * or xfs_bmap_add_extent_hole_real might have merged it into one of\n\t * the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &bma->got);\n\n\tASSERT(bma->got.br_startoff <= bma->offset);\n\tASSERT(bma->got.br_startoff + bma->got.br_blockcount >=\n\t       bma->offset + bma->length);\n\tASSERT(bma->got.br_state == XFS_EXT_NORM ||\n\t       bma->got.br_state == XFS_EXT_UNWRITTEN);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmapi_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "4214-4293",
    "snippet": "int\nxfs_bmapi_delay(\n\tstruct xfs_inode\t*ip,\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t/* length to map in file */\n\tstruct xfs_bmbt_irec\t*mval,\t/* output: map values */\n\tint\t\t\t*nmap,\t/* i/o: mval size/count */\n\tint\t\t\tflags)\t/* XFS_BMAPI_... */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tstruct xfs_bmbt_irec\tgot;\t/* current file extent record */\n\tstruct xfs_bmbt_irec\tprev;\t/* previous file extent record */\n\txfs_fileoff_t\t\tobno;\t/* old block number (offset) */\n\txfs_fileoff_t\t\tend;\t/* end of mapped file region */\n\txfs_extnum_t\t\tlastx;\t/* last useful extent number */\n\tint\t\t\teof;\t/* we've hit the end of extents */\n\tint\t\t\tn = 0;\t/* current extent index */\n\tint\t\t\terror = 0;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & ~XFS_BMAPI_ENTIRE));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_delay\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, XFS_DATA_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, XFS_DATA_FORK, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\tif (eof || got.br_startoff > bno) {\n\t\t\terror = xfs_bmapi_reserve_delalloc(ip, bno, len, &got,\n\t\t\t\t\t\t\t   &prev, &lastx, eof);\n\t\t\tif (error) {\n\t\t\t\tif (n == 0) {\n\t\t\t\t\t*nmap = 0;\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tprev = got;\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\n\t*nmap = n;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, lastx)",
            "&got"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "lastx"
          ],
          "line": 4286
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_update_map",
          "args": [
            "&mval",
            "&bno",
            "&len",
            "obno",
            "end",
            "&n",
            "flags"
          ],
          "line": 4277
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_update_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3962-4012",
          "snippet": "STATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tint\t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t/* update previous map with new information */\n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   ((flags & XFS_BMAPI_IGSTATE) ||\n\t\t\tmval[-1].br_state == mval->br_state)) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tint\t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t/* update previous map with new information */\n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   ((flags & XFS_BMAPI_IGSTATE) ||\n\t\t\tmval[-1].br_state == mval->br_state)) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_trim_map",
          "args": [
            "mval",
            "&got",
            "&bno",
            "len",
            "obno",
            "end",
            "n",
            "flags"
          ],
          "line": 4276
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_trim_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3916-3957",
          "snippet": "STATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tint\t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t/*\n\t * Return the minimum of what we got and what we asked for for\n\t * the length.  We can use the len variable here because it is\n\t * modified below and we could have been there before coming\n\t * here if the first part of the allocation didn't overlap what\n\t * was asked for.\n\t */\n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tint\t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t/*\n\t * Return the minimum of what we got and what we asked for for\n\t * the length.  We can use the len variable here because it is\n\t * modified below and we could have been there before coming\n\t * here if the first part of the allocation didn't overlap what\n\t * was asked for.\n\t */\n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_reserve_delalloc",
          "args": [
            "ip",
            "bno",
            "len",
            "&got",
            "&prev",
            "&lastx",
            "eof"
          ],
          "line": 4264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_reserve_delalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "4105-4209",
          "snippet": "STATIC int\nxfs_bmapi_reserve_delalloc(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\taoff,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*got,\n\tstruct xfs_bmbt_irec\t*prev,\n\txfs_extnum_t\t\t*lastx,\n\tint\t\t\teof)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\txfs_extlen_t\t\talen;\n\txfs_extlen_t\t\tindlen;\n\tchar\t\t\trt = XFS_IS_REALTIME_INODE(ip);\n\txfs_extlen_t\t\textsz;\n\tint\t\t\terror;\n\n\talen = XFS_FILBLKS_MIN(len, MAXEXTLEN);\n\tif (!eof)\n\t\talen = XFS_FILBLKS_MIN(alen, got->br_startoff - aoff);\n\n\t/* Figure out the extent size, adjust alen */\n\textsz = xfs_get_extsz_hint(ip);\n\tif (extsz) {\n\t\t/*\n\t\t * Make sure we don't exceed a single extent length when we\n\t\t * align the extent by reducing length we are going to\n\t\t * allocate by the maximum amount extent size aligment may\n\t\t * require.\n\t\t */\n\t\talen = XFS_FILBLKS_MIN(len, MAXEXTLEN - (2 * extsz - 1));\n\t\terror = xfs_bmap_extsize_align(mp, got, prev, extsz, rt, eof,\n\t\t\t\t\t       1, 0, &aoff, &alen);\n\t\tASSERT(!error);\n\t}\n\n\tif (rt)\n\t\textsz = alen / mp->m_sb.sb_rextsize;\n\n\t/*\n\t * Make a transaction-less quota reservation for delayed allocation\n\t * blocks.  This number gets adjusted later.  We return if we haven't\n\t * allocated blocks already inside this loop.\n\t */\n\terror = xfs_trans_reserve_quota_nblks(NULL, ip, (long)alen, 0,\n\t\t\trt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Split changing sb for alen and indlen since they could be coming\n\t * from different places.\n\t */\n\tindlen = (xfs_extlen_t)xfs_bmap_worst_indlen(ip, alen);\n\tASSERT(indlen > 0);\n\n\tif (rt) {\n\t\terror = xfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)extsz), 0);\n\t} else {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t -((int64_t)alen), 0);\n\t}\n\n\tif (error)\n\t\tgoto out_unreserve_quota;\n\n\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t -((int64_t)indlen), 0);\n\tif (error)\n\t\tgoto out_unreserve_blocks;\n\n\n\tip->i_delayed_blks += alen;\n\n\tgot->br_startoff = aoff;\n\tgot->br_startblock = nullstartblock(indlen);\n\tgot->br_blockcount = alen;\n\tgot->br_state = XFS_EXT_NORM;\n\txfs_bmap_add_extent_hole_delay(ip, lastx, got);\n\n\t/*\n\t * Update our extent pointer, given that xfs_bmap_add_extent_hole_delay\n\t * might have merged it into one of the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *lastx), got);\n\n\tASSERT(got->br_startoff <= aoff);\n\tASSERT(got->br_startoff + got->br_blockcount >= aoff + alen);\n\tASSERT(isnullstartblock(got->br_startblock));\n\tASSERT(got->br_state == XFS_EXT_NORM);\n\treturn 0;\n\nout_unreserve_blocks:\n\tif (rt)\n\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS, extsz, 0);\n\telse\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, alen, 0);\nout_unreserve_quota:\n\tif (XFS_IS_QUOTA_ON(mp))\n\t\txfs_trans_unreserve_quota_nblks(NULL, ip, (long)alen, 0, rt ?\n\t\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmapi_reserve_delalloc(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\taoff,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*got,\n\tstruct xfs_bmbt_irec\t*prev,\n\txfs_extnum_t\t\t*lastx,\n\tint\t\t\teof)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\txfs_extlen_t\t\talen;\n\txfs_extlen_t\t\tindlen;\n\tchar\t\t\trt = XFS_IS_REALTIME_INODE(ip);\n\txfs_extlen_t\t\textsz;\n\tint\t\t\terror;\n\n\talen = XFS_FILBLKS_MIN(len, MAXEXTLEN);\n\tif (!eof)\n\t\talen = XFS_FILBLKS_MIN(alen, got->br_startoff - aoff);\n\n\t/* Figure out the extent size, adjust alen */\n\textsz = xfs_get_extsz_hint(ip);\n\tif (extsz) {\n\t\t/*\n\t\t * Make sure we don't exceed a single extent length when we\n\t\t * align the extent by reducing length we are going to\n\t\t * allocate by the maximum amount extent size aligment may\n\t\t * require.\n\t\t */\n\t\talen = XFS_FILBLKS_MIN(len, MAXEXTLEN - (2 * extsz - 1));\n\t\terror = xfs_bmap_extsize_align(mp, got, prev, extsz, rt, eof,\n\t\t\t\t\t       1, 0, &aoff, &alen);\n\t\tASSERT(!error);\n\t}\n\n\tif (rt)\n\t\textsz = alen / mp->m_sb.sb_rextsize;\n\n\t/*\n\t * Make a transaction-less quota reservation for delayed allocation\n\t * blocks.  This number gets adjusted later.  We return if we haven't\n\t * allocated blocks already inside this loop.\n\t */\n\terror = xfs_trans_reserve_quota_nblks(NULL, ip, (long)alen, 0,\n\t\t\trt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Split changing sb for alen and indlen since they could be coming\n\t * from different places.\n\t */\n\tindlen = (xfs_extlen_t)xfs_bmap_worst_indlen(ip, alen);\n\tASSERT(indlen > 0);\n\n\tif (rt) {\n\t\terror = xfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)extsz), 0);\n\t} else {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t -((int64_t)alen), 0);\n\t}\n\n\tif (error)\n\t\tgoto out_unreserve_quota;\n\n\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t -((int64_t)indlen), 0);\n\tif (error)\n\t\tgoto out_unreserve_blocks;\n\n\n\tip->i_delayed_blks += alen;\n\n\tgot->br_startoff = aoff;\n\tgot->br_startblock = nullstartblock(indlen);\n\tgot->br_blockcount = alen;\n\tgot->br_state = XFS_EXT_NORM;\n\txfs_bmap_add_extent_hole_delay(ip, lastx, got);\n\n\t/*\n\t * Update our extent pointer, given that xfs_bmap_add_extent_hole_delay\n\t * might have merged it into one of the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *lastx), got);\n\n\tASSERT(got->br_startoff <= aoff);\n\tASSERT(got->br_startoff + got->br_blockcount >= aoff + alen);\n\tASSERT(isnullstartblock(got->br_startblock));\n\tASSERT(got->br_state == XFS_EXT_NORM);\n\treturn 0;\n\nout_unreserve_blocks:\n\tif (rt)\n\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS, extsz, 0);\n\telse\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, alen, 0);\nout_unreserve_quota:\n\tif (XFS_IS_QUOTA_ON(mp))\n\t\txfs_trans_unreserve_quota_nblks(NULL, ip, (long)alen, 0, rt ?\n\t\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_search_extents",
          "args": [
            "ip",
            "bno",
            "XFS_DATA_FORK",
            "&eof",
            "&lastx",
            "&got",
            "&prev"
          ],
          "line": 4258
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_search_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1459-1493",
          "snippet": "STATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "NULL",
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 4253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_blk_mapw"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 4247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_bmapi_delay\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT)"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "(XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_BTREE)",
            "mp",
            "XFS_ERRTAG_BMAPIFORMAT",
            "XFS_RANDOM_BMAPIFORMAT"
          ],
          "line": 4239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 4241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 4240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_EXCL)"
          ],
          "line": 4237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 4237
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & ~XFS_BMAPI_ENTIRE)"
          ],
          "line": 4236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*nmap <= XFS_BMAP_MAX_NMAP"
          ],
          "line": 4235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*nmap >= 1"
          ],
          "line": 4234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 4224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_delay(\n\tstruct xfs_inode\t*ip,\t/* incore inode */\n\txfs_fileoff_t\t\tbno,\t/* starting file offs. mapped */\n\txfs_filblks_t\t\tlen,\t/* length to map in file */\n\tstruct xfs_bmbt_irec\t*mval,\t/* output: map values */\n\tint\t\t\t*nmap,\t/* i/o: mval size/count */\n\tint\t\t\tflags)\t/* XFS_BMAPI_... */\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tstruct xfs_bmbt_irec\tgot;\t/* current file extent record */\n\tstruct xfs_bmbt_irec\tprev;\t/* previous file extent record */\n\txfs_fileoff_t\t\tobno;\t/* old block number (offset) */\n\txfs_fileoff_t\t\tend;\t/* end of mapped file region */\n\txfs_extnum_t\t\tlastx;\t/* last useful extent number */\n\tint\t\t\teof;\t/* we've hit the end of extents */\n\tint\t\t\tn = 0;\t/* current extent index */\n\tint\t\t\terror = 0;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(*nmap <= XFS_BMAP_MAX_NMAP);\n\tASSERT(!(flags & ~XFS_BMAPI_ENTIRE));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, XFS_DATA_FORK) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_delay\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapw);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, XFS_DATA_FORK);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, XFS_DATA_FORK, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\tif (eof || got.br_startoff > bno) {\n\t\t\terror = xfs_bmapi_reserve_delalloc(ip, bno, len, &got,\n\t\t\t\t\t\t\t   &prev, &lastx, eof);\n\t\t\tif (error) {\n\t\t\t\tif (n == 0) {\n\t\t\t\t\t*nmap = 0;\n\t\t\t\t\treturn error;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tprev = got;\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\n\t*nmap = n;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmapi_reserve_delalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "4105-4209",
    "snippet": "STATIC int\nxfs_bmapi_reserve_delalloc(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\taoff,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*got,\n\tstruct xfs_bmbt_irec\t*prev,\n\txfs_extnum_t\t\t*lastx,\n\tint\t\t\teof)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\txfs_extlen_t\t\talen;\n\txfs_extlen_t\t\tindlen;\n\tchar\t\t\trt = XFS_IS_REALTIME_INODE(ip);\n\txfs_extlen_t\t\textsz;\n\tint\t\t\terror;\n\n\talen = XFS_FILBLKS_MIN(len, MAXEXTLEN);\n\tif (!eof)\n\t\talen = XFS_FILBLKS_MIN(alen, got->br_startoff - aoff);\n\n\t/* Figure out the extent size, adjust alen */\n\textsz = xfs_get_extsz_hint(ip);\n\tif (extsz) {\n\t\t/*\n\t\t * Make sure we don't exceed a single extent length when we\n\t\t * align the extent by reducing length we are going to\n\t\t * allocate by the maximum amount extent size aligment may\n\t\t * require.\n\t\t */\n\t\talen = XFS_FILBLKS_MIN(len, MAXEXTLEN - (2 * extsz - 1));\n\t\terror = xfs_bmap_extsize_align(mp, got, prev, extsz, rt, eof,\n\t\t\t\t\t       1, 0, &aoff, &alen);\n\t\tASSERT(!error);\n\t}\n\n\tif (rt)\n\t\textsz = alen / mp->m_sb.sb_rextsize;\n\n\t/*\n\t * Make a transaction-less quota reservation for delayed allocation\n\t * blocks.  This number gets adjusted later.  We return if we haven't\n\t * allocated blocks already inside this loop.\n\t */\n\terror = xfs_trans_reserve_quota_nblks(NULL, ip, (long)alen, 0,\n\t\t\trt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Split changing sb for alen and indlen since they could be coming\n\t * from different places.\n\t */\n\tindlen = (xfs_extlen_t)xfs_bmap_worst_indlen(ip, alen);\n\tASSERT(indlen > 0);\n\n\tif (rt) {\n\t\terror = xfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)extsz), 0);\n\t} else {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t -((int64_t)alen), 0);\n\t}\n\n\tif (error)\n\t\tgoto out_unreserve_quota;\n\n\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t -((int64_t)indlen), 0);\n\tif (error)\n\t\tgoto out_unreserve_blocks;\n\n\n\tip->i_delayed_blks += alen;\n\n\tgot->br_startoff = aoff;\n\tgot->br_startblock = nullstartblock(indlen);\n\tgot->br_blockcount = alen;\n\tgot->br_state = XFS_EXT_NORM;\n\txfs_bmap_add_extent_hole_delay(ip, lastx, got);\n\n\t/*\n\t * Update our extent pointer, given that xfs_bmap_add_extent_hole_delay\n\t * might have merged it into one of the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *lastx), got);\n\n\tASSERT(got->br_startoff <= aoff);\n\tASSERT(got->br_startoff + got->br_blockcount >= aoff + alen);\n\tASSERT(isnullstartblock(got->br_startblock));\n\tASSERT(got->br_state == XFS_EXT_NORM);\n\treturn 0;\n\nout_unreserve_blocks:\n\tif (rt)\n\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS, extsz, 0);\n\telse\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, alen, 0);\nout_unreserve_quota:\n\tif (XFS_IS_QUOTA_ON(mp))\n\t\txfs_trans_unreserve_quota_nblks(NULL, ip, (long)alen, 0, rt ?\n\t\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_unreserve_quota_nblks",
          "args": [
            "NULL",
            "ip",
            "(long)alen",
            "0",
            "rt ?\n\t\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_QUOTA_ON",
          "args": [
            "mp"
          ],
          "line": 4205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_icsb_modify_counters",
          "args": [
            "mp",
            "XFS_SBS_FDBLOCKS",
            "alen",
            "0"
          ],
          "line": 4203
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_modify_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1846-1977",
          "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_mod_incore_sb",
          "args": [
            "mp",
            "XFS_SBS_FREXTENTS",
            "extsz",
            "0"
          ],
          "line": 4201
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mod_incore_sb_batch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1312-1349",
          "snippet": "int\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_mod_incore_sb_batch(\n\tstruct xfs_mount\t*mp,\n\txfs_mod_sb_t\t\t*msb,\n\tuint\t\t\tnmsb,\n\tint\t\t\trsvd)\n{\n\txfs_mod_sb_t\t\t*msbp;\n\tint\t\t\terror = 0;\n\n\t/*\n\t * Loop through the array of mod structures and apply each individually.\n\t * If any fail, then back out all those which have already been applied.\n\t * Do all of this within the scope of the m_sb_lock so that all of the\n\t * changes will be atomic.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tfor (msbp = msb; msbp < (msb + nmsb); msbp++) {\n\t\tASSERT(msbp->msb_field < XFS_SBS_ICOUNT ||\n\t\t       msbp->msb_field > XFS_SBS_FDBLOCKS);\n\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   msbp->msb_delta, rsvd);\n\t\tif (error)\n\t\t\tgoto unwind;\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn 0;\n\nunwind:\n\twhile (--msbp >= msb) {\n\t\terror = xfs_mod_incore_sb_unlocked(mp, msbp->msb_field,\n\t\t\t\t\t\t   -msbp->msb_delta, rsvd);\n\t\tASSERT(error == 0);\n\t}\n\tspin_unlock(&mp->m_sb_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "got->br_state == XFS_EXT_NORM"
          ],
          "line": 4196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "isnullstartblock(got->br_startblock)"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "got->br_startblock"
          ],
          "line": 4195
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "got->br_startoff + got->br_blockcount >= aoff + alen"
          ],
          "line": 4194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "got->br_startoff <= aoff"
          ],
          "line": 4193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, *lastx)",
            "got"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "*lastx"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_extent_hole_delay",
          "args": [
            "ip",
            "lastx",
            "got"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_extent_hole_delay",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "2814-2953",
          "snippet": "STATIC void\nxfs_bmap_add_extent_hole_delay(\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_bmbt_irec_t\t\t*new)\t/* new data to add to file extents */\n{\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_bmbt_irec_t\t\tleft;\t/* left neighbor extent entry */\n\txfs_filblks_t\t\tnewlen=0;\t/* new indirect size */\n\txfs_filblks_t\t\toldlen=0;\t/* old indirect size */\n\txfs_bmbt_irec_t\t\tright;\t/* right neighbor extent entry */\n\tint\t\t\tstate;  /* state bits, accessed thru macros */\n\txfs_filblks_t\t\ttemp=0;\t/* temp for indirect calculations */\n\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tstate = 0;\n\tASSERT(isnullstartblock(new->br_startblock));\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &left);\n\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t/*\n\t * Check and set flags if the current (right) segment exists.\n\t * If it doesn't exist, we're converting the hole at end-of-file.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx), &right);\n\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t/*\n\t * Set contiguity flags on the left and right neighbors.\n\t * Don't let extents get too large, even if the pieces are contiguous.\n\t */\n\tif ((state & BMAP_LEFT_VALID) && (state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && (state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_blockcount + right.br_blockcount <= MAXEXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     (left.br_blockcount + new->br_blockcount +\n\t      right.br_blockcount <= MAXEXTLEN)))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the contiguity flags.\n\t */\n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with delayed allocations\n\t\t * on the left and on the right.\n\t\t * Merge all three into a single extent record.\n\t\t */\n\t\t--*idx;\n\t\ttemp = left.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx), temp);\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnullstartblock((int)newlen));\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a delayed allocation\n\t\t * on the left.\n\t\t * Merge the new allocation with the left neighbor.\n\t\t */\n\t\t--*idx;\n\t\ttemp = left.br_blockcount + new->br_blockcount;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx), temp);\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnullstartblock((int)newlen));\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a delayed allocation\n\t\t * on the right.\n\t\t * Merge the new allocation with the right neighbor.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\ttemp = new->br_blockcount + right.br_blockcount;\n\t\toldlen = startblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff,\n\t\t\tnullstartblock((int)newlen), temp, right.br_state);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * New allocation is not contiguous with another\n\t\t * delayed allocation.\n\t\t * Insert a new entry.\n\t\t */\n\t\toldlen = newlen = 0;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tbreak;\n\t}\n\tif (oldlen != newlen) {\n\t\tASSERT(oldlen > newlen);\n\t\txfs_icsb_modify_counters(ip->i_mount, XFS_SBS_FDBLOCKS,\n\t\t\t(int64_t)(oldlen - newlen), 0);\n\t\t/*\n\t\t * Nothing to do for disk quota accounting here.\n\t\t */\n\t}\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_add_extent_hole_delay(\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_bmbt_irec_t\t\t*new)\t/* new data to add to file extents */\n{\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_bmbt_irec_t\t\tleft;\t/* left neighbor extent entry */\n\txfs_filblks_t\t\tnewlen=0;\t/* new indirect size */\n\txfs_filblks_t\t\toldlen=0;\t/* old indirect size */\n\txfs_bmbt_irec_t\t\tright;\t/* right neighbor extent entry */\n\tint\t\t\tstate;  /* state bits, accessed thru macros */\n\txfs_filblks_t\t\ttemp=0;\t/* temp for indirect calculations */\n\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tstate = 0;\n\tASSERT(isnullstartblock(new->br_startblock));\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &left);\n\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t/*\n\t * Check and set flags if the current (right) segment exists.\n\t * If it doesn't exist, we're converting the hole at end-of-file.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx), &right);\n\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t/*\n\t * Set contiguity flags on the left and right neighbors.\n\t * Don't let extents get too large, even if the pieces are contiguous.\n\t */\n\tif ((state & BMAP_LEFT_VALID) && (state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && (state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_blockcount + right.br_blockcount <= MAXEXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     (left.br_blockcount + new->br_blockcount +\n\t      right.br_blockcount <= MAXEXTLEN)))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the contiguity flags.\n\t */\n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with delayed allocations\n\t\t * on the left and on the right.\n\t\t * Merge all three into a single extent record.\n\t\t */\n\t\t--*idx;\n\t\ttemp = left.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx), temp);\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnullstartblock((int)newlen));\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a delayed allocation\n\t\t * on the left.\n\t\t * Merge the new allocation with the left neighbor.\n\t\t */\n\t\t--*idx;\n\t\ttemp = left.br_blockcount + new->br_blockcount;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx), temp);\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnullstartblock((int)newlen));\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a delayed allocation\n\t\t * on the right.\n\t\t * Merge the new allocation with the right neighbor.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\ttemp = new->br_blockcount + right.br_blockcount;\n\t\toldlen = startblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff,\n\t\t\tnullstartblock((int)newlen), temp, right.br_state);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * New allocation is not contiguous with another\n\t\t * delayed allocation.\n\t\t * Insert a new entry.\n\t\t */\n\t\toldlen = newlen = 0;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tbreak;\n\t}\n\tif (oldlen != newlen) {\n\t\tASSERT(oldlen > newlen);\n\t\txfs_icsb_modify_counters(ip->i_mount, XFS_SBS_FDBLOCKS,\n\t\t\t(int64_t)(oldlen - newlen), 0);\n\t\t/*\n\t\t * Nothing to do for disk quota accounting here.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nullstartblock",
          "args": [
            "indlen"
          ],
          "line": 4182
        },
        "resolved": true,
        "details": {
          "function_name": "nullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1383-1387",
          "snippet": "static inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)",
            "#define STARTBLOCKVALBITS\t17"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n#define STARTBLOCKVALBITS\t17\n\nstatic inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "indlen > 0"
          ],
          "line": 4160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_worst_indlen",
          "args": [
            "ip",
            "alen"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_worst_indlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "178-203",
          "snippet": "STATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota_nblks",
          "args": [
            "NULL",
            "ip",
            "(long)alen",
            "0",
            "rt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS"
          ],
          "line": 4150
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_nblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "802-832",
          "snippet": "int\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!error"
          ],
          "line": 4139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_extsize_align",
          "args": [
            "mp",
            "got",
            "prev",
            "extsz",
            "rt",
            "eof",
            "1",
            "0",
            "&aoff",
            "&alen"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_extsize_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3204-3362",
          "snippet": "int\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t/* next extent pointer */\n\txfs_bmbt_irec_t\t*prevp,\t\t/* previous extent pointer */\n\txfs_extlen_t\textsz,\t\t/* align to this extent size */\n\tint\t\trt,\t\t/* is this a realtime inode? */\n\tint\t\teof,\t\t/* is extent at end-of-file? */\n\tint\t\tdelay,\t\t/* creating delalloc extent? */\n\tint\t\tconvert,\t/* overwriting unwritten extent? */\n\txfs_fileoff_t\t*offp,\t\t/* in/out: aligned offset */\n\txfs_extlen_t\t*lenp)\t\t/* in/out: aligned length */\n{\n\txfs_fileoff_t\torig_off;\t/* original offset */\n\txfs_extlen_t\torig_alen;\t/* original length */\n\txfs_fileoff_t\torig_end;\t/* original off+len */\n\txfs_fileoff_t\tnexto;\t\t/* next file offset */\n\txfs_fileoff_t\tprevo;\t\t/* previous file offset */\n\txfs_fileoff_t\talign_off;\t/* temp for offset */\n\txfs_extlen_t\talign_alen;\t/* temp for length */\n\txfs_extlen_t\ttemp;\t\t/* temp for calculations */\n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t/*\n\t * If this request overlaps an existing extent, then don't\n\t * attempt to perform any additional alignment.\n\t */\n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file offset is unaligned vs. the extent size\n\t * we need to align it.  This will be possible unless\n\t * the file was previously written with a kernel that didn't\n\t * perform this alignment, or if a truncate shot us in the\n\t * foot.\n\t */\n\ttemp = do_mod(orig_off, extsz);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\t/*\n\t * Same adjustment for the end of the requested area.\n\t */\n\tif ((temp = (align_alen % extsz))) {\n\t\talign_alen += extsz - temp;\n\t}\n\t/*\n\t * If the previous block overlaps with this proposed allocation\n\t * then move the start forward without adjusting the length.\n\t */\n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t/*\n\t * If the next block overlaps with this proposed allocation\n\t * then move the start back without adjusting the length,\n\t * but not before offset 0.\n\t * This may of course make the start overlap previous block,\n\t * and if we hit the offset 0 limit then the next block\n\t * can still overlap too.\n\t */\n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t/*\n\t * If we're now overlapping the next or previous extent that\n\t * means we can't fit an extsz piece in this hole.  Just move\n\t * the start forward to the first valid spot and set\n\t * the length so we hit the end.\n\t */\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t/*\n\t * If realtime, and the result isn't a multiple of the realtime\n\t * extent size we need to remove blocks until it is.\n\t */\n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t/*\n\t\t * We're not covering the original request, or\n\t\t * we won't be able to once we fix the length.\n\t\t */\n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Try to fix it by moving the start up.\n\t\t */\n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t/*\n\t\t * Try to fix it by moving the end in.\n\t\t */\n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t/*\n\t\t * Set the start to the minimum then trim the length.\n\t\t */\n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t/*\n\t\t * Result doesn't cover the request, fail it.\n\t\t */\n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\tASSERT(orig_end <= align_off + align_alen);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t/* next extent pointer */\n\txfs_bmbt_irec_t\t*prevp,\t\t/* previous extent pointer */\n\txfs_extlen_t\textsz,\t\t/* align to this extent size */\n\tint\t\trt,\t\t/* is this a realtime inode? */\n\tint\t\teof,\t\t/* is extent at end-of-file? */\n\tint\t\tdelay,\t\t/* creating delalloc extent? */\n\tint\t\tconvert,\t/* overwriting unwritten extent? */\n\txfs_fileoff_t\t*offp,\t\t/* in/out: aligned offset */\n\txfs_extlen_t\t*lenp)\t\t/* in/out: aligned length */\n{\n\txfs_fileoff_t\torig_off;\t/* original offset */\n\txfs_extlen_t\torig_alen;\t/* original length */\n\txfs_fileoff_t\torig_end;\t/* original off+len */\n\txfs_fileoff_t\tnexto;\t\t/* next file offset */\n\txfs_fileoff_t\tprevo;\t\t/* previous file offset */\n\txfs_fileoff_t\talign_off;\t/* temp for offset */\n\txfs_extlen_t\talign_alen;\t/* temp for length */\n\txfs_extlen_t\ttemp;\t\t/* temp for calculations */\n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t/*\n\t * If this request overlaps an existing extent, then don't\n\t * attempt to perform any additional alignment.\n\t */\n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file offset is unaligned vs. the extent size\n\t * we need to align it.  This will be possible unless\n\t * the file was previously written with a kernel that didn't\n\t * perform this alignment, or if a truncate shot us in the\n\t * foot.\n\t */\n\ttemp = do_mod(orig_off, extsz);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\t/*\n\t * Same adjustment for the end of the requested area.\n\t */\n\tif ((temp = (align_alen % extsz))) {\n\t\talign_alen += extsz - temp;\n\t}\n\t/*\n\t * If the previous block overlaps with this proposed allocation\n\t * then move the start forward without adjusting the length.\n\t */\n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t/*\n\t * If the next block overlaps with this proposed allocation\n\t * then move the start back without adjusting the length,\n\t * but not before offset 0.\n\t * This may of course make the start overlap previous block,\n\t * and if we hit the offset 0 limit then the next block\n\t * can still overlap too.\n\t */\n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t/*\n\t * If we're now overlapping the next or previous extent that\n\t * means we can't fit an extsz piece in this hole.  Just move\n\t * the start forward to the first valid spot and set\n\t * the length so we hit the end.\n\t */\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t/*\n\t * If realtime, and the result isn't a multiple of the realtime\n\t * extent size we need to remove blocks until it is.\n\t */\n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t/*\n\t\t * We're not covering the original request, or\n\t\t * we won't be able to once we fix the length.\n\t\t */\n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Try to fix it by moving the start up.\n\t\t */\n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t/*\n\t\t * Try to fix it by moving the end in.\n\t\t */\n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t/*\n\t\t * Set the start to the minimum then trim the length.\n\t\t */\n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t/*\n\t\t * Result doesn't cover the request, fail it.\n\t\t */\n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\tASSERT(orig_end <= align_off + align_alen);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "len",
            "MAXEXTLEN - (2 * extsz - 1)"
          ],
          "line": 4136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_extsz_hint",
          "args": [
            "ip"
          ],
          "line": 4128
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_extsz_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "67-76",
          "snippet": "xfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "alen",
            "got->br_startoff - aoff"
          ],
          "line": 4125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "len",
            "MAXEXTLEN"
          ],
          "line": 4123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 4119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 4116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmapi_reserve_delalloc(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\taoff,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*got,\n\tstruct xfs_bmbt_irec\t*prev,\n\txfs_extnum_t\t\t*lastx,\n\tint\t\t\teof)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\txfs_extlen_t\t\talen;\n\txfs_extlen_t\t\tindlen;\n\tchar\t\t\trt = XFS_IS_REALTIME_INODE(ip);\n\txfs_extlen_t\t\textsz;\n\tint\t\t\terror;\n\n\talen = XFS_FILBLKS_MIN(len, MAXEXTLEN);\n\tif (!eof)\n\t\talen = XFS_FILBLKS_MIN(alen, got->br_startoff - aoff);\n\n\t/* Figure out the extent size, adjust alen */\n\textsz = xfs_get_extsz_hint(ip);\n\tif (extsz) {\n\t\t/*\n\t\t * Make sure we don't exceed a single extent length when we\n\t\t * align the extent by reducing length we are going to\n\t\t * allocate by the maximum amount extent size aligment may\n\t\t * require.\n\t\t */\n\t\talen = XFS_FILBLKS_MIN(len, MAXEXTLEN - (2 * extsz - 1));\n\t\terror = xfs_bmap_extsize_align(mp, got, prev, extsz, rt, eof,\n\t\t\t\t\t       1, 0, &aoff, &alen);\n\t\tASSERT(!error);\n\t}\n\n\tif (rt)\n\t\textsz = alen / mp->m_sb.sb_rextsize;\n\n\t/*\n\t * Make a transaction-less quota reservation for delayed allocation\n\t * blocks.  This number gets adjusted later.  We return if we haven't\n\t * allocated blocks already inside this loop.\n\t */\n\terror = xfs_trans_reserve_quota_nblks(NULL, ip, (long)alen, 0,\n\t\t\trt ? XFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * Split changing sb for alen and indlen since they could be coming\n\t * from different places.\n\t */\n\tindlen = (xfs_extlen_t)xfs_bmap_worst_indlen(ip, alen);\n\tASSERT(indlen > 0);\n\n\tif (rt) {\n\t\terror = xfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)extsz), 0);\n\t} else {\n\t\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t\t -((int64_t)alen), 0);\n\t}\n\n\tif (error)\n\t\tgoto out_unreserve_quota;\n\n\terror = xfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t -((int64_t)indlen), 0);\n\tif (error)\n\t\tgoto out_unreserve_blocks;\n\n\n\tip->i_delayed_blks += alen;\n\n\tgot->br_startoff = aoff;\n\tgot->br_startblock = nullstartblock(indlen);\n\tgot->br_blockcount = alen;\n\tgot->br_state = XFS_EXT_NORM;\n\txfs_bmap_add_extent_hole_delay(ip, lastx, got);\n\n\t/*\n\t * Update our extent pointer, given that xfs_bmap_add_extent_hole_delay\n\t * might have merged it into one of the neighbouring ones.\n\t */\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *lastx), got);\n\n\tASSERT(got->br_startoff <= aoff);\n\tASSERT(got->br_startoff + got->br_blockcount >= aoff + alen);\n\tASSERT(isnullstartblock(got->br_startblock));\n\tASSERT(got->br_state == XFS_EXT_NORM);\n\treturn 0;\n\nout_unreserve_blocks:\n\tif (rt)\n\t\txfs_mod_incore_sb(mp, XFS_SBS_FREXTENTS, extsz, 0);\n\telse\n\t\txfs_icsb_modify_counters(mp, XFS_SBS_FDBLOCKS, alen, 0);\nout_unreserve_quota:\n\tif (XFS_IS_QUOTA_ON(mp))\n\t\txfs_trans_unreserve_quota_nblks(NULL, ip, (long)alen, 0, rt ?\n\t\t\t\tXFS_QMOPT_RES_RTBLKS : XFS_QMOPT_RES_REGBLKS);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmapi_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "4017-4103",
    "snippet": "int\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, lastx)",
            "&got"
          ],
          "line": 4097
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "lastx"
          ],
          "line": 4097
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_update_map",
          "args": [
            "&mval",
            "&bno",
            "&len",
            "obno",
            "end",
            "&n",
            "flags"
          ],
          "line": 4089
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_update_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3962-4012",
          "snippet": "STATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tint\t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t/* update previous map with new information */\n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   ((flags & XFS_BMAPI_IGSTATE) ||\n\t\t\tmval[-1].br_state == mval->br_state)) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tint\t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t/* update previous map with new information */\n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   ((flags & XFS_BMAPI_IGSTATE) ||\n\t\t\tmval[-1].br_state == mval->br_state)) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmapi_trim_map",
          "args": [
            "mval",
            "&got",
            "&bno",
            "len",
            "obno",
            "end",
            "n",
            "flags"
          ],
          "line": 4088
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmapi_trim_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3916-3957",
          "snippet": "STATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tint\t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t/*\n\t * Return the minimum of what we got and what we asked for for\n\t * the length.  We can use the len variable here because it is\n\t * modified below and we could have been there before coming\n\t * here if the first part of the allocation didn't overlap what\n\t * was asked for.\n\t */\n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tint\t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t/*\n\t * Return the minimum of what we got and what we asked for for\n\t * the length.  We can use the len variable here because it is\n\t * modified below and we could have been there before coming\n\t * here if the first part of the allocation didn't overlap what\n\t * was asked for.\n\t */\n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "len",
            "got.br_startoff - bno"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_search_extents",
          "args": [
            "ip",
            "bno",
            "whichfork",
            "&eof",
            "&lastx",
            "&got",
            "&prev"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_search_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1459-1493",
          "snippet": "STATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "NULL",
            "ip",
            "whichfork"
          ],
          "line": 4060
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_blk_mapr"
          ],
          "line": 4055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FORCED_SHUTDOWN",
          "args": [
            "mp"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_bmapi_read\"",
            "XFS_ERRLEVEL_LOW",
            "mp"
          ],
          "line": 4048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT)"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_TEST_ERROR",
          "args": [
            "(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)",
            "mp",
            "XFS_ERRTAG_BMAPIFORMAT",
            "XFS_RANDOM_BMAPIFORMAT"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 4045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL)"
          ],
          "line": 4042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_isilocked",
          "args": [
            "ip",
            "XFS_ILOCK_SHARED|XFS_ILOCK_EXCL"
          ],
          "line": 4042
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_isilocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "286-305",
          "snippet": "int\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nint\nxfs_isilocked(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tif (lock_flags & (XFS_ILOCK_EXCL|XFS_ILOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_ILOCK_SHARED))\n\t\t\treturn !!ip->i_lock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_lock.mr_lock);\n\t}\n\n\tif (lock_flags & (XFS_IOLOCK_EXCL|XFS_IOLOCK_SHARED)) {\n\t\tif (!(lock_flags & XFS_IOLOCK_SHARED))\n\t\t\treturn !!ip->i_iolock.mr_writer;\n\t\treturn rwsem_is_locked(&ip->i_iolock.mr_lock);\n\t}\n\n\tASSERT(0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE))"
          ],
          "line": 4040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*nmap >= 1"
          ],
          "line": 4039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmapi_read(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tstruct xfs_bmbt_irec\t*mval,\n\tint\t\t\t*nmap,\n\tint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_ifork\t*ifp;\n\tstruct xfs_bmbt_irec\tgot;\n\tstruct xfs_bmbt_irec\tprev;\n\txfs_fileoff_t\t\tobno;\n\txfs_fileoff_t\t\tend;\n\txfs_extnum_t\t\tlastx;\n\tint\t\t\terror;\n\tint\t\t\teof;\n\tint\t\t\tn = 0;\n\tint\t\t\twhichfork = (flags & XFS_BMAPI_ATTRFORK) ?\n\t\t\t\t\t\tXFS_ATTR_FORK : XFS_DATA_FORK;\n\n\tASSERT(*nmap >= 1);\n\tASSERT(!(flags & ~(XFS_BMAPI_ATTRFORK|XFS_BMAPI_ENTIRE|\n\t\t\t   XFS_BMAPI_IGSTATE)));\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_SHARED|XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_TEST_ERROR(\n\t    (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t     XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE),\n\t     mp, XFS_ERRTAG_BMAPIFORMAT, XFS_RANDOM_BMAPIFORMAT))) {\n\t\tXFS_ERROR_REPORT(\"xfs_bmapi_read\", XFS_ERRLEVEL_LOW, mp);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (XFS_FORCED_SHUTDOWN(mp))\n\t\treturn -EIO;\n\n\tXFS_STATS_INC(xs_blk_mapr);\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(NULL, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\txfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got, &prev);\n\tend = bno + len;\n\tobno = bno;\n\n\twhile (bno < end && n < *nmap) {\n\t\t/* Reading past eof, act as though there's a hole up to end. */\n\t\tif (eof)\n\t\t\tgot.br_startoff = end;\n\t\tif (got.br_startoff > bno) {\n\t\t\t/* Reading in a hole.  */\n\t\t\tmval->br_startoff = bno;\n\t\t\tmval->br_startblock = HOLESTARTBLOCK;\n\t\t\tmval->br_blockcount =\n\t\t\t\tXFS_FILBLKS_MIN(len, got.br_startoff - bno);\n\t\t\tmval->br_state = XFS_EXT_NORM;\n\t\t\tbno += mval->br_blockcount;\n\t\t\tlen -= mval->br_blockcount;\n\t\t\tmval++;\n\t\t\tn++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* set up the extent map to return. */\n\t\txfs_bmapi_trim_map(mval, &got, &bno, len, obno, end, n, flags);\n\t\txfs_bmapi_update_map(&mval, &bno, &len, obno, end, &n, flags);\n\n\t\t/* If we're done, stop now. */\n\t\tif (bno >= end || n >= *nmap)\n\t\t\tbreak;\n\n\t\t/* Else go on to the next record. */\n\t\tif (++lastx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t))\n\t\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx), &got);\n\t\telse\n\t\t\teof = 1;\n\t}\n\t*nmap = n;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmapi_update_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3962-4012",
    "snippet": "STATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tint\t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t/* update previous map with new information */\n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   ((flags & XFS_BMAPI_IGSTATE) ||\n\t\t\tmval[-1].br_state == mval->br_state)) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval->br_state == mval[-1].br_state"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval->br_blockcount > mval[-1].br_blockcount"
          ],
          "line": 3984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval->br_startblock == mval[-1].br_startblock"
          ],
          "line": 3983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno)"
          ],
          "line": 3976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end)"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmapi_update_map(\n\tstruct xfs_bmbt_irec\t**map,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\t*len,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\t*n,\n\tint\t\t\tflags)\n{\n\txfs_bmbt_irec_t\t*mval = *map;\n\n\tASSERT((flags & XFS_BMAPI_ENTIRE) ||\n\t       ((mval->br_startoff + mval->br_blockcount) <= end));\n\tASSERT((flags & XFS_BMAPI_ENTIRE) || (mval->br_blockcount <= *len) ||\n\t       (mval->br_startoff < obno));\n\n\t*bno = mval->br_startoff + mval->br_blockcount;\n\t*len = end - *bno;\n\tif (*n > 0 && mval->br_startoff == mval[-1].br_startoff) {\n\t\t/* update previous map with new information */\n\t\tASSERT(mval->br_startblock == mval[-1].br_startblock);\n\t\tASSERT(mval->br_blockcount > mval[-1].br_blockcount);\n\t\tASSERT(mval->br_state == mval[-1].br_state);\n\t\tmval[-1].br_blockcount = mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (*n > 0 && mval->br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock != HOLESTARTBLOCK &&\n\t\t   mval->br_startblock == mval[-1].br_startblock +\n\t\t\t\t\t  mval[-1].br_blockcount &&\n\t\t   ((flags & XFS_BMAPI_IGSTATE) ||\n\t\t\tmval[-1].br_state == mval->br_state)) {\n\t\tASSERT(mval->br_startoff ==\n\t\t       mval[-1].br_startoff + mval[-1].br_blockcount);\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t} else if (*n > 0 &&\n\t\t   mval->br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval[-1].br_startblock == DELAYSTARTBLOCK &&\n\t\t   mval->br_startoff ==\n\t\t   mval[-1].br_startoff + mval[-1].br_blockcount) {\n\t\tmval[-1].br_blockcount += mval->br_blockcount;\n\t\tmval[-1].br_state = mval->br_state;\n\t} else if (!((*n == 0) &&\n\t\t     ((mval->br_startoff + mval->br_blockcount) <=\n\t\t      obno))) {\n\t\tmval++;\n\t\t(*n)++;\n\t}\n\t*map = mval;\n}"
  },
  {
    "function_name": "xfs_bmapi_trim_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3916-3957",
    "snippet": "STATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tint\t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t/*\n\t * Return the minimum of what we got and what we asked for for\n\t * the length.  We can use the len variable here because it is\n\t * modified below and we could have been there before coming\n\t * here if the first part of the allocation didn't overlap what\n\t * was asked for.\n\t */\n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval->br_blockcount <= len"
          ],
          "line": 3955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "end - *bno",
            "got->br_blockcount - (*bno - got->br_startoff)"
          ],
          "line": 3952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "got->br_startblock"
          ],
          "line": 3940
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*bno < end"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(*bno >= obno) || (n == 0)"
          ],
          "line": 3937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmapi_trim_map(\n\tstruct xfs_bmbt_irec\t*mval,\n\tstruct xfs_bmbt_irec\t*got,\n\txfs_fileoff_t\t\t*bno,\n\txfs_filblks_t\t\tlen,\n\txfs_fileoff_t\t\tobno,\n\txfs_fileoff_t\t\tend,\n\tint\t\t\tn,\n\tint\t\t\tflags)\n{\n\tif ((flags & XFS_BMAPI_ENTIRE) ||\n\t    got->br_startoff + got->br_blockcount <= obno) {\n\t\t*mval = *got;\n\t\tif (isnullstartblock(got->br_startblock))\n\t\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\t\treturn;\n\t}\n\n\tif (obno > *bno)\n\t\t*bno = obno;\n\tASSERT((*bno >= obno) || (n == 0));\n\tASSERT(*bno < end);\n\tmval->br_startoff = *bno;\n\tif (isnullstartblock(got->br_startblock))\n\t\tmval->br_startblock = DELAYSTARTBLOCK;\n\telse\n\t\tmval->br_startblock = got->br_startblock +\n\t\t\t\t\t(*bno - got->br_startoff);\n\t/*\n\t * Return the minimum of what we got and what we asked for for\n\t * the length.  We can use the len variable here because it is\n\t * modified below and we could have been there before coming\n\t * here if the first part of the allocation didn't overlap what\n\t * was asked for.\n\t */\n\tmval->br_blockcount = XFS_FILBLKS_MIN(end - *bno,\n\t\t\tgot->br_blockcount - (*bno - got->br_startoff));\n\tmval->br_state = got->br_state;\n\tASSERT(mval->br_blockcount <= len);\n\treturn;\n}"
  },
  {
    "function_name": "xfs_bmap_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3904-3911",
    "snippet": "STATIC int\nxfs_bmap_alloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\tif (XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata)\n\t\treturn xfs_bmap_rtalloc(ap);\n\treturn xfs_bmap_btalloc(ap);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_btalloc",
          "args": [
            "ap"
          ],
          "line": 3910
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_btalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3653-3898",
          "snippet": "STATIC int\nxfs_bmap_btalloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\txfs_alloctype_t\tatype = 0;\t/* type for allocation routines */\n\txfs_extlen_t\talign;\t\t/* minimum allocation alignment */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_agnumber_t\tag;\n\txfs_alloc_arg_t\targs;\n\txfs_extlen_t\tblen;\n\txfs_extlen_t\tnextminlen = 0;\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\tisaligned;\n\tint\t\ttryagain;\n\tint\t\terror;\n\tint\t\tstripe_align;\n\n\tASSERT(ap->length);\n\n\tmp = ap->ip->i_mount;\n\n\t/* stripe alignment for allocation is determined by mount parameters */\n\tstripe_align = 0;\n\tif (mp->m_swidth && (mp->m_flags & XFS_MOUNT_SWALLOC))\n\t\tstripe_align = mp->m_swidth;\n\telse if (mp->m_dalign)\n\t\tstripe_align = mp->m_dalign;\n\n\talign = ap->userdata ? xfs_get_extsz_hint(ap->ip) : 0;\n\tif (unlikely(align)) {\n\t\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\t\talign, 0, ap->eof, 0, ap->conv,\n\t\t\t\t\t\t&ap->offset, &ap->length);\n\t\tASSERT(!error);\n\t\tASSERT(ap->length);\n\t}\n\n\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\tif (nullfb) {\n\t\tif (ap->userdata && xfs_inode_is_filestream(ap->ip)) {\n\t\t\tag = xfs_filestream_lookup_ag(ap->ip);\n\t\t\tag = (ag != NULLAGNUMBER) ? ag : 0;\n\t\t\tap->blkno = XFS_AGB_TO_FSB(mp, ag, 0);\n\t\t} else {\n\t\t\tap->blkno = XFS_INO_TO_FSB(mp, ap->ip->i_ino);\n\t\t}\n\t} else\n\t\tap->blkno = *ap->firstblock;\n\n\txfs_bmap_adjacent(ap);\n\n\t/*\n\t * If allowed, use ap->blkno; otherwise must use firstblock since\n\t * it's in the right allocation group.\n\t */\n\tif (nullfb || XFS_FSB_TO_AGNO(mp, ap->blkno) == fb_agno)\n\t\t;\n\telse\n\t\tap->blkno = *ap->firstblock;\n\t/*\n\t * Normal allocation, done through xfs_alloc_vextent.\n\t */\n\ttryagain = isaligned = 0;\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = ap->tp;\n\targs.mp = mp;\n\targs.fsbno = ap->blkno;\n\n\t/* Trim the allocation back to the maximum an AG can fit. */\n\targs.maxlen = MIN(ap->length, XFS_ALLOC_AG_MAX_USABLE(mp));\n\targs.firstblock = *ap->firstblock;\n\tblen = 0;\n\tif (nullfb) {\n\t\t/*\n\t\t * Search for an allocation group with a single extent large\n\t\t * enough for the request.  If one isn't found, then adjust\n\t\t * the minimum allocation size to the largest space found.\n\t\t */\n\t\tif (ap->userdata && xfs_inode_is_filestream(ap->ip))\n\t\t\terror = xfs_bmap_btalloc_filestreams(ap, &args, &blen);\n\t\telse\n\t\t\terror = xfs_bmap_btalloc_nullfb(ap, &args, &blen);\n\t\tif (error)\n\t\t\treturn error;\n\t} else if (ap->flist->xbf_low) {\n\t\tif (xfs_inode_is_filestream(ap->ip))\n\t\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\telse\n\t\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.total = args.minlen = ap->minlen;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.total = ap->total;\n\t\targs.minlen = ap->minlen;\n\t}\n\t/* apply extent size hints if obtained earlier */\n\tif (unlikely(align)) {\n\t\targs.prod = align;\n\t\tif ((args.mod = (xfs_extlen_t)do_mod(ap->offset, args.prod)))\n\t\t\targs.mod = (xfs_extlen_t)(args.prod - args.mod);\n\t} else if (mp->m_sb.sb_blocksize >= PAGE_CACHE_SIZE) {\n\t\targs.prod = 1;\n\t\targs.mod = 0;\n\t} else {\n\t\targs.prod = PAGE_CACHE_SIZE >> mp->m_sb.sb_blocklog;\n\t\tif ((args.mod = (xfs_extlen_t)(do_mod(ap->offset, args.prod))))\n\t\t\targs.mod = (xfs_extlen_t)(args.prod - args.mod);\n\t}\n\t/*\n\t * If we are not low on available data blocks, and the\n\t * underlying logical volume manager is a stripe, and\n\t * the file offset is zero then try to allocate data\n\t * blocks on stripe unit boundary.\n\t * NOTE: ap->aeof is only set if the allocation length\n\t * is >= the stripe unit and the allocation offset is\n\t * at the end of file.\n\t */\n\tif (!ap->flist->xbf_low && ap->aeof) {\n\t\tif (!ap->offset) {\n\t\t\targs.alignment = stripe_align;\n\t\t\tatype = args.type;\n\t\t\tisaligned = 1;\n\t\t\t/*\n\t\t\t * Adjust for alignment\n\t\t\t */\n\t\t\tif (blen > args.alignment && blen <= args.maxlen)\n\t\t\t\targs.minlen = blen - args.alignment;\n\t\t\targs.minalignslop = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * First try an exact bno allocation.\n\t\t\t * If it fails then do a near or start bno\n\t\t\t * allocation with alignment turned on.\n\t\t\t */\n\t\t\tatype = args.type;\n\t\t\ttryagain = 1;\n\t\t\targs.type = XFS_ALLOCTYPE_THIS_BNO;\n\t\t\targs.alignment = 1;\n\t\t\t/*\n\t\t\t * Compute the minlen+alignment for the\n\t\t\t * next case.  Set slop so that the value\n\t\t\t * of minlen+alignment+slop doesn't go up\n\t\t\t * between the calls.\n\t\t\t */\n\t\t\tif (blen > stripe_align && blen <= args.maxlen)\n\t\t\t\tnextminlen = blen - stripe_align;\n\t\t\telse\n\t\t\t\tnextminlen = args.minlen;\n\t\t\tif (nextminlen + stripe_align > args.minlen + 1)\n\t\t\t\targs.minalignslop =\n\t\t\t\t\tnextminlen + stripe_align -\n\t\t\t\t\targs.minlen - 1;\n\t\t\telse\n\t\t\t\targs.minalignslop = 0;\n\t\t}\n\t} else {\n\t\targs.alignment = 1;\n\t\targs.minalignslop = 0;\n\t}\n\targs.minleft = ap->minleft;\n\targs.wasdel = ap->wasdel;\n\targs.isfl = 0;\n\targs.userdata = ap->userdata;\n\tif ((error = xfs_alloc_vextent(&args)))\n\t\treturn error;\n\tif (tryagain && args.fsbno == NULLFSBLOCK) {\n\t\t/*\n\t\t * Exact allocation failed. Now try with alignment\n\t\t * turned on.\n\t\t */\n\t\targs.type = atype;\n\t\targs.fsbno = ap->blkno;\n\t\targs.alignment = stripe_align;\n\t\targs.minlen = nextminlen;\n\t\targs.minalignslop = 0;\n\t\tisaligned = 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\t/*\n\t\t * allocation failed, so turn off alignment and\n\t\t * try again.\n\t\t */\n\t\targs.type = atype;\n\t\targs.fsbno = ap->blkno;\n\t\targs.alignment = 0;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK && nullfb &&\n\t    args.minlen > ap->minlen) {\n\t\targs.minlen = ap->minlen;\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = ap->blkno;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK && nullfb) {\n\t\targs.fsbno = 0;\n\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\targs.total = ap->minlen;\n\t\targs.minleft = 0;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t\tap->flist->xbf_low = 1;\n\t}\n\tif (args.fsbno != NULLFSBLOCK) {\n\t\t/*\n\t\t * check the allocation happened at the same or higher AG than\n\t\t * the first block that was allocated.\n\t\t */\n\t\tASSERT(*ap->firstblock == NULLFSBLOCK ||\n\t\t       XFS_FSB_TO_AGNO(mp, *ap->firstblock) ==\n\t\t       XFS_FSB_TO_AGNO(mp, args.fsbno) ||\n\t\t       (ap->flist->xbf_low &&\n\t\t\tXFS_FSB_TO_AGNO(mp, *ap->firstblock) <\n\t\t\tXFS_FSB_TO_AGNO(mp, args.fsbno)));\n\n\t\tap->blkno = args.fsbno;\n\t\tif (*ap->firstblock == NULLFSBLOCK)\n\t\t\t*ap->firstblock = args.fsbno;\n\t\tASSERT(nullfb || fb_agno == args.agno ||\n\t\t       (ap->flist->xbf_low && fb_agno < args.agno));\n\t\tap->length = args.len;\n\t\tap->ip->i_d.di_nblocks += args.len;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= args.len;\n\t\t/*\n\t\t * Adjust the disk quota also. This was reserved\n\t\t * earlier.\n\t\t */\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_BCOUNT,\n\t\t\t(long) args.len);\n\t} else {\n\t\tap->blkno = NULLFSBLOCK;\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_btalloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\txfs_alloctype_t\tatype = 0;\t/* type for allocation routines */\n\txfs_extlen_t\talign;\t\t/* minimum allocation alignment */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_agnumber_t\tag;\n\txfs_alloc_arg_t\targs;\n\txfs_extlen_t\tblen;\n\txfs_extlen_t\tnextminlen = 0;\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\tisaligned;\n\tint\t\ttryagain;\n\tint\t\terror;\n\tint\t\tstripe_align;\n\n\tASSERT(ap->length);\n\n\tmp = ap->ip->i_mount;\n\n\t/* stripe alignment for allocation is determined by mount parameters */\n\tstripe_align = 0;\n\tif (mp->m_swidth && (mp->m_flags & XFS_MOUNT_SWALLOC))\n\t\tstripe_align = mp->m_swidth;\n\telse if (mp->m_dalign)\n\t\tstripe_align = mp->m_dalign;\n\n\talign = ap->userdata ? xfs_get_extsz_hint(ap->ip) : 0;\n\tif (unlikely(align)) {\n\t\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\t\talign, 0, ap->eof, 0, ap->conv,\n\t\t\t\t\t\t&ap->offset, &ap->length);\n\t\tASSERT(!error);\n\t\tASSERT(ap->length);\n\t}\n\n\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\tif (nullfb) {\n\t\tif (ap->userdata && xfs_inode_is_filestream(ap->ip)) {\n\t\t\tag = xfs_filestream_lookup_ag(ap->ip);\n\t\t\tag = (ag != NULLAGNUMBER) ? ag : 0;\n\t\t\tap->blkno = XFS_AGB_TO_FSB(mp, ag, 0);\n\t\t} else {\n\t\t\tap->blkno = XFS_INO_TO_FSB(mp, ap->ip->i_ino);\n\t\t}\n\t} else\n\t\tap->blkno = *ap->firstblock;\n\n\txfs_bmap_adjacent(ap);\n\n\t/*\n\t * If allowed, use ap->blkno; otherwise must use firstblock since\n\t * it's in the right allocation group.\n\t */\n\tif (nullfb || XFS_FSB_TO_AGNO(mp, ap->blkno) == fb_agno)\n\t\t;\n\telse\n\t\tap->blkno = *ap->firstblock;\n\t/*\n\t * Normal allocation, done through xfs_alloc_vextent.\n\t */\n\ttryagain = isaligned = 0;\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = ap->tp;\n\targs.mp = mp;\n\targs.fsbno = ap->blkno;\n\n\t/* Trim the allocation back to the maximum an AG can fit. */\n\targs.maxlen = MIN(ap->length, XFS_ALLOC_AG_MAX_USABLE(mp));\n\targs.firstblock = *ap->firstblock;\n\tblen = 0;\n\tif (nullfb) {\n\t\t/*\n\t\t * Search for an allocation group with a single extent large\n\t\t * enough for the request.  If one isn't found, then adjust\n\t\t * the minimum allocation size to the largest space found.\n\t\t */\n\t\tif (ap->userdata && xfs_inode_is_filestream(ap->ip))\n\t\t\terror = xfs_bmap_btalloc_filestreams(ap, &args, &blen);\n\t\telse\n\t\t\terror = xfs_bmap_btalloc_nullfb(ap, &args, &blen);\n\t\tif (error)\n\t\t\treturn error;\n\t} else if (ap->flist->xbf_low) {\n\t\tif (xfs_inode_is_filestream(ap->ip))\n\t\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\telse\n\t\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.total = args.minlen = ap->minlen;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.total = ap->total;\n\t\targs.minlen = ap->minlen;\n\t}\n\t/* apply extent size hints if obtained earlier */\n\tif (unlikely(align)) {\n\t\targs.prod = align;\n\t\tif ((args.mod = (xfs_extlen_t)do_mod(ap->offset, args.prod)))\n\t\t\targs.mod = (xfs_extlen_t)(args.prod - args.mod);\n\t} else if (mp->m_sb.sb_blocksize >= PAGE_CACHE_SIZE) {\n\t\targs.prod = 1;\n\t\targs.mod = 0;\n\t} else {\n\t\targs.prod = PAGE_CACHE_SIZE >> mp->m_sb.sb_blocklog;\n\t\tif ((args.mod = (xfs_extlen_t)(do_mod(ap->offset, args.prod))))\n\t\t\targs.mod = (xfs_extlen_t)(args.prod - args.mod);\n\t}\n\t/*\n\t * If we are not low on available data blocks, and the\n\t * underlying logical volume manager is a stripe, and\n\t * the file offset is zero then try to allocate data\n\t * blocks on stripe unit boundary.\n\t * NOTE: ap->aeof is only set if the allocation length\n\t * is >= the stripe unit and the allocation offset is\n\t * at the end of file.\n\t */\n\tif (!ap->flist->xbf_low && ap->aeof) {\n\t\tif (!ap->offset) {\n\t\t\targs.alignment = stripe_align;\n\t\t\tatype = args.type;\n\t\t\tisaligned = 1;\n\t\t\t/*\n\t\t\t * Adjust for alignment\n\t\t\t */\n\t\t\tif (blen > args.alignment && blen <= args.maxlen)\n\t\t\t\targs.minlen = blen - args.alignment;\n\t\t\targs.minalignslop = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * First try an exact bno allocation.\n\t\t\t * If it fails then do a near or start bno\n\t\t\t * allocation with alignment turned on.\n\t\t\t */\n\t\t\tatype = args.type;\n\t\t\ttryagain = 1;\n\t\t\targs.type = XFS_ALLOCTYPE_THIS_BNO;\n\t\t\targs.alignment = 1;\n\t\t\t/*\n\t\t\t * Compute the minlen+alignment for the\n\t\t\t * next case.  Set slop so that the value\n\t\t\t * of minlen+alignment+slop doesn't go up\n\t\t\t * between the calls.\n\t\t\t */\n\t\t\tif (blen > stripe_align && blen <= args.maxlen)\n\t\t\t\tnextminlen = blen - stripe_align;\n\t\t\telse\n\t\t\t\tnextminlen = args.minlen;\n\t\t\tif (nextminlen + stripe_align > args.minlen + 1)\n\t\t\t\targs.minalignslop =\n\t\t\t\t\tnextminlen + stripe_align -\n\t\t\t\t\targs.minlen - 1;\n\t\t\telse\n\t\t\t\targs.minalignslop = 0;\n\t\t}\n\t} else {\n\t\targs.alignment = 1;\n\t\targs.minalignslop = 0;\n\t}\n\targs.minleft = ap->minleft;\n\targs.wasdel = ap->wasdel;\n\targs.isfl = 0;\n\targs.userdata = ap->userdata;\n\tif ((error = xfs_alloc_vextent(&args)))\n\t\treturn error;\n\tif (tryagain && args.fsbno == NULLFSBLOCK) {\n\t\t/*\n\t\t * Exact allocation failed. Now try with alignment\n\t\t * turned on.\n\t\t */\n\t\targs.type = atype;\n\t\targs.fsbno = ap->blkno;\n\t\targs.alignment = stripe_align;\n\t\targs.minlen = nextminlen;\n\t\targs.minalignslop = 0;\n\t\tisaligned = 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\t/*\n\t\t * allocation failed, so turn off alignment and\n\t\t * try again.\n\t\t */\n\t\targs.type = atype;\n\t\targs.fsbno = ap->blkno;\n\t\targs.alignment = 0;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK && nullfb &&\n\t    args.minlen > ap->minlen) {\n\t\targs.minlen = ap->minlen;\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = ap->blkno;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK && nullfb) {\n\t\targs.fsbno = 0;\n\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\targs.total = ap->minlen;\n\t\targs.minleft = 0;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t\tap->flist->xbf_low = 1;\n\t}\n\tif (args.fsbno != NULLFSBLOCK) {\n\t\t/*\n\t\t * check the allocation happened at the same or higher AG than\n\t\t * the first block that was allocated.\n\t\t */\n\t\tASSERT(*ap->firstblock == NULLFSBLOCK ||\n\t\t       XFS_FSB_TO_AGNO(mp, *ap->firstblock) ==\n\t\t       XFS_FSB_TO_AGNO(mp, args.fsbno) ||\n\t\t       (ap->flist->xbf_low &&\n\t\t\tXFS_FSB_TO_AGNO(mp, *ap->firstblock) <\n\t\t\tXFS_FSB_TO_AGNO(mp, args.fsbno)));\n\n\t\tap->blkno = args.fsbno;\n\t\tif (*ap->firstblock == NULLFSBLOCK)\n\t\t\t*ap->firstblock = args.fsbno;\n\t\tASSERT(nullfb || fb_agno == args.agno ||\n\t\t       (ap->flist->xbf_low && fb_agno < args.agno));\n\t\tap->length = args.len;\n\t\tap->ip->i_d.di_nblocks += args.len;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= args.len;\n\t\t/*\n\t\t * Adjust the disk quota also. This was reserved\n\t\t * earlier.\n\t\t */\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_BCOUNT,\n\t\t\t(long) args.len);\n\t} else {\n\t\tap->blkno = NULLFSBLOCK;\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_rtalloc",
          "args": [
            "ap"
          ],
          "line": 3909
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_rtalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "145-246",
          "snippet": "int\nxfs_bmap_rtalloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_alloctype_t\tatype = 0;\t/* type for allocation routines */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\txfs_extlen_t\tprod = 0;\t/* product factor for allocators */\n\txfs_extlen_t\tralen = 0;\t/* realtime allocation length */\n\txfs_extlen_t\talign;\t\t/* minimum allocation alignment */\n\txfs_rtblock_t\trtb;\n\n\tmp = ap->ip->i_mount;\n\talign = xfs_get_extsz_hint(ap->ip);\n\tprod = align / mp->m_sb.sb_rextsize;\n\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\talign, 1, ap->eof, 0,\n\t\t\t\t\tap->conv, &ap->offset, &ap->length);\n\tif (error)\n\t\treturn error;\n\tASSERT(ap->length);\n\tASSERT(ap->length % mp->m_sb.sb_rextsize == 0);\n\n\t/*\n\t * If the offset & length are not perfectly aligned\n\t * then kill prod, it will just get us in trouble.\n\t */\n\tif (do_mod(ap->offset, align) || ap->length % align)\n\t\tprod = 1;\n\t/*\n\t * Set ralen to be the actual requested length in rtextents.\n\t */\n\tralen = ap->length / mp->m_sb.sb_rextsize;\n\t/*\n\t * If the old value was close enough to MAXEXTLEN that\n\t * we rounded up to it, cut it back so it's valid again.\n\t * Note that if it's a really large request (bigger than\n\t * MAXEXTLEN), we don't hear about that number, and can't\n\t * adjust the starting point to match it.\n\t */\n\tif (ralen * mp->m_sb.sb_rextsize >= MAXEXTLEN)\n\t\tralen = MAXEXTLEN / mp->m_sb.sb_rextsize;\n\n\t/*\n\t * Lock out other modifications to the RT bitmap inode.\n\t */\n\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(ap->tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If it's an allocation to an empty file at offset 0,\n\t * pick an extent that will space things out in the rt area.\n\t */\n\tif (ap->eof && ap->offset == 0) {\n\t\txfs_rtblock_t uninitialized_var(rtx); /* realtime extent no */\n\n\t\terror = xfs_rtpick_extent(mp, ap->tp, ralen, &rtx);\n\t\tif (error)\n\t\t\treturn error;\n\t\tap->blkno = rtx * mp->m_sb.sb_rextsize;\n\t} else {\n\t\tap->blkno = 0;\n\t}\n\n\txfs_bmap_adjacent(ap);\n\n\t/*\n\t * Realtime allocation, done through xfs_rtallocate_extent.\n\t */\n\tatype = ap->blkno == 0 ?  XFS_ALLOCTYPE_ANY_AG : XFS_ALLOCTYPE_NEAR_BNO;\n\tdo_div(ap->blkno, mp->m_sb.sb_rextsize);\n\trtb = ap->blkno;\n\tap->length = ralen;\n\tif ((error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1, ap->length,\n\t\t\t\t&ralen, atype, ap->wasdel, prod, &rtb)))\n\t\treturn error;\n\tif (rtb == NULLFSBLOCK && prod > 1 &&\n\t    (error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1,\n\t\t\t\t\t   ap->length, &ralen, atype,\n\t\t\t\t\t   ap->wasdel, 1, &rtb)))\n\t\treturn error;\n\tap->blkno = rtb;\n\tif (ap->blkno != NULLFSBLOCK) {\n\t\tap->blkno *= mp->m_sb.sb_rextsize;\n\t\tralen *= mp->m_sb.sb_rextsize;\n\t\tap->length = ralen;\n\t\tap->ip->i_d.di_nblocks += ralen;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= ralen;\n\t\t/*\n\t\t * Adjust the disk quota also. This was reserved\n\t\t * earlier.\n\t\t */\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELRTBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_RTBCOUNT, (long) ralen);\n\t} else {\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_rtalloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_alloctype_t\tatype = 0;\t/* type for allocation routines */\n\tint\t\terror;\t\t/* error return value */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\txfs_extlen_t\tprod = 0;\t/* product factor for allocators */\n\txfs_extlen_t\tralen = 0;\t/* realtime allocation length */\n\txfs_extlen_t\talign;\t\t/* minimum allocation alignment */\n\txfs_rtblock_t\trtb;\n\n\tmp = ap->ip->i_mount;\n\talign = xfs_get_extsz_hint(ap->ip);\n\tprod = align / mp->m_sb.sb_rextsize;\n\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\talign, 1, ap->eof, 0,\n\t\t\t\t\tap->conv, &ap->offset, &ap->length);\n\tif (error)\n\t\treturn error;\n\tASSERT(ap->length);\n\tASSERT(ap->length % mp->m_sb.sb_rextsize == 0);\n\n\t/*\n\t * If the offset & length are not perfectly aligned\n\t * then kill prod, it will just get us in trouble.\n\t */\n\tif (do_mod(ap->offset, align) || ap->length % align)\n\t\tprod = 1;\n\t/*\n\t * Set ralen to be the actual requested length in rtextents.\n\t */\n\tralen = ap->length / mp->m_sb.sb_rextsize;\n\t/*\n\t * If the old value was close enough to MAXEXTLEN that\n\t * we rounded up to it, cut it back so it's valid again.\n\t * Note that if it's a really large request (bigger than\n\t * MAXEXTLEN), we don't hear about that number, and can't\n\t * adjust the starting point to match it.\n\t */\n\tif (ralen * mp->m_sb.sb_rextsize >= MAXEXTLEN)\n\t\tralen = MAXEXTLEN / mp->m_sb.sb_rextsize;\n\n\t/*\n\t * Lock out other modifications to the RT bitmap inode.\n\t */\n\txfs_ilock(mp->m_rbmip, XFS_ILOCK_EXCL);\n\txfs_trans_ijoin(ap->tp, mp->m_rbmip, XFS_ILOCK_EXCL);\n\n\t/*\n\t * If it's an allocation to an empty file at offset 0,\n\t * pick an extent that will space things out in the rt area.\n\t */\n\tif (ap->eof && ap->offset == 0) {\n\t\txfs_rtblock_t uninitialized_var(rtx); /* realtime extent no */\n\n\t\terror = xfs_rtpick_extent(mp, ap->tp, ralen, &rtx);\n\t\tif (error)\n\t\t\treturn error;\n\t\tap->blkno = rtx * mp->m_sb.sb_rextsize;\n\t} else {\n\t\tap->blkno = 0;\n\t}\n\n\txfs_bmap_adjacent(ap);\n\n\t/*\n\t * Realtime allocation, done through xfs_rtallocate_extent.\n\t */\n\tatype = ap->blkno == 0 ?  XFS_ALLOCTYPE_ANY_AG : XFS_ALLOCTYPE_NEAR_BNO;\n\tdo_div(ap->blkno, mp->m_sb.sb_rextsize);\n\trtb = ap->blkno;\n\tap->length = ralen;\n\tif ((error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1, ap->length,\n\t\t\t\t&ralen, atype, ap->wasdel, prod, &rtb)))\n\t\treturn error;\n\tif (rtb == NULLFSBLOCK && prod > 1 &&\n\t    (error = xfs_rtallocate_extent(ap->tp, ap->blkno, 1,\n\t\t\t\t\t   ap->length, &ralen, atype,\n\t\t\t\t\t   ap->wasdel, 1, &rtb)))\n\t\treturn error;\n\tap->blkno = rtb;\n\tif (ap->blkno != NULLFSBLOCK) {\n\t\tap->blkno *= mp->m_sb.sb_rextsize;\n\t\tralen *= mp->m_sb.sb_rextsize;\n\t\tap->length = ralen;\n\t\tap->ip->i_d.di_nblocks += ralen;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= ralen;\n\t\t/*\n\t\t * Adjust the disk quota also. This was reserved\n\t\t * earlier.\n\t\t */\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELRTBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_RTBCOUNT, (long) ralen);\n\t} else {\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ap->ip"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_alloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\tif (XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata)\n\t\treturn xfs_bmap_rtalloc(ap);\n\treturn xfs_bmap_btalloc(ap);\n}"
  },
  {
    "function_name": "xfs_bmap_btalloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3653-3898",
    "snippet": "STATIC int\nxfs_bmap_btalloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\txfs_alloctype_t\tatype = 0;\t/* type for allocation routines */\n\txfs_extlen_t\talign;\t\t/* minimum allocation alignment */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_agnumber_t\tag;\n\txfs_alloc_arg_t\targs;\n\txfs_extlen_t\tblen;\n\txfs_extlen_t\tnextminlen = 0;\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\tisaligned;\n\tint\t\ttryagain;\n\tint\t\terror;\n\tint\t\tstripe_align;\n\n\tASSERT(ap->length);\n\n\tmp = ap->ip->i_mount;\n\n\t/* stripe alignment for allocation is determined by mount parameters */\n\tstripe_align = 0;\n\tif (mp->m_swidth && (mp->m_flags & XFS_MOUNT_SWALLOC))\n\t\tstripe_align = mp->m_swidth;\n\telse if (mp->m_dalign)\n\t\tstripe_align = mp->m_dalign;\n\n\talign = ap->userdata ? xfs_get_extsz_hint(ap->ip) : 0;\n\tif (unlikely(align)) {\n\t\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\t\talign, 0, ap->eof, 0, ap->conv,\n\t\t\t\t\t\t&ap->offset, &ap->length);\n\t\tASSERT(!error);\n\t\tASSERT(ap->length);\n\t}\n\n\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\tif (nullfb) {\n\t\tif (ap->userdata && xfs_inode_is_filestream(ap->ip)) {\n\t\t\tag = xfs_filestream_lookup_ag(ap->ip);\n\t\t\tag = (ag != NULLAGNUMBER) ? ag : 0;\n\t\t\tap->blkno = XFS_AGB_TO_FSB(mp, ag, 0);\n\t\t} else {\n\t\t\tap->blkno = XFS_INO_TO_FSB(mp, ap->ip->i_ino);\n\t\t}\n\t} else\n\t\tap->blkno = *ap->firstblock;\n\n\txfs_bmap_adjacent(ap);\n\n\t/*\n\t * If allowed, use ap->blkno; otherwise must use firstblock since\n\t * it's in the right allocation group.\n\t */\n\tif (nullfb || XFS_FSB_TO_AGNO(mp, ap->blkno) == fb_agno)\n\t\t;\n\telse\n\t\tap->blkno = *ap->firstblock;\n\t/*\n\t * Normal allocation, done through xfs_alloc_vextent.\n\t */\n\ttryagain = isaligned = 0;\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = ap->tp;\n\targs.mp = mp;\n\targs.fsbno = ap->blkno;\n\n\t/* Trim the allocation back to the maximum an AG can fit. */\n\targs.maxlen = MIN(ap->length, XFS_ALLOC_AG_MAX_USABLE(mp));\n\targs.firstblock = *ap->firstblock;\n\tblen = 0;\n\tif (nullfb) {\n\t\t/*\n\t\t * Search for an allocation group with a single extent large\n\t\t * enough for the request.  If one isn't found, then adjust\n\t\t * the minimum allocation size to the largest space found.\n\t\t */\n\t\tif (ap->userdata && xfs_inode_is_filestream(ap->ip))\n\t\t\terror = xfs_bmap_btalloc_filestreams(ap, &args, &blen);\n\t\telse\n\t\t\terror = xfs_bmap_btalloc_nullfb(ap, &args, &blen);\n\t\tif (error)\n\t\t\treturn error;\n\t} else if (ap->flist->xbf_low) {\n\t\tif (xfs_inode_is_filestream(ap->ip))\n\t\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\telse\n\t\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.total = args.minlen = ap->minlen;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.total = ap->total;\n\t\targs.minlen = ap->minlen;\n\t}\n\t/* apply extent size hints if obtained earlier */\n\tif (unlikely(align)) {\n\t\targs.prod = align;\n\t\tif ((args.mod = (xfs_extlen_t)do_mod(ap->offset, args.prod)))\n\t\t\targs.mod = (xfs_extlen_t)(args.prod - args.mod);\n\t} else if (mp->m_sb.sb_blocksize >= PAGE_CACHE_SIZE) {\n\t\targs.prod = 1;\n\t\targs.mod = 0;\n\t} else {\n\t\targs.prod = PAGE_CACHE_SIZE >> mp->m_sb.sb_blocklog;\n\t\tif ((args.mod = (xfs_extlen_t)(do_mod(ap->offset, args.prod))))\n\t\t\targs.mod = (xfs_extlen_t)(args.prod - args.mod);\n\t}\n\t/*\n\t * If we are not low on available data blocks, and the\n\t * underlying logical volume manager is a stripe, and\n\t * the file offset is zero then try to allocate data\n\t * blocks on stripe unit boundary.\n\t * NOTE: ap->aeof is only set if the allocation length\n\t * is >= the stripe unit and the allocation offset is\n\t * at the end of file.\n\t */\n\tif (!ap->flist->xbf_low && ap->aeof) {\n\t\tif (!ap->offset) {\n\t\t\targs.alignment = stripe_align;\n\t\t\tatype = args.type;\n\t\t\tisaligned = 1;\n\t\t\t/*\n\t\t\t * Adjust for alignment\n\t\t\t */\n\t\t\tif (blen > args.alignment && blen <= args.maxlen)\n\t\t\t\targs.minlen = blen - args.alignment;\n\t\t\targs.minalignslop = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * First try an exact bno allocation.\n\t\t\t * If it fails then do a near or start bno\n\t\t\t * allocation with alignment turned on.\n\t\t\t */\n\t\t\tatype = args.type;\n\t\t\ttryagain = 1;\n\t\t\targs.type = XFS_ALLOCTYPE_THIS_BNO;\n\t\t\targs.alignment = 1;\n\t\t\t/*\n\t\t\t * Compute the minlen+alignment for the\n\t\t\t * next case.  Set slop so that the value\n\t\t\t * of minlen+alignment+slop doesn't go up\n\t\t\t * between the calls.\n\t\t\t */\n\t\t\tif (blen > stripe_align && blen <= args.maxlen)\n\t\t\t\tnextminlen = blen - stripe_align;\n\t\t\telse\n\t\t\t\tnextminlen = args.minlen;\n\t\t\tif (nextminlen + stripe_align > args.minlen + 1)\n\t\t\t\targs.minalignslop =\n\t\t\t\t\tnextminlen + stripe_align -\n\t\t\t\t\targs.minlen - 1;\n\t\t\telse\n\t\t\t\targs.minalignslop = 0;\n\t\t}\n\t} else {\n\t\targs.alignment = 1;\n\t\targs.minalignslop = 0;\n\t}\n\targs.minleft = ap->minleft;\n\targs.wasdel = ap->wasdel;\n\targs.isfl = 0;\n\targs.userdata = ap->userdata;\n\tif ((error = xfs_alloc_vextent(&args)))\n\t\treturn error;\n\tif (tryagain && args.fsbno == NULLFSBLOCK) {\n\t\t/*\n\t\t * Exact allocation failed. Now try with alignment\n\t\t * turned on.\n\t\t */\n\t\targs.type = atype;\n\t\targs.fsbno = ap->blkno;\n\t\targs.alignment = stripe_align;\n\t\targs.minlen = nextminlen;\n\t\targs.minalignslop = 0;\n\t\tisaligned = 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\t/*\n\t\t * allocation failed, so turn off alignment and\n\t\t * try again.\n\t\t */\n\t\targs.type = atype;\n\t\targs.fsbno = ap->blkno;\n\t\targs.alignment = 0;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK && nullfb &&\n\t    args.minlen > ap->minlen) {\n\t\targs.minlen = ap->minlen;\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = ap->blkno;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK && nullfb) {\n\t\targs.fsbno = 0;\n\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\targs.total = ap->minlen;\n\t\targs.minleft = 0;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t\tap->flist->xbf_low = 1;\n\t}\n\tif (args.fsbno != NULLFSBLOCK) {\n\t\t/*\n\t\t * check the allocation happened at the same or higher AG than\n\t\t * the first block that was allocated.\n\t\t */\n\t\tASSERT(*ap->firstblock == NULLFSBLOCK ||\n\t\t       XFS_FSB_TO_AGNO(mp, *ap->firstblock) ==\n\t\t       XFS_FSB_TO_AGNO(mp, args.fsbno) ||\n\t\t       (ap->flist->xbf_low &&\n\t\t\tXFS_FSB_TO_AGNO(mp, *ap->firstblock) <\n\t\t\tXFS_FSB_TO_AGNO(mp, args.fsbno)));\n\n\t\tap->blkno = args.fsbno;\n\t\tif (*ap->firstblock == NULLFSBLOCK)\n\t\t\t*ap->firstblock = args.fsbno;\n\t\tASSERT(nullfb || fb_agno == args.agno ||\n\t\t       (ap->flist->xbf_low && fb_agno < args.agno));\n\t\tap->length = args.len;\n\t\tap->ip->i_d.di_nblocks += args.len;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= args.len;\n\t\t/*\n\t\t * Adjust the disk quota also. This was reserved\n\t\t * earlier.\n\t\t */\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_BCOUNT,\n\t\t\t(long) args.len);\n\t} else {\n\t\tap->blkno = NULLFSBLOCK;\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "ap->tp",
            "ap->ip",
            "ap->wasdel ? XFS_TRANS_DQ_DELBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_BCOUNT",
            "(long) args.len"
          ],
          "line": 3889
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "ap->tp",
            "ap->ip",
            "XFS_ILOG_CORE"
          ],
          "line": 3882
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nullfb || fb_agno == args.agno ||\n\t\t       (ap->flist->xbf_low && fb_agno < args.agno)"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*ap->firstblock == NULLFSBLOCK ||\n\t\t       XFS_FSB_TO_AGNO(mp, *ap->firstblock) ==\n\t\t       XFS_FSB_TO_AGNO(mp, args.fsbno) ||\n\t\t       (ap->flist->xbf_low &&\n\t\t\tXFS_FSB_TO_AGNO(mp, *ap->firstblock) <\n\t\t\tXFS_FSB_TO_AGNO(mp, args.fsbno))"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args.fsbno"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "*ap->firstblock"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args.fsbno"
          ],
          "line": 3870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "*ap->firstblock"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_vextent",
          "args": [
            "&args"
          ],
          "line": 3859
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_vextent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2371-2580",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "args.prod - args.mod"
          ],
          "line": 3762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "do_mod(ap->offset, args.prod)"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "ap->offset",
            "args.prod"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "args.prod - args.mod"
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "ap->offset",
            "args.prod"
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "align"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_inode_is_filestream",
          "args": [
            "ap->ip"
          ],
          "line": 3741
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inode_is_filestream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.h",
          "lines": "32-38",
          "snippet": "static inline int\nxfs_inode_is_filestream(\n\tstruct xfs_inode\t*ip)\n{\n\treturn (ip->i_mount->m_flags & XFS_MOUNT_FILESTREAMS) ||\n\t\t(ip->i_d.di_flags & XFS_DIFLAG_FILESTREAM);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nxfs_inode_is_filestream(\n\tstruct xfs_inode\t*ip)\n{\n\treturn (ip->i_mount->m_flags & XFS_MOUNT_FILESTREAMS) ||\n\t\t(ip->i_d.di_flags & XFS_DIFLAG_FILESTREAM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_btalloc_nullfb",
          "args": [
            "ap",
            "&args",
            "&blen"
          ],
          "line": 3737
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_btalloc_nullfb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3575-3607",
          "snippet": "STATIC int\nxfs_bmap_btalloc_nullfb(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag, startag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\n\targs->type = XFS_ALLOCTYPE_START_BNO;\n\targs->total = ap->total;\n\n\tstartag = ag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (startag == NULLAGNUMBER)\n\t\tstartag = ag = 0;\n\n\twhile (*blen < args->maxlen) {\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (++ag == mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\t\tif (ag == startag)\n\t\t\tbreak;\n\t}\n\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_btalloc_nullfb(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag, startag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\n\targs->type = XFS_ALLOCTYPE_START_BNO;\n\targs->total = ap->total;\n\n\tstartag = ag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (startag == NULLAGNUMBER)\n\t\tstartag = ag = 0;\n\n\twhile (*blen < args->maxlen) {\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (++ag == mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\t\tif (ag == startag)\n\t\t\tbreak;\n\t}\n\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_btalloc_filestreams",
          "args": [
            "ap",
            "&args",
            "&blen"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_btalloc_filestreams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3609-3651",
          "snippet": "STATIC int\nxfs_bmap_btalloc_filestreams(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\n\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\targs->total = ap->total;\n\n\tag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (ag == NULLAGNUMBER)\n\t\tag = 0;\n\n\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen, &notinit);\n\tif (error)\n\t\treturn error;\n\n\tif (*blen < args->maxlen) {\n\t\terror = xfs_filestream_new_ag(ap, &ag);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\n\t}\n\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\n\t/*\n\t * Set the failure fallback case to look in the selected AG as stream\n\t * may have moved.\n\t */\n\tap->blkno = args->fsbno = XFS_AGB_TO_FSB(mp, ag, 0);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_btalloc_filestreams(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\n\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\targs->total = ap->total;\n\n\tag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (ag == NULLAGNUMBER)\n\t\tag = 0;\n\n\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen, &notinit);\n\tif (error)\n\t\treturn error;\n\n\tif (*blen < args->maxlen) {\n\t\terror = xfs_filestream_new_ag(ap, &ag);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\n\t}\n\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\n\t/*\n\t * Set the failure fallback case to look in the selected AG as stream\n\t * may have moved.\n\t */\n\tap->blkno = args->fsbno = XFS_AGB_TO_FSB(mp, ag, 0);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "ap->length",
            "XFS_ALLOC_AG_MAX_USABLE(mp)"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ALLOC_AG_MAX_USABLE",
          "args": [
            "mp"
          ],
          "line": 3725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "ap->blkno"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_adjacent",
          "args": [
            "ap"
          ],
          "line": 3705
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_adjacent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3366-3512",
          "snippet": "void\nxfs_bmap_adjacent(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_fsblock_t\tadjust;\t\t/* adjustment to block numbers */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\trt;\t\t/* true if inode is realtime */\n\n#define\tISVALID(x,y)\t\\\n\t(rt ? \\\n\t\t(x) < mp->m_sb.sb_rblocks : \\\n\t\tXFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y) && \\\n\t\tXFS_FSB_TO_AGNO(mp, x) < mp->m_sb.sb_agcount && \\\n\t\tXFS_FSB_TO_AGBNO(mp, x) < mp->m_sb.sb_agblocks)\n\n\tmp = ap->ip->i_mount;\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\trt = XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\t/*\n\t * If allocating at eof, and there's a previous real block,\n\t * try to use its last block as our starting point.\n\t */\n\tif (ap->eof && ap->prev.br_startoff != NULLFILEOFF &&\n\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t    ISVALID(ap->prev.br_startblock + ap->prev.br_blockcount,\n\t\t    ap->prev.br_startblock)) {\n\t\tap->blkno = ap->prev.br_startblock + ap->prev.br_blockcount;\n\t\t/*\n\t\t * Adjust for the gap between prevp and us.\n\t\t */\n\t\tadjust = ap->offset -\n\t\t\t(ap->prev.br_startoff + ap->prev.br_blockcount);\n\t\tif (adjust &&\n\t\t    ISVALID(ap->blkno + adjust, ap->prev.br_startblock))\n\t\t\tap->blkno += adjust;\n\t}\n\t/*\n\t * If not at eof, then compare the two neighbor blocks.\n\t * Figure out whether either one gives us a good starting point,\n\t * and pick the better one.\n\t */\n\telse if (!ap->eof) {\n\t\txfs_fsblock_t\tgotbno;\t\t/* right side block number */\n\t\txfs_fsblock_t\tgotdiff=0;\t/* right side difference */\n\t\txfs_fsblock_t\tprevbno;\t/* left side block number */\n\t\txfs_fsblock_t\tprevdiff=0;\t/* left side difference */\n\n\t\t/*\n\t\t * If there's a previous (left) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (ap->prev.br_startoff != NULLFILEOFF &&\n\t\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t\t    (prevbno = ap->prev.br_startblock +\n\t\t\t       ap->prev.br_blockcount) &&\n\t\t    ISVALID(prevbno, ap->prev.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to end of previous block.\n\t\t\t */\n\t\t\tadjust = prevdiff = ap->offset -\n\t\t\t\t(ap->prev.br_startoff +\n\t\t\t\t ap->prev.br_blockcount);\n\t\t\t/*\n\t\t\t * Figure the startblock based on the previous block's\n\t\t\t * end and the gap size.\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the end of the previous block.\n\t\t\t */\n\t\t\tif (prevdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(prevbno + prevdiff,\n\t\t\t\t    ap->prev.br_startblock))\n\t\t\t\tprevbno += adjust;\n\t\t\telse\n\t\t\t\tprevdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, prevbno) != fb_agno)\n\t\t\t\tprevbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No previous block or can't follow it, just default.\n\t\t */\n\t\telse\n\t\t\tprevbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If there's a following (right) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (!isnullstartblock(ap->got.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to start of next block.\n\t\t\t */\n\t\t\tadjust = gotdiff = ap->got.br_startoff - ap->offset;\n\t\t\t/*\n\t\t\t * Figure the startblock based on the next block's\n\t\t\t * start and the gap size.\n\t\t\t */\n\t\t\tgotbno = ap->got.br_startblock;\n\t\t\t/*\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the start of the next block\n\t\t\t * offset by our length.\n\t\t\t */\n\t\t\tif (gotdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(gotbno - gotdiff, gotbno))\n\t\t\t\tgotbno -= adjust;\n\t\t\telse if (ISVALID(gotbno - ap->length, gotbno)) {\n\t\t\t\tgotbno -= ap->length;\n\t\t\t\tgotdiff += adjust - ap->length;\n\t\t\t} else\n\t\t\t\tgotdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, gotbno) != fb_agno)\n\t\t\t\tgotbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No next block, just default.\n\t\t */\n\t\telse\n\t\t\tgotbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If both valid, pick the better one, else the only good\n\t\t * one, else ap->blkno is already set (to 0 or the inode block).\n\t\t */\n\t\tif (prevbno != NULLFSBLOCK && gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevdiff <= gotdiff ? prevbno : gotbno;\n\t\telse if (prevbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevbno;\n\t\telse if (gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = gotbno;\n\t}\n#undef ISVALID\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [
            "#define XFS_ALLOC_GAP_UNITS\t4"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_ALLOC_GAP_UNITS\t4\n\nvoid\nxfs_bmap_adjacent(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_fsblock_t\tadjust;\t\t/* adjustment to block numbers */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\trt;\t\t/* true if inode is realtime */\n\n#define\tISVALID(x,y)\t\\\n\t(rt ? \\\n\t\t(x) < mp->m_sb.sb_rblocks : \\\n\t\tXFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y) && \\\n\t\tXFS_FSB_TO_AGNO(mp, x) < mp->m_sb.sb_agcount && \\\n\t\tXFS_FSB_TO_AGBNO(mp, x) < mp->m_sb.sb_agblocks)\n\n\tmp = ap->ip->i_mount;\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\trt = XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\t/*\n\t * If allocating at eof, and there's a previous real block,\n\t * try to use its last block as our starting point.\n\t */\n\tif (ap->eof && ap->prev.br_startoff != NULLFILEOFF &&\n\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t    ISVALID(ap->prev.br_startblock + ap->prev.br_blockcount,\n\t\t    ap->prev.br_startblock)) {\n\t\tap->blkno = ap->prev.br_startblock + ap->prev.br_blockcount;\n\t\t/*\n\t\t * Adjust for the gap between prevp and us.\n\t\t */\n\t\tadjust = ap->offset -\n\t\t\t(ap->prev.br_startoff + ap->prev.br_blockcount);\n\t\tif (adjust &&\n\t\t    ISVALID(ap->blkno + adjust, ap->prev.br_startblock))\n\t\t\tap->blkno += adjust;\n\t}\n\t/*\n\t * If not at eof, then compare the two neighbor blocks.\n\t * Figure out whether either one gives us a good starting point,\n\t * and pick the better one.\n\t */\n\telse if (!ap->eof) {\n\t\txfs_fsblock_t\tgotbno;\t\t/* right side block number */\n\t\txfs_fsblock_t\tgotdiff=0;\t/* right side difference */\n\t\txfs_fsblock_t\tprevbno;\t/* left side block number */\n\t\txfs_fsblock_t\tprevdiff=0;\t/* left side difference */\n\n\t\t/*\n\t\t * If there's a previous (left) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (ap->prev.br_startoff != NULLFILEOFF &&\n\t\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t\t    (prevbno = ap->prev.br_startblock +\n\t\t\t       ap->prev.br_blockcount) &&\n\t\t    ISVALID(prevbno, ap->prev.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to end of previous block.\n\t\t\t */\n\t\t\tadjust = prevdiff = ap->offset -\n\t\t\t\t(ap->prev.br_startoff +\n\t\t\t\t ap->prev.br_blockcount);\n\t\t\t/*\n\t\t\t * Figure the startblock based on the previous block's\n\t\t\t * end and the gap size.\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the end of the previous block.\n\t\t\t */\n\t\t\tif (prevdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(prevbno + prevdiff,\n\t\t\t\t    ap->prev.br_startblock))\n\t\t\t\tprevbno += adjust;\n\t\t\telse\n\t\t\t\tprevdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, prevbno) != fb_agno)\n\t\t\t\tprevbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No previous block or can't follow it, just default.\n\t\t */\n\t\telse\n\t\t\tprevbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If there's a following (right) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (!isnullstartblock(ap->got.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to start of next block.\n\t\t\t */\n\t\t\tadjust = gotdiff = ap->got.br_startoff - ap->offset;\n\t\t\t/*\n\t\t\t * Figure the startblock based on the next block's\n\t\t\t * start and the gap size.\n\t\t\t */\n\t\t\tgotbno = ap->got.br_startblock;\n\t\t\t/*\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the start of the next block\n\t\t\t * offset by our length.\n\t\t\t */\n\t\t\tif (gotdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(gotbno - gotdiff, gotbno))\n\t\t\t\tgotbno -= adjust;\n\t\t\telse if (ISVALID(gotbno - ap->length, gotbno)) {\n\t\t\t\tgotbno -= ap->length;\n\t\t\t\tgotdiff += adjust - ap->length;\n\t\t\t} else\n\t\t\t\tgotdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, gotbno) != fb_agno)\n\t\t\t\tgotbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No next block, just default.\n\t\t */\n\t\telse\n\t\t\tgotbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If both valid, pick the better one, else the only good\n\t\t * one, else ap->blkno is already set (to 0 or the inode block).\n\t\t */\n\t\tif (prevbno != NULLFSBLOCK && gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevdiff <= gotdiff ? prevbno : gotbno;\n\t\telse if (prevbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevbno;\n\t\telse if (gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = gotbno;\n\t}\n#undef ISVALID\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_FSB",
          "args": [
            "mp",
            "ap->ip->i_ino"
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "mp",
            "ag",
            "0"
          ],
          "line": 3698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_filestream_lookup_ag",
          "args": [
            "ap->ip"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_lookup_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "312-353",
          "snippet": "xfs_agnumber_t\nxfs_filestream_lookup_ag(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_inode\t*pip = NULL;\n\txfs_agnumber_t\t\tstartag, ag = NULLAGNUMBER;\n\tstruct xfs_mru_cache_elem *mru;\n\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\n\tpip = xfs_filestream_get_parent(ip);\n\tif (!pip)\n\t\tgoto out;\n\n\tmru = xfs_mru_cache_lookup(mp->m_filestream, pip->i_ino);\n\tif (mru) {\n\t\tag = container_of(mru, struct xfs_fstrm_item, mru)->ag;\n\t\txfs_mru_cache_done(mp->m_filestream);\n\n\t\ttrace_xfs_filestream_lookup(ip, ag);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Set the starting AG using the rotor for inode32, otherwise\n\t * use the directory inode's AG.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES) {\n\t\txfs_agnumber_t\t rotorstep = xfs_rotorstep;\n\t\tstartag = (mp->m_agfrotor / rotorstep) % mp->m_sb.sb_agcount;\n\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t                 (mp->m_sb.sb_agcount * rotorstep);\n\t} else\n\t\tstartag = XFS_INO_TO_AGNO(mp, pip->i_ino);\n\n\tif (xfs_filestream_pick_ag(pip, startag, &ag, 0, 0))\n\t\tag = NULLAGNUMBER;\nout:\n\tIRELE(pip);\n\treturn ag;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nxfs_agnumber_t\nxfs_filestream_lookup_ag(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tstruct xfs_inode\t*pip = NULL;\n\txfs_agnumber_t\t\tstartag, ag = NULLAGNUMBER;\n\tstruct xfs_mru_cache_elem *mru;\n\n\tASSERT(S_ISREG(ip->i_d.di_mode));\n\n\tpip = xfs_filestream_get_parent(ip);\n\tif (!pip)\n\t\tgoto out;\n\n\tmru = xfs_mru_cache_lookup(mp->m_filestream, pip->i_ino);\n\tif (mru) {\n\t\tag = container_of(mru, struct xfs_fstrm_item, mru)->ag;\n\t\txfs_mru_cache_done(mp->m_filestream);\n\n\t\ttrace_xfs_filestream_lookup(ip, ag);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Set the starting AG using the rotor for inode32, otherwise\n\t * use the directory inode's AG.\n\t */\n\tif (mp->m_flags & XFS_MOUNT_32BITINODES) {\n\t\txfs_agnumber_t\t rotorstep = xfs_rotorstep;\n\t\tstartag = (mp->m_agfrotor / rotorstep) % mp->m_sb.sb_agcount;\n\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t                 (mp->m_sb.sb_agcount * rotorstep);\n\t} else\n\t\tstartag = XFS_INO_TO_AGNO(mp, pip->i_ino);\n\n\tif (xfs_filestream_pick_ag(pip, startag, &ag, 0, 0))\n\t\tag = NULLAGNUMBER;\nout:\n\tIRELE(pip);\n\treturn ag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "*ap->firstblock"
          ],
          "line": 3693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ap->length"
          ],
          "line": 3688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!error"
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_extsize_align",
          "args": [
            "mp",
            "&ap->got",
            "&ap->prev",
            "align",
            "0",
            "ap->eof",
            "0",
            "ap->conv",
            "&ap->offset",
            "&ap->length"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_extsize_align",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3204-3362",
          "snippet": "int\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t/* next extent pointer */\n\txfs_bmbt_irec_t\t*prevp,\t\t/* previous extent pointer */\n\txfs_extlen_t\textsz,\t\t/* align to this extent size */\n\tint\t\trt,\t\t/* is this a realtime inode? */\n\tint\t\teof,\t\t/* is extent at end-of-file? */\n\tint\t\tdelay,\t\t/* creating delalloc extent? */\n\tint\t\tconvert,\t/* overwriting unwritten extent? */\n\txfs_fileoff_t\t*offp,\t\t/* in/out: aligned offset */\n\txfs_extlen_t\t*lenp)\t\t/* in/out: aligned length */\n{\n\txfs_fileoff_t\torig_off;\t/* original offset */\n\txfs_extlen_t\torig_alen;\t/* original length */\n\txfs_fileoff_t\torig_end;\t/* original off+len */\n\txfs_fileoff_t\tnexto;\t\t/* next file offset */\n\txfs_fileoff_t\tprevo;\t\t/* previous file offset */\n\txfs_fileoff_t\talign_off;\t/* temp for offset */\n\txfs_extlen_t\talign_alen;\t/* temp for length */\n\txfs_extlen_t\ttemp;\t\t/* temp for calculations */\n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t/*\n\t * If this request overlaps an existing extent, then don't\n\t * attempt to perform any additional alignment.\n\t */\n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file offset is unaligned vs. the extent size\n\t * we need to align it.  This will be possible unless\n\t * the file was previously written with a kernel that didn't\n\t * perform this alignment, or if a truncate shot us in the\n\t * foot.\n\t */\n\ttemp = do_mod(orig_off, extsz);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\t/*\n\t * Same adjustment for the end of the requested area.\n\t */\n\tif ((temp = (align_alen % extsz))) {\n\t\talign_alen += extsz - temp;\n\t}\n\t/*\n\t * If the previous block overlaps with this proposed allocation\n\t * then move the start forward without adjusting the length.\n\t */\n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t/*\n\t * If the next block overlaps with this proposed allocation\n\t * then move the start back without adjusting the length,\n\t * but not before offset 0.\n\t * This may of course make the start overlap previous block,\n\t * and if we hit the offset 0 limit then the next block\n\t * can still overlap too.\n\t */\n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t/*\n\t * If we're now overlapping the next or previous extent that\n\t * means we can't fit an extsz piece in this hole.  Just move\n\t * the start forward to the first valid spot and set\n\t * the length so we hit the end.\n\t */\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t/*\n\t * If realtime, and the result isn't a multiple of the realtime\n\t * extent size we need to remove blocks until it is.\n\t */\n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t/*\n\t\t * We're not covering the original request, or\n\t\t * we won't be able to once we fix the length.\n\t\t */\n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Try to fix it by moving the start up.\n\t\t */\n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t/*\n\t\t * Try to fix it by moving the end in.\n\t\t */\n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t/*\n\t\t * Set the start to the minimum then trim the length.\n\t\t */\n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t/*\n\t\t * Result doesn't cover the request, fail it.\n\t\t */\n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\tASSERT(orig_end <= align_off + align_alen);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t/* next extent pointer */\n\txfs_bmbt_irec_t\t*prevp,\t\t/* previous extent pointer */\n\txfs_extlen_t\textsz,\t\t/* align to this extent size */\n\tint\t\trt,\t\t/* is this a realtime inode? */\n\tint\t\teof,\t\t/* is extent at end-of-file? */\n\tint\t\tdelay,\t\t/* creating delalloc extent? */\n\tint\t\tconvert,\t/* overwriting unwritten extent? */\n\txfs_fileoff_t\t*offp,\t\t/* in/out: aligned offset */\n\txfs_extlen_t\t*lenp)\t\t/* in/out: aligned length */\n{\n\txfs_fileoff_t\torig_off;\t/* original offset */\n\txfs_extlen_t\torig_alen;\t/* original length */\n\txfs_fileoff_t\torig_end;\t/* original off+len */\n\txfs_fileoff_t\tnexto;\t\t/* next file offset */\n\txfs_fileoff_t\tprevo;\t\t/* previous file offset */\n\txfs_fileoff_t\talign_off;\t/* temp for offset */\n\txfs_extlen_t\talign_alen;\t/* temp for length */\n\txfs_extlen_t\ttemp;\t\t/* temp for calculations */\n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t/*\n\t * If this request overlaps an existing extent, then don't\n\t * attempt to perform any additional alignment.\n\t */\n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file offset is unaligned vs. the extent size\n\t * we need to align it.  This will be possible unless\n\t * the file was previously written with a kernel that didn't\n\t * perform this alignment, or if a truncate shot us in the\n\t * foot.\n\t */\n\ttemp = do_mod(orig_off, extsz);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\t/*\n\t * Same adjustment for the end of the requested area.\n\t */\n\tif ((temp = (align_alen % extsz))) {\n\t\talign_alen += extsz - temp;\n\t}\n\t/*\n\t * If the previous block overlaps with this proposed allocation\n\t * then move the start forward without adjusting the length.\n\t */\n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t/*\n\t * If the next block overlaps with this proposed allocation\n\t * then move the start back without adjusting the length,\n\t * but not before offset 0.\n\t * This may of course make the start overlap previous block,\n\t * and if we hit the offset 0 limit then the next block\n\t * can still overlap too.\n\t */\n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t/*\n\t * If we're now overlapping the next or previous extent that\n\t * means we can't fit an extsz piece in this hole.  Just move\n\t * the start forward to the first valid spot and set\n\t * the length so we hit the end.\n\t */\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t/*\n\t * If realtime, and the result isn't a multiple of the realtime\n\t * extent size we need to remove blocks until it is.\n\t */\n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t/*\n\t\t * We're not covering the original request, or\n\t\t * we won't be able to once we fix the length.\n\t\t */\n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Try to fix it by moving the start up.\n\t\t */\n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t/*\n\t\t * Try to fix it by moving the end in.\n\t\t */\n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t/*\n\t\t * Set the start to the minimum then trim the length.\n\t\t */\n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t/*\n\t\t * Result doesn't cover the request, fail it.\n\t\t */\n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\tASSERT(orig_end <= align_off + align_alen);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "align"
          ],
          "line": 3683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_get_extsz_hint",
          "args": [
            "ap->ip"
          ],
          "line": 3682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_get_extsz_hint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "67-76",
          "snippet": "xfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_extlen_t\nxfs_get_extsz_hint(\n\tstruct xfs_inode\t*ip)\n{\n\tif ((ip->i_d.di_flags & XFS_DIFLAG_EXTSIZE) && ip->i_d.di_extsize)\n\t\treturn ip->i_d.di_extsize;\n\tif (XFS_IS_REALTIME_INODE(ip))\n\t\treturn ip->i_mount->m_sb.sb_rextsize;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ap->length"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_btalloc(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\txfs_alloctype_t\tatype = 0;\t/* type for allocation routines */\n\txfs_extlen_t\talign;\t\t/* minimum allocation alignment */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_agnumber_t\tag;\n\txfs_alloc_arg_t\targs;\n\txfs_extlen_t\tblen;\n\txfs_extlen_t\tnextminlen = 0;\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\tisaligned;\n\tint\t\ttryagain;\n\tint\t\terror;\n\tint\t\tstripe_align;\n\n\tASSERT(ap->length);\n\n\tmp = ap->ip->i_mount;\n\n\t/* stripe alignment for allocation is determined by mount parameters */\n\tstripe_align = 0;\n\tif (mp->m_swidth && (mp->m_flags & XFS_MOUNT_SWALLOC))\n\t\tstripe_align = mp->m_swidth;\n\telse if (mp->m_dalign)\n\t\tstripe_align = mp->m_dalign;\n\n\talign = ap->userdata ? xfs_get_extsz_hint(ap->ip) : 0;\n\tif (unlikely(align)) {\n\t\terror = xfs_bmap_extsize_align(mp, &ap->got, &ap->prev,\n\t\t\t\t\t\talign, 0, ap->eof, 0, ap->conv,\n\t\t\t\t\t\t&ap->offset, &ap->length);\n\t\tASSERT(!error);\n\t\tASSERT(ap->length);\n\t}\n\n\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\tif (nullfb) {\n\t\tif (ap->userdata && xfs_inode_is_filestream(ap->ip)) {\n\t\t\tag = xfs_filestream_lookup_ag(ap->ip);\n\t\t\tag = (ag != NULLAGNUMBER) ? ag : 0;\n\t\t\tap->blkno = XFS_AGB_TO_FSB(mp, ag, 0);\n\t\t} else {\n\t\t\tap->blkno = XFS_INO_TO_FSB(mp, ap->ip->i_ino);\n\t\t}\n\t} else\n\t\tap->blkno = *ap->firstblock;\n\n\txfs_bmap_adjacent(ap);\n\n\t/*\n\t * If allowed, use ap->blkno; otherwise must use firstblock since\n\t * it's in the right allocation group.\n\t */\n\tif (nullfb || XFS_FSB_TO_AGNO(mp, ap->blkno) == fb_agno)\n\t\t;\n\telse\n\t\tap->blkno = *ap->firstblock;\n\t/*\n\t * Normal allocation, done through xfs_alloc_vextent.\n\t */\n\ttryagain = isaligned = 0;\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = ap->tp;\n\targs.mp = mp;\n\targs.fsbno = ap->blkno;\n\n\t/* Trim the allocation back to the maximum an AG can fit. */\n\targs.maxlen = MIN(ap->length, XFS_ALLOC_AG_MAX_USABLE(mp));\n\targs.firstblock = *ap->firstblock;\n\tblen = 0;\n\tif (nullfb) {\n\t\t/*\n\t\t * Search for an allocation group with a single extent large\n\t\t * enough for the request.  If one isn't found, then adjust\n\t\t * the minimum allocation size to the largest space found.\n\t\t */\n\t\tif (ap->userdata && xfs_inode_is_filestream(ap->ip))\n\t\t\terror = xfs_bmap_btalloc_filestreams(ap, &args, &blen);\n\t\telse\n\t\t\terror = xfs_bmap_btalloc_nullfb(ap, &args, &blen);\n\t\tif (error)\n\t\t\treturn error;\n\t} else if (ap->flist->xbf_low) {\n\t\tif (xfs_inode_is_filestream(ap->ip))\n\t\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\telse\n\t\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.total = args.minlen = ap->minlen;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.total = ap->total;\n\t\targs.minlen = ap->minlen;\n\t}\n\t/* apply extent size hints if obtained earlier */\n\tif (unlikely(align)) {\n\t\targs.prod = align;\n\t\tif ((args.mod = (xfs_extlen_t)do_mod(ap->offset, args.prod)))\n\t\t\targs.mod = (xfs_extlen_t)(args.prod - args.mod);\n\t} else if (mp->m_sb.sb_blocksize >= PAGE_CACHE_SIZE) {\n\t\targs.prod = 1;\n\t\targs.mod = 0;\n\t} else {\n\t\targs.prod = PAGE_CACHE_SIZE >> mp->m_sb.sb_blocklog;\n\t\tif ((args.mod = (xfs_extlen_t)(do_mod(ap->offset, args.prod))))\n\t\t\targs.mod = (xfs_extlen_t)(args.prod - args.mod);\n\t}\n\t/*\n\t * If we are not low on available data blocks, and the\n\t * underlying logical volume manager is a stripe, and\n\t * the file offset is zero then try to allocate data\n\t * blocks on stripe unit boundary.\n\t * NOTE: ap->aeof is only set if the allocation length\n\t * is >= the stripe unit and the allocation offset is\n\t * at the end of file.\n\t */\n\tif (!ap->flist->xbf_low && ap->aeof) {\n\t\tif (!ap->offset) {\n\t\t\targs.alignment = stripe_align;\n\t\t\tatype = args.type;\n\t\t\tisaligned = 1;\n\t\t\t/*\n\t\t\t * Adjust for alignment\n\t\t\t */\n\t\t\tif (blen > args.alignment && blen <= args.maxlen)\n\t\t\t\targs.minlen = blen - args.alignment;\n\t\t\targs.minalignslop = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * First try an exact bno allocation.\n\t\t\t * If it fails then do a near or start bno\n\t\t\t * allocation with alignment turned on.\n\t\t\t */\n\t\t\tatype = args.type;\n\t\t\ttryagain = 1;\n\t\t\targs.type = XFS_ALLOCTYPE_THIS_BNO;\n\t\t\targs.alignment = 1;\n\t\t\t/*\n\t\t\t * Compute the minlen+alignment for the\n\t\t\t * next case.  Set slop so that the value\n\t\t\t * of minlen+alignment+slop doesn't go up\n\t\t\t * between the calls.\n\t\t\t */\n\t\t\tif (blen > stripe_align && blen <= args.maxlen)\n\t\t\t\tnextminlen = blen - stripe_align;\n\t\t\telse\n\t\t\t\tnextminlen = args.minlen;\n\t\t\tif (nextminlen + stripe_align > args.minlen + 1)\n\t\t\t\targs.minalignslop =\n\t\t\t\t\tnextminlen + stripe_align -\n\t\t\t\t\targs.minlen - 1;\n\t\t\telse\n\t\t\t\targs.minalignslop = 0;\n\t\t}\n\t} else {\n\t\targs.alignment = 1;\n\t\targs.minalignslop = 0;\n\t}\n\targs.minleft = ap->minleft;\n\targs.wasdel = ap->wasdel;\n\targs.isfl = 0;\n\targs.userdata = ap->userdata;\n\tif ((error = xfs_alloc_vextent(&args)))\n\t\treturn error;\n\tif (tryagain && args.fsbno == NULLFSBLOCK) {\n\t\t/*\n\t\t * Exact allocation failed. Now try with alignment\n\t\t * turned on.\n\t\t */\n\t\targs.type = atype;\n\t\targs.fsbno = ap->blkno;\n\t\targs.alignment = stripe_align;\n\t\targs.minlen = nextminlen;\n\t\targs.minalignslop = 0;\n\t\tisaligned = 1;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (isaligned && args.fsbno == NULLFSBLOCK) {\n\t\t/*\n\t\t * allocation failed, so turn off alignment and\n\t\t * try again.\n\t\t */\n\t\targs.type = atype;\n\t\targs.fsbno = ap->blkno;\n\t\targs.alignment = 0;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK && nullfb &&\n\t    args.minlen > ap->minlen) {\n\t\targs.minlen = ap->minlen;\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = ap->blkno;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t}\n\tif (args.fsbno == NULLFSBLOCK && nullfb) {\n\t\targs.fsbno = 0;\n\t\targs.type = XFS_ALLOCTYPE_FIRST_AG;\n\t\targs.total = ap->minlen;\n\t\targs.minleft = 0;\n\t\tif ((error = xfs_alloc_vextent(&args)))\n\t\t\treturn error;\n\t\tap->flist->xbf_low = 1;\n\t}\n\tif (args.fsbno != NULLFSBLOCK) {\n\t\t/*\n\t\t * check the allocation happened at the same or higher AG than\n\t\t * the first block that was allocated.\n\t\t */\n\t\tASSERT(*ap->firstblock == NULLFSBLOCK ||\n\t\t       XFS_FSB_TO_AGNO(mp, *ap->firstblock) ==\n\t\t       XFS_FSB_TO_AGNO(mp, args.fsbno) ||\n\t\t       (ap->flist->xbf_low &&\n\t\t\tXFS_FSB_TO_AGNO(mp, *ap->firstblock) <\n\t\t\tXFS_FSB_TO_AGNO(mp, args.fsbno)));\n\n\t\tap->blkno = args.fsbno;\n\t\tif (*ap->firstblock == NULLFSBLOCK)\n\t\t\t*ap->firstblock = args.fsbno;\n\t\tASSERT(nullfb || fb_agno == args.agno ||\n\t\t       (ap->flist->xbf_low && fb_agno < args.agno));\n\t\tap->length = args.len;\n\t\tap->ip->i_d.di_nblocks += args.len;\n\t\txfs_trans_log_inode(ap->tp, ap->ip, XFS_ILOG_CORE);\n\t\tif (ap->wasdel)\n\t\t\tap->ip->i_delayed_blks -= args.len;\n\t\t/*\n\t\t * Adjust the disk quota also. This was reserved\n\t\t * earlier.\n\t\t */\n\t\txfs_trans_mod_dquot_byino(ap->tp, ap->ip,\n\t\t\tap->wasdel ? XFS_TRANS_DQ_DELBCOUNT :\n\t\t\t\t\tXFS_TRANS_DQ_BCOUNT,\n\t\t\t(long) args.len);\n\t} else {\n\t\tap->blkno = NULLFSBLOCK;\n\t\tap->length = 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_btalloc_filestreams",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3609-3651",
    "snippet": "STATIC int\nxfs_bmap_btalloc_filestreams(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\n\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\targs->total = ap->total;\n\n\tag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (ag == NULLAGNUMBER)\n\t\tag = 0;\n\n\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen, &notinit);\n\tif (error)\n\t\treturn error;\n\n\tif (*blen < args->maxlen) {\n\t\terror = xfs_filestream_new_ag(ap, &ag);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\n\t}\n\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\n\t/*\n\t * Set the failure fallback case to look in the selected AG as stream\n\t * may have moved.\n\t */\n\tap->blkno = args->fsbno = XFS_AGB_TO_FSB(mp, ag, 0);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_AGB_TO_FSB",
          "args": [
            "mp",
            "ag",
            "0"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_select_minlen",
          "args": [
            "ap",
            "args",
            "blen",
            "notinit"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_select_minlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3547-3573",
          "snippet": "static void\nxfs_bmap_select_minlen(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\tnotinit)\n{\n\tif (notinit || *blen < ap->minlen) {\n\t\t/*\n\t\t * Since we did a BUF_TRYLOCK above, it is possible that\n\t\t * there is space for this request.\n\t\t */\n\t\targs->minlen = ap->minlen;\n\t} else if (*blen < args->maxlen) {\n\t\t/*\n\t\t * If the best seen length is less than the request length,\n\t\t * use the best as the minimum.\n\t\t */\n\t\targs->minlen = *blen;\n\t} else {\n\t\t/*\n\t\t * Otherwise we've seen an extent as big as maxlen, use that\n\t\t * as the minimum.\n\t\t */\n\t\targs->minlen = args->maxlen;\n\t}\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_bmap_select_minlen(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\tnotinit)\n{\n\tif (notinit || *blen < ap->minlen) {\n\t\t/*\n\t\t * Since we did a BUF_TRYLOCK above, it is possible that\n\t\t * there is space for this request.\n\t\t */\n\t\targs->minlen = ap->minlen;\n\t} else if (*blen < args->maxlen) {\n\t\t/*\n\t\t * If the best seen length is less than the request length,\n\t\t * use the best as the minimum.\n\t\t */\n\t\targs->minlen = *blen;\n\t} else {\n\t\t/*\n\t\t * Otherwise we've seen an extent as big as maxlen, use that\n\t\t * as the minimum.\n\t\t */\n\t\targs->minlen = args->maxlen;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_longest_free_extent",
          "args": [
            "args->tp",
            "ag",
            "blen",
            "&notinit"
          ],
          "line": 3636
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_longest_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3514-3545",
          "snippet": "static int\nxfs_bmap_longest_free_extent(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tag,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\t*notinit)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest;\n\tint\t\t\terror = 0;\n\n\tpag = xfs_perag_get(mp, ag);\n\tif (!pag->pagf_init) {\n\t\terror = xfs_alloc_pagf_init(mp, tp, ag, XFS_ALLOC_FLAG_TRYLOCK);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (!pag->pagf_init) {\n\t\t\t*notinit = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\tif (*blen < longest)\n\t\t*blen = longest;\n\nout:\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_bmap_longest_free_extent(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tag,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\t*notinit)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest;\n\tint\t\t\terror = 0;\n\n\tpag = xfs_perag_get(mp, ag);\n\tif (!pag->pagf_init) {\n\t\terror = xfs_alloc_pagf_init(mp, tp, ag, XFS_ALLOC_FLAG_TRYLOCK);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (!pag->pagf_init) {\n\t\t\t*notinit = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\tif (*blen < longest)\n\t\t*blen = longest;\n\nout:\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_filestream_new_ag",
          "args": [
            "ap",
            "&ag"
          ],
          "line": 3632
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_filestream_new_ag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_filestream.c",
          "lines": "361-402",
          "snippet": "int\nxfs_filestream_new_ag(\n\tstruct xfs_bmalloca\t*ap,\n\txfs_agnumber_t\t\t*agp)\n{\n\tstruct xfs_inode\t*ip = ap->ip, *pip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_extlen_t\t\tminlen = ap->length;\n\txfs_agnumber_t\t\tstartag = 0;\n\tint\t\t\tflags, err = 0;\n\tstruct xfs_mru_cache_elem *mru;\n\n\t*agp = NULLAGNUMBER;\n\n\tpip = xfs_filestream_get_parent(ip);\n\tif (!pip)\n\t\tgoto exit;\n\n\tmru = xfs_mru_cache_remove(mp->m_filestream, pip->i_ino);\n\tif (mru) {\n\t\tstruct xfs_fstrm_item *item =\n\t\t\tcontainer_of(mru, struct xfs_fstrm_item, mru);\n\t\tstartag = (item->ag + 1) % mp->m_sb.sb_agcount;\n\t}\n\n\tflags = (ap->userdata ? XFS_PICK_USERDATA : 0) |\n\t        (ap->flist->xbf_low ? XFS_PICK_LOWSPACE : 0);\n\n\terr = xfs_filestream_pick_ag(pip, startag, agp, flags, minlen);\n\n\t/*\n\t * Only free the item here so we skip over the old AG earlier.\n\t */\n\tif (mru)\n\t\txfs_fstrm_free_func(mru);\n\n\tIRELE(pip);\nexit:\n\tif (*agp == NULLAGNUMBER)\n\t\t*agp = 0;\n\treturn err;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nint\nxfs_filestream_new_ag(\n\tstruct xfs_bmalloca\t*ap,\n\txfs_agnumber_t\t\t*agp)\n{\n\tstruct xfs_inode\t*ip = ap->ip, *pip;\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\txfs_extlen_t\t\tminlen = ap->length;\n\txfs_agnumber_t\t\tstartag = 0;\n\tint\t\t\tflags, err = 0;\n\tstruct xfs_mru_cache_elem *mru;\n\n\t*agp = NULLAGNUMBER;\n\n\tpip = xfs_filestream_get_parent(ip);\n\tif (!pip)\n\t\tgoto exit;\n\n\tmru = xfs_mru_cache_remove(mp->m_filestream, pip->i_ino);\n\tif (mru) {\n\t\tstruct xfs_fstrm_item *item =\n\t\t\tcontainer_of(mru, struct xfs_fstrm_item, mru);\n\t\tstartag = (item->ag + 1) % mp->m_sb.sb_agcount;\n\t}\n\n\tflags = (ap->userdata ? XFS_PICK_USERDATA : 0) |\n\t        (ap->flist->xbf_low ? XFS_PICK_LOWSPACE : 0);\n\n\terr = xfs_filestream_pick_ag(pip, startag, agp, flags, minlen);\n\n\t/*\n\t * Only free the item here so we skip over the old AG earlier.\n\t */\n\tif (mru)\n\t\txfs_fstrm_free_func(mru);\n\n\tIRELE(pip);\nexit:\n\tif (*agp == NULLAGNUMBER)\n\t\t*agp = 0;\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 3623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_btalloc_filestreams(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\n\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\targs->total = ap->total;\n\n\tag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (ag == NULLAGNUMBER)\n\t\tag = 0;\n\n\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen, &notinit);\n\tif (error)\n\t\treturn error;\n\n\tif (*blen < args->maxlen) {\n\t\terror = xfs_filestream_new_ag(ap, &ag);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\n\t}\n\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\n\t/*\n\t * Set the failure fallback case to look in the selected AG as stream\n\t * may have moved.\n\t */\n\tap->blkno = args->fsbno = XFS_AGB_TO_FSB(mp, ag, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_btalloc_nullfb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3575-3607",
    "snippet": "STATIC int\nxfs_bmap_btalloc_nullfb(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag, startag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\n\targs->type = XFS_ALLOCTYPE_START_BNO;\n\targs->total = ap->total;\n\n\tstartag = ag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (startag == NULLAGNUMBER)\n\t\tstartag = ag = 0;\n\n\twhile (*blen < args->maxlen) {\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (++ag == mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\t\tif (ag == startag)\n\t\t\tbreak;\n\t}\n\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_select_minlen",
          "args": [
            "ap",
            "args",
            "blen",
            "notinit"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_select_minlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3547-3573",
          "snippet": "static void\nxfs_bmap_select_minlen(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\tnotinit)\n{\n\tif (notinit || *blen < ap->minlen) {\n\t\t/*\n\t\t * Since we did a BUF_TRYLOCK above, it is possible that\n\t\t * there is space for this request.\n\t\t */\n\t\targs->minlen = ap->minlen;\n\t} else if (*blen < args->maxlen) {\n\t\t/*\n\t\t * If the best seen length is less than the request length,\n\t\t * use the best as the minimum.\n\t\t */\n\t\targs->minlen = *blen;\n\t} else {\n\t\t/*\n\t\t * Otherwise we've seen an extent as big as maxlen, use that\n\t\t * as the minimum.\n\t\t */\n\t\targs->minlen = args->maxlen;\n\t}\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_bmap_select_minlen(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\tnotinit)\n{\n\tif (notinit || *blen < ap->minlen) {\n\t\t/*\n\t\t * Since we did a BUF_TRYLOCK above, it is possible that\n\t\t * there is space for this request.\n\t\t */\n\t\targs->minlen = ap->minlen;\n\t} else if (*blen < args->maxlen) {\n\t\t/*\n\t\t * If the best seen length is less than the request length,\n\t\t * use the best as the minimum.\n\t\t */\n\t\targs->minlen = *blen;\n\t} else {\n\t\t/*\n\t\t * Otherwise we've seen an extent as big as maxlen, use that\n\t\t * as the minimum.\n\t\t */\n\t\targs->minlen = args->maxlen;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_longest_free_extent",
          "args": [
            "args->tp",
            "ag",
            "blen",
            "&notinit"
          ],
          "line": 3594
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_longest_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "3514-3545",
          "snippet": "static int\nxfs_bmap_longest_free_extent(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tag,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\t*notinit)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest;\n\tint\t\t\terror = 0;\n\n\tpag = xfs_perag_get(mp, ag);\n\tif (!pag->pagf_init) {\n\t\terror = xfs_alloc_pagf_init(mp, tp, ag, XFS_ALLOC_FLAG_TRYLOCK);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (!pag->pagf_init) {\n\t\t\t*notinit = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\tif (*blen < longest)\n\t\t*blen = longest;\n\nout:\n\txfs_perag_put(pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_bmap_longest_free_extent(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tag,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\t*notinit)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest;\n\tint\t\t\terror = 0;\n\n\tpag = xfs_perag_get(mp, ag);\n\tif (!pag->pagf_init) {\n\t\terror = xfs_alloc_pagf_init(mp, tp, ag, XFS_ALLOC_FLAG_TRYLOCK);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (!pag->pagf_init) {\n\t\t\t*notinit = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\tif (*blen < longest)\n\t\t*blen = longest;\n\nout:\n\txfs_perag_put(pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "args->fsbno"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_btalloc_nullfb(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen)\n{\n\tstruct xfs_mount\t*mp = ap->ip->i_mount;\n\txfs_agnumber_t\t\tag, startag;\n\tint\t\t\tnotinit = 0;\n\tint\t\t\terror;\n\n\targs->type = XFS_ALLOCTYPE_START_BNO;\n\targs->total = ap->total;\n\n\tstartag = ag = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\tif (startag == NULLAGNUMBER)\n\t\tstartag = ag = 0;\n\n\twhile (*blen < args->maxlen) {\n\t\terror = xfs_bmap_longest_free_extent(args->tp, ag, blen,\n\t\t\t\t\t\t     &notinit);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (++ag == mp->m_sb.sb_agcount)\n\t\t\tag = 0;\n\t\tif (ag == startag)\n\t\t\tbreak;\n\t}\n\n\txfs_bmap_select_minlen(ap, args, blen, notinit);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_select_minlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3547-3573",
    "snippet": "static void\nxfs_bmap_select_minlen(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\tnotinit)\n{\n\tif (notinit || *blen < ap->minlen) {\n\t\t/*\n\t\t * Since we did a BUF_TRYLOCK above, it is possible that\n\t\t * there is space for this request.\n\t\t */\n\t\targs->minlen = ap->minlen;\n\t} else if (*blen < args->maxlen) {\n\t\t/*\n\t\t * If the best seen length is less than the request length,\n\t\t * use the best as the minimum.\n\t\t */\n\t\targs->minlen = *blen;\n\t} else {\n\t\t/*\n\t\t * Otherwise we've seen an extent as big as maxlen, use that\n\t\t * as the minimum.\n\t\t */\n\t\targs->minlen = args->maxlen;\n\t}\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_bmap_select_minlen(\n\tstruct xfs_bmalloca\t*ap,\n\tstruct xfs_alloc_arg\t*args,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\tnotinit)\n{\n\tif (notinit || *blen < ap->minlen) {\n\t\t/*\n\t\t * Since we did a BUF_TRYLOCK above, it is possible that\n\t\t * there is space for this request.\n\t\t */\n\t\targs->minlen = ap->minlen;\n\t} else if (*blen < args->maxlen) {\n\t\t/*\n\t\t * If the best seen length is less than the request length,\n\t\t * use the best as the minimum.\n\t\t */\n\t\targs->minlen = *blen;\n\t} else {\n\t\t/*\n\t\t * Otherwise we've seen an extent as big as maxlen, use that\n\t\t * as the minimum.\n\t\t */\n\t\targs->minlen = args->maxlen;\n\t}\n}"
  },
  {
    "function_name": "xfs_bmap_longest_free_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3514-3545",
    "snippet": "static int\nxfs_bmap_longest_free_extent(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tag,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\t*notinit)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest;\n\tint\t\t\terror = 0;\n\n\tpag = xfs_perag_get(mp, ag);\n\tif (!pag->pagf_init) {\n\t\terror = xfs_alloc_pagf_init(mp, tp, ag, XFS_ALLOC_FLAG_TRYLOCK);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (!pag->pagf_init) {\n\t\t\t*notinit = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\tif (*blen < longest)\n\t\t*blen = longest;\n\nout:\n\txfs_perag_put(pag);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_longest_free_extent",
          "args": [
            "mp",
            "pag"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_longest_free_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "1819-1833",
          "snippet": "xfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\txfs_extlen_t\t\tneed, delta = 0;\n\n\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\tif (pag->pagf_longest > delta)\n\t\treturn pag->pagf_longest - delta;\n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nxfs_extlen_t\nxfs_alloc_longest_free_extent(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_perag\t*pag)\n{\n\txfs_extlen_t\t\tneed, delta = 0;\n\n\tneed = XFS_MIN_FREELIST_PAG(pag, mp);\n\tif (need > pag->pagf_flcount)\n\t\tdelta = need - pag->pagf_flcount;\n\n\tif (pag->pagf_longest > delta)\n\t\treturn pag->pagf_longest - delta;\n\treturn pag->pagf_flcount > 0 || pag->pagf_longest > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_pagf_init",
          "args": [
            "mp",
            "tp",
            "ag",
            "XFS_ALLOC_FLAG_TRYLOCK"
          ],
          "line": 3528
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_pagf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2115-2130",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "ag"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_bmap_longest_free_extent(\n\tstruct xfs_trans\t*tp,\n\txfs_agnumber_t\t\tag,\n\txfs_extlen_t\t\t*blen,\n\tint\t\t\t*notinit)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_perag\t*pag;\n\txfs_extlen_t\t\tlongest;\n\tint\t\t\terror = 0;\n\n\tpag = xfs_perag_get(mp, ag);\n\tif (!pag->pagf_init) {\n\t\terror = xfs_alloc_pagf_init(mp, tp, ag, XFS_ALLOC_FLAG_TRYLOCK);\n\t\tif (error)\n\t\t\tgoto out;\n\n\t\tif (!pag->pagf_init) {\n\t\t\t*notinit = 1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlongest = xfs_alloc_longest_free_extent(mp, pag);\n\tif (*blen < longest)\n\t\t*blen = longest;\n\nout:\n\txfs_perag_put(pag);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmap_adjacent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3366-3512",
    "snippet": "void\nxfs_bmap_adjacent(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_fsblock_t\tadjust;\t\t/* adjustment to block numbers */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\trt;\t\t/* true if inode is realtime */\n\n#define\tISVALID(x,y)\t\\\n\t(rt ? \\\n\t\t(x) < mp->m_sb.sb_rblocks : \\\n\t\tXFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y) && \\\n\t\tXFS_FSB_TO_AGNO(mp, x) < mp->m_sb.sb_agcount && \\\n\t\tXFS_FSB_TO_AGBNO(mp, x) < mp->m_sb.sb_agblocks)\n\n\tmp = ap->ip->i_mount;\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\trt = XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\t/*\n\t * If allocating at eof, and there's a previous real block,\n\t * try to use its last block as our starting point.\n\t */\n\tif (ap->eof && ap->prev.br_startoff != NULLFILEOFF &&\n\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t    ISVALID(ap->prev.br_startblock + ap->prev.br_blockcount,\n\t\t    ap->prev.br_startblock)) {\n\t\tap->blkno = ap->prev.br_startblock + ap->prev.br_blockcount;\n\t\t/*\n\t\t * Adjust for the gap between prevp and us.\n\t\t */\n\t\tadjust = ap->offset -\n\t\t\t(ap->prev.br_startoff + ap->prev.br_blockcount);\n\t\tif (adjust &&\n\t\t    ISVALID(ap->blkno + adjust, ap->prev.br_startblock))\n\t\t\tap->blkno += adjust;\n\t}\n\t/*\n\t * If not at eof, then compare the two neighbor blocks.\n\t * Figure out whether either one gives us a good starting point,\n\t * and pick the better one.\n\t */\n\telse if (!ap->eof) {\n\t\txfs_fsblock_t\tgotbno;\t\t/* right side block number */\n\t\txfs_fsblock_t\tgotdiff=0;\t/* right side difference */\n\t\txfs_fsblock_t\tprevbno;\t/* left side block number */\n\t\txfs_fsblock_t\tprevdiff=0;\t/* left side difference */\n\n\t\t/*\n\t\t * If there's a previous (left) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (ap->prev.br_startoff != NULLFILEOFF &&\n\t\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t\t    (prevbno = ap->prev.br_startblock +\n\t\t\t       ap->prev.br_blockcount) &&\n\t\t    ISVALID(prevbno, ap->prev.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to end of previous block.\n\t\t\t */\n\t\t\tadjust = prevdiff = ap->offset -\n\t\t\t\t(ap->prev.br_startoff +\n\t\t\t\t ap->prev.br_blockcount);\n\t\t\t/*\n\t\t\t * Figure the startblock based on the previous block's\n\t\t\t * end and the gap size.\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the end of the previous block.\n\t\t\t */\n\t\t\tif (prevdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(prevbno + prevdiff,\n\t\t\t\t    ap->prev.br_startblock))\n\t\t\t\tprevbno += adjust;\n\t\t\telse\n\t\t\t\tprevdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, prevbno) != fb_agno)\n\t\t\t\tprevbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No previous block or can't follow it, just default.\n\t\t */\n\t\telse\n\t\t\tprevbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If there's a following (right) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (!isnullstartblock(ap->got.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to start of next block.\n\t\t\t */\n\t\t\tadjust = gotdiff = ap->got.br_startoff - ap->offset;\n\t\t\t/*\n\t\t\t * Figure the startblock based on the next block's\n\t\t\t * start and the gap size.\n\t\t\t */\n\t\t\tgotbno = ap->got.br_startblock;\n\t\t\t/*\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the start of the next block\n\t\t\t * offset by our length.\n\t\t\t */\n\t\t\tif (gotdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(gotbno - gotdiff, gotbno))\n\t\t\t\tgotbno -= adjust;\n\t\t\telse if (ISVALID(gotbno - ap->length, gotbno)) {\n\t\t\t\tgotbno -= ap->length;\n\t\t\t\tgotdiff += adjust - ap->length;\n\t\t\t} else\n\t\t\t\tgotdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, gotbno) != fb_agno)\n\t\t\t\tgotbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No next block, just default.\n\t\t */\n\t\telse\n\t\t\tgotbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If both valid, pick the better one, else the only good\n\t\t * one, else ap->blkno is already set (to 0 or the inode block).\n\t\t */\n\t\tif (prevbno != NULLFSBLOCK && gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevdiff <= gotdiff ? prevbno : gotbno;\n\t\telse if (prevbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevbno;\n\t\telse if (gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = gotbno;\n\t}\n#undef ISVALID\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define XFS_ALLOC_GAP_UNITS\t4"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "gotbno"
          ],
          "line": 3492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISVALID",
          "args": [
            "gotbno - ap->length",
            "gotbno"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISVALID",
          "args": [
            "gotbno - gotdiff",
            "gotbno"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "ap->got.br_startblock"
          ],
          "line": 3462
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "prevbno"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISVALID",
          "args": [
            "prevbno + prevdiff",
            "ap->prev.br_startblock"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISVALID",
          "args": [
            "prevbno",
            "ap->prev.br_startblock"
          ],
          "line": 3424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISVALID",
          "args": [
            "ap->blkno + adjust",
            "ap->prev.br_startblock"
          ],
          "line": 3402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISVALID",
          "args": [
            "ap->prev.br_startblock + ap->prev.br_blockcount",
            "ap->prev.br_startblock"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "*ap->firstblock"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ap->ip"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define XFS_ALLOC_GAP_UNITS\t4\n\nvoid\nxfs_bmap_adjacent(\n\tstruct xfs_bmalloca\t*ap)\t/* bmap alloc argument struct */\n{\n\txfs_fsblock_t\tadjust;\t\t/* adjustment to block numbers */\n\txfs_agnumber_t\tfb_agno;\t/* ag number of ap->firstblock */\n\txfs_mount_t\t*mp;\t\t/* mount point structure */\n\tint\t\tnullfb;\t\t/* true if ap->firstblock isn't set */\n\tint\t\trt;\t\t/* true if inode is realtime */\n\n#define\tISVALID(x,y)\t\\\n\t(rt ? \\\n\t\t(x) < mp->m_sb.sb_rblocks : \\\n\t\tXFS_FSB_TO_AGNO(mp, x) == XFS_FSB_TO_AGNO(mp, y) && \\\n\t\tXFS_FSB_TO_AGNO(mp, x) < mp->m_sb.sb_agcount && \\\n\t\tXFS_FSB_TO_AGBNO(mp, x) < mp->m_sb.sb_agblocks)\n\n\tmp = ap->ip->i_mount;\n\tnullfb = *ap->firstblock == NULLFSBLOCK;\n\trt = XFS_IS_REALTIME_INODE(ap->ip) && ap->userdata;\n\tfb_agno = nullfb ? NULLAGNUMBER : XFS_FSB_TO_AGNO(mp, *ap->firstblock);\n\t/*\n\t * If allocating at eof, and there's a previous real block,\n\t * try to use its last block as our starting point.\n\t */\n\tif (ap->eof && ap->prev.br_startoff != NULLFILEOFF &&\n\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t    ISVALID(ap->prev.br_startblock + ap->prev.br_blockcount,\n\t\t    ap->prev.br_startblock)) {\n\t\tap->blkno = ap->prev.br_startblock + ap->prev.br_blockcount;\n\t\t/*\n\t\t * Adjust for the gap between prevp and us.\n\t\t */\n\t\tadjust = ap->offset -\n\t\t\t(ap->prev.br_startoff + ap->prev.br_blockcount);\n\t\tif (adjust &&\n\t\t    ISVALID(ap->blkno + adjust, ap->prev.br_startblock))\n\t\t\tap->blkno += adjust;\n\t}\n\t/*\n\t * If not at eof, then compare the two neighbor blocks.\n\t * Figure out whether either one gives us a good starting point,\n\t * and pick the better one.\n\t */\n\telse if (!ap->eof) {\n\t\txfs_fsblock_t\tgotbno;\t\t/* right side block number */\n\t\txfs_fsblock_t\tgotdiff=0;\t/* right side difference */\n\t\txfs_fsblock_t\tprevbno;\t/* left side block number */\n\t\txfs_fsblock_t\tprevdiff=0;\t/* left side difference */\n\n\t\t/*\n\t\t * If there's a previous (left) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (ap->prev.br_startoff != NULLFILEOFF &&\n\t\t    !isnullstartblock(ap->prev.br_startblock) &&\n\t\t    (prevbno = ap->prev.br_startblock +\n\t\t\t       ap->prev.br_blockcount) &&\n\t\t    ISVALID(prevbno, ap->prev.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to end of previous block.\n\t\t\t */\n\t\t\tadjust = prevdiff = ap->offset -\n\t\t\t\t(ap->prev.br_startoff +\n\t\t\t\t ap->prev.br_blockcount);\n\t\t\t/*\n\t\t\t * Figure the startblock based on the previous block's\n\t\t\t * end and the gap size.\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the end of the previous block.\n\t\t\t */\n\t\t\tif (prevdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(prevbno + prevdiff,\n\t\t\t\t    ap->prev.br_startblock))\n\t\t\t\tprevbno += adjust;\n\t\t\telse\n\t\t\t\tprevdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, prevbno) != fb_agno)\n\t\t\t\tprevbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No previous block or can't follow it, just default.\n\t\t */\n\t\telse\n\t\t\tprevbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If there's a following (right) block, select a requested\n\t\t * start block based on it.\n\t\t */\n\t\tif (!isnullstartblock(ap->got.br_startblock)) {\n\t\t\t/*\n\t\t\t * Calculate gap to start of next block.\n\t\t\t */\n\t\t\tadjust = gotdiff = ap->got.br_startoff - ap->offset;\n\t\t\t/*\n\t\t\t * Figure the startblock based on the next block's\n\t\t\t * start and the gap size.\n\t\t\t */\n\t\t\tgotbno = ap->got.br_startblock;\n\t\t\t/*\n\t\t\t * Heuristic!\n\t\t\t * If the gap is large relative to the piece we're\n\t\t\t * allocating, or using it gives us an invalid block\n\t\t\t * number, then just use the start of the next block\n\t\t\t * offset by our length.\n\t\t\t */\n\t\t\tif (gotdiff <= XFS_ALLOC_GAP_UNITS * ap->length &&\n\t\t\t    ISVALID(gotbno - gotdiff, gotbno))\n\t\t\t\tgotbno -= adjust;\n\t\t\telse if (ISVALID(gotbno - ap->length, gotbno)) {\n\t\t\t\tgotbno -= ap->length;\n\t\t\t\tgotdiff += adjust - ap->length;\n\t\t\t} else\n\t\t\t\tgotdiff += adjust;\n\t\t\t/*\n\t\t\t * If the firstblock forbids it, can't use it,\n\t\t\t * must use default.\n\t\t\t */\n\t\t\tif (!rt && !nullfb &&\n\t\t\t    XFS_FSB_TO_AGNO(mp, gotbno) != fb_agno)\n\t\t\t\tgotbno = NULLFSBLOCK;\n\t\t}\n\t\t/*\n\t\t * No next block, just default.\n\t\t */\n\t\telse\n\t\t\tgotbno = NULLFSBLOCK;\n\t\t/*\n\t\t * If both valid, pick the better one, else the only good\n\t\t * one, else ap->blkno is already set (to 0 or the inode block).\n\t\t */\n\t\tif (prevbno != NULLFSBLOCK && gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevdiff <= gotdiff ? prevbno : gotbno;\n\t\telse if (prevbno != NULLFSBLOCK)\n\t\t\tap->blkno = prevbno;\n\t\telse if (gotbno != NULLFSBLOCK)\n\t\t\tap->blkno = gotbno;\n\t}\n#undef ISVALID\n}"
  },
  {
    "function_name": "xfs_bmap_extsize_align",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "3204-3362",
    "snippet": "int\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t/* next extent pointer */\n\txfs_bmbt_irec_t\t*prevp,\t\t/* previous extent pointer */\n\txfs_extlen_t\textsz,\t\t/* align to this extent size */\n\tint\t\trt,\t\t/* is this a realtime inode? */\n\tint\t\teof,\t\t/* is extent at end-of-file? */\n\tint\t\tdelay,\t\t/* creating delalloc extent? */\n\tint\t\tconvert,\t/* overwriting unwritten extent? */\n\txfs_fileoff_t\t*offp,\t\t/* in/out: aligned offset */\n\txfs_extlen_t\t*lenp)\t\t/* in/out: aligned length */\n{\n\txfs_fileoff_t\torig_off;\t/* original offset */\n\txfs_extlen_t\torig_alen;\t/* original length */\n\txfs_fileoff_t\torig_end;\t/* original off+len */\n\txfs_fileoff_t\tnexto;\t\t/* next file offset */\n\txfs_fileoff_t\tprevo;\t\t/* previous file offset */\n\txfs_fileoff_t\talign_off;\t/* temp for offset */\n\txfs_extlen_t\talign_alen;\t/* temp for length */\n\txfs_extlen_t\ttemp;\t\t/* temp for calculations */\n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t/*\n\t * If this request overlaps an existing extent, then don't\n\t * attempt to perform any additional alignment.\n\t */\n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file offset is unaligned vs. the extent size\n\t * we need to align it.  This will be possible unless\n\t * the file was previously written with a kernel that didn't\n\t * perform this alignment, or if a truncate shot us in the\n\t * foot.\n\t */\n\ttemp = do_mod(orig_off, extsz);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\t/*\n\t * Same adjustment for the end of the requested area.\n\t */\n\tif ((temp = (align_alen % extsz))) {\n\t\talign_alen += extsz - temp;\n\t}\n\t/*\n\t * If the previous block overlaps with this proposed allocation\n\t * then move the start forward without adjusting the length.\n\t */\n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t/*\n\t * If the next block overlaps with this proposed allocation\n\t * then move the start back without adjusting the length,\n\t * but not before offset 0.\n\t * This may of course make the start overlap previous block,\n\t * and if we hit the offset 0 limit then the next block\n\t * can still overlap too.\n\t */\n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t/*\n\t * If we're now overlapping the next or previous extent that\n\t * means we can't fit an extsz piece in this hole.  Just move\n\t * the start forward to the first valid spot and set\n\t * the length so we hit the end.\n\t */\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t/*\n\t * If realtime, and the result isn't a multiple of the realtime\n\t * extent size we need to remove blocks until it is.\n\t */\n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t/*\n\t\t * We're not covering the original request, or\n\t\t * we won't be able to once we fix the length.\n\t\t */\n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Try to fix it by moving the start up.\n\t\t */\n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t/*\n\t\t * Try to fix it by moving the end in.\n\t\t */\n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t/*\n\t\t * Set the start to the minimum then trim the length.\n\t\t */\n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t/*\n\t\t * Result doesn't cover the request, fail it.\n\t\t */\n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\tASSERT(orig_end <= align_off + align_alen);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "align_off >= prevp->br_startoff + prevp->br_blockcount"
          ],
          "line": 3356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "align_off + align_alen <= gotp->br_startoff"
          ],
          "line": 3354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "orig_end <= align_off + align_alen"
          ],
          "line": 3349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "orig_off >= align_off"
          ],
          "line": 3348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nexto > prevo"
          ],
          "line": 3305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_mod",
          "args": [
            "orig_off",
            "extsz"
          ],
          "line": 3250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_extsize_align(\n\txfs_mount_t\t*mp,\n\txfs_bmbt_irec_t\t*gotp,\t\t/* next extent pointer */\n\txfs_bmbt_irec_t\t*prevp,\t\t/* previous extent pointer */\n\txfs_extlen_t\textsz,\t\t/* align to this extent size */\n\tint\t\trt,\t\t/* is this a realtime inode? */\n\tint\t\teof,\t\t/* is extent at end-of-file? */\n\tint\t\tdelay,\t\t/* creating delalloc extent? */\n\tint\t\tconvert,\t/* overwriting unwritten extent? */\n\txfs_fileoff_t\t*offp,\t\t/* in/out: aligned offset */\n\txfs_extlen_t\t*lenp)\t\t/* in/out: aligned length */\n{\n\txfs_fileoff_t\torig_off;\t/* original offset */\n\txfs_extlen_t\torig_alen;\t/* original length */\n\txfs_fileoff_t\torig_end;\t/* original off+len */\n\txfs_fileoff_t\tnexto;\t\t/* next file offset */\n\txfs_fileoff_t\tprevo;\t\t/* previous file offset */\n\txfs_fileoff_t\talign_off;\t/* temp for offset */\n\txfs_extlen_t\talign_alen;\t/* temp for length */\n\txfs_extlen_t\ttemp;\t\t/* temp for calculations */\n\n\tif (convert)\n\t\treturn 0;\n\n\torig_off = align_off = *offp;\n\torig_alen = align_alen = *lenp;\n\torig_end = orig_off + orig_alen;\n\n\t/*\n\t * If this request overlaps an existing extent, then don't\n\t * attempt to perform any additional alignment.\n\t */\n\tif (!delay && !eof &&\n\t    (orig_off >= gotp->br_startoff) &&\n\t    (orig_end <= gotp->br_startoff + gotp->br_blockcount)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the file offset is unaligned vs. the extent size\n\t * we need to align it.  This will be possible unless\n\t * the file was previously written with a kernel that didn't\n\t * perform this alignment, or if a truncate shot us in the\n\t * foot.\n\t */\n\ttemp = do_mod(orig_off, extsz);\n\tif (temp) {\n\t\talign_alen += temp;\n\t\talign_off -= temp;\n\t}\n\t/*\n\t * Same adjustment for the end of the requested area.\n\t */\n\tif ((temp = (align_alen % extsz))) {\n\t\talign_alen += extsz - temp;\n\t}\n\t/*\n\t * If the previous block overlaps with this proposed allocation\n\t * then move the start forward without adjusting the length.\n\t */\n\tif (prevp->br_startoff != NULLFILEOFF) {\n\t\tif (prevp->br_startblock == HOLESTARTBLOCK)\n\t\t\tprevo = prevp->br_startoff;\n\t\telse\n\t\t\tprevo = prevp->br_startoff + prevp->br_blockcount;\n\t} else\n\t\tprevo = 0;\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\t/*\n\t * If the next block overlaps with this proposed allocation\n\t * then move the start back without adjusting the length,\n\t * but not before offset 0.\n\t * This may of course make the start overlap previous block,\n\t * and if we hit the offset 0 limit then the next block\n\t * can still overlap too.\n\t */\n\tif (!eof && gotp->br_startoff != NULLFILEOFF) {\n\t\tif ((delay && gotp->br_startblock == HOLESTARTBLOCK) ||\n\t\t    (!delay && gotp->br_startblock == DELAYSTARTBLOCK))\n\t\t\tnexto = gotp->br_startoff + gotp->br_blockcount;\n\t\telse\n\t\t\tnexto = gotp->br_startoff;\n\t} else\n\t\tnexto = NULLFILEOFF;\n\tif (!eof &&\n\t    align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto)\n\t\talign_off = nexto > align_alen ? nexto - align_alen : 0;\n\t/*\n\t * If we're now overlapping the next or previous extent that\n\t * means we can't fit an extsz piece in this hole.  Just move\n\t * the start forward to the first valid spot and set\n\t * the length so we hit the end.\n\t */\n\tif (align_off != orig_off && align_off < prevo)\n\t\talign_off = prevo;\n\tif (align_off + align_alen != orig_end &&\n\t    align_off + align_alen > nexto &&\n\t    nexto != NULLFILEOFF) {\n\t\tASSERT(nexto > prevo);\n\t\talign_alen = nexto - align_off;\n\t}\n\n\t/*\n\t * If realtime, and the result isn't a multiple of the realtime\n\t * extent size we need to remove blocks until it is.\n\t */\n\tif (rt && (temp = (align_alen % mp->m_sb.sb_rextsize))) {\n\t\t/*\n\t\t * We're not covering the original request, or\n\t\t * we won't be able to once we fix the length.\n\t\t */\n\t\tif (orig_off < align_off ||\n\t\t    orig_end > align_off + align_alen ||\n\t\t    align_alen - temp < orig_alen)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Try to fix it by moving the start up.\n\t\t */\n\t\tif (align_off + temp <= orig_off) {\n\t\t\talign_alen -= temp;\n\t\t\talign_off += temp;\n\t\t}\n\t\t/*\n\t\t * Try to fix it by moving the end in.\n\t\t */\n\t\telse if (align_off + align_alen - temp >= orig_end)\n\t\t\talign_alen -= temp;\n\t\t/*\n\t\t * Set the start to the minimum then trim the length.\n\t\t */\n\t\telse {\n\t\t\talign_alen -= orig_off - align_off;\n\t\t\talign_off = orig_off;\n\t\t\talign_alen -= align_alen % mp->m_sb.sb_rextsize;\n\t\t}\n\t\t/*\n\t\t * Result doesn't cover the request, fail it.\n\t\t */\n\t\tif (orig_off < align_off || orig_end > align_off + align_alen)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tASSERT(orig_off >= align_off);\n\t\tASSERT(orig_end <= align_off + align_alen);\n\t}\n\n#ifdef DEBUG\n\tif (!eof && gotp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off + align_alen <= gotp->br_startoff);\n\tif (prevp->br_startoff != NULLFILEOFF)\n\t\tASSERT(align_off >= prevp->br_startoff + prevp->br_blockcount);\n#endif\n\n\t*lenp = align_alen;\n\t*offp = align_off;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_add_extent_hole_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "2958-3195",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_hole_real(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_bmbt_irec_t\t\tleft;\t/* left neighbor extent entry */\n\txfs_bmbt_irec_t\t\tright;\t/* right neighbor extent entry */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate;\t/* state bits, accessed thru macros */\n\n\tifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\n\tASSERT(bma->idx >= 0);\n\tASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       !(bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n\tstate = 0;\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t */\n\tif (bma->idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1), &left);\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t/*\n\t * Check and set flags if this segment has a current value.\n\t * Not true if we're inserting into the \"hole\" at eof.\n\t */\n\tif (bma->idx < ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &right);\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t/*\n\t * We're inserting a real allocation between \"left\" and \"right\".\n\t * Set the contiguity flags.  Don't let extents get too large.\n\t */\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_startblock + left.br_blockcount == new->br_startblock &&\n\t    left.br_state == new->br_state &&\n\t    left.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == right.br_startblock &&\n\t    new->br_state == right.br_state &&\n\t    new->br_blockcount + right.br_blockcount <= MAXEXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     left.br_blockcount + new->br_blockcount +\n\t     right.br_blockcount <= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t/*\n\t * Select which case we're in here, and implement it.\n\t */\n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with real allocations on the\n\t\t * left and on the right.\n\t\t * Merge all three into a single extent record.\n\t\t */\n\t\t--bma->idx;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tleft.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\n\t\tXFS_IFORK_NEXT_SET(bma->ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(bma->ip, whichfork) - 1);\n\t\tif (bma->cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, right.br_startoff,\n\t\t\t\t\tright.br_startblock, right.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock,\n\t\t\t\t\tleft.br_blockcount +\n\t\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount,\n\t\t\t\t\tleft.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a real allocation\n\t\t * on the left.\n\t\t * Merge the new allocation with the left neighbor.\n\t\t */\n\t\t--bma->idx;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tleft.br_blockcount + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tif (bma->cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock, left.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock,\n\t\t\t\t\tleft.br_blockcount +\n\t\t\t\t\t\tnew->br_blockcount,\n\t\t\t\t\tleft.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a real allocation\n\t\t * on the right.\n\t\t * Merge the new allocation with the right neighbor.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + right.br_blockcount,\n\t\t\tright.br_state);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tif (bma->cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur,\n\t\t\t\t\tright.br_startoff,\n\t\t\t\t\tright.br_startblock,\n\t\t\t\t\tright.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount,\n\t\t\t\t\tright.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * New allocation is not contiguous with another\n\t\t * real allocation.\n\t\t * Insert a new entry.\n\t\t */\n\t\txfs_iext_insert(bma->ip, bma->idx, 1, new, state);\n\t\tXFS_IFORK_NEXT_SET(bma->ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(bma->ip, whichfork) + 1);\n\t\tif (bma->cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur,\n\t\t\t\t\tnew->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = new->br_state;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(bma->ip, whichfork)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\t0, &tmp_logflags, whichfork);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, whichfork);\ndone:\n\tbma->logflags |= rval;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_check_leaf_extents",
          "args": [
            "bma->cur",
            "bma->ip",
            "whichfork"
          ],
          "line": 3191
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_check_leaf_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "355-515",
          "snippet": "STATIC void\nxfs_bmap_check_leaf_extents(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor or null */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_extnum_t\t\ti=0, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\txfs_bmbt_rec_t\t\t*ep;\t/* pointer to current extent */\n\txfs_bmbt_rec_t\t\tlast = {0, 0}; /* last extent in prev block */\n\txfs_bmbt_rec_t\t\t*nextp;\t/* pointer to next extent */\n\tint\t\t\tbp_release = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE) {\n\t\treturn;\n\t}\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\t/* See if buf is in cur first */\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this block for basic sanity (increasing keys and\n\t\t * no duplicate blocks).\n\t\t */\n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\ti = 0;\n\n\t/*\n\t * Loop over all leaf nodes checking that all extents are in the right order.\n\t */\n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t/*\n\t\t * Check all the extents to make sure they are OK.\n\t\t * If we had a previous block, the last entry should\n\t\t * conform with the first entry in this one.\n\t\t */\n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tif (bp_release) {\n\t\tbp_release = 0;\n\t\txfs_trans_brelse(NULL, bp);\n\t}\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %d extents\",\n\t\t__func__, i);\n\tpanic(\"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_check_leaf_extents(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor or null */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_extnum_t\t\ti=0, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\txfs_bmbt_rec_t\t\t*ep;\t/* pointer to current extent */\n\txfs_bmbt_rec_t\t\tlast = {0, 0}; /* last extent in prev block */\n\txfs_bmbt_rec_t\t\t*nextp;\t/* pointer to next extent */\n\tint\t\t\tbp_release = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE) {\n\t\treturn;\n\t}\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\t/* See if buf is in cur first */\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this block for basic sanity (increasing keys and\n\t\t * no duplicate blocks).\n\t\t */\n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\ti = 0;\n\n\t/*\n\t * Loop over all leaf nodes checking that all extents are in the right order.\n\t */\n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t/*\n\t\t * Check all the extents to make sure they are OK.\n\t\t * If we had a previous block, the last entry should\n\t\t * conform with the first entry in this one.\n\t\t */\n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tif (bp_release) {\n\t\tbp_release = 0;\n\t\txfs_trans_brelse(NULL, bp);\n\t}\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %d extents\",\n\t\t__func__, i);\n\tpanic(\"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_extents_to_btree",
          "args": [
            "bma->tp",
            "bma->ip",
            "bma->firstblock",
            "bma->flist",
            "&bma->cur",
            "0",
            "&tmp_logflags",
            "whichfork"
          ],
          "line": 3179
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_extents_to_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "743-885",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->cur == NULL"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_needs_btree",
          "args": [
            "bma->ip",
            "whichfork"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_needs_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "138-143",
          "snippet": "static inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_insert",
          "args": [
            "bma->cur",
            "&i"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3104-3170",
          "snippet": "int\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 0",
            "done"
          ],
          "line": 3164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_lookup_eq",
          "args": [
            "bma->cur",
            "new->br_startoff",
            "new->br_startblock",
            "new->br_blockcount",
            "&i"
          ],
          "line": 3158
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "107-119",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilog_fext",
          "args": [
            "whichfork"
          ],
          "line": 3155
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "341-344",
          "snippet": "static inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */",
            "#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */\n#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */\n\nstatic inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXT_SET",
          "args": [
            "bma->ip",
            "whichfork",
            "XFS_IFORK_NEXTENTS(bma->ip, whichfork) + 1"
          ],
          "line": 3152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "bma->ip",
            "whichfork"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_insert",
          "args": [
            "bma->ip",
            "bma->idx",
            "1",
            "new",
            "state"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "909-926",
          "snippet": "void\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_update",
          "args": [
            "bma->cur",
            "new->br_startoff",
            "new->br_startblock",
            "new->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount",
            "right.br_state"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "160-172",
          "snippet": "STATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_allf",
          "args": [
            "xfs_iext_get_ext(ifp, bma->idx)",
            "new->br_startoff",
            "new->br_startblock",
            "new->br_blockcount + right.br_blockcount",
            "right.br_state"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "199-221",
          "snippet": "void\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "bma->idx"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_blockcount",
          "args": [
            "xfs_iext_get_ext(ifp, bma->idx)",
            "left.br_blockcount + new->br_blockcount"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "279-287",
          "snippet": "void\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 3067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "bma->cur",
            "0",
            "&i"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 3063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "bma->cur",
            "&i"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXT_SET",
          "args": [
            "bma->ip",
            "whichfork",
            "XFS_IFORK_NEXTENTS(bma->ip, whichfork) - 1"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "bma->ip",
            "whichfork"
          ],
          "line": 3049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_remove",
          "args": [
            "bma->ip",
            "bma->idx + 1",
            "1",
            "state"
          ],
          "line": 3046
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1160-1187",
          "snippet": "void\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 3040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "right.br_startblock"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, bma->idx)",
            "&right"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_add_exlist"
          ],
          "line": 2980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!bma->cur ||\n\t       !(bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL)"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!isnullstartblock(new->br_startblock)"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec)"
          ],
          "line": 2975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->idx >= 0"
          ],
          "line": 2974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "bma->ip",
            "whichfork"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_hole_real(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_bmbt_irec_t\t\tleft;\t/* left neighbor extent entry */\n\txfs_bmbt_irec_t\t\tright;\t/* right neighbor extent entry */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate;\t/* state bits, accessed thru macros */\n\n\tifp = XFS_IFORK_PTR(bma->ip, whichfork);\n\n\tASSERT(bma->idx >= 0);\n\tASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       !(bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n\tstate = 0;\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t */\n\tif (bma->idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1), &left);\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t/*\n\t * Check and set flags if this segment has a current value.\n\t * Not true if we're inserting into the \"hole\" at eof.\n\t */\n\tif (bma->idx < ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx), &right);\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t/*\n\t * We're inserting a real allocation between \"left\" and \"right\".\n\t * Set the contiguity flags.  Don't let extents get too large.\n\t */\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_startblock + left.br_blockcount == new->br_startblock &&\n\t    left.br_state == new->br_state &&\n\t    left.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == right.br_startblock &&\n\t    new->br_state == right.br_state &&\n\t    new->br_blockcount + right.br_blockcount <= MAXEXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     left.br_blockcount + new->br_blockcount +\n\t     right.br_blockcount <= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t/*\n\t * Select which case we're in here, and implement it.\n\t */\n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with real allocations on the\n\t\t * left and on the right.\n\t\t * Merge all three into a single extent record.\n\t\t */\n\t\t--bma->idx;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tleft.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\n\t\tXFS_IFORK_NEXT_SET(bma->ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(bma->ip, whichfork) - 1);\n\t\tif (bma->cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, right.br_startoff,\n\t\t\t\t\tright.br_startblock, right.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock,\n\t\t\t\t\tleft.br_blockcount +\n\t\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount,\n\t\t\t\t\tleft.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a real allocation\n\t\t * on the left.\n\t\t * Merge the new allocation with the left neighbor.\n\t\t */\n\t\t--bma->idx;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tleft.br_blockcount + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tif (bma->cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock, left.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, left.br_startoff,\n\t\t\t\t\tleft.br_startblock,\n\t\t\t\t\tleft.br_blockcount +\n\t\t\t\t\t\tnew->br_blockcount,\n\t\t\t\t\tleft.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a real allocation\n\t\t * on the right.\n\t\t * Merge the new allocation with the right neighbor.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + right.br_blockcount,\n\t\t\tright.br_state);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tif (bma->cur == NULL) {\n\t\t\trval = xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur,\n\t\t\t\t\tright.br_startoff,\n\t\t\t\t\tright.br_startblock,\n\t\t\t\t\tright.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\t\tright.br_blockcount,\n\t\t\t\t\tright.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * New allocation is not contiguous with another\n\t\t * real allocation.\n\t\t * Insert a new entry.\n\t\t */\n\t\txfs_iext_insert(bma->ip, bma->idx, 1, new, state);\n\t\tXFS_IFORK_NEXT_SET(bma->ip, whichfork,\n\t\t\tXFS_IFORK_NEXTENTS(bma->ip, whichfork) + 1);\n\t\tif (bma->cur == NULL) {\n\t\t\trval = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\t\t} else {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur,\n\t\t\t\t\tnew->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = new->br_state;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(bma->ip, whichfork)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\t0, &tmp_logflags, whichfork);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, whichfork);\ndone:\n\tbma->logflags |= rval;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmap_add_extent_hole_delay",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "2814-2953",
    "snippet": "STATIC void\nxfs_bmap_add_extent_hole_delay(\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_bmbt_irec_t\t\t*new)\t/* new data to add to file extents */\n{\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_bmbt_irec_t\t\tleft;\t/* left neighbor extent entry */\n\txfs_filblks_t\t\tnewlen=0;\t/* new indirect size */\n\txfs_filblks_t\t\toldlen=0;\t/* old indirect size */\n\txfs_bmbt_irec_t\t\tright;\t/* right neighbor extent entry */\n\tint\t\t\tstate;  /* state bits, accessed thru macros */\n\txfs_filblks_t\t\ttemp=0;\t/* temp for indirect calculations */\n\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tstate = 0;\n\tASSERT(isnullstartblock(new->br_startblock));\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &left);\n\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t/*\n\t * Check and set flags if the current (right) segment exists.\n\t * If it doesn't exist, we're converting the hole at end-of-file.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx), &right);\n\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t/*\n\t * Set contiguity flags on the left and right neighbors.\n\t * Don't let extents get too large, even if the pieces are contiguous.\n\t */\n\tif ((state & BMAP_LEFT_VALID) && (state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && (state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_blockcount + right.br_blockcount <= MAXEXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     (left.br_blockcount + new->br_blockcount +\n\t      right.br_blockcount <= MAXEXTLEN)))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the contiguity flags.\n\t */\n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with delayed allocations\n\t\t * on the left and on the right.\n\t\t * Merge all three into a single extent record.\n\t\t */\n\t\t--*idx;\n\t\ttemp = left.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx), temp);\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnullstartblock((int)newlen));\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a delayed allocation\n\t\t * on the left.\n\t\t * Merge the new allocation with the left neighbor.\n\t\t */\n\t\t--*idx;\n\t\ttemp = left.br_blockcount + new->br_blockcount;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx), temp);\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnullstartblock((int)newlen));\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a delayed allocation\n\t\t * on the right.\n\t\t * Merge the new allocation with the right neighbor.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\ttemp = new->br_blockcount + right.br_blockcount;\n\t\toldlen = startblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff,\n\t\t\tnullstartblock((int)newlen), temp, right.br_state);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * New allocation is not contiguous with another\n\t\t * delayed allocation.\n\t\t * Insert a new entry.\n\t\t */\n\t\toldlen = newlen = 0;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tbreak;\n\t}\n\tif (oldlen != newlen) {\n\t\tASSERT(oldlen > newlen);\n\t\txfs_icsb_modify_counters(ip->i_mount, XFS_SBS_FDBLOCKS,\n\t\t\t(int64_t)(oldlen - newlen), 0);\n\t\t/*\n\t\t * Nothing to do for disk quota accounting here.\n\t\t */\n\t}\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_modify_counters",
          "args": [
            "ip->i_mount",
            "XFS_SBS_FDBLOCKS",
            "(int64_t)(oldlen - newlen)",
            "0"
          ],
          "line": 2947
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_modify_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1846-1977",
          "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "oldlen > newlen"
          ],
          "line": 2946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_insert",
          "args": [
            "ip",
            "*idx",
            "1",
            "new",
            "state"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "909-926",
          "snippet": "void\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_allf",
          "args": [
            "xfs_iext_get_ext(ifp, *idx)",
            "new->br_startoff",
            "nullstartblock((int)newlen)",
            "temp",
            "right.br_state"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "199-221",
          "snippet": "void\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nullstartblock",
          "args": [
            "(int)newlen"
          ],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "nullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1383-1387",
          "snippet": "static inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)",
            "#define STARTBLOCKVALBITS\t17"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n#define STARTBLOCKVALBITS\t17\n\nstatic inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "*idx"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_worst_indlen",
          "args": [
            "ip",
            "temp"
          ],
          "line": 2928
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_worst_indlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "178-203",
          "snippet": "STATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "startblockval",
          "args": [
            "right.br_startblock"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "startblockval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1389-1392",
          "snippet": "static inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_startblock",
          "args": [
            "xfs_iext_get_ext(ifp, *idx)",
            "nullstartblock((int)newlen)"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_startblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "292-302",
          "snippet": "void\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_blockcount",
          "args": [
            "xfs_iext_get_ext(ifp, *idx)",
            "temp"
          ],
          "line": 2909
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "279-287",
          "snippet": "void\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_remove",
          "args": [
            "ip",
            "*idx + 1",
            "1",
            "state"
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1160-1187",
          "snippet": "void\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "right.br_startblock"
          ],
          "line": 2851
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, *idx)",
            "&right"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "isnullstartblock(new->br_startblock)"
          ],
          "line": 2830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_add_extent_hole_delay(\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_bmbt_irec_t\t\t*new)\t/* new data to add to file extents */\n{\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_bmbt_irec_t\t\tleft;\t/* left neighbor extent entry */\n\txfs_filblks_t\t\tnewlen=0;\t/* new indirect size */\n\txfs_filblks_t\t\toldlen=0;\t/* old indirect size */\n\txfs_bmbt_irec_t\t\tright;\t/* right neighbor extent entry */\n\tint\t\t\tstate;  /* state bits, accessed thru macros */\n\txfs_filblks_t\t\ttemp=0;\t/* temp for indirect calculations */\n\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\tstate = 0;\n\tASSERT(isnullstartblock(new->br_startblock));\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &left);\n\n\t\tif (isnullstartblock(left.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\t/*\n\t * Check and set flags if the current (right) segment exists.\n\t * If it doesn't exist, we're converting the hole at end-of-file.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t)) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx), &right);\n\n\t\tif (isnullstartblock(right.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\t/*\n\t * Set contiguity flags on the left and right neighbors.\n\t * Don't let extents get too large, even if the pieces are contiguous.\n\t */\n\tif ((state & BMAP_LEFT_VALID) && (state & BMAP_LEFT_DELAY) &&\n\t    left.br_startoff + left.br_blockcount == new->br_startoff &&\n\t    left.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\tif ((state & BMAP_RIGHT_VALID) && (state & BMAP_RIGHT_DELAY) &&\n\t    new->br_startoff + new->br_blockcount == right.br_startoff &&\n\t    new->br_blockcount + right.br_blockcount <= MAXEXTLEN &&\n\t    (!(state & BMAP_LEFT_CONTIG) ||\n\t     (left.br_blockcount + new->br_blockcount +\n\t      right.br_blockcount <= MAXEXTLEN)))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the contiguity flags.\n\t */\n\tswitch (state & (BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with delayed allocations\n\t\t * on the left and on the right.\n\t\t * Merge all three into a single extent record.\n\t\t */\n\t\t--*idx;\n\t\ttemp = left.br_blockcount + new->br_blockcount +\n\t\t\tright.br_blockcount;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx), temp);\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnullstartblock((int)newlen));\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tbreak;\n\n\tcase BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a delayed allocation\n\t\t * on the left.\n\t\t * Merge the new allocation with the left neighbor.\n\t\t */\n\t\t--*idx;\n\t\ttemp = left.br_blockcount + new->br_blockcount;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx), temp);\n\t\toldlen = startblockval(left.br_startblock) +\n\t\t\tstartblockval(new->br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnullstartblock((int)newlen));\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * New allocation is contiguous with a delayed allocation\n\t\t * on the right.\n\t\t * Merge the new allocation with the right neighbor.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\ttemp = new->br_blockcount + right.br_blockcount;\n\t\toldlen = startblockval(new->br_startblock) +\n\t\t\tstartblockval(right.br_startblock);\n\t\tnewlen = xfs_bmap_worst_indlen(ip, temp);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff,\n\t\t\tnullstartblock((int)newlen), temp, right.br_state);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * New allocation is not contiguous with another\n\t\t * delayed allocation.\n\t\t * Insert a new entry.\n\t\t */\n\t\toldlen = newlen = 0;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tbreak;\n\t}\n\tif (oldlen != newlen) {\n\t\tASSERT(oldlen > newlen);\n\t\txfs_icsb_modify_counters(ip->i_mount, XFS_SBS_FDBLOCKS,\n\t\t\t(int64_t)(oldlen - newlen), 0);\n\t\t/*\n\t\t * Nothing to do for disk quota accounting here.\n\t\t */\n\t}\n}"
  },
  {
    "function_name": "xfs_bmap_add_extent_unwritten_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "2289-2809",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_unwritten_real(\n\tstruct xfs_trans\t*tp,\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_btree_cur_t\t\t**curp,\t/* if *curp is null, not a btree */\n\txfs_bmbt_irec_t\t\t*new,\t/* new data to add to file extents */\n\txfs_fsblock_t\t\t*first,\t/* pointer to firstblock variable */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\tint\t\t\t*logflagsp) /* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_exntst_t\t\tnewext;\t/* new extent state */\n\txfs_exntst_t\t\toldext;\t/* old extent state */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\n\t*logflagsp = 0;\n\n\tcur = *curp;\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\n\tASSERT(*idx >= 0);\n\tASSERT(*idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\terror = 0;\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnewext = new->br_state;\n\toldext = (newext == XFS_EXT_UNWRITTEN) ?\n\t\tXFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\tASSERT(PREV.br_state == oldext);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\t/*\n\t * Set flags determining what part of the previous oldext allocation\n\t * extent is being replaced by a newext allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == newext &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx + 1), &RIGHT);\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    newext == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 2, state);\n\t\tip->i_d.di_nextents -= 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\t\tRIGHT.br_blockcount, LEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount,\n\t\t\t\tLEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx - 1, state, _THIS_IP_);\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t--*idx;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + new->br_blockcount,\n\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\tASSERT(ep && xfs_bmbt_get_state(ep) == oldext);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tcur->bc_rec.b = *new;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock,\n\t\t\t\t\tPREV.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tcur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Setting the middle part of a previous oldext extent to\n\t\t * newext.  Contiguity is impossible here.\n\t\t * One extent becomes three extents.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tnew->br_startoff - PREV.br_startoff);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tr[0] = *new;\n\t\tr[1].br_startoff = new_endoff;\n\t\tr[1].br_blockcount =\n\t\t\tPREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\tr[1].br_startblock = new->br_startblock + new->br_blockcount;\n\t\tr[1].br_state = oldext;\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 2, &r[0], state);\n\n\t\tip->i_d.di_nextents += 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/* new right extent - oldext */\n\t\t\tif ((error = xfs_bmbt_update(cur, r[1].br_startoff,\n\t\t\t\tr[1].br_startblock, r[1].br_blockcount,\n\t\t\t\tr[1].br_state)))\n\t\t\t\tgoto done;\n\t\t\t/* new left extent - oldext */\n\t\t\tcur->bc_rec.b = PREV;\n\t\t\tcur->bc_rec.b.br_blockcount =\n\t\t\t\tnew->br_startoff - PREV.br_startoff;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/*\n\t\t\t * Reset the cursor to the position of the new extent\n\t\t\t * we are about to insert as we can't trust it after\n\t\t\t * the previous insert.\n\t\t\t */\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\t/* new middle extent - newext */\n\t\t\tcur->bc_rec.b.br_state = new->br_state;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, first, flist, &cur,\n\t\t\t\t0, &tmp_logflags, XFS_DATA_FORK);\n\t\t*logflagsp |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\t*curp = cur;\n\t}\n\n\txfs_bmap_check_leaf_extents(*curp, ip, XFS_DATA_FORK);\ndone:\n\t*logflagsp |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define\tPREV\t\tr[2]",
      "#define\tRIGHT\t\tr[1]",
      "#define\tLEFT\t\tr[0]",
      "#define\tPREV\t\tr[2]",
      "#define\tRIGHT\t\tr[1]",
      "#define\tLEFT\t\tr[0]"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_check_leaf_extents",
          "args": [
            "*curp",
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_check_leaf_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "355-515",
          "snippet": "STATIC void\nxfs_bmap_check_leaf_extents(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor or null */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_extnum_t\t\ti=0, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\txfs_bmbt_rec_t\t\t*ep;\t/* pointer to current extent */\n\txfs_bmbt_rec_t\t\tlast = {0, 0}; /* last extent in prev block */\n\txfs_bmbt_rec_t\t\t*nextp;\t/* pointer to next extent */\n\tint\t\t\tbp_release = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE) {\n\t\treturn;\n\t}\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\t/* See if buf is in cur first */\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this block for basic sanity (increasing keys and\n\t\t * no duplicate blocks).\n\t\t */\n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\ti = 0;\n\n\t/*\n\t * Loop over all leaf nodes checking that all extents are in the right order.\n\t */\n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t/*\n\t\t * Check all the extents to make sure they are OK.\n\t\t * If we had a previous block, the last entry should\n\t\t * conform with the first entry in this one.\n\t\t */\n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tif (bp_release) {\n\t\tbp_release = 0;\n\t\txfs_trans_brelse(NULL, bp);\n\t}\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %d extents\",\n\t\t__func__, i);\n\tpanic(\"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_check_leaf_extents(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor or null */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_extnum_t\t\ti=0, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\txfs_bmbt_rec_t\t\t*ep;\t/* pointer to current extent */\n\txfs_bmbt_rec_t\t\tlast = {0, 0}; /* last extent in prev block */\n\txfs_bmbt_rec_t\t\t*nextp;\t/* pointer to next extent */\n\tint\t\t\tbp_release = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE) {\n\t\treturn;\n\t}\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\t/* See if buf is in cur first */\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this block for basic sanity (increasing keys and\n\t\t * no duplicate blocks).\n\t\t */\n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\ti = 0;\n\n\t/*\n\t * Loop over all leaf nodes checking that all extents are in the right order.\n\t */\n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t/*\n\t\t * Check all the extents to make sure they are OK.\n\t\t * If we had a previous block, the last entry should\n\t\t * conform with the first entry in this one.\n\t\t */\n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tif (bp_release) {\n\t\tbp_release = 0;\n\t\txfs_trans_brelse(NULL, bp);\n\t}\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %d extents\",\n\t\t__func__, i);\n\tpanic(\"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_extents_to_btree",
          "args": [
            "tp",
            "ip",
            "first",
            "flist",
            "&cur",
            "0",
            "&tmp_logflags",
            "XFS_DATA_FORK"
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_extents_to_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "743-885",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cur == NULL"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_needs_btree",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_needs_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "138-143",
          "snippet": "static inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_insert",
          "args": [
            "cur",
            "&i"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3104-3170",
          "snippet": "int\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 0",
            "done"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_lookup_eq",
          "args": [
            "cur",
            "new->br_startoff",
            "new->br_startblock",
            "new->br_blockcount",
            "&i"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "107-119",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_update",
          "args": [
            "cur",
            "r[1].br_startoff",
            "r[1].br_startblock",
            "r[1].br_blockcount",
            "r[1].br_state"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "160-172",
          "snippet": "STATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_insert",
          "args": [
            "ip",
            "*idx",
            "2",
            "&r[0]",
            "state"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "909-926",
          "snippet": "void\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_blockcount",
          "args": [
            "ep",
            "new->br_startoff - PREV.br_startoff"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "279-287",
          "snippet": "void\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 0",
            "done"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_increment",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_increment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1431-1533",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_increment(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\tunion xfs_btree_ptr\tptr;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the right at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_RIGHTRA);\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* We're done if we remain in the block after the increment. */\n\tif (++cur->bc_ptrs[level] <= xfs_btree_get_numrecs(block))\n\t\tgoto out1;\n\n\t/* Fail if we just went off the right edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, increment);\n\n\t/*\n\t * March up the tree incrementing pointers.\n\t * Stop when we don't go off the right edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tblock = xfs_btree_get_block(cur, lev, &bp);\n\n#ifdef DEBUG\n\t\terror = xfs_btree_check_block(cur, block, lev, bp);\n\t\tif (error)\n\t\t\tgoto error0;\n#endif\n\n\t\tif (++cur->bc_ptrs[lev] <= xfs_btree_get_numrecs(block))\n\t\t\tbreak;\n\n\t\t/* Read-ahead the right block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_RIGHTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are either seriously\n\t * confused or have the tree root in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = 1;\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_allf",
          "args": [
            "xfs_iext_get_ext(ifp, *idx)",
            "new->br_startoff",
            "new->br_startblock",
            "new->br_blockcount + RIGHT.br_blockcount",
            "newext"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "199-221",
          "snippet": "void\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "*idx"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_startblock",
          "args": [
            "ep",
            "new->br_startblock + new->br_blockcount"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_startblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "292-302",
          "snippet": "void\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_startoff",
          "args": [
            "ep",
            "new_endoff"
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "307-316",
          "snippet": "void\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ep && xfs_bmbt_get_state(ep) == oldext"
          ],
          "line": 2596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_state",
          "args": [
            "ep"
          ],
          "line": 2596
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "163-172",
          "snippet": "xfs_exntst_t\nxfs_bmbt_get_state(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\tint\text_flag;\n\n\text_flag = (int)((r->l0) >> (64 - BMBT_EXNTFLAG_BITLEN));\n\treturn xfs_extent_state(xfs_bmbt_get_blockcount(r),\n\t\t\t\text_flag);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_exntst_t\nxfs_bmbt_get_state(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\tint\text_flag;\n\n\text_flag = (int)((r->l0) >> (64 - BMBT_EXNTFLAG_BITLEN));\n\treturn xfs_extent_state(xfs_bmbt_get_blockcount(r),\n\t\t\t\text_flag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "cur",
            "0",
            "&i"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx - 1",
            "state",
            "_THIS_IP_"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx - 1",
            "state",
            "_THIS_IP_"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_state",
          "args": [
            "ep",
            "newext"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "321-331",
          "snippet": "void\nxfs_bmbt_set_state(\n\txfs_bmbt_rec_host_t *r,\n\txfs_exntst_t\tv)\n{\n\tASSERT(v == XFS_EXT_NORM || v == XFS_EXT_UNWRITTEN);\n\tif (v == XFS_EXT_NORM)\n\t\tr->l0 &= xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN);\n\telse\n\t\tr->l0 |= xfs_mask64hi(BMBT_EXNTFLAG_BITLEN);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_state(\n\txfs_bmbt_rec_host_t *r,\n\txfs_exntst_t\tv)\n{\n\tASSERT(v == XFS_EXT_NORM || v == XFS_EXT_UNWRITTEN);\n\tif (v == XFS_EXT_NORM)\n\t\tr->l0 &= xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN);\n\telse\n\t\tr->l0 |= xfs_mask64hi(BMBT_EXNTFLAG_BITLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "cur",
            "&i"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_remove",
          "args": [
            "ip",
            "*idx + 1",
            "1",
            "state"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1160-1187",
          "snippet": "void\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "ip",
            "*idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "RIGHT.br_startblock"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, *idx + 1)",
            "&RIGHT"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "PREV.br_startoff + PREV.br_blockcount >= new_endoff"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "PREV.br_startoff <= new->br_startoff"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "PREV.br_state == oldext"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_add_exlist"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!isnullstartblock(new->br_startblock)"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec)"
          ],
          "line": 2319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*idx >= 0"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_unwritten_real(\n\tstruct xfs_trans\t*tp,\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_extnum_t\t\t*idx,\t/* extent number to update/insert */\n\txfs_btree_cur_t\t\t**curp,\t/* if *curp is null, not a btree */\n\txfs_bmbt_irec_t\t\t*new,\t/* new data to add to file extents */\n\txfs_fsblock_t\t\t*first,\t/* pointer to firstblock variable */\n\txfs_bmap_free_t\t\t*flist,\t/* list of extents to be freed */\n\tint\t\t\t*logflagsp) /* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t/* btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_exntst_t\t\tnewext;\t/* new extent state */\n\txfs_exntst_t\t\toldext;\t/* old extent state */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\n\t*logflagsp = 0;\n\n\tcur = *curp;\n\tifp = XFS_IFORK_PTR(ip, XFS_DATA_FORK);\n\n\tASSERT(*idx >= 0);\n\tASSERT(*idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\terror = 0;\n\tep = xfs_iext_get_ext(ifp, *idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnewext = new->br_state;\n\toldext = (newext == XFS_EXT_UNWRITTEN) ?\n\t\tXFS_EXT_NORM : XFS_EXT_UNWRITTEN;\n\tASSERT(PREV.br_state == oldext);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\t/*\n\t * Set flags determining what part of the previous oldext allocation\n\t * extent is being replaced by a newext allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (*idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == newext &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (*idx < ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, *idx + 1), &RIGHT);\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    newext == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 2, state);\n\t\tip->i_d.di_nextents -= 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\t\tRIGHT.br_blockcount, LEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\t--*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + PREV.br_blockcount,\n\t\t\t\tLEFT.br_state)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_iext_remove(ip, *idx + 1, 1, state);\n\t\tip->i_d.di_nextents--;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_delete(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting all of a previous oldext extent to newext.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_state(ep, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, *idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx - 1, state, _THIS_IP_);\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t--*idx;\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_decrement(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\terror = xfs_bmbt_update(cur, LEFT.br_startoff,\n\t\t\t\tLEFT.br_startblock,\n\t\t\t\tLEFT.br_blockcount + new->br_blockcount,\n\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Setting the first part of a previous oldext extent to newext.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\tASSERT(ep && xfs_bmbt_get_state(ep) == oldext);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\txfs_bmbt_set_startblock(ep,\n\t\t\tnew->br_startblock + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur,\n\t\t\t\tPREV.br_startoff + new->br_blockcount,\n\t\t\t\tPREV.br_startblock + new->br_blockcount,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tcur->bc_rec.b = *new;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, *idx),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount, newext);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock,\n\t\t\t\t\tPREV.br_blockcount, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_btree_increment(cur, 0, &i)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_update(cur, new->br_startoff,\n\t\t\t\tnew->br_startblock,\n\t\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\t\tnewext)))\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Setting the last part of a previous oldext extent to newext.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount - new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 1, new, state);\n\n\t\tip->i_d.di_nextents++;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\tif ((error = xfs_bmbt_update(cur, PREV.br_startoff,\n\t\t\t\tPREV.br_startblock,\n\t\t\t\tPREV.br_blockcount - new->br_blockcount,\n\t\t\t\toldext)))\n\t\t\t\tgoto done;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tcur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Setting the middle part of a previous oldext extent to\n\t\t * newext.  Contiguity is impossible here.\n\t\t * One extent becomes three extents.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(ip, *idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tnew->br_startoff - PREV.br_startoff);\n\t\ttrace_xfs_bmap_post_update(ip, *idx, state, _THIS_IP_);\n\n\t\tr[0] = *new;\n\t\tr[1].br_startoff = new_endoff;\n\t\tr[1].br_blockcount =\n\t\t\tPREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\tr[1].br_startblock = new->br_startblock + new->br_blockcount;\n\t\tr[1].br_state = oldext;\n\n\t\t++*idx;\n\t\txfs_iext_insert(ip, *idx, 2, &r[0], state);\n\n\t\tip->i_d.di_nextents += 2;\n\t\tif (cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, PREV.br_startoff,\n\t\t\t\t\tPREV.br_startblock, PREV.br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/* new right extent - oldext */\n\t\t\tif ((error = xfs_bmbt_update(cur, r[1].br_startoff,\n\t\t\t\tr[1].br_startblock, r[1].br_blockcount,\n\t\t\t\tr[1].br_state)))\n\t\t\t\tgoto done;\n\t\t\t/* new left extent - oldext */\n\t\t\tcur->bc_rec.b = PREV;\n\t\t\tcur->bc_rec.b.br_blockcount =\n\t\t\t\tnew->br_startoff - PREV.br_startoff;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\t/*\n\t\t\t * Reset the cursor to the position of the new extent\n\t\t\t * we are about to insert as we can't trust it after\n\t\t\t * the previous insert.\n\t\t\t */\n\t\t\tif ((error = xfs_bmbt_lookup_eq(cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\t/* new middle extent - newext */\n\t\t\tcur->bc_rec.b.br_state = new->br_state;\n\t\t\tif ((error = xfs_btree_insert(cur, &i)))\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(tp, ip, first, flist, &cur,\n\t\t\t\t0, &tmp_logflags, XFS_DATA_FORK);\n\t\t*logflagsp |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\t*curp = cur;\n\t}\n\n\txfs_bmap_check_leaf_extents(*curp, ip, XFS_DATA_FORK);\ndone:\n\t*logflagsp |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}"
  },
  {
    "function_name": "xfs_bmap_add_extent_delay_real",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1738-2284",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_delay_real(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\tdiff;\t/* temp value */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\txfs_filblks_t\t\tda_new; /* new count del alloc blocks used */\n\txfs_filblks_t\t\tda_old; /* old count del alloc blocks used */\n\txfs_filblks_t\t\ttemp=0;\t/* value for da_new calculations */\n\txfs_filblks_t\t\ttemp2=0;/* value for da_new calculations */\n\tint\t\t\ttmp_rval;\t/* partial logging flags */\n\n\tifp = XFS_IFORK_PTR(bma->ip, XFS_DATA_FORK);\n\n\tASSERT(bma->idx >= 0);\n\tASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       (bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\tep = xfs_iext_get_ext(ifp, bma->idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\tda_old = startblockval(PREV.br_startblock);\n\tda_new = 0;\n\n\t/*\n\t * Set flags determining what part of the previous delayed allocation\n\t * extent is being replaced by a real allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (bma->idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == new->br_state &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (bma->idx < bma->ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx + 1), &RIGHT);\n\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    new->br_state == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\tbma->idx--;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 2, state);\n\t\tbma->ip->i_d.di_nextents--;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tPREV.br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount, LEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\tbma->idx--;\n\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock, LEFT.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tPREV.br_blockcount, LEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, new->br_startblock);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, PREV.br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tPREV.br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount, PREV.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, new->br_startblock);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Filling in the first part of a previous delayed allocation.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx - 1, state, _THIS_IP_);\n\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock, LEFT.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tnew->br_blockcount,\n\t\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx--;\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Filling in the first part of a previous delayed allocation.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_iext_insert(bma->ip, bma->idx, 1, new, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\tbma->firstblock, bma->flist,\n\t\t\t\t\t&bma->cur, 1, &tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tep = xfs_iext_get_ext(ifp, bma->idx + 1);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in the last part of a previous delayed allocation.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, bma->idx + 1),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\tRIGHT.br_state);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount,\n\t\t\t\t\tRIGHT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Filling in the last part of a previous delayed allocation.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_iext_insert(bma->ip, bma->idx + 1, 1, new, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur, 1,\n\t\t\t\t&tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tep = xfs_iext_get_ext(ifp, bma->idx);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Filling in the middle part of a previous delayed allocation.\n\t\t * Contiguity is impossible here.\n\t\t * This case is avoided almost all the time.\n\t\t *\n\t\t * We start with a delayed allocation:\n\t\t *\n\t\t * +ddddddddddddddddddddddddddddddddddddddddddddddddddddddd+\n\t\t *  PREV @ idx\n\t\t *\n\t         * and we are allocating:\n\t\t *                     +rrrrrrrrrrrrrrrrr+\n\t\t *\t\t\t      new\n\t\t *\n\t\t * and we set it up for insertion as:\n\t\t * +ddddddddddddddddddd+rrrrrrrrrrrrrrrrr+ddddddddddddddddd+\n\t\t *                            new\n\t\t *  PREV @ idx          LEFT              RIGHT\n\t\t *                      inserted at idx + 1\n\t\t */\n\t\ttemp = new->br_startoff - PREV.br_startoff;\n\t\ttemp2 = PREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, 0, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\t/* truncate PREV */\n\t\tLEFT = *new;\n\t\tRIGHT.br_state = PREV.br_state;\n\t\tRIGHT.br_startblock = nullstartblock(\n\t\t\t\t(int)xfs_bmap_worst_indlen(bma->ip, temp2));\n\t\tRIGHT.br_startoff = new_endoff;\n\t\tRIGHT.br_blockcount = temp2;\n\t\t/* insert LEFT (r[0]) and RIGHT (r[1]) at the same time */\n\t\txfs_iext_insert(bma->ip, bma->idx + 1, 2, &LEFT, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\t\t1, &tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\ttemp = xfs_bmap_worst_indlen(bma->ip, temp);\n\t\ttemp2 = xfs_bmap_worst_indlen(bma->ip, temp2);\n\t\tdiff = (int)(temp + temp2 - startblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tif (diff > 0) {\n\t\t\terror = xfs_icsb_modify_counters(bma->ip->i_mount,\n\t\t\t\t\tXFS_SBS_FDBLOCKS,\n\t\t\t\t\t-((int64_t)diff), 0);\n\t\t\tASSERT(!error);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tep = xfs_iext_get_ext(ifp, bma->idx);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx + 2, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, bma->idx + 2),\n\t\t\tnullstartblock((int)temp2));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 2, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tda_new = temp + temp2;\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\tda_old > 0, &tmp_logflags, XFS_DATA_FORK);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* adjust for changes in reserved delayed indirect blocks */\n\tif (da_old || da_new) {\n\t\ttemp = da_new;\n\t\tif (bma->cur)\n\t\t\ttemp += bma->cur->bc_private.b.allocated;\n\t\tASSERT(temp <= da_old);\n\t\tif (temp < da_old)\n\t\t\txfs_icsb_modify_counters(bma->ip->i_mount,\n\t\t\t\t\tXFS_SBS_FDBLOCKS,\n\t\t\t\t\t(int64_t)(da_old - temp), 0);\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, XFS_DATA_FORK);\ndone:\n\tbma->logflags |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [
      "#define\tPREV\t\tr[2]",
      "#define\tRIGHT\t\tr[1]",
      "#define\tLEFT\t\tr[0]",
      "#define\tPREV\t\tr[2]",
      "#define\tRIGHT\t\tr[1]",
      "#define\tLEFT\t\tr[0]"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_check_leaf_extents",
          "args": [
            "bma->cur",
            "bma->ip",
            "XFS_DATA_FORK"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_check_leaf_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "355-515",
          "snippet": "STATIC void\nxfs_bmap_check_leaf_extents(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor or null */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_extnum_t\t\ti=0, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\txfs_bmbt_rec_t\t\t*ep;\t/* pointer to current extent */\n\txfs_bmbt_rec_t\t\tlast = {0, 0}; /* last extent in prev block */\n\txfs_bmbt_rec_t\t\t*nextp;\t/* pointer to next extent */\n\tint\t\t\tbp_release = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE) {\n\t\treturn;\n\t}\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\t/* See if buf is in cur first */\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this block for basic sanity (increasing keys and\n\t\t * no duplicate blocks).\n\t\t */\n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\ti = 0;\n\n\t/*\n\t * Loop over all leaf nodes checking that all extents are in the right order.\n\t */\n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t/*\n\t\t * Check all the extents to make sure they are OK.\n\t\t * If we had a previous block, the last entry should\n\t\t * conform with the first entry in this one.\n\t\t */\n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tif (bp_release) {\n\t\tbp_release = 0;\n\t\txfs_trans_brelse(NULL, bp);\n\t}\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %d extents\",\n\t\t__func__, i);\n\tpanic(\"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\treturn;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_check_leaf_extents(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor or null */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_extnum_t\t\ti=0, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\txfs_bmbt_rec_t\t\t*ep;\t/* pointer to current extent */\n\txfs_bmbt_rec_t\t\tlast = {0, 0}; /* last extent in prev block */\n\txfs_bmbt_rec_t\t\t*nextp;\t/* pointer to next extent */\n\tint\t\t\tbp_release = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE) {\n\t\treturn;\n\t}\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\t/* See if buf is in cur first */\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this block for basic sanity (increasing keys and\n\t\t * no duplicate blocks).\n\t\t */\n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\ti = 0;\n\n\t/*\n\t * Loop over all leaf nodes checking that all extents are in the right order.\n\t */\n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t/*\n\t\t * Check all the extents to make sure they are OK.\n\t\t * If we had a previous block, the last entry should\n\t\t * conform with the first entry in this one.\n\t\t */\n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tif (bp_release) {\n\t\tbp_release = 0;\n\t\txfs_trans_brelse(NULL, bp);\n\t}\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %d extents\",\n\t\t__func__, i);\n\tpanic(\"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_icsb_modify_counters",
          "args": [
            "bma->ip->i_mount",
            "XFS_SBS_FDBLOCKS",
            "(int64_t)(da_old - temp)",
            "0"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_modify_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1846-1977",
          "snippet": "int\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_icsb_modify_counters(\n\txfs_mount_t\t*mp,\n\txfs_sb_field_t\tfield,\n\tint64_t\t\tdelta,\n\tint\t\trsvd)\n{\n\txfs_icsb_cnts_t\t*icsbp;\n\tlong long\tlcounter;\t/* long counter for 64 bit fields */\n\tint\t\tret = 0;\n\n\tmight_sleep();\nagain:\n\tpreempt_disable();\n\ticsbp = this_cpu_ptr(mp->m_sb_cnts);\n\n\t/*\n\t * if the counter is disabled, go to slow path\n\t */\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field)))\n\t\tgoto slow_path;\n\txfs_icsb_lock_cntr(icsbp);\n\tif (unlikely(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock_cntr(icsbp);\n\t\tgoto slow_path;\n\t}\n\n\tswitch (field) {\n\tcase XFS_SBS_ICOUNT:\n\t\tlcounter = icsbp->icsb_icount;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_icount = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_IFREE:\n\t\tlcounter = icsbp->icsb_ifree;\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_ifree = lcounter;\n\t\tbreak;\n\n\tcase XFS_SBS_FDBLOCKS:\n\t\tBUG_ON((mp->m_resblks - mp->m_resblks_avail) != 0);\n\n\t\tlcounter = icsbp->icsb_fdblocks - XFS_ALLOC_SET_ASIDE(mp);\n\t\tlcounter += delta;\n\t\tif (unlikely(lcounter < 0))\n\t\t\tgoto balance_counter;\n\t\ticsbp->icsb_fdblocks = lcounter + XFS_ALLOC_SET_ASIDE(mp);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\treturn 0;\n\nslow_path:\n\tpreempt_enable();\n\n\t/*\n\t * serialise with a mutex so we don't burn lots of cpu on\n\t * the superblock lock. We still need to hold the superblock\n\t * lock, however, when we modify the global structures.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * Now running atomically.\n\t *\n\t * If the counter is enabled, someone has beaten us to rebalancing.\n\t * Drop the lock and try again in the fast path....\n\t */\n\tif (!(xfs_icsb_counter_disabled(mp, field))) {\n\t\txfs_icsb_unlock(mp);\n\t\tgoto again;\n\t}\n\n\t/*\n\t * The counter is currently disabled. Because we are\n\t * running atomically here, we know a rebalance cannot\n\t * be in progress. Hence we can go straight to operating\n\t * on the global superblock. We do not call xfs_mod_incore_sb()\n\t * here even though we need to get the m_sb_lock. Doing so\n\t * will cause us to re-enter this function and deadlock.\n\t * Hence we get the m_sb_lock ourselves and then call\n\t * xfs_mod_incore_sb_unlocked() as the unlocked path operates\n\t * directly on the global counters.\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tret = xfs_mod_incore_sb_unlocked(mp, field, delta, rsvd);\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/*\n\t * Now that we've modified the global superblock, we\n\t * may be able to re-enable the distributed counters\n\t * (e.g. lots of space just got freed). After that\n\t * we are done.\n\t */\n\tif (ret != -ENOSPC)\n\t\txfs_icsb_balance_counter(mp, field, 0);\n\txfs_icsb_unlock(mp);\n\treturn ret;\n\nbalance_counter:\n\txfs_icsb_unlock_cntr(icsbp);\n\tpreempt_enable();\n\n\t/*\n\t * We may have multiple threads here if multiple per-cpu\n\t * counters run dry at the same time. This will mean we can\n\t * do more balances than strictly necessary but it is not\n\t * the common slowpath case.\n\t */\n\txfs_icsb_lock(mp);\n\n\t/*\n\t * running atomically.\n\t *\n\t * This will leave the counter in the correct state for future\n\t * accesses. After the rebalance, we simply try again and our retry\n\t * will either succeed through the fast path or slow path without\n\t * another balance operation being required.\n\t */\n\txfs_icsb_balance_counter(mp, field, delta);\n\txfs_icsb_unlock(mp);\n\tgoto again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "temp <= da_old"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_extents_to_btree",
          "args": [
            "bma->tp",
            "bma->ip",
            "bma->firstblock",
            "bma->flist",
            "&bma->cur",
            "da_old > 0",
            "&tmp_logflags",
            "XFS_DATA_FORK"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_extents_to_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "743-885",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->cur == NULL"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_needs_btree",
          "args": [
            "bma->ip",
            "XFS_DATA_FORK"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_needs_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "138-143",
          "snippet": "static inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 2245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx + 2",
            "state",
            "_THIS_IP_"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_startblock",
          "args": [
            "xfs_iext_get_ext(ifp, bma->idx + 2)",
            "nullstartblock((int)temp2)"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_startblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "292-302",
          "snippet": "void\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startblock(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fsblock_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(12)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64hi(55)) |\n\t\t  (xfs_bmbt_rec_base_t)(v >> 43);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64lo(21)) |\n\t\t  (xfs_bmbt_rec_base_t)(v << 21);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nullstartblock",
          "args": [
            "(int)temp2"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "nullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1383-1387",
          "snippet": "static inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)",
            "#define STARTBLOCKVALBITS\t17"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n#define STARTBLOCKVALBITS\t17\n\nstatic inline xfs_fsblock_t nullstartblock(int k)\n{\n\tASSERT(k < (1 << STARTBLOCKVALBITS));\n\treturn STARTBLOCKMASK | (k);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "bma->idx + 2"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx + 2",
            "state",
            "_THIS_IP_"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!error"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "startblockval",
          "args": [
            "PREV.br_startblock"
          ],
          "line": 2212
        },
        "resolved": true,
        "details": {
          "function_name": "startblockval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1389-1392",
          "snippet": "static inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline xfs_filblks_t startblockval(xfs_fsblock_t x)\n{\n\treturn (xfs_filblks_t)((x) & ~STARTBLOCKMASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_worst_indlen",
          "args": [
            "bma->ip",
            "temp2"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_worst_indlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "178-203",
          "snippet": "STATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_insert",
          "args": [
            "bma->cur",
            "&i"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3104-3170",
          "snippet": "int\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_insert(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* result value, 0 for failure */\n\tint\t\t\tlevel;\t/* current level number in btree */\n\tunion xfs_btree_ptr\tnptr;\t/* new block number (split result) */\n\tstruct xfs_btree_cur\t*ncur;\t/* new cursor (split result) */\n\tstruct xfs_btree_cur\t*pcur;\t/* previous level's cursor */\n\tunion xfs_btree_rec\trec;\t/* record to insert */\n\n\tlevel = 0;\n\tncur = NULL;\n\tpcur = cur;\n\n\txfs_btree_set_ptr_null(cur, &nptr);\n\tcur->bc_ops->init_rec_from_cur(cur, &rec);\n\n\t/*\n\t * Loop going up the tree, starting at the leaf level.\n\t * Stop when we don't get a split block, that must mean that\n\t * the insert is finished with this level.\n\t */\n\tdo {\n\t\t/*\n\t\t * Insert nrec/nptr into this level of the tree.\n\t\t * Note if we fail, nptr will be null.\n\t\t */\n\t\terror = xfs_btree_insrec(pcur, level, &nptr, &rec, &ncur, &i);\n\t\tif (error) {\n\t\t\tif (pcur != cur)\n\t\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_ERROR);\n\t\t\tgoto error0;\n\t\t}\n\n\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, error0);\n\t\tlevel++;\n\n\t\t/*\n\t\t * See if the cursor we just used is trash.\n\t\t * Can't trash the caller's cursor, but otherwise we should\n\t\t * if ncur is a new cursor or we're about to be done.\n\t\t */\n\t\tif (pcur != cur &&\n\t\t    (ncur || xfs_btree_ptr_is_null(cur, &nptr))) {\n\t\t\t/* Save the state from the cursor before we trash it */\n\t\t\tif (cur->bc_ops->update_cursor)\n\t\t\t\tcur->bc_ops->update_cursor(pcur, cur);\n\t\t\tcur->bc_nlevels = pcur->bc_nlevels;\n\t\t\txfs_btree_del_cursor(pcur, XFS_BTREE_NOERROR);\n\t\t}\n\t\t/* If we got a new cursor, switch to it. */\n\t\tif (ncur) {\n\t\t\tpcur = ncur;\n\t\t\tncur = NULL;\n\t\t}\n\t} while (!xfs_btree_ptr_is_null(cur, &nptr));\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 0",
            "done"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_lookup_eq",
          "args": [
            "bma->cur",
            "new->br_startoff",
            "new->br_startblock",
            "new->br_blockcount",
            "&i"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_lookup_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "107-119",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_insert",
          "args": [
            "bma->ip",
            "bma->idx + 1",
            "2",
            "&LEFT",
            "state"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "909-926",
          "snippet": "void\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_insert(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* starting index of new items */\n\txfs_extnum_t\tcount,\t\t/* number of inserted items */\n\txfs_bmbt_irec_t\t*new,\t\t/* items to insert */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\ti;\t\t/* extent record index */\n\n\ttrace_xfs_iext_insert(ip, idx, new, state, _RET_IP_);\n\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\txfs_iext_add(ifp, idx, count);\n\tfor (i = idx; i < idx + count; i++, new++)\n\t\txfs_bmbt_set_all(xfs_iext_get_ext(ifp, i), new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_blockcount",
          "args": [
            "ep",
            "temp"
          ],
          "line": 2175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "279-287",
          "snippet": "void\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_blockcount(\n\txfs_bmbt_rec_host_t *r,\n\txfs_filblks_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(43)) == 0);\n\tr->l1 = (r->l1 & (xfs_bmbt_rec_base_t)xfs_mask64hi(43)) |\n\t\t  (xfs_bmbt_rec_base_t)(v & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "0",
            "_THIS_IP_"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "xfs_bmap_worst_indlen(bma->ip, temp)",
            "startblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0)"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 0",
            "done"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "xfs_bmap_worst_indlen(bma->ip, temp)",
            "startblockval(PREV.br_startblock)"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_update",
          "args": [
            "bma->cur",
            "new->br_startoff",
            "new->br_startblock",
            "new->br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount",
            "RIGHT.br_state"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "160-172",
          "snippet": "STATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx + 1",
            "state",
            "_THIS_IP_"
          ],
          "line": 2077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_allf",
          "args": [
            "xfs_iext_get_ext(ifp, bma->idx + 1)",
            "new->br_startoff",
            "new->br_startblock",
            "new->br_blockcount + RIGHT.br_blockcount",
            "RIGHT.br_state"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "199-221",
          "snippet": "void\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx + 1",
            "state",
            "_THIS_IP_"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx + 1",
            "state",
            "_THIS_IP_"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "xfs_bmap_worst_indlen(bma->ip, temp)",
            "startblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0)"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 0",
            "done"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_startoff",
          "args": [
            "ep",
            "new_endoff"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "307-316",
          "snippet": "void\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_startoff(\n\txfs_bmbt_rec_host_t *r,\n\txfs_fileoff_t\tv)\n{\n\tASSERT((v & xfs_mask64hi(9)) == 0);\n\tr->l0 = (r->l0 & (xfs_bmbt_rec_base_t) xfs_mask64hi(1)) |\n\t\t((xfs_bmbt_rec_base_t)v << 9) |\n\t\t  (r->l0 & (xfs_bmbt_rec_base_t)xfs_mask64lo(9));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FILBLKS_MIN",
          "args": [
            "xfs_bmap_worst_indlen(bma->ip, temp)",
            "startblockval(PREV.br_startblock)"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx - 1",
            "state",
            "_THIS_IP_"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx - 1",
            "state",
            "_THIS_IP_"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 0",
            "done"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_remove",
          "args": [
            "bma->ip",
            "bma->idx + 1",
            "1",
            "state"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1160-1187",
          "snippet": "void\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_remove(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin removing exts */\n\tint\t\text_diff,\t/* number of extents to remove */\n\tint\t\tstate)\t\t/* type of extent conversion */\n{\n\txfs_ifork_t\t*ifp = (state & BMAP_ATTRFORK) ? ip->i_afp : &ip->i_df;\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\tint\t\tnew_size;\t/* size of extents after removal */\n\n\ttrace_xfs_iext_remove(ip, idx, state, _RET_IP_);\n\n\tASSERT(ext_diff > 0);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tnew_size = (nextents - ext_diff) * sizeof(xfs_bmbt_rec_t);\n\n\tif (new_size == 0) {\n\t\txfs_iext_destroy(ifp);\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_iext_remove_indirect(ifp, idx, ext_diff);\n\t} else if (ifp->if_real_bytes) {\n\t\txfs_iext_remove_direct(ifp, idx, ext_diff);\n\t} else {\n\t\txfs_iext_remove_inline(ifp, idx, ext_diff);\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 1877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_decrement",
          "args": [
            "bma->cur",
            "0",
            "&i"
          ],
          "line": 1874
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_decrement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1539-1631",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_decrement(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel,\n\tint\t\t\t*stat)\t\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tlev;\n\tunion xfs_btree_ptr\tptr;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, level);\n\n\tASSERT(level < cur->bc_nlevels);\n\n\t/* Read-ahead to the left at this level. */\n\txfs_btree_readahead(cur, level, XFS_BTCUR_LEFTRA);\n\n\t/* We're done if we remain in the block after the decrement. */\n\tif (--cur->bc_ptrs[level] > 0)\n\t\tgoto out1;\n\n\t/* Get a pointer to the btree block. */\n\tblock = xfs_btree_get_block(cur, level, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, level, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\n\t/* Fail if we just went off the left edge of the tree. */\n\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_LEFTSIB);\n\tif (xfs_btree_ptr_is_null(cur, &ptr))\n\t\tgoto out0;\n\n\tXFS_BTREE_STATS_INC(cur, decrement);\n\n\t/*\n\t * March up the tree decrementing pointers.\n\t * Stop when we don't go off the left edge of a block.\n\t */\n\tfor (lev = level + 1; lev < cur->bc_nlevels; lev++) {\n\t\tif (--cur->bc_ptrs[lev] > 0)\n\t\t\tbreak;\n\t\t/* Read-ahead the left block for the next loop. */\n\t\txfs_btree_readahead(cur, lev, XFS_BTCUR_LEFTRA);\n\t}\n\n\t/*\n\t * If we went off the root then we are seriously confused.\n\t * or the root of the tree is in an inode.\n\t */\n\tif (lev == cur->bc_nlevels) {\n\t\tif (cur->bc_flags & XFS_BTREE_ROOT_IN_INODE)\n\t\t\tgoto out0;\n\t\tASSERT(0);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto error0;\n\t}\n\tASSERT(lev < cur->bc_nlevels);\n\n\t/*\n\t * Now walk back down the tree, fixing up the cursor's buffer\n\t * pointers and key numbers.\n\t */\n\tfor (block = xfs_btree_get_block(cur, lev, &bp); lev > level; ) {\n\t\tunion xfs_btree_ptr\t*ptrp;\n\n\t\tptrp = xfs_btree_ptr_addr(cur, cur->bc_ptrs[lev], block);\n\t\t--lev;\n\t\terror = xfs_btree_read_buf_block(cur, ptrp, 0, &block, &bp);\n\t\tif (error)\n\t\t\tgoto error0;\n\t\txfs_btree_setbuf(cur, lev, bp);\n\t\tcur->bc_ptrs[lev] = xfs_btree_get_numrecs(block);\n\t}\nout1:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 1;\n\treturn 0;\n\nout0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = 0;\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_delete",
          "args": [
            "bma->cur",
            "&i"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "3869-3909",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error */\nxfs_btree_delete(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tlevel;\n\tint\t\t\ti;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\n\t/*\n\t * Go up the tree, starting at leaf level.\n\t *\n\t * If 2 is returned then a join was done; go to the next level.\n\t * Otherwise we are done.\n\t */\n\tfor (level = 0, i = 2; i == 2; level++) {\n\t\terror = xfs_btree_delrec(cur, level, &i);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tif (i == 0) {\n\t\tfor (level = 1; level < cur->bc_nlevels; level++) {\n\t\t\tif (cur->bc_ptrs[level] == 0) {\n\t\t\t\terror = xfs_btree_decrement(cur, level, &i);\n\t\t\t\tif (error)\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t*stat = i;\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "i == 1",
            "done"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_pre_update",
          "args": [
            "bma->ip",
            "bma->idx",
            "state",
            "_THIS_IP_"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "RIGHT.br_startblock"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, bma->idx + 1)",
            "&RIGHT"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "PREV.br_startoff + PREV.br_blockcount >= new_endoff"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "PREV.br_startoff <= new->br_startoff"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_add_exlist"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!bma->cur ||\n\t       (bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL)"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!isnullstartblock(new->br_startblock)"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec)"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bma->idx >= 0"
          ],
          "line": 1761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "bma->ip",
            "XFS_DATA_FORK"
          ],
          "line": 1759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n#define\tPREV\t\tr[2]\n#define\tRIGHT\t\tr[1]\n#define\tLEFT\t\tr[0]\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_add_extent_delay_real(\n\tstruct xfs_bmalloca\t*bma)\n{\n\tstruct xfs_bmbt_irec\t*new = &bma->got;\n\tint\t\t\tdiff;\t/* temp value */\n\txfs_bmbt_rec_host_t\t*ep;\t/* extent entry for idx */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\ti;\t/* temp state */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork pointer */\n\txfs_fileoff_t\t\tnew_endoff;\t/* end offset of new entry */\n\txfs_bmbt_irec_t\t\tr[3];\t/* neighbor extent entries */\n\t\t\t\t\t/* left is 0, right is 1, prev is 2 */\n\tint\t\t\trval=0;\t/* return value (logging flags) */\n\tint\t\t\tstate = 0;/* state bits, accessed thru macros */\n\txfs_filblks_t\t\tda_new; /* new count del alloc blocks used */\n\txfs_filblks_t\t\tda_old; /* old count del alloc blocks used */\n\txfs_filblks_t\t\ttemp=0;\t/* value for da_new calculations */\n\txfs_filblks_t\t\ttemp2=0;/* value for da_new calculations */\n\tint\t\t\ttmp_rval;\t/* partial logging flags */\n\n\tifp = XFS_IFORK_PTR(bma->ip, XFS_DATA_FORK);\n\n\tASSERT(bma->idx >= 0);\n\tASSERT(bma->idx <= ifp->if_bytes / sizeof(struct xfs_bmbt_rec));\n\tASSERT(!isnullstartblock(new->br_startblock));\n\tASSERT(!bma->cur ||\n\t       (bma->cur->bc_private.b.flags & XFS_BTCUR_BPRV_WASDEL));\n\n\tXFS_STATS_INC(xs_add_exlist);\n\n#define\tLEFT\t\tr[0]\n#define\tRIGHT\t\tr[1]\n#define\tPREV\t\tr[2]\n\n\t/*\n\t * Set up a bunch of variables to make the tests simpler.\n\t */\n\tep = xfs_iext_get_ext(ifp, bma->idx);\n\txfs_bmbt_get_all(ep, &PREV);\n\tnew_endoff = new->br_startoff + new->br_blockcount;\n\tASSERT(PREV.br_startoff <= new->br_startoff);\n\tASSERT(PREV.br_startoff + PREV.br_blockcount >= new_endoff);\n\n\tda_old = startblockval(PREV.br_startblock);\n\tda_new = 0;\n\n\t/*\n\t * Set flags determining what part of the previous delayed allocation\n\t * extent is being replaced by a real allocation.\n\t */\n\tif (PREV.br_startoff == new->br_startoff)\n\t\tstate |= BMAP_LEFT_FILLING;\n\tif (PREV.br_startoff + PREV.br_blockcount == new_endoff)\n\t\tstate |= BMAP_RIGHT_FILLING;\n\n\t/*\n\t * Check and set flags if this segment has a left neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t */\n\tif (bma->idx > 0) {\n\t\tstate |= BMAP_LEFT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx - 1), &LEFT);\n\n\t\tif (isnullstartblock(LEFT.br_startblock))\n\t\t\tstate |= BMAP_LEFT_DELAY;\n\t}\n\n\tif ((state & BMAP_LEFT_VALID) && !(state & BMAP_LEFT_DELAY) &&\n\t    LEFT.br_startoff + LEFT.br_blockcount == new->br_startoff &&\n\t    LEFT.br_startblock + LEFT.br_blockcount == new->br_startblock &&\n\t    LEFT.br_state == new->br_state &&\n\t    LEFT.br_blockcount + new->br_blockcount <= MAXEXTLEN)\n\t\tstate |= BMAP_LEFT_CONTIG;\n\n\t/*\n\t * Check and set flags if this segment has a right neighbor.\n\t * Don't set contiguous if the combined extent would be too large.\n\t * Also check for all-three-contiguous being too large.\n\t */\n\tif (bma->idx < bma->ip->i_df.if_bytes / (uint)sizeof(xfs_bmbt_rec_t) - 1) {\n\t\tstate |= BMAP_RIGHT_VALID;\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, bma->idx + 1), &RIGHT);\n\n\t\tif (isnullstartblock(RIGHT.br_startblock))\n\t\t\tstate |= BMAP_RIGHT_DELAY;\n\t}\n\n\tif ((state & BMAP_RIGHT_VALID) && !(state & BMAP_RIGHT_DELAY) &&\n\t    new_endoff == RIGHT.br_startoff &&\n\t    new->br_startblock + new->br_blockcount == RIGHT.br_startblock &&\n\t    new->br_state == RIGHT.br_state &&\n\t    new->br_blockcount + RIGHT.br_blockcount <= MAXEXTLEN &&\n\t    ((state & (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING)) !=\n\t\t      (BMAP_LEFT_CONTIG | BMAP_LEFT_FILLING |\n\t\t       BMAP_RIGHT_FILLING) ||\n\t     LEFT.br_blockcount + new->br_blockcount + RIGHT.br_blockcount\n\t\t\t<= MAXEXTLEN))\n\t\tstate |= BMAP_RIGHT_CONTIG;\n\n\terror = 0;\n\t/*\n\t * Switch out based on the FILLING and CONTIG state bits.\n\t */\n\tswitch (state & (BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t\t\t BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG)) {\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG |\n\t     BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The left and right neighbors are both contiguous with new.\n\t\t */\n\t\tbma->idx--;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount +\n\t\t\tRIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 2, state);\n\t\tbma->ip->i_d.di_nextents--;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_delete(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_btree_decrement(bma->cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tPREV.br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount, LEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The left neighbor is contiguous, the right is not.\n\t\t */\n\t\tbma->idx--;\n\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx),\n\t\t\tLEFT.br_blockcount + PREV.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock, LEFT.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tPREV.br_blockcount, LEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * The right neighbor is contiguous, the left is not.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, new->br_startblock);\n\t\txfs_bmbt_set_blockcount(ep,\n\t\t\tPREV.br_blockcount + RIGHT.br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\txfs_iext_remove(bma->ip, bma->idx + 1, 1, state);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, PREV.br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tPREV.br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount, PREV.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Filling in all of a previously delayed allocation extent.\n\t\t * Neither the left nor right neighbors are contiguous with\n\t\t * the new one.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, new->br_startblock);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG:\n\t\t/*\n\t\t * Filling in the first part of a previous delayed allocation.\n\t\t * The left neighbor is contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx - 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(xfs_iext_get_ext(ifp, bma->idx - 1),\n\t\t\tLEFT.br_blockcount + new->br_blockcount);\n\t\txfs_bmbt_set_startoff(ep,\n\t\t\tPREV.br_startoff + new->br_blockcount);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx - 1, state, _THIS_IP_);\n\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock, LEFT.br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, LEFT.br_startoff,\n\t\t\t\t\tLEFT.br_startblock,\n\t\t\t\t\tLEFT.br_blockcount +\n\t\t\t\t\tnew->br_blockcount,\n\t\t\t\t\tLEFT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx--;\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING:\n\t\t/*\n\t\t * Filling in the first part of a previous delayed allocation.\n\t\t * The left neighbor is not contiguous.\n\t\t */\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startoff(ep, new_endoff);\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_iext_insert(bma->ip, bma->idx, 1, new, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\tbma->firstblock, bma->flist,\n\t\t\t\t\t&bma->cur, 1, &tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tep = xfs_iext_get_ext(ifp, bma->idx + 1);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * Filling in the last part of a previous delayed allocation.\n\t\t * The right neighbor is contiguous with the new allocation.\n\t\t */\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_bmbt_set_allf(xfs_iext_get_ext(ifp, bma->idx + 1),\n\t\t\tnew->br_startoff, new->br_startblock,\n\t\t\tnew->br_blockcount + RIGHT.br_blockcount,\n\t\t\tRIGHT.br_state);\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 1, state, _THIS_IP_);\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = 0;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, RIGHT.br_startoff,\n\t\t\t\t\tRIGHT.br_startblock,\n\t\t\t\t\tRIGHT.br_blockcount, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t\terror = xfs_bmbt_update(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock,\n\t\t\t\t\tnew->br_blockcount +\n\t\t\t\t\tRIGHT.br_blockcount,\n\t\t\t\t\tRIGHT.br_state);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock));\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tbreak;\n\n\tcase BMAP_RIGHT_FILLING:\n\t\t/*\n\t\t * Filling in the last part of a previous delayed allocation.\n\t\t * The right neighbor is not contiguous.\n\t\t */\n\t\ttemp = PREV.br_blockcount - new->br_blockcount;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\n\t\txfs_iext_insert(bma->ip, bma->idx + 1, 1, new, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur, 1,\n\t\t\t\t&tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\tda_new = XFS_FILBLKS_MIN(xfs_bmap_worst_indlen(bma->ip, temp),\n\t\t\tstartblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tep = xfs_iext_get_ext(ifp, bma->idx);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock(da_new));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tbreak;\n\n\tcase 0:\n\t\t/*\n\t\t * Filling in the middle part of a previous delayed allocation.\n\t\t * Contiguity is impossible here.\n\t\t * This case is avoided almost all the time.\n\t\t *\n\t\t * We start with a delayed allocation:\n\t\t *\n\t\t * +ddddddddddddddddddddddddddddddddddddddddddddddddddddddd+\n\t\t *  PREV @ idx\n\t\t *\n\t         * and we are allocating:\n\t\t *                     +rrrrrrrrrrrrrrrrr+\n\t\t *\t\t\t      new\n\t\t *\n\t\t * and we set it up for insertion as:\n\t\t * +ddddddddddddddddddd+rrrrrrrrrrrrrrrrr+ddddddddddddddddd+\n\t\t *                            new\n\t\t *  PREV @ idx          LEFT              RIGHT\n\t\t *                      inserted at idx + 1\n\t\t */\n\t\ttemp = new->br_startoff - PREV.br_startoff;\n\t\ttemp2 = PREV.br_startoff + PREV.br_blockcount - new_endoff;\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx, 0, _THIS_IP_);\n\t\txfs_bmbt_set_blockcount(ep, temp);\t/* truncate PREV */\n\t\tLEFT = *new;\n\t\tRIGHT.br_state = PREV.br_state;\n\t\tRIGHT.br_startblock = nullstartblock(\n\t\t\t\t(int)xfs_bmap_worst_indlen(bma->ip, temp2));\n\t\tRIGHT.br_startoff = new_endoff;\n\t\tRIGHT.br_blockcount = temp2;\n\t\t/* insert LEFT (r[0]) and RIGHT (r[1]) at the same time */\n\t\txfs_iext_insert(bma->ip, bma->idx + 1, 2, &LEFT, state);\n\t\tbma->ip->i_d.di_nextents++;\n\t\tif (bma->cur == NULL)\n\t\t\trval = XFS_ILOG_CORE | XFS_ILOG_DEXT;\n\t\telse {\n\t\t\trval = XFS_ILOG_CORE;\n\t\t\terror = xfs_bmbt_lookup_eq(bma->cur, new->br_startoff,\n\t\t\t\t\tnew->br_startblock, new->br_blockcount,\n\t\t\t\t\t&i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 0, done);\n\t\t\tbma->cur->bc_rec.b.br_state = XFS_EXT_NORM;\n\t\t\terror = xfs_btree_insert(bma->cur, &i);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t\tXFS_WANT_CORRUPTED_GOTO(i == 1, done);\n\t\t}\n\n\t\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\t\t1, &tmp_rval, XFS_DATA_FORK);\n\t\t\trval |= tmp_rval;\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\t\ttemp = xfs_bmap_worst_indlen(bma->ip, temp);\n\t\ttemp2 = xfs_bmap_worst_indlen(bma->ip, temp2);\n\t\tdiff = (int)(temp + temp2 - startblockval(PREV.br_startblock) -\n\t\t\t(bma->cur ? bma->cur->bc_private.b.allocated : 0));\n\t\tif (diff > 0) {\n\t\t\terror = xfs_icsb_modify_counters(bma->ip->i_mount,\n\t\t\t\t\tXFS_SBS_FDBLOCKS,\n\t\t\t\t\t-((int64_t)diff), 0);\n\t\t\tASSERT(!error);\n\t\t\tif (error)\n\t\t\t\tgoto done;\n\t\t}\n\n\t\tep = xfs_iext_get_ext(ifp, bma->idx);\n\t\txfs_bmbt_set_startblock(ep, nullstartblock((int)temp));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx, state, _THIS_IP_);\n\t\ttrace_xfs_bmap_pre_update(bma->ip, bma->idx + 2, state, _THIS_IP_);\n\t\txfs_bmbt_set_startblock(xfs_iext_get_ext(ifp, bma->idx + 2),\n\t\t\tnullstartblock((int)temp2));\n\t\ttrace_xfs_bmap_post_update(bma->ip, bma->idx + 2, state, _THIS_IP_);\n\n\t\tbma->idx++;\n\t\tda_new = temp + temp2;\n\t\tbreak;\n\n\tcase BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_FILLING | BMAP_RIGHT_CONTIG:\n\tcase BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG:\n\tcase BMAP_LEFT_CONTIG | BMAP_RIGHT_CONTIG:\n\tcase BMAP_LEFT_CONTIG:\n\tcase BMAP_RIGHT_CONTIG:\n\t\t/*\n\t\t * These cases are all impossible.\n\t\t */\n\t\tASSERT(0);\n\t}\n\n\t/* convert to a btree if necessary */\n\tif (xfs_bmap_needs_btree(bma->ip, XFS_DATA_FORK)) {\n\t\tint\ttmp_logflags;\t/* partial log flag return val */\n\n\t\tASSERT(bma->cur == NULL);\n\t\terror = xfs_bmap_extents_to_btree(bma->tp, bma->ip,\n\t\t\t\tbma->firstblock, bma->flist, &bma->cur,\n\t\t\t\tda_old > 0, &tmp_logflags, XFS_DATA_FORK);\n\t\tbma->logflags |= tmp_logflags;\n\t\tif (error)\n\t\t\tgoto done;\n\t}\n\n\t/* adjust for changes in reserved delayed indirect blocks */\n\tif (da_old || da_new) {\n\t\ttemp = da_new;\n\t\tif (bma->cur)\n\t\t\ttemp += bma->cur->bc_private.b.allocated;\n\t\tASSERT(temp <= da_old);\n\t\tif (temp < da_old)\n\t\t\txfs_icsb_modify_counters(bma->ip->i_mount,\n\t\t\t\t\tXFS_SBS_FDBLOCKS,\n\t\t\t\t\t(int64_t)(da_old - temp), 0);\n\t}\n\n\t/* clear out the allocated field, done with it now in any case. */\n\tif (bma->cur)\n\t\tbma->cur->bc_private.b.allocated = 0;\n\n\txfs_bmap_check_leaf_extents(bma->cur, bma->ip, XFS_DATA_FORK);\ndone:\n\tbma->logflags |= rval;\n\treturn error;\n#undef\tLEFT\n#undef\tRIGHT\n#undef\tPREV\n}"
  },
  {
    "function_name": "xfs_bmap_one_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1703-1729",
    "snippet": "int\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ISIZE",
          "args": [
            "ip"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "XFS_ISIZE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.h",
          "lines": "88-93",
          "snippet": "static inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}",
          "includes": [
            "#include \"xfs_inode_fork.h\"",
            "#include \"xfs_inode_buf.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_inode_fork.h\"\n#include \"xfs_inode_buf.h\"\n\nstatic inline xfs_fsize_t XFS_ISIZE(struct xfs_inode *ip)\n{\n\tif (S_ISREG(ip->i_d.di_mode))\n\t\treturn i_size_read(VFS_I(ip));\n\treturn ip->i_d.di_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "ep",
            "&s"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "0"
          ],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTENTS"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* 1=>1 block, 0=>otherwise */\nxfs_bmap_one_block(\n\txfs_inode_t\t*ip,\t\t/* incore inode */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\txfs_bmbt_rec_host_t *ep;\t/* ptr to fork's extent */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\trval;\t\t/* return value */\n\txfs_bmbt_irec_t\ts;\t\t/* internal version of extent */\n\n#ifndef DEBUG\n\tif (whichfork == XFS_DATA_FORK)\n\t\treturn XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize;\n#endif\t/* !DEBUG */\n\tif (XFS_IFORK_NEXTENTS(ip, whichfork) != 1)\n\t\treturn 0;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t\treturn 0;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_get_all(ep, &s);\n\trval = s.br_startoff == 0 && s.br_blockcount == 1;\n\tif (rval && whichfork == XFS_DATA_FORK)\n\t\tASSERT(XFS_ISIZE(ip) == ip->i_mount->m_sb.sb_blocksize);\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_bmap_last_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1671-1696",
    "snippet": "int\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmap_last_extent",
          "args": [
            "NULL",
            "ip",
            "whichfork",
            "&rec",
            "&is_empty"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1598-1625",
          "snippet": "int\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tint\t\t\terror;\n\tint\t\t\tnextents;\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnextents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*is_empty = 1;\n\t\treturn 0;\n\t}\n\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, nextents - 1), rec);\n\t*is_empty = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tint\t\t\terror;\n\tint\t\t\tnextents;\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnextents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*is_empty = 1;\n\t\treturn 0;\n\t}\n\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, nextents - 1), rec);\n\t*is_empty = 0;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_offset(\n\tstruct xfs_inode\t*ip,\n\txfs_fileoff_t\t\t*last_block,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\t*last_block = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL)\n\t\treturn 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS)\n\t       return -EIO;\n\n\terror = xfs_bmap_last_extent(NULL, ip, whichfork, &rec, &is_empty);\n\tif (error || is_empty)\n\t\treturn error;\n\n\t*last_block = rec.br_startoff + rec.br_blockcount;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_isaeof",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1636-1664",
    "snippet": "STATIC int\nxfs_bmap_isaeof(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\tbma->aeof = 0;\n\terror = xfs_bmap_last_extent(NULL, bma->ip, whichfork, &rec,\n\t\t\t\t     &is_empty);\n\tif (error)\n\t\treturn error;\n\n\tif (is_empty) {\n\t\tbma->aeof = 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if we are allocation or past the last extent, or at least into\n\t * the last delayed allocated extent.\n\t */\n\tbma->aeof = bma->offset >= rec.br_startoff + rec.br_blockcount ||\n\t\t(bma->offset >= rec.br_startoff &&\n\t\t isnullstartblock(rec.br_startblock));\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "rec.br_startblock"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_last_extent",
          "args": [
            "NULL",
            "bma->ip",
            "whichfork",
            "&rec",
            "&is_empty"
          ],
          "line": 1646
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_last_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1598-1625",
          "snippet": "int\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tint\t\t\terror;\n\tint\t\t\tnextents;\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnextents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*is_empty = 1;\n\t\treturn 0;\n\t}\n\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, nextents - 1), rec);\n\t*is_empty = 0;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tint\t\t\terror;\n\tint\t\t\tnextents;\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnextents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*is_empty = 1;\n\t\treturn 0;\n\t}\n\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, nextents - 1), rec);\n\t*is_empty = 0;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_isaeof(\n\tstruct xfs_bmalloca\t*bma,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_bmbt_irec\trec;\n\tint\t\t\tis_empty;\n\tint\t\t\terror;\n\n\tbma->aeof = 0;\n\terror = xfs_bmap_last_extent(NULL, bma->ip, whichfork, &rec,\n\t\t\t\t     &is_empty);\n\tif (error)\n\t\treturn error;\n\n\tif (is_empty) {\n\t\tbma->aeof = 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if we are allocation or past the last extent, or at least into\n\t * the last delayed allocated extent.\n\t */\n\tbma->aeof = bma->offset >= rec.br_startoff + rec.br_blockcount ||\n\t\t(bma->offset >= rec.br_startoff &&\n\t\t isnullstartblock(rec.br_startblock));\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_last_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1598-1625",
    "snippet": "int\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tint\t\t\terror;\n\tint\t\t\tnextents;\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnextents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*is_empty = 1;\n\t\treturn 0;\n\t}\n\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, nextents - 1), rec);\n\t*is_empty = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "xfs_iext_get_ext(ifp, nextents - 1)",
            "rec"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "nextents - 1"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmap_last_extent(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork,\n\tstruct xfs_bmbt_irec\t*rec,\n\tint\t\t\t*is_empty)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tint\t\t\terror;\n\tint\t\t\tnextents;\n\n\tif (!(ifp->if_flags & XFS_IFEXTENTS)) {\n\t\terror = xfs_iread_extents(tp, ip, whichfork);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tnextents = ifp->if_bytes / sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*is_empty = 1;\n\t\treturn 0;\n\t}\n\n\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, nextents - 1), rec);\n\t*is_empty = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_last_before",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1555-1596",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_last_before(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_fileoff_t\t*last_block,\t\t/* last block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\txfs_fileoff_t\tbno;\t\t\t/* input file offset */\n\tint\t\teof;\t\t\t/* hit end of file */\n\txfs_bmbt_rec_host_t *ep;\t\t/* pointer to last extent */\n\tint\t\terror;\t\t\t/* error return value */\n\txfs_bmbt_irec_t\tgot;\t\t\t/* current extent value */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tlastx;\t\t\t/* last extent used */\n\txfs_bmbt_irec_t\tprev;\t\t\t/* previous extent value */\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)\n\t       return -EIO;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*last_block = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tbno = *last_block - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\tif (eof || xfs_bmbt_get_startoff(ep) > bno) {\n\t\tif (prev.br_startoff == NULLFILEOFF)\n\t\t\t*last_block = 0;\n\t\telse\n\t\t\t*last_block = prev.br_startoff + prev.br_blockcount;\n\t}\n\t/*\n\t * Otherwise *last_block is already the right answer.\n\t */\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_startoff",
          "args": [
            "ep"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "155-161",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_search_extents",
          "args": [
            "ip",
            "bno",
            "whichfork",
            "&eof",
            "&lastx",
            "&got",
            "&prev"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_search_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1459-1493",
          "snippet": "STATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_last_before(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_fileoff_t\t*last_block,\t\t/* last block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\txfs_fileoff_t\tbno;\t\t\t/* input file offset */\n\tint\t\teof;\t\t\t/* hit end of file */\n\txfs_bmbt_rec_host_t *ep;\t\t/* pointer to last extent */\n\tint\t\terror;\t\t\t/* error return value */\n\txfs_bmbt_irec_t\tgot;\t\t\t/* current extent value */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_extnum_t\tlastx;\t\t\t/* last extent used */\n\txfs_bmbt_irec_t\tprev;\t\t\t/* previous extent value */\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_EXTENTS &&\n\t    XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_LOCAL)\n\t       return -EIO;\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*last_block = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tbno = *last_block - 1;\n\tep = xfs_bmap_search_extents(ip, bno, whichfork, &eof, &lastx, &got,\n\t\t&prev);\n\tif (eof || xfs_bmbt_get_startoff(ep) > bno) {\n\t\tif (prev.br_startoff == NULLFILEOFF)\n\t\t\t*last_block = 0;\n\t\telse\n\t\t\t*last_block = prev.br_startoff + prev.br_blockcount;\n\t}\n\t/*\n\t * Otherwise *last_block is already the right answer.\n\t */\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_first_unused",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1502-1547",
    "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_first_unused(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_extlen_t\tlen,\t\t\t/* size of hole to find */\n\txfs_fileoff_t\t*first_unused,\t\t/* unused block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_fileoff_t\tlastaddr;\t\t/* last block number seen */\n\txfs_fileoff_t\tlowest;\t\t\t/* lowest useful block */\n\txfs_fileoff_t\tmax;\t\t\t/* starting useful block */\n\txfs_fileoff_t\toff;\t\t\t/* offset for this block */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*first_unused = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tlowest = *first_unused;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0, lastaddr = 0, max = lowest; idx < nextents; idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\toff = xfs_bmbt_get_startoff(ep);\n\t\t/*\n\t\t * See if the hole before this extent will work.\n\t\t */\n\t\tif (off >= lowest + len && off - max >= len) {\n\t\t\t*first_unused = max;\n\t\t\treturn 0;\n\t\t}\n\t\tlastaddr = off + xfs_bmbt_get_blockcount(ep);\n\t\tmax = XFS_FILEOFF_MAX(lastaddr, lowest);\n\t}\n\t*first_unused = max;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_FILEOFF_MAX",
          "args": [
            "lastaddr",
            "lowest"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_blockcount",
          "args": [
            "ep"
          ],
          "line": 1542
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "134-139",
          "snippet": "xfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_get_blockcount(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (xfs_filblks_t)(r->l1 & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_startoff",
          "args": [
            "ep"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "155-161",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_get_startoff(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn ((xfs_fileoff_t)r->l0 &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "idx"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iread_extents",
          "args": [
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iread_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "420-454",
          "snippet": "int\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nint\nxfs_iread_extents(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tint\t\terror;\n\txfs_ifork_t\t*ifp;\n\txfs_extnum_t\tnextents;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\tif (unlikely(XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE)) {\n\t\tXFS_ERROR_REPORT(\"xfs_iread_extents\", XFS_ERRLEVEL_LOW,\n\t\t\t\t ip->i_mount);\n\t\treturn -EFSCORRUPTED;\n\t}\n\tnextents = XFS_IFORK_NEXTENTS(ip, whichfork);\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\n\t/*\n\t * We know that the size is valid (it's checked in iformat_btree)\n\t */\n\tifp->if_bytes = ifp->if_real_bytes = 0;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\txfs_iext_add(ifp, 0, nextents);\n\terror = xfs_bmap_read_extents(tp, ip, whichfork);\n\tif (error) {\n\t\txfs_iext_destroy(ifp);\n\t\tifp->if_flags &= ~XFS_IFEXTENTS;\n\t\treturn error;\n\t}\n\txfs_validate_extents(ifp, nextents, XFS_EXTFMT_INODE(ip));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_first_unused(\n\txfs_trans_t\t*tp,\t\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t\t/* incore inode */\n\txfs_extlen_t\tlen,\t\t\t/* size of hole to find */\n\txfs_fileoff_t\t*first_unused,\t\t/* unused block */\n\tint\t\twhichfork)\t\t/* data or attr fork */\n{\n\tint\t\terror;\t\t\t/* error return value */\n\tint\t\tidx;\t\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t\t/* inode fork pointer */\n\txfs_fileoff_t\tlastaddr;\t\t/* last block number seen */\n\txfs_fileoff_t\tlowest;\t\t\t/* lowest useful block */\n\txfs_fileoff_t\tmax;\t\t\t/* starting useful block */\n\txfs_fileoff_t\toff;\t\t\t/* offset for this block */\n\txfs_extnum_t\tnextents;\t\t/* number of extent entries */\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS ||\n\t       XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tif (XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL) {\n\t\t*first_unused = 0;\n\t\treturn 0;\n\t}\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (!(ifp->if_flags & XFS_IFEXTENTS) &&\n\t    (error = xfs_iread_extents(tp, ip, whichfork)))\n\t\treturn error;\n\tlowest = *first_unused;\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (idx = 0, lastaddr = 0, max = lowest; idx < nextents; idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\toff = xfs_bmbt_get_startoff(ep);\n\t\t/*\n\t\t * See if the hole before this extent will work.\n\t\t */\n\t\tif (off >= lowest + len && off - max >= len) {\n\t\t\t*first_unused = max;\n\t\t\treturn 0;\n\t\t}\n\t\tlastaddr = off + xfs_bmbt_get_blockcount(ep);\n\t\tmax = XFS_FILEOFF_MAX(lastaddr, lowest);\n\t}\n\t*first_unused = max;\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_search_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1459-1493",
    "snippet": "STATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_alert_tag",
          "args": [
            "ip->i_mount",
            "XFS_PTAG_FSBLOCK_ZERO",
            "\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\"",
            "(unsigned long long)ip->i_ino",
            "(unsigned long long)gotp->br_startblock",
            "(unsigned long long)gotp->br_startoff",
            "(unsigned long long)gotp->br_blockcount",
            "gotp->br_state",
            "*lastxp"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK)"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IS_REALTIME_INODE",
          "args": [
            "ip"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_search_multi_extents",
          "args": [
            "ifp",
            "bno",
            "eofp",
            "lastxp",
            "gotp",
            "prevp"
          ],
          "line": 1475
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_search_multi_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1412-1450",
          "snippet": "STATIC xfs_bmbt_rec_host_t *\t\t/* pointer to found extent entry */\nxfs_bmap_search_multi_extents(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number searched for */\n\tint\t\t*eofp,\t\t/* out: end of file found */\n\txfs_extnum_t\t*lastxp,\t/* out: last extent index */\n\txfs_bmbt_irec_t\t*gotp,\t\t/* out: extent entry found */\n\txfs_bmbt_irec_t\t*prevp)\t\t/* out: previous extent entry found */\n{\n\txfs_bmbt_rec_host_t *ep;\t\t/* extent record pointer */\n\txfs_extnum_t\tlastx;\t\t/* last extent index */\n\n\t/*\n\t * Initialize the extent entry structure to catch access to\n\t * uninitialized br_startblock field.\n\t */\n\tgotp->br_startoff = 0xffa5a5a5a5a5a5a5LL;\n\tgotp->br_blockcount = 0xa55a5a5a5a5a5a5aLL;\n\tgotp->br_state = XFS_EXT_INVALID;\n\tgotp->br_startblock = 0xffffa5a5a5a5a5a5LL;\n\tprevp->br_startoff = NULLFILEOFF;\n\n\tep = xfs_iext_bno_to_ext(ifp, bno, &lastx);\n\tif (lastx > 0) {\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx - 1), prevp);\n\t}\n\tif (lastx < (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))) {\n\t\txfs_bmbt_get_all(ep, gotp);\n\t\t*eofp = 0;\n\t} else {\n\t\tif (lastx > 0) {\n\t\t\t*gotp = *prevp;\n\t\t}\n\t\t*eofp = 1;\n\t\tep = NULL;\n\t}\n\t*lastxp = lastx;\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_bmbt_rec_host_t *\t\t/* pointer to found extent entry */\nxfs_bmap_search_multi_extents(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number searched for */\n\tint\t\t*eofp,\t\t/* out: end of file found */\n\txfs_extnum_t\t*lastxp,\t/* out: last extent index */\n\txfs_bmbt_irec_t\t*gotp,\t\t/* out: extent entry found */\n\txfs_bmbt_irec_t\t*prevp)\t\t/* out: previous extent entry found */\n{\n\txfs_bmbt_rec_host_t *ep;\t\t/* extent record pointer */\n\txfs_extnum_t\tlastx;\t\t/* last extent index */\n\n\t/*\n\t * Initialize the extent entry structure to catch access to\n\t * uninitialized br_startblock field.\n\t */\n\tgotp->br_startoff = 0xffa5a5a5a5a5a5a5LL;\n\tgotp->br_blockcount = 0xa55a5a5a5a5a5a5aLL;\n\tgotp->br_state = XFS_EXT_INVALID;\n\tgotp->br_startblock = 0xffffa5a5a5a5a5a5LL;\n\tprevp->br_startoff = NULLFILEOFF;\n\n\tep = xfs_iext_bno_to_ext(ifp, bno, &lastx);\n\tif (lastx > 0) {\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx - 1), prevp);\n\t}\n\tif (lastx < (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))) {\n\t\txfs_bmbt_get_all(ep, gotp);\n\t\t*eofp = 0;\n\t} else {\n\t\tif (lastx > 0) {\n\t\t\t*gotp = *prevp;\n\t\t}\n\t\t*eofp = 1;\n\t\tep = NULL;\n\t}\n\t*lastxp = lastx;\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "fork"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_STATS_INC",
          "args": [
            "xs_look_exlist"
          ],
          "line": 1472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_bmbt_rec_host_t *                 /* pointer to found extent entry */\nxfs_bmap_search_extents(\n\txfs_inode_t     *ip,            /* incore inode pointer */\n\txfs_fileoff_t   bno,            /* block number searched for */\n\tint             fork,      \t/* data or attr fork */\n\tint             *eofp,          /* out: end of file found */\n\txfs_extnum_t    *lastxp,        /* out: last extent index */\n\txfs_bmbt_irec_t *gotp,          /* out: extent entry found */\n\txfs_bmbt_irec_t *prevp)         /* out: previous extent entry found */\n{\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_rec_host_t  *ep;            /* extent record pointer */\n\n\tXFS_STATS_INC(xs_look_exlist);\n\tifp = XFS_IFORK_PTR(ip, fork);\n\n\tep = xfs_bmap_search_multi_extents(ifp, bno, eofp, lastxp, gotp, prevp);\n\n\tif (unlikely(!(gotp->br_startblock) && (*lastxp != NULLEXTNUM) &&\n\t\t     !(XFS_IS_REALTIME_INODE(ip) && fork == XFS_DATA_FORK))) {\n\t\txfs_alert_tag(ip->i_mount, XFS_PTAG_FSBLOCK_ZERO,\n\t\t\t\t\"Access to block zero in inode %llu \"\n\t\t\t\t\"start_block: %llx start_off: %llx \"\n\t\t\t\t\"blkcnt: %llx extent-state: %x lastx: %x\",\n\t\t\t(unsigned long long)ip->i_ino,\n\t\t\t(unsigned long long)gotp->br_startblock,\n\t\t\t(unsigned long long)gotp->br_startoff,\n\t\t\t(unsigned long long)gotp->br_blockcount,\n\t\t\tgotp->br_state, *lastxp);\n\t\t*lastxp = NULLEXTNUM;\n\t\t*eofp = 1;\n\t\treturn NULL;\n\t}\n\treturn ep;\n}"
  },
  {
    "function_name": "xfs_bmap_search_multi_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1412-1450",
    "snippet": "STATIC xfs_bmbt_rec_host_t *\t\t/* pointer to found extent entry */\nxfs_bmap_search_multi_extents(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number searched for */\n\tint\t\t*eofp,\t\t/* out: end of file found */\n\txfs_extnum_t\t*lastxp,\t/* out: last extent index */\n\txfs_bmbt_irec_t\t*gotp,\t\t/* out: extent entry found */\n\txfs_bmbt_irec_t\t*prevp)\t\t/* out: previous extent entry found */\n{\n\txfs_bmbt_rec_host_t *ep;\t\t/* extent record pointer */\n\txfs_extnum_t\tlastx;\t\t/* last extent index */\n\n\t/*\n\t * Initialize the extent entry structure to catch access to\n\t * uninitialized br_startblock field.\n\t */\n\tgotp->br_startoff = 0xffa5a5a5a5a5a5a5LL;\n\tgotp->br_blockcount = 0xa55a5a5a5a5a5a5aLL;\n\tgotp->br_state = XFS_EXT_INVALID;\n\tgotp->br_startblock = 0xffffa5a5a5a5a5a5LL;\n\tprevp->br_startoff = NULLFILEOFF;\n\n\tep = xfs_iext_bno_to_ext(ifp, bno, &lastx);\n\tif (lastx > 0) {\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx - 1), prevp);\n\t}\n\tif (lastx < (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))) {\n\t\txfs_bmbt_get_all(ep, gotp);\n\t\t*eofp = 0;\n\t} else {\n\t\tif (lastx > 0) {\n\t\t\t*gotp = *prevp;\n\t\t}\n\t\t*eofp = 1;\n\t\tep = NULL;\n\t}\n\t*lastxp = lastx;\n\treturn ep;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmbt_get_all",
          "args": [
            "ep",
            "gotp"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "123-129",
          "snippet": "void\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_get_all(\n\txfs_bmbt_rec_host_t *r,\n\txfs_bmbt_irec_t *s)\n{\n\t__xfs_bmbt_get_all(r->l0, r->l1, s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "lastx - 1"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_bno_to_ext",
          "args": [
            "ifp",
            "bno",
            "&lastx"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_bno_to_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "1528-1592",
          "snippet": "xfs_bmbt_rec_host_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\txfs_extnum_t\t*idxp)\t\t/* index of target extent */\n{\n\txfs_bmbt_rec_host_t *base;\t/* pointer to first extent */\n\txfs_filblks_t\tblockcount = 0;\t/* number of blocks in extent */\n\txfs_bmbt_rec_host_t *ep = NULL;\t/* pointer to target extent */\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\tint\t\thigh;\t\t/* upper boundary in search */\n\txfs_extnum_t\tidx = 0;\t/* index of target extent */\n\tint\t\tlow;\t\t/* lower boundary in search */\n\txfs_extnum_t\tnextents;\t/* number of file extents */\n\txfs_fileoff_t\tstartoff = 0;\t/* start offset of extent */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*idxp = 0;\n\t\treturn NULL;\n\t}\n\tlow = 0;\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t/* Find target extent list */\n\t\tint\terp_idx = 0;\n\t\terp = xfs_iext_bno_to_irec(ifp, bno, &erp_idx);\n\t\tbase = erp->er_extbuf;\n\t\thigh = erp->er_extcount - 1;\n\t} else {\n\t\tbase = ifp->if_u1.if_extents;\n\t\thigh = nextents - 1;\n\t}\n\t/* Binary search extent records */\n\twhile (low <= high) {\n\t\tidx = (low + high) >> 1;\n\t\tep = base + idx;\n\t\tstartoff = xfs_bmbt_get_startoff(ep);\n\t\tblockcount = xfs_bmbt_get_blockcount(ep);\n\t\tif (bno < startoff) {\n\t\t\thigh = idx - 1;\n\t\t} else if (bno >= startoff + blockcount) {\n\t\t\tlow = idx + 1;\n\t\t} else {\n\t\t\t/* Convert back to file-based extent index */\n\t\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\t\tidx += erp->er_extoff;\n\t\t\t}\n\t\t\t*idxp = idx;\n\t\t\treturn ep;\n\t\t}\n\t}\n\t/* Convert back to file-based extent index */\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tidx += erp->er_extoff;\n\t}\n\tif (bno >= startoff + blockcount) {\n\t\tif (++idx == nextents) {\n\t\t\tep = NULL;\n\t\t} else {\n\t\t\tep = xfs_iext_get_ext(ifp, idx);\n\t\t}\n\t}\n\t*idxp = idx;\n\treturn ep;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\t\t\t/* pointer to found extent record */\nxfs_iext_bno_to_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number to search for */\n\txfs_extnum_t\t*idxp)\t\t/* index of target extent */\n{\n\txfs_bmbt_rec_host_t *base;\t/* pointer to first extent */\n\txfs_filblks_t\tblockcount = 0;\t/* number of blocks in extent */\n\txfs_bmbt_rec_host_t *ep = NULL;\t/* pointer to target extent */\n\txfs_ext_irec_t\t*erp = NULL;\t/* indirection array pointer */\n\tint\t\thigh;\t\t/* upper boundary in search */\n\txfs_extnum_t\tidx = 0;\t/* index of target extent */\n\tint\t\tlow;\t\t/* lower boundary in search */\n\txfs_extnum_t\tnextents;\t/* number of file extents */\n\txfs_fileoff_t\tstartoff = 0;\t/* start offset of extent */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tif (nextents == 0) {\n\t\t*idxp = 0;\n\t\treturn NULL;\n\t}\n\tlow = 0;\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t/* Find target extent list */\n\t\tint\terp_idx = 0;\n\t\terp = xfs_iext_bno_to_irec(ifp, bno, &erp_idx);\n\t\tbase = erp->er_extbuf;\n\t\thigh = erp->er_extcount - 1;\n\t} else {\n\t\tbase = ifp->if_u1.if_extents;\n\t\thigh = nextents - 1;\n\t}\n\t/* Binary search extent records */\n\twhile (low <= high) {\n\t\tidx = (low + high) >> 1;\n\t\tep = base + idx;\n\t\tstartoff = xfs_bmbt_get_startoff(ep);\n\t\tblockcount = xfs_bmbt_get_blockcount(ep);\n\t\tif (bno < startoff) {\n\t\t\thigh = idx - 1;\n\t\t} else if (bno >= startoff + blockcount) {\n\t\t\tlow = idx + 1;\n\t\t} else {\n\t\t\t/* Convert back to file-based extent index */\n\t\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\t\tidx += erp->er_extoff;\n\t\t\t}\n\t\t\t*idxp = idx;\n\t\t\treturn ep;\n\t\t}\n\t}\n\t/* Convert back to file-based extent index */\n\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\tidx += erp->er_extoff;\n\t}\n\tif (bno >= startoff + blockcount) {\n\t\tif (++idx == nextents) {\n\t\t\tep = NULL;\n\t\t} else {\n\t\t\tep = xfs_iext_get_ext(ifp, idx);\n\t\t}\n\t}\n\t*idxp = idx;\n\treturn ep;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_bmbt_rec_host_t *\t\t/* pointer to found extent entry */\nxfs_bmap_search_multi_extents(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_fileoff_t\tbno,\t\t/* block number searched for */\n\tint\t\t*eofp,\t\t/* out: end of file found */\n\txfs_extnum_t\t*lastxp,\t/* out: last extent index */\n\txfs_bmbt_irec_t\t*gotp,\t\t/* out: extent entry found */\n\txfs_bmbt_irec_t\t*prevp)\t\t/* out: previous extent entry found */\n{\n\txfs_bmbt_rec_host_t *ep;\t\t/* extent record pointer */\n\txfs_extnum_t\tlastx;\t\t/* last extent index */\n\n\t/*\n\t * Initialize the extent entry structure to catch access to\n\t * uninitialized br_startblock field.\n\t */\n\tgotp->br_startoff = 0xffa5a5a5a5a5a5a5LL;\n\tgotp->br_blockcount = 0xa55a5a5a5a5a5a5aLL;\n\tgotp->br_state = XFS_EXT_INVALID;\n\tgotp->br_startblock = 0xffffa5a5a5a5a5a5LL;\n\tprevp->br_startoff = NULLFILEOFF;\n\n\tep = xfs_iext_bno_to_ext(ifp, bno, &lastx);\n\tif (lastx > 0) {\n\t\txfs_bmbt_get_all(xfs_iext_get_ext(ifp, lastx - 1), prevp);\n\t}\n\tif (lastx < (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))) {\n\t\txfs_bmbt_get_all(ep, gotp);\n\t\t*eofp = 0;\n\t} else {\n\t\tif (lastx > 0) {\n\t\t\t*gotp = *prevp;\n\t\t}\n\t\t*eofp = 1;\n\t\tep = NULL;\n\t}\n\t*lastxp = lastx;\n\treturn ep;\n}"
  },
  {
    "function_name": "xfs_bmap_read_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1269-1402",
    "snippet": "int\t\t\t\t\t/* error */\nxfs_bmap_read_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode */\n\tint\t\t\twhichfork) /* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_exntfmt_t\t\texntf;\t/* XFS_EXTFMT_NOSTATE, if checking */\n\txfs_extnum_t\t\ti, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\t/* REFERENCED */\n\txfs_extnum_t\t\troom;\t/* number of entries there's room for */\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\texntf = (whichfork != XFS_DATA_FORK) ? XFS_EXTFMT_NOSTATE :\n\t\t\t\t\tXFS_EXTFMT_INODE(ip);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\tXFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\txfs_trans_brelse(tp, bp);\n\t}\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\troom = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\ti = 0;\n\t/*\n\t * Loop over all leaf nodes.  Copy information to the extent records.\n\t */\n\tfor (;;) {\n\t\txfs_bmbt_rec_t\t*frp;\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\t\txfs_extnum_t\tstart;\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\t\tif (unlikely(i + num_recs > room)) {\n\t\t\tASSERT(i + num_recs <= room);\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt dinode %Lu, (btree extents).\",\n\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_bmap_read_extents(1)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, ip->i_mount, block);\n\t\t\tgoto error0;\n\t\t}\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, 0),\n\t\t\terror0);\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\tif (nextbno != NULLFSBLOCK)\n\t\t\txfs_btree_reada_bufl(mp, nextbno, 1,\n\t\t\t\t\t     &xfs_bmbt_buf_ops);\n\t\t/*\n\t\t * Copy records into the extent records.\n\t\t */\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tstart = i;\n\t\tfor (j = 0; j < num_recs; j++, i++, frp++) {\n\t\t\txfs_bmbt_rec_host_t *trp = xfs_iext_get_ext(ifp, i);\n\t\t\ttrp->l0 = be64_to_cpu(frp->l0);\n\t\t\ttrp->l1 = be64_to_cpu(frp->l1);\n\t\t}\n\t\tif (exntf == XFS_EXTFMT_NOSTATE) {\n\t\t\t/*\n\t\t\t * Check all attribute bmap btree records and\n\t\t\t * any \"older\" data bmap btree records for a\n\t\t\t * set bit in the \"extent flag\" position.\n\t\t\t */\n\t\t\tif (unlikely(xfs_check_nostate_extents(ifp,\n\t\t\t\t\tstart, num_recs))) {\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_read_extents(2)\",\n\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t ip->i_mount);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\tXFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tASSERT(i == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)));\n\tASSERT(i == XFS_IFORK_NEXTENTS(ip, whichfork));\n\tXFS_BMAP_TRACE_EXLIST(ip, i, whichfork);\n\treturn 0;\nerror0:\n\txfs_trans_brelse(tp, bp);\n\treturn -EFSCORRUPTED;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "tp",
            "bp"
          ],
          "line": 1400
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_TRACE_EXLIST",
          "args": [
            "ip",
            "i",
            "whichfork"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == XFS_IFORK_NEXTENTS(ip, whichfork)"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_bufl",
          "args": [
            "mp",
            "tp",
            "bno",
            "0",
            "&bp",
            "XFS_BMAP_BTREE_REF",
            "&xfs_bmbt_buf_ops"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_bufl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "699-723",
          "snippet": "int\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_ERROR_REPORT",
          "args": [
            "\"xfs_bmap_read_extents(2)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "xfs_check_nostate_extents(ifp,\n\t\t\t\t\tstart, num_recs)"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_check_nostate_extents",
          "args": [
            "ifp",
            "start",
            "num_recs"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_nostate_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "380-395",
          "snippet": "int\nxfs_check_nostate_extents(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\txfs_extnum_t\t\tnum)\n{\n\tfor (; num > 0; num--, idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\tif ((ep->l0 >>\n\t\t     (64 - BMBT_EXNTFLAG_BITLEN)) != 0) {\n\t\t\tASSERT(0);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_check_nostate_extents(\n\txfs_ifork_t\t\t*ifp,\n\txfs_extnum_t\t\tidx,\n\txfs_extnum_t\t\tnum)\n{\n\tfor (; num > 0; num--, idx++) {\n\t\txfs_bmbt_rec_host_t *ep = xfs_iext_get_ext(ifp, idx);\n\t\tif ((ep->l0 >>\n\t\t     (64 - BMBT_EXNTFLAG_BITLEN)) != 0) {\n\t\t\tASSERT(0);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "frp->l1"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "frp->l0"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "i"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_REC_ADDR",
          "args": [
            "mp",
            "block",
            "1"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_reada_bufl",
          "args": [
            "mp",
            "nextbno",
            "1",
            "&xfs_bmbt_buf_ops"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_reada_bufl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "730-742",
          "snippet": "void\nxfs_btree_reada_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_reada_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\txfs_extlen_t\t\tcount,\t\t/* count of filesystem blocks */\n\tconst struct xfs_buf_ops *ops)\n{\n\txfs_daddr_t\t\td;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\txfs_buf_readahead(mp->m_ddev_targp, d, mp->m_bsize * count, ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_rightsib"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "xfs_bmap_sanity_check(mp, bp, 0)",
            "error0"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_sanity_check",
          "args": [
            "mp",
            "bp",
            "0"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_sanity_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "251-269",
          "snippet": "STATIC int\nxfs_bmap_sanity_check(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block  *block = XFS_BUF_TO_BLOCK(bp);\n\n\tif (block->bb_magic != cpu_to_be32(XFS_BMAP_CRC_MAGIC) &&\n\t    block->bb_magic != cpu_to_be32(XFS_BMAP_MAGIC))\n\t\treturn 0;\n\n\tif (be16_to_cpu(block->bb_level) != level ||\n\t    be16_to_cpu(block->bb_numrecs) == 0 ||\n\t    be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_sanity_check(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block  *block = XFS_BUF_TO_BLOCK(bp);\n\n\tif (block->bb_magic != cpu_to_be32(XFS_BMAP_CRC_MAGIC) &&\n\t    block->bb_magic != cpu_to_be32(XFS_BMAP_MAGIC))\n\t\treturn 0;\n\n\tif (be16_to_cpu(block->bb_level) != level ||\n\t    be16_to_cpu(block->bb_numrecs) == 0 ||\n\t    be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_CORRUPTION_ERROR",
          "args": [
            "\"xfs_bmap_read_extents(1)\"",
            "XFS_ERRLEVEL_LOW",
            "ip->i_mount",
            "block"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "ip->i_mount",
            "\"corrupt dinode %Lu, (btree extents).\"",
            "(unsigned long long) ip->i_ino"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i + num_recs <= room"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "i + num_recs > room"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "XFS_FSB_SANITY_CHECK(mp, bno)",
            "error0"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_SANITY_CHECK",
          "args": [
            "mp",
            "bno"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*pp"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "1",
            "mp->m_bmap_dmxr[1]"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "xfs_bmap_sanity_check(mp, bp, level)",
            "error0"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "bno"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "bno"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno != NULLFSBLOCK"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*pp"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "1",
            "ifp->if_broot_bytes"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level > 0"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_EXTFMT_INODE",
          "args": [
            "ip"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_bmap_read_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode */\n\tint\t\t\twhichfork) /* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_exntfmt_t\t\texntf;\t/* XFS_EXTFMT_NOSTATE, if checking */\n\txfs_extnum_t\t\ti, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\t/* REFERENCED */\n\txfs_extnum_t\t\troom;\t/* number of entries there's room for */\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\texntf = (whichfork != XFS_DATA_FORK) ? XFS_EXTFMT_NOSTATE :\n\t\t\t\t\tXFS_EXTFMT_INODE(ip);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\tXFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\txfs_trans_brelse(tp, bp);\n\t}\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\troom = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\ti = 0;\n\t/*\n\t * Loop over all leaf nodes.  Copy information to the extent records.\n\t */\n\tfor (;;) {\n\t\txfs_bmbt_rec_t\t*frp;\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\t\txfs_extnum_t\tstart;\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\t\tif (unlikely(i + num_recs > room)) {\n\t\t\tASSERT(i + num_recs <= room);\n\t\t\txfs_warn(ip->i_mount,\n\t\t\t\t\"corrupt dinode %Lu, (btree extents).\",\n\t\t\t\t(unsigned long long) ip->i_ino);\n\t\t\tXFS_CORRUPTION_ERROR(\"xfs_bmap_read_extents(1)\",\n\t\t\t\tXFS_ERRLEVEL_LOW, ip->i_mount, block);\n\t\t\tgoto error0;\n\t\t}\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, 0),\n\t\t\terror0);\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\t\tif (nextbno != NULLFSBLOCK)\n\t\t\txfs_btree_reada_bufl(mp, nextbno, 1,\n\t\t\t\t\t     &xfs_bmbt_buf_ops);\n\t\t/*\n\t\t * Copy records into the extent records.\n\t\t */\n\t\tfrp = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tstart = i;\n\t\tfor (j = 0; j < num_recs; j++, i++, frp++) {\n\t\t\txfs_bmbt_rec_host_t *trp = xfs_iext_get_ext(ifp, i);\n\t\t\ttrp->l0 = be64_to_cpu(frp->l0);\n\t\t\ttrp->l1 = be64_to_cpu(frp->l1);\n\t\t}\n\t\tif (exntf == XFS_EXTFMT_NOSTATE) {\n\t\t\t/*\n\t\t\t * Check all attribute bmap btree records and\n\t\t\t * any \"older\" data bmap btree records for a\n\t\t\t * set bit in the \"extent flag\" position.\n\t\t\t */\n\t\t\tif (unlikely(xfs_check_nostate_extents(ifp,\n\t\t\t\t\tstart, num_recs))) {\n\t\t\t\tXFS_ERROR_REPORT(\"xfs_bmap_read_extents(2)\",\n\t\t\t\t\t\t XFS_ERRLEVEL_LOW,\n\t\t\t\t\t\t ip->i_mount);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t}\n\t\txfs_trans_brelse(tp, bp);\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\t\terror = xfs_btree_read_bufl(mp, tp, bno, 0, &bp,\n\t\t\t\tXFS_BMAP_BTREE_REF, &xfs_bmbt_buf_ops);\n\t\tif (error)\n\t\t\treturn error;\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tASSERT(i == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)));\n\tASSERT(i == XFS_IFORK_NEXTENTS(ip, whichfork));\n\tXFS_BMAP_TRACE_EXLIST(ip, i, whichfork);\n\treturn 0;\nerror0:\n\txfs_trans_brelse(tp, bp);\n\treturn -EFSCORRUPTED;\n}"
  },
  {
    "function_name": "xfs_bmap_add_attrfork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1126-1257",
    "snippet": "int\t\t\t\t\t\t/* error code */\nxfs_bmap_add_attrfork(\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\tsize,\t\t/* space new attribute needs */\n\tint\t\t\trsvd)\t\t/* xact may use reserved blks */\n{\n\txfs_fsblock_t\t\tfirstblock;\t/* 1st block/ag allocated */\n\txfs_bmap_free_t\t\tflist;\t\t/* freed extent records */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint\t\t\tblks;\t\t/* space reservation */\n\tint\t\t\tversion = 1;\t/* superblock attr version */\n\tint\t\t\tcommitted;\t/* xaction was committed */\n\tint\t\t\tlogflags;\t/* logging flags */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tcancel_flags = 0;\n\n\tASSERT(XFS_IFORK_Q(ip) == 0);\n\n\tmp = ip->i_mount;\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_ADDAFORK);\n\tblks = XFS_ADDAFORK_SPACE_RES(mp);\n\tif (rsvd)\n\t\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_addafork, blks, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_trans_reserve_quota_nblks(tp, ip, blks, 0, rsvd ?\n\t\t\tXFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\tXFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\tgoto trans_cancel;\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (XFS_IFORK_Q(ip))\n\t\tgoto trans_cancel;\n\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS) {\n\t\t/*\n\t\t * For inodes coming from pre-6.2 filesystems.\n\t\t */\n\t\tASSERT(ip->i_d.di_aformat == 0);\n\t\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\t}\n\tASSERT(ip->i_d.di_anextents == 0);\n\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tip->i_d.di_forkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tip->i_d.di_forkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tip->i_d.di_forkoff = xfs_attr_shortform_bytesfit(ip, size);\n\t\tif (!ip->i_d.di_forkoff)\n\t\t\tip->i_d.di_forkoff = xfs_default_attroffset(ip) >> 3;\n\t\telse if (mp->m_flags & XFS_MOUNT_ATTR2)\n\t\t\tversion = 2;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t\tgoto trans_cancel;\n\t}\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP);\n\tip->i_afp->if_flags = XFS_IFEXTENTS;\n\tlogflags = 0;\n\txfs_bmap_init(&flist, &firstblock);\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\terror = xfs_bmap_add_attrfork_local(tp, ip, &firstblock, &flist,\n\t\t\t&logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_bmap_add_attrfork_extents(tp, ip, &firstblock,\n\t\t\t&flist, &logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_bmap_add_attrfork_btree(tp, ip, &firstblock, &flist,\n\t\t\t&logflags);\n\t\tbreak;\n\tdefault:\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (error)\n\t\tgoto bmap_cancel;\n\tif (!xfs_sb_version_hasattr(&mp->m_sb) ||\n\t   (!xfs_sb_version_hasattr2(&mp->m_sb) && version == 2)) {\n\t\tbool log_sb = false;\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr(&mp->m_sb);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb) && version == 2) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tif (log_sb)\n\t\t\txfs_log_sb(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &flist, &committed);\n\tif (error)\n\t\tgoto bmap_cancel;\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nbmap_cancel:\n\txfs_bmap_cancel(&flist);\ntrans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_iunlock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iunlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "235-263",
          "snippet": "void\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_iunlock(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\t/*\n\t * You can't set both SHARED and EXCL for the same lock,\n\t * and only XFS_IOLOCK_SHARED, XFS_IOLOCK_EXCL, XFS_ILOCK_SHARED,\n\t * and XFS_ILOCK_EXCL are valid values to set in lock_flags.\n\t */\n\tASSERT((lock_flags & (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL)) !=\n\t       (XFS_IOLOCK_SHARED | XFS_IOLOCK_EXCL));\n\tASSERT((lock_flags & (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL)) !=\n\t       (XFS_ILOCK_SHARED | XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_LOCK_MASK | XFS_LOCK_DEP_MASK)) == 0);\n\tASSERT(lock_flags != 0);\n\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_iolock);\n\telse if (lock_flags & XFS_IOLOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_iolock);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrunlock_excl(&ip->i_lock);\n\telse if (lock_flags & XFS_ILOCK_SHARED)\n\t\tmrunlock_shared(&ip->i_lock);\n\n\ttrace_xfs_iunlock(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "cancel_flags"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_cancel",
          "args": [
            "&flist"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "658-673",
          "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "XFS_TRANS_RELEASE_LOG_RES"
          ],
          "line": 1247
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_finish",
          "args": [
            "&tp",
            "&flist",
            "&committed"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_bmap_util.c",
          "lines": "68-143",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error */\nxfs_bmap_finish(\n\txfs_trans_t\t\t**tp,\t\t/* transaction pointer addr */\n\txfs_bmap_free_t\t\t*flist,\t\t/* i/o: list extents to free */\n\tint\t\t\t*committed)\t/* xact committed or not */\n{\n\txfs_efd_log_item_t\t*efd;\t\t/* extent free data */\n\txfs_efi_log_item_t\t*efi;\t\t/* extent free intention */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_bmap_free_item_t\t*free;\t\t/* free extent item */\n\tstruct xfs_trans_res\ttres;\t\t/* new log reservation */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount structure */\n\txfs_bmap_free_item_t\t*next;\t\t/* next item on free list */\n\txfs_trans_t\t\t*ntp;\t\t/* new transaction pointer */\n\n\tASSERT((*tp)->t_flags & XFS_TRANS_PERM_LOG_RES);\n\tif (flist->xbf_count == 0) {\n\t\t*committed = 0;\n\t\treturn 0;\n\t}\n\tntp = *tp;\n\tefi = xfs_trans_get_efi(ntp, flist->xbf_count);\n\tfor (free = flist->xbf_first; free; free = free->xbfi_next)\n\t\txfs_trans_log_efi_extent(ntp, efi, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\n\ttres.tr_logres = ntp->t_log_res;\n\ttres.tr_logcount = ntp->t_log_count;\n\ttres.tr_logflags = XFS_TRANS_PERM_LOG_RES;\n\tntp = xfs_trans_dup(*tp);\n\terror = xfs_trans_commit(*tp, 0);\n\t*tp = ntp;\n\t*committed = 1;\n\t/*\n\t * We have a new transaction, so we should return committed=1,\n\t * even though we're returning an error.\n\t */\n\tif (error)\n\t\treturn error;\n\n\t/*\n\t * transaction commit worked ok so we can drop the extra ticket\n\t * reference that we gained in xfs_trans_dup()\n\t */\n\txfs_log_ticket_put(ntp->t_ticket);\n\n\terror = xfs_trans_reserve(ntp, &tres, 0, 0);\n\tif (error)\n\t\treturn error;\n\tefd = xfs_trans_get_efd(ntp, efi, flist->xbf_count);\n\tfor (free = flist->xbf_first; free != NULL; free = next) {\n\t\tnext = free->xbfi_next;\n\t\tif ((error = xfs_free_extent(ntp, free->xbfi_startblock,\n\t\t\t\tfree->xbfi_blockcount))) {\n\t\t\t/*\n\t\t\t * The bmap free list will be cleaned up at a\n\t\t\t * higher level.  The EFI will be canceled when\n\t\t\t * this transaction is aborted.\n\t\t\t * Need to force shutdown here to make sure it\n\t\t\t * happens, since this transaction may not be\n\t\t\t * dirty yet.\n\t\t\t */\n\t\t\tmp = ntp->t_mountp;\n\t\t\tif (!XFS_FORCED_SHUTDOWN(mp))\n\t\t\t\txfs_force_shutdown(mp,\n\t\t\t\t\t\t   (error == -EFSCORRUPTED) ?\n\t\t\t\t\t\t   SHUTDOWN_CORRUPT_INCORE :\n\t\t\t\t\t\t   SHUTDOWN_META_IO_ERROR);\n\t\t\treturn error;\n\t\t}\n\t\txfs_trans_log_efd_extent(ntp, efd, free->xbfi_startblock,\n\t\t\tfree->xbfi_blockcount);\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_log_sb",
          "args": [
            "tp"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "767-777",
          "snippet": "void\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp, mp, 0);\n\n\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp, mp, 0);\n\n\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_addattr2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_addattr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "455-459",
          "snippet": "static inline void xfs_sb_version_addattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_MOREBITSBIT;\n\tsbp->sb_features2 |= XFS_SB_VERSION2_ATTR2BIT;\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */",
            "#define\tXFS_SB_VERSION_MOREBITSBIT\t0x8000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define\tXFS_SB_VERSION_MOREBITSBIT\t0x8000\n\nstatic inline void xfs_sb_version_addattr2(struct xfs_sb *sbp)\n{\n\tsbp->sb_versionnum |= XFS_SB_VERSION_MOREBITSBIT;\n\tsbp->sb_features2 |= XFS_SB_VERSION2_ATTR2BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hasattr2",
          "args": [
            "&mp->m_sb"
          ],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hasattr2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "448-453",
          "snippet": "static inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}",
          "includes": [],
          "macros_used": [
            "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */",
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define XFS_SB_VERSION2_ATTR2BIT\t0x00000008\t/* Inline attr rework */\n#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline bool xfs_sb_version_hasattr2(struct xfs_sb *sbp)\n{\n\treturn (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) ||\n\t       (xfs_sb_version_hasmorebits(sbp) &&\n\t\t(sbp->sb_features2 & XFS_SB_VERSION2_ATTR2BIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_inode",
          "args": [
            "tp",
            "ip",
            "logflags"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "101-135",
          "snippet": "void\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_inode(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tflags)\n{\n\tASSERT(ip->i_itemp != NULL);\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\n\t/*\n\t * First time we log the inode in a transaction, bump the inode change\n\t * counter if it is configured for this to occur. We don't use\n\t * inode_inc_version() because there is no need for extra locking around\n\t * i_version as we already hold the inode locked exclusively for\n\t * metadata modification.\n\t */\n\tif (!(ip->i_itemp->ili_item.li_desc->lid_flags & XFS_LID_DIRTY) &&\n\t    IS_I_VERSION(VFS_I(ip))) {\n\t\tip->i_d.di_changecount = ++VFS_I(ip)->i_version;\n\t\tflags |= XFS_ILOG_CORE;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tip->i_itemp->ili_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * Always OR in the bits from the ili_last_fields field.\n\t * This is to coordinate with the xfs_iflush() and xfs_iflush_done()\n\t * routines in the eventual clearing of the ili_fields bits.\n\t * See the big comment in xfs_iflush() for an explanation of\n\t * this coordination mechanism.\n\t */\n\tflags |= ip->i_itemp->ili_last_fields;\n\tip->i_itemp->ili_fields |= flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_attrfork_btree",
          "args": [
            "tp",
            "ip",
            "&firstblock",
            "&flist",
            "&logflags"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_attrfork_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1009-1047",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* btree cursor */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount struct */\n\tint\t\t\tstat;\t\t/* newroot status */\n\n\tmp = ip->i_mount;\n\tif (ip->i_df.if_broot_bytes <= XFS_IFORK_DSIZE(ip))\n\t\t*flags |= XFS_ILOG_DBROOT;\n\telse {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, XFS_DATA_FORK);\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tif ((error = xfs_bmbt_lookup_ge(cur, 0, 0, 0, &stat)))\n\t\t\tgoto error0;\n\t\t/* must be at least one entry */\n\t\tXFS_WANT_CORRUPTED_GOTO(stat == 1, error0);\n\t\tif ((error = xfs_btree_new_iroot(cur, flags, &stat)))\n\t\t\tgoto error0;\n\t\tif (stat == 0) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\tcur->bc_private.b.allocated = 0;\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t}\n\treturn 0;\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* btree cursor */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount struct */\n\tint\t\t\tstat;\t\t/* newroot status */\n\n\tmp = ip->i_mount;\n\tif (ip->i_df.if_broot_bytes <= XFS_IFORK_DSIZE(ip))\n\t\t*flags |= XFS_ILOG_DBROOT;\n\telse {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, XFS_DATA_FORK);\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tif ((error = xfs_bmbt_lookup_ge(cur, 0, 0, 0, &stat)))\n\t\t\tgoto error0;\n\t\t/* must be at least one entry */\n\t\tXFS_WANT_CORRUPTED_GOTO(stat == 1, error0);\n\t\tif ((error = xfs_btree_new_iroot(cur, flags, &stat)))\n\t\t\tgoto error0;\n\t\tif (stat == 0) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\tcur->bc_private.b.allocated = 0;\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t}\n\treturn 0;\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_attrfork_extents",
          "args": [
            "tp",
            "ip",
            "&firstblock",
            "&flist",
            "&logflags"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_attrfork_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1052-1074",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_extents(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tif (ip->i_d.di_nextents * sizeof(xfs_bmbt_rec_t) <= XFS_IFORK_DSIZE(ip))\n\t\treturn 0;\n\tcur = NULL;\n\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist, &cur, 0,\n\t\tflags, XFS_DATA_FORK);\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_extents(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tif (ip->i_d.di_nextents * sizeof(xfs_bmbt_rec_t) <= XFS_IFORK_DSIZE(ip))\n\t\treturn 0;\n\tcur = NULL;\n\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist, &cur, 0,\n\t\tflags, XFS_DATA_FORK);\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_attrfork_local",
          "args": [
            "tp",
            "ip",
            "&firstblock",
            "&flist",
            "&logflags"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_attrfork_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "1087-1120",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_local(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_da_args_t\t\tdargs;\t\t/* args for dir/attr code */\n\n\tif (ip->i_df.if_bytes <= XFS_IFORK_DSIZE(ip))\n\t\treturn 0;\n\n\tif (S_ISDIR(ip->i_d.di_mode)) {\n\t\tmemset(&dargs, 0, sizeof(dargs));\n\t\tdargs.geo = ip->i_mount->m_dir_geo;\n\t\tdargs.dp = ip;\n\t\tdargs.firstblock = firstblock;\n\t\tdargs.flist = flist;\n\t\tdargs.total = dargs.geo->fsbcount;\n\t\tdargs.whichfork = XFS_DATA_FORK;\n\t\tdargs.trans = tp;\n\t\treturn xfs_dir2_sf_to_block(&dargs);\n\t}\n\n\tif (S_ISLNK(ip->i_d.di_mode))\n\t\treturn xfs_bmap_local_to_extents(tp, ip, firstblock, 1,\n\t\t\t\t\t\t flags, XFS_DATA_FORK,\n\t\t\t\t\t\t xfs_symlink_local_to_remote);\n\n\t/* should only be called for types that support local format data */\n\tASSERT(0);\n\treturn -EFSCORRUPTED;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_local(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_da_args_t\t\tdargs;\t\t/* args for dir/attr code */\n\n\tif (ip->i_df.if_bytes <= XFS_IFORK_DSIZE(ip))\n\t\treturn 0;\n\n\tif (S_ISDIR(ip->i_d.di_mode)) {\n\t\tmemset(&dargs, 0, sizeof(dargs));\n\t\tdargs.geo = ip->i_mount->m_dir_geo;\n\t\tdargs.dp = ip;\n\t\tdargs.firstblock = firstblock;\n\t\tdargs.flist = flist;\n\t\tdargs.total = dargs.geo->fsbcount;\n\t\tdargs.whichfork = XFS_DATA_FORK;\n\t\tdargs.trans = tp;\n\t\treturn xfs_dir2_sf_to_block(&dargs);\n\t}\n\n\tif (S_ISLNK(ip->i_d.di_mode))\n\t\treturn xfs_bmap_local_to_extents(tp, ip, firstblock, 1,\n\t\t\t\t\t\t flags, XFS_DATA_FORK,\n\t\t\t\t\t\t xfs_symlink_local_to_remote);\n\n\t/* should only be called for types that support local format data */\n\tASSERT(0);\n\treturn -EFSCORRUPTED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_init",
          "args": [
            "&flist",
            "&firstblock"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.h",
          "lines": "133-137",
          "snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)\n{\n\t((flp)->xbf_first = NULL, (flp)->xbf_count = 0, \\\n\t\t(flp)->xbf_low = 0, *(fbp) = NULLFSBLOCK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_zone_zalloc",
          "args": [
            "xfs_ifork_zone",
            "KM_SLEEP"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_zalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "119-123",
          "snippet": "static inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache",
            "#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n#define KM_ZERO\t\t((__force xfs_km_flags_t)0x0010u)\n\nstatic inline void *\nkmem_zone_zalloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\treturn kmem_zone_alloc(zone, flags | KM_ZERO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_afp == NULL"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_default_attroffset",
          "args": [
            "ip"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_default_attroffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "208-224",
          "snippet": "uint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\toffset;\n\n\tif (mp->m_sb.sb_inodesize == 256) {\n\t\toffset = XFS_LITINO(mp, ip->i_d.di_version) -\n\t\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t} else {\n\t\toffset = XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n\t}\n\n\tASSERT(offset < XFS_LITINO(mp, ip->i_d.di_version));\n\treturn offset;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nuint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\toffset;\n\n\tif (mp->m_sb.sb_inodesize == 256) {\n\t\toffset = XFS_LITINO(mp, ip->i_d.di_version) -\n\t\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t} else {\n\t\toffset = XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n\t}\n\n\tASSERT(offset < XFS_LITINO(mp, ip->i_d.di_version));\n\treturn offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_attr_shortform_bytesfit",
          "args": [
            "ip",
            "size"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_attr_shortform_bytesfit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_attr_leaf.c",
          "lines": "302-392",
          "snippet": "int\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_remote.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_dir2.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_remote.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_attr_shortform_bytesfit(xfs_inode_t *dp, int bytes)\n{\n\tint offset;\n\tint minforkoff;\t/* lower limit on valid forkoff locations */\n\tint maxforkoff;\t/* upper limit on valid forkoff locations */\n\tint dsize;\n\txfs_mount_t *mp = dp->i_mount;\n\n\t/* rounded down */\n\toffset = (XFS_LITINO(mp, dp->i_d.di_version) - bytes) >> 3;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tminforkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tminforkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\treturn (offset >= minforkoff) ? minforkoff : 0;\n\t}\n\n\t/*\n\t * If the requested numbers of bytes is smaller or equal to the\n\t * current attribute fork size we can always proceed.\n\t *\n\t * Note that if_bytes in the data fork might actually be larger than\n\t * the current data fork size is due to delalloc extents. In that\n\t * case either the extent count will go down when they are converted\n\t * to real extents, or the delalloc conversion will take care of the\n\t * literal area rebalancing.\n\t */\n\tif (bytes <= XFS_IFORK_ASIZE(dp))\n\t\treturn dp->i_d.di_forkoff;\n\n\t/*\n\t * For attr2 we can try to move the forkoff if there is space in the\n\t * literal area, but for the old format we are done if there is no\n\t * space in the fixed attribute fork.\n\t */\n\tif (!(mp->m_flags & XFS_MOUNT_ATTR2))\n\t\treturn 0;\n\n\tdsize = dp->i_df.if_bytes;\n\n\tswitch (dp->i_d.di_format) {\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\t/*\n\t\t * If there is no attr fork and the data fork is extents, \n\t\t * determine if creating the default attr fork will result\n\t\t * in the extents form migrating to btree. If so, the\n\t\t * minimum offset only needs to be the space required for\n\t\t * the btree root.\n\t\t */\n\t\tif (!dp->i_d.di_forkoff && dp->i_df.if_bytes >\n\t\t    xfs_default_attroffset(dp))\n\t\t\tdsize = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\t/*\n\t\t * If we have a data btree then keep forkoff if we have one,\n\t\t * otherwise we are adding a new attr, so then we set\n\t\t * minforkoff to where the btree root can finish so we have\n\t\t * plenty of room for attrs\n\t\t */\n\t\tif (dp->i_d.di_forkoff) {\n\t\t\tif (offset < dp->i_d.di_forkoff)\n\t\t\t\treturn 0;\n\t\t\treturn dp->i_d.di_forkoff;\n\t\t}\n\t\tdsize = XFS_BMAP_BROOT_SPACE(mp, dp->i_df.if_broot);\n\t\tbreak;\n\t}\n\n\t/*\n\t * A data fork btree root must have space for at least\n\t * MINDBTPTRS key/ptr pairs if the data fork is small or empty.\n\t */\n\tminforkoff = MAX(dsize, XFS_BMDR_SPACE_CALC(MINDBTPTRS));\n\tminforkoff = roundup(minforkoff, 8) >> 3;\n\n\t/* attr fork btree root can have at least this many key/ptr pairs */\n\tmaxforkoff = XFS_LITINO(mp, dp->i_d.di_version) -\n\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\tmaxforkoff = maxforkoff >> 3;\t/* rounded down */\n\n\tif (offset >= maxforkoff)\n\t\treturn maxforkoff;\n\tif (offset >= minforkoff)\n\t\treturn offset;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "sizeof(uuid_t)",
            "8"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "roundup_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "333-338",
          "snippet": "static inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t roundup_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x * y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_ijoin",
          "args": [
            "tp",
            "ip",
            "0"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_ijoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_inode.c",
          "lines": "37-57",
          "snippet": "void\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_ijoin(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\txfs_inode_log_item_t\t*iip;\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tif (ip->i_itemp == NULL)\n\t\txfs_inode_item_init(ip, ip->i_mount);\n\tiip = ip->i_itemp;\n\n\tASSERT(iip->ili_lock_flags == 0);\n\tiip->ili_lock_flags = lock_flags;\n\n\t/*\n\t * Get a log_item_desc to point at the new item.\n\t */\n\txfs_trans_add_item(tp, &iip->ili_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_anextents == 0"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ip->i_d.di_aformat == 0"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve_quota_nblks",
          "args": [
            "tp",
            "ip",
            "blks",
            "0",
            "rsvd ?\n\t\t\tXFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\tXFS_QMOPT_RES_REGBLKS"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve_quota_nblks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "802-832",
          "snippet": "int\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_trans_reserve_quota_nblks(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*ip,\n\tlong\t\t\tnblks,\n\tlong\t\t\tninos,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) || !XFS_IS_QUOTA_ON(mp))\n\t\treturn 0;\n\tif (XFS_IS_PQUOTA_ON(mp))\n\t\tflags |= XFS_QMOPT_ENOSPC;\n\n\tASSERT(!xfs_is_quota_inode(&mp->m_sb, ip->i_ino));\n\n\tASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\n\tASSERT((flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_RTBLKS ||\n\t       (flags & ~(XFS_QMOPT_FORCE_RES | XFS_QMOPT_ENOSPC)) ==\n\t\t\t\tXFS_TRANS_DQ_RES_BLKS);\n\n\t/*\n\t * Reserve nblks against these dquots, with trans as the mediator.\n\t */\n\treturn xfs_trans_reserve_quota_bydquots(tp, mp,\n\t\t\t\t\t\tip->i_udquot, ip->i_gdquot,\n\t\t\t\t\t\tip->i_pdquot,\n\t\t\t\t\t\tnblks, ninos, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ilock",
          "args": [
            "ip",
            "XFS_ILOCK_EXCL"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilock_demote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_inode.c",
          "lines": "269-283",
          "snippet": "void\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_attr.h\"",
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_bmap_btree.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_attr.h\"\n#include \"xfs_attr_sf.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nSTATIC int xfs_iunlink_remove(xfs_trans_t *, xfs_inode_t *);\n\nvoid\nxfs_ilock_demote(\n\txfs_inode_t\t\t*ip,\n\tuint\t\t\tlock_flags)\n{\n\tASSERT(lock_flags & (XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL));\n\tASSERT((lock_flags & ~(XFS_IOLOCK_EXCL|XFS_ILOCK_EXCL)) == 0);\n\n\tif (lock_flags & XFS_ILOCK_EXCL)\n\t\tmrdemote(&ip->i_lock);\n\tif (lock_flags & XFS_IOLOCK_EXCL)\n\t\tmrdemote(&ip->i_iolock);\n\n\ttrace_xfs_ilock_demote(ip, lock_flags, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_addafork",
            "blks",
            "0"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_ADDAFORK_SPACE_RES",
          "args": [
            "mp"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_ADDAFORK"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "57-68",
          "snippet": "xfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_trans_t *\nxfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype)\n{\n\txfs_trans_t     *tp;\n\n\tsb_start_intwrite(mp->m_super);\n\ttp = _xfs_trans_alloc(mp, type, KM_SLEEP);\n\ttp->t_flags |= XFS_TRANS_FREEZE_PROT;\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!XFS_NOT_DQATTACHED(mp, ip)"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_NOT_DQATTACHED",
          "args": [
            "mp",
            "ip"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_Q(ip) == 0"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_Q",
          "args": [
            "ip"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t\t/* error code */\nxfs_bmap_add_attrfork(\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\tsize,\t\t/* space new attribute needs */\n\tint\t\t\trsvd)\t\t/* xact may use reserved blks */\n{\n\txfs_fsblock_t\t\tfirstblock;\t/* 1st block/ag allocated */\n\txfs_bmap_free_t\t\tflist;\t\t/* freed extent records */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tint\t\t\tblks;\t\t/* space reservation */\n\tint\t\t\tversion = 1;\t/* superblock attr version */\n\tint\t\t\tcommitted;\t/* xaction was committed */\n\tint\t\t\tlogflags;\t/* logging flags */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\tcancel_flags = 0;\n\n\tASSERT(XFS_IFORK_Q(ip) == 0);\n\n\tmp = ip->i_mount;\n\tASSERT(!XFS_NOT_DQATTACHED(mp, ip));\n\ttp = xfs_trans_alloc(mp, XFS_TRANS_ADDAFORK);\n\tblks = XFS_ADDAFORK_SPACE_RES(mp);\n\tif (rsvd)\n\t\ttp->t_flags |= XFS_TRANS_RESERVE;\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_addafork, blks, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\tcancel_flags = XFS_TRANS_RELEASE_LOG_RES;\n\txfs_ilock(ip, XFS_ILOCK_EXCL);\n\terror = xfs_trans_reserve_quota_nblks(tp, ip, blks, 0, rsvd ?\n\t\t\tXFS_QMOPT_RES_REGBLKS | XFS_QMOPT_FORCE_RES :\n\t\t\tXFS_QMOPT_RES_REGBLKS);\n\tif (error)\n\t\tgoto trans_cancel;\n\tcancel_flags |= XFS_TRANS_ABORT;\n\tif (XFS_IFORK_Q(ip))\n\t\tgoto trans_cancel;\n\tif (ip->i_d.di_aformat != XFS_DINODE_FMT_EXTENTS) {\n\t\t/*\n\t\t * For inodes coming from pre-6.2 filesystems.\n\t\t */\n\t\tASSERT(ip->i_d.di_aformat == 0);\n\t\tip->i_d.di_aformat = XFS_DINODE_FMT_EXTENTS;\n\t}\n\tASSERT(ip->i_d.di_anextents == 0);\n\n\txfs_trans_ijoin(tp, ip, 0);\n\txfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_DEV:\n\t\tip->i_d.di_forkoff = roundup(sizeof(xfs_dev_t), 8) >> 3;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_UUID:\n\t\tip->i_d.di_forkoff = roundup(sizeof(uuid_t), 8) >> 3;\n\t\tbreak;\n\tcase XFS_DINODE_FMT_LOCAL:\n\tcase XFS_DINODE_FMT_EXTENTS:\n\tcase XFS_DINODE_FMT_BTREE:\n\t\tip->i_d.di_forkoff = xfs_attr_shortform_bytesfit(ip, size);\n\t\tif (!ip->i_d.di_forkoff)\n\t\t\tip->i_d.di_forkoff = xfs_default_attroffset(ip) >> 3;\n\t\telse if (mp->m_flags & XFS_MOUNT_ATTR2)\n\t\t\tversion = 2;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\terror = -EINVAL;\n\t\tgoto trans_cancel;\n\t}\n\n\tASSERT(ip->i_afp == NULL);\n\tip->i_afp = kmem_zone_zalloc(xfs_ifork_zone, KM_SLEEP);\n\tip->i_afp->if_flags = XFS_IFEXTENTS;\n\tlogflags = 0;\n\txfs_bmap_init(&flist, &firstblock);\n\tswitch (ip->i_d.di_format) {\n\tcase XFS_DINODE_FMT_LOCAL:\n\t\terror = xfs_bmap_add_attrfork_local(tp, ip, &firstblock, &flist,\n\t\t\t&logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_EXTENTS:\n\t\terror = xfs_bmap_add_attrfork_extents(tp, ip, &firstblock,\n\t\t\t&flist, &logflags);\n\t\tbreak;\n\tcase XFS_DINODE_FMT_BTREE:\n\t\terror = xfs_bmap_add_attrfork_btree(tp, ip, &firstblock, &flist,\n\t\t\t&logflags);\n\t\tbreak;\n\tdefault:\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (logflags)\n\t\txfs_trans_log_inode(tp, ip, logflags);\n\tif (error)\n\t\tgoto bmap_cancel;\n\tif (!xfs_sb_version_hasattr(&mp->m_sb) ||\n\t   (!xfs_sb_version_hasattr2(&mp->m_sb) && version == 2)) {\n\t\tbool log_sb = false;\n\n\t\tspin_lock(&mp->m_sb_lock);\n\t\tif (!xfs_sb_version_hasattr(&mp->m_sb)) {\n\t\t\txfs_sb_version_addattr(&mp->m_sb);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tif (!xfs_sb_version_hasattr2(&mp->m_sb) && version == 2) {\n\t\t\txfs_sb_version_addattr2(&mp->m_sb);\n\t\t\tlog_sb = true;\n\t\t}\n\t\tspin_unlock(&mp->m_sb_lock);\n\t\tif (log_sb)\n\t\t\txfs_log_sb(tp);\n\t}\n\n\terror = xfs_bmap_finish(&tp, &flist, &committed);\n\tif (error)\n\t\tgoto bmap_cancel;\n\terror = xfs_trans_commit(tp, XFS_TRANS_RELEASE_LOG_RES);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n\nbmap_cancel:\n\txfs_bmap_cancel(&flist);\ntrans_cancel:\n\txfs_trans_cancel(tp, cancel_flags);\n\txfs_iunlock(ip, XFS_ILOCK_EXCL);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmap_add_attrfork_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1087-1120",
    "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_local(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_da_args_t\t\tdargs;\t\t/* args for dir/attr code */\n\n\tif (ip->i_df.if_bytes <= XFS_IFORK_DSIZE(ip))\n\t\treturn 0;\n\n\tif (S_ISDIR(ip->i_d.di_mode)) {\n\t\tmemset(&dargs, 0, sizeof(dargs));\n\t\tdargs.geo = ip->i_mount->m_dir_geo;\n\t\tdargs.dp = ip;\n\t\tdargs.firstblock = firstblock;\n\t\tdargs.flist = flist;\n\t\tdargs.total = dargs.geo->fsbcount;\n\t\tdargs.whichfork = XFS_DATA_FORK;\n\t\tdargs.trans = tp;\n\t\treturn xfs_dir2_sf_to_block(&dargs);\n\t}\n\n\tif (S_ISLNK(ip->i_d.di_mode))\n\t\treturn xfs_bmap_local_to_extents(tp, ip, firstblock, 1,\n\t\t\t\t\t\t flags, XFS_DATA_FORK,\n\t\t\t\t\t\t xfs_symlink_local_to_remote);\n\n\t/* should only be called for types that support local format data */\n\tASSERT(0);\n\treturn -EFSCORRUPTED;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "0"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_local_to_extents",
          "args": [
            "tp",
            "ip",
            "firstblock",
            "1",
            "flags",
            "XFS_DATA_FORK",
            "xfs_symlink_local_to_remote"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_local_to_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "911-1004",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_local_to_extents(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t*firstblock,\t/* first block allocated in xaction */\n\txfs_extlen_t\ttotal,\t\t/* total blocks needed by transaction */\n\tint\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\twhichfork,\n\tvoid\t\t(*init_fn)(struct xfs_trans *tp,\n\t\t\t\t   struct xfs_buf *bp,\n\t\t\t\t   struct xfs_inode *ip,\n\t\t\t\t   struct xfs_ifork *ifp))\n{\n\tint\t\terror = 0;\n\tint\t\tflags;\t\t/* logging flags returned */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_alloc_arg_t\targs;\t\t/* allocation arguments */\n\txfs_buf_t\t*bp;\t\t/* buffer for extent block */\n\txfs_bmbt_rec_host_t *ep;\t/* extent record pointer */\n\n\t/*\n\t * We don't want to deal with the case of keeping inode data inline yet.\n\t * So sending the data fork of a regular inode is invalid.\n\t */\n\tASSERT(!(S_ISREG(ip->i_d.di_mode) && whichfork == XFS_DATA_FORK));\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\n\tif (!ifp->if_bytes) {\n\t\txfs_bmap_local_to_extents_empty(ip, whichfork);\n\t\tflags = XFS_ILOG_CORE;\n\t\tgoto done;\n\t}\n\n\tflags = 0;\n\terror = 0;\n\tASSERT((ifp->if_flags & (XFS_IFINLINE|XFS_IFEXTENTS|XFS_IFEXTIREC)) ==\n\t\t\t\t\t\t\t\tXFS_IFINLINE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = ip->i_mount;\n\targs.firstblock = *firstblock;\n\t/*\n\t * Allocate a block.  We know we need only one, since the\n\t * file currently fits in an inode.\n\t */\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.fsbno = XFS_INO_TO_FSB(args.mp, ip->i_ino);\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t} else {\n\t\targs.fsbno = *firstblock;\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t}\n\targs.total = total;\n\targs.minlen = args.maxlen = args.prod = 1;\n\terror = xfs_alloc_vextent(&args);\n\tif (error)\n\t\tgoto done;\n\n\t/* Can't fail, the space was reserved. */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(args.len == 1);\n\t*firstblock = args.fsbno;\n\tbp = xfs_btree_get_bufl(args.mp, tp, args.fsbno, 0);\n\n\t/*\n\t * Initialise the block and copy the data\n\t *\n\t * Note: init_fn must set the buffer log item type correctly!\n\t */\n\tinit_fn(tp, bp, ip, ifp);\n\n\t/* account for the change in fork size and log everything */\n\txfs_trans_log_buf(tp, bp, 0, ifp->if_bytes - 1);\n\txfs_idata_realloc(ip, -ifp->if_bytes, whichfork);\n\txfs_bmap_local_to_extents_empty(ip, whichfork);\n\tflags |= XFS_ILOG_CORE;\n\n\txfs_iext_add(ifp, 0, 1);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_set_allf(ep, 0, args.fsbno, 1, XFS_EXT_NORM);\n\ttrace_xfs_bmap_post_update(ip, 0,\n\t\t\twhichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0,\n\t\t\t_THIS_IP_);\n\tXFS_IFORK_NEXT_SET(ip, whichfork, 1);\n\tip->i_d.di_nblocks = 1;\n\txfs_trans_mod_dquot_byino(tp, ip,\n\t\tXFS_TRANS_DQ_BCOUNT, 1L);\n\tflags |= xfs_ilog_fext(whichfork);\n\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_local_to_extents(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t*firstblock,\t/* first block allocated in xaction */\n\txfs_extlen_t\ttotal,\t\t/* total blocks needed by transaction */\n\tint\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\twhichfork,\n\tvoid\t\t(*init_fn)(struct xfs_trans *tp,\n\t\t\t\t   struct xfs_buf *bp,\n\t\t\t\t   struct xfs_inode *ip,\n\t\t\t\t   struct xfs_ifork *ifp))\n{\n\tint\t\terror = 0;\n\tint\t\tflags;\t\t/* logging flags returned */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_alloc_arg_t\targs;\t\t/* allocation arguments */\n\txfs_buf_t\t*bp;\t\t/* buffer for extent block */\n\txfs_bmbt_rec_host_t *ep;\t/* extent record pointer */\n\n\t/*\n\t * We don't want to deal with the case of keeping inode data inline yet.\n\t * So sending the data fork of a regular inode is invalid.\n\t */\n\tASSERT(!(S_ISREG(ip->i_d.di_mode) && whichfork == XFS_DATA_FORK));\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\n\tif (!ifp->if_bytes) {\n\t\txfs_bmap_local_to_extents_empty(ip, whichfork);\n\t\tflags = XFS_ILOG_CORE;\n\t\tgoto done;\n\t}\n\n\tflags = 0;\n\terror = 0;\n\tASSERT((ifp->if_flags & (XFS_IFINLINE|XFS_IFEXTENTS|XFS_IFEXTIREC)) ==\n\t\t\t\t\t\t\t\tXFS_IFINLINE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = ip->i_mount;\n\targs.firstblock = *firstblock;\n\t/*\n\t * Allocate a block.  We know we need only one, since the\n\t * file currently fits in an inode.\n\t */\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.fsbno = XFS_INO_TO_FSB(args.mp, ip->i_ino);\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t} else {\n\t\targs.fsbno = *firstblock;\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t}\n\targs.total = total;\n\targs.minlen = args.maxlen = args.prod = 1;\n\terror = xfs_alloc_vextent(&args);\n\tif (error)\n\t\tgoto done;\n\n\t/* Can't fail, the space was reserved. */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(args.len == 1);\n\t*firstblock = args.fsbno;\n\tbp = xfs_btree_get_bufl(args.mp, tp, args.fsbno, 0);\n\n\t/*\n\t * Initialise the block and copy the data\n\t *\n\t * Note: init_fn must set the buffer log item type correctly!\n\t */\n\tinit_fn(tp, bp, ip, ifp);\n\n\t/* account for the change in fork size and log everything */\n\txfs_trans_log_buf(tp, bp, 0, ifp->if_bytes - 1);\n\txfs_idata_realloc(ip, -ifp->if_bytes, whichfork);\n\txfs_bmap_local_to_extents_empty(ip, whichfork);\n\tflags |= XFS_ILOG_CORE;\n\n\txfs_iext_add(ifp, 0, 1);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_set_allf(ep, 0, args.fsbno, 1, XFS_EXT_NORM);\n\ttrace_xfs_bmap_post_update(ip, 0,\n\t\t\twhichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0,\n\t\t\t_THIS_IP_);\n\tXFS_IFORK_NEXT_SET(ip, whichfork, 1);\n\tip->i_d.di_nblocks = 1;\n\txfs_trans_mod_dquot_byino(tp, ip,\n\t\tXFS_TRANS_DQ_BCOUNT, 1L);\n\tflags |= xfs_ilog_fext(whichfork);\n\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_dir2_sf_to_block",
          "args": [
            "&dargs"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_dir2_sf_to_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_dir2_block.c",
          "lines": "1042-1254",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_dir2_sf_to_block(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_dir2_db_t\t\tblkno;\t\t/* dir-relative block # (0) */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tdummy;\t\t/* trash */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tint\t\t\tendoffset;\t/* end of data objects */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to scan block freespc */\n\tint\t\t\tnewoffset;\t/* offset from current entry */\n\tint\t\t\toffset;\t\t/* target block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* sf entry pointer */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old shortform header  */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform header  */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_name\t\tname;\n\tstruct xfs_ifork\t*ifp;\n\n\ttrace_xfs_dir2_sf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tifp = XFS_IFORK_PTR(dp, XFS_DATA_FORK);\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t/*\n\t * Bomb out if the shortform directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn -EIO;\n\t}\n\n\toldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;\n\n\tASSERT(ifp->if_bytes == dp->i_d.di_size);\n\tASSERT(ifp->if_u1.if_data != NULL);\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count));\n\tASSERT(dp->i_d.di_nextents == 0);\n\n\t/*\n\t * Copy the directory into a temporary buffer.\n\t * Then pitch the incore inode data so we can make extents.\n\t */\n\tsfp = kmem_alloc(ifp->if_bytes, KM_SLEEP);\n\tmemcpy(sfp, oldsfp, ifp->if_bytes);\n\n\txfs_idata_realloc(dp, -ifp->if_bytes, XFS_DATA_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_DATA_FORK);\n\tdp->i_d.di_size = 0;\n\n\t/*\n\t * Add block 0 to the inode.\n\t */\n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, &blkno);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the data block, then convert it to block format.\n\t */\n\terror = xfs_dir3_data_init(args, blkno, &bp);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\txfs_dir3_block_init(mp, tp, bp, dp);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Compute size of block \"tail\" area.\n\t */\n\ti = (uint)sizeof(*btp) +\n\t    (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t);\n\t/*\n\t * The whole thing is initialized to free by the init routine.\n\t * Say we're using the leaf and tail area.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_use_free(args, bp, dup, args->geo->blksize - i,\n\t\t\t       i, &needlog, &needscan);\n\tASSERT(needscan == 0);\n\t/*\n\t * Fill in the tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(sfp->count + 2);\t/* ., .. */\n\tbtp->stale = 0;\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tendoffset = (uint)((char *)blp - (char *)hdr);\n\t/*\n\t * Remove the freespace, we'll manage it.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\tbe16_to_cpu(dup->length), &needlog, &needscan);\n\t/*\n\t * Create entry for .\n\t */\n\tdep = dp->d_ops->data_dot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->i_ino);\n\tdep->namelen = 1;\n\tdep->name[0] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);\n\tblp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\t/*\n\t * Create entry for ..\n\t */\n\tdep = dp->d_ops->data_dotdot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));\n\tdep->namelen = 2;\n\tdep->name[0] = dep->name[1] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);\n\tblp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\toffset = dp->d_ops->data_first_offset;\n\t/*\n\t * Loop over existing entries, stuff them in.\n\t */\n\ti = 0;\n\tif (!sfp->count)\n\t\tsfep = NULL;\n\telse\n\t\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Need to preserve the existing offset values in the sf directory.\n\t * Insert holes (unused entries) where necessary.\n\t */\n\twhile (offset < endoffset) {\n\t\t/*\n\t\t * sfep is null when we reach the end of the list.\n\t\t */\n\t\tif (sfep == NULL)\n\t\t\tnewoffset = endoffset;\n\t\telse\n\t\t\tnewoffset = xfs_dir2_sf_get_offset(sfep);\n\t\t/*\n\t\t * There should be a hole here, make one.\n\t\t */\n\t\tif (offset < newoffset) {\n\t\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\t\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\t\tdup->length = cpu_to_be16(newoffset - offset);\n\t\t\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16(\n\t\t\t\t((char *)dup - (char *)hdr));\n\t\t\txfs_dir2_data_log_unused(args, bp, dup);\n\t\t\txfs_dir2_data_freeinsert(hdr,\n\t\t\t\t\t\t dp->d_ops->data_bestfree_p(hdr),\n\t\t\t\t\t\t dup, &dummy);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Copy a real entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);\n\t\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));\n\t\tdep->namelen = sfep->namelen;\n\t\tdp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));\n\t\tmemcpy(dep->name, sfep->name, dep->namelen);\n\t\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t\txfs_dir2_data_log_entry(args, bp, dep);\n\t\tname.name = sfep->name;\n\t\tname.len = sfep->namelen;\n\t\tblp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name));\n\t\tblp[2 + i].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr));\n\t\toffset = (int)((char *)(tagp + 1) - (char *)hdr);\n\t\tif (++i == sfp->count)\n\t\t\tsfep = NULL;\n\t\telse\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/* Done with the temporary buffer */\n\tkmem_free(sfp);\n\t/*\n\t * Sort the leaf entries by hash value.\n\t */\n\txfs_sort(blp, be32_to_cpu(btp->count), sizeof(*blp), xfs_dir2_block_sort);\n\t/*\n\t * Log the leaf entry area and tail.\n\t * Already logged the header in data_init, ignore needlog.\n\t */\n\tASSERT(needscan == 0);\n\txfs_dir2_block_log_leaf(tp, bp, 0, be32_to_cpu(btp->count) - 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_dir2_priv.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);",
            "static xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_dir2_priv.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void xfs_dir2_block_log_tail(xfs_trans_t *tp, struct xfs_buf *bp);\nstatic xfs_dahash_t xfs_dir_hash_dot, xfs_dir_hash_dotdot;\n\nint\t\t\t\t\t\t/* error */\nxfs_dir2_sf_to_block(\n\txfs_da_args_t\t\t*args)\t\t/* operation arguments */\n{\n\txfs_dir2_db_t\t\tblkno;\t\t/* dir-relative block # (0) */\n\txfs_dir2_data_hdr_t\t*hdr;\t\t/* block header */\n\txfs_dir2_leaf_entry_t\t*blp;\t\t/* block leaf entries */\n\tstruct xfs_buf\t\t*bp;\t\t/* block buffer */\n\txfs_dir2_block_tail_t\t*btp;\t\t/* block tail pointer */\n\txfs_dir2_data_entry_t\t*dep;\t\t/* data entry pointer */\n\txfs_inode_t\t\t*dp;\t\t/* incore directory inode */\n\tint\t\t\tdummy;\t\t/* trash */\n\txfs_dir2_data_unused_t\t*dup;\t\t/* unused entry pointer */\n\tint\t\t\tendoffset;\t/* end of data objects */\n\tint\t\t\terror;\t\t/* error return value */\n\tint\t\t\ti;\t\t/* index */\n\txfs_mount_t\t\t*mp;\t\t/* filesystem mount point */\n\tint\t\t\tneedlog;\t/* need to log block header */\n\tint\t\t\tneedscan;\t/* need to scan block freespc */\n\tint\t\t\tnewoffset;\t/* offset from current entry */\n\tint\t\t\toffset;\t\t/* target block offset */\n\txfs_dir2_sf_entry_t\t*sfep;\t\t/* sf entry pointer */\n\txfs_dir2_sf_hdr_t\t*oldsfp;\t/* old shortform header  */\n\txfs_dir2_sf_hdr_t\t*sfp;\t\t/* shortform header  */\n\t__be16\t\t\t*tagp;\t\t/* end of data entry */\n\txfs_trans_t\t\t*tp;\t\t/* transaction pointer */\n\tstruct xfs_name\t\tname;\n\tstruct xfs_ifork\t*ifp;\n\n\ttrace_xfs_dir2_sf_to_block(args);\n\n\tdp = args->dp;\n\ttp = args->trans;\n\tmp = dp->i_mount;\n\tifp = XFS_IFORK_PTR(dp, XFS_DATA_FORK);\n\tASSERT(ifp->if_flags & XFS_IFINLINE);\n\t/*\n\t * Bomb out if the shortform directory is way too short.\n\t */\n\tif (dp->i_d.di_size < offsetof(xfs_dir2_sf_hdr_t, parent)) {\n\t\tASSERT(XFS_FORCED_SHUTDOWN(mp));\n\t\treturn -EIO;\n\t}\n\n\toldsfp = (xfs_dir2_sf_hdr_t *)ifp->if_u1.if_data;\n\n\tASSERT(ifp->if_bytes == dp->i_d.di_size);\n\tASSERT(ifp->if_u1.if_data != NULL);\n\tASSERT(dp->i_d.di_size >= xfs_dir2_sf_hdr_size(oldsfp->i8count));\n\tASSERT(dp->i_d.di_nextents == 0);\n\n\t/*\n\t * Copy the directory into a temporary buffer.\n\t * Then pitch the incore inode data so we can make extents.\n\t */\n\tsfp = kmem_alloc(ifp->if_bytes, KM_SLEEP);\n\tmemcpy(sfp, oldsfp, ifp->if_bytes);\n\n\txfs_idata_realloc(dp, -ifp->if_bytes, XFS_DATA_FORK);\n\txfs_bmap_local_to_extents_empty(dp, XFS_DATA_FORK);\n\tdp->i_d.di_size = 0;\n\n\t/*\n\t * Add block 0 to the inode.\n\t */\n\terror = xfs_dir2_grow_inode(args, XFS_DIR2_DATA_SPACE, &blkno);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\t/*\n\t * Initialize the data block, then convert it to block format.\n\t */\n\terror = xfs_dir3_data_init(args, blkno, &bp);\n\tif (error) {\n\t\tkmem_free(sfp);\n\t\treturn error;\n\t}\n\txfs_dir3_block_init(mp, tp, bp, dp);\n\thdr = bp->b_addr;\n\n\t/*\n\t * Compute size of block \"tail\" area.\n\t */\n\ti = (uint)sizeof(*btp) +\n\t    (sfp->count + 2) * (uint)sizeof(xfs_dir2_leaf_entry_t);\n\t/*\n\t * The whole thing is initialized to free by the init routine.\n\t * Say we're using the leaf and tail area.\n\t */\n\tdup = dp->d_ops->data_unused_p(hdr);\n\tneedlog = needscan = 0;\n\txfs_dir2_data_use_free(args, bp, dup, args->geo->blksize - i,\n\t\t\t       i, &needlog, &needscan);\n\tASSERT(needscan == 0);\n\t/*\n\t * Fill in the tail.\n\t */\n\tbtp = xfs_dir2_block_tail_p(args->geo, hdr);\n\tbtp->count = cpu_to_be32(sfp->count + 2);\t/* ., .. */\n\tbtp->stale = 0;\n\tblp = xfs_dir2_block_leaf_p(btp);\n\tendoffset = (uint)((char *)blp - (char *)hdr);\n\t/*\n\t * Remove the freespace, we'll manage it.\n\t */\n\txfs_dir2_data_use_free(args, bp, dup,\n\t\t(xfs_dir2_data_aoff_t)((char *)dup - (char *)hdr),\n\t\tbe16_to_cpu(dup->length), &needlog, &needscan);\n\t/*\n\t * Create entry for .\n\t */\n\tdep = dp->d_ops->data_dot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->i_ino);\n\tdep->namelen = 1;\n\tdep->name[0] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[0].hashval = cpu_to_be32(xfs_dir_hash_dot);\n\tblp[0].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\t/*\n\t * Create entry for ..\n\t */\n\tdep = dp->d_ops->data_dotdot_entry_p(hdr);\n\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_parent_ino(sfp));\n\tdep->namelen = 2;\n\tdep->name[0] = dep->name[1] = '.';\n\tdp->d_ops->data_put_ftype(dep, XFS_DIR3_FT_DIR);\n\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\txfs_dir2_data_log_entry(args, bp, dep);\n\tblp[1].hashval = cpu_to_be32(xfs_dir_hash_dotdot);\n\tblp[1].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t(char *)dep - (char *)hdr));\n\toffset = dp->d_ops->data_first_offset;\n\t/*\n\t * Loop over existing entries, stuff them in.\n\t */\n\ti = 0;\n\tif (!sfp->count)\n\t\tsfep = NULL;\n\telse\n\t\tsfep = xfs_dir2_sf_firstentry(sfp);\n\t/*\n\t * Need to preserve the existing offset values in the sf directory.\n\t * Insert holes (unused entries) where necessary.\n\t */\n\twhile (offset < endoffset) {\n\t\t/*\n\t\t * sfep is null when we reach the end of the list.\n\t\t */\n\t\tif (sfep == NULL)\n\t\t\tnewoffset = endoffset;\n\t\telse\n\t\t\tnewoffset = xfs_dir2_sf_get_offset(sfep);\n\t\t/*\n\t\t * There should be a hole here, make one.\n\t\t */\n\t\tif (offset < newoffset) {\n\t\t\tdup = (xfs_dir2_data_unused_t *)((char *)hdr + offset);\n\t\t\tdup->freetag = cpu_to_be16(XFS_DIR2_DATA_FREE_TAG);\n\t\t\tdup->length = cpu_to_be16(newoffset - offset);\n\t\t\t*xfs_dir2_data_unused_tag_p(dup) = cpu_to_be16(\n\t\t\t\t((char *)dup - (char *)hdr));\n\t\t\txfs_dir2_data_log_unused(args, bp, dup);\n\t\t\txfs_dir2_data_freeinsert(hdr,\n\t\t\t\t\t\t dp->d_ops->data_bestfree_p(hdr),\n\t\t\t\t\t\t dup, &dummy);\n\t\t\toffset += be16_to_cpu(dup->length);\n\t\t\tcontinue;\n\t\t}\n\t\t/*\n\t\t * Copy a real entry.\n\t\t */\n\t\tdep = (xfs_dir2_data_entry_t *)((char *)hdr + newoffset);\n\t\tdep->inumber = cpu_to_be64(dp->d_ops->sf_get_ino(sfp, sfep));\n\t\tdep->namelen = sfep->namelen;\n\t\tdp->d_ops->data_put_ftype(dep, dp->d_ops->sf_get_ftype(sfep));\n\t\tmemcpy(dep->name, sfep->name, dep->namelen);\n\t\ttagp = dp->d_ops->data_entry_tag_p(dep);\n\t\t*tagp = cpu_to_be16((char *)dep - (char *)hdr);\n\t\txfs_dir2_data_log_entry(args, bp, dep);\n\t\tname.name = sfep->name;\n\t\tname.len = sfep->namelen;\n\t\tblp[2 + i].hashval = cpu_to_be32(mp->m_dirnameops->\n\t\t\t\t\t\t\thashname(&name));\n\t\tblp[2 + i].address = cpu_to_be32(xfs_dir2_byte_to_dataptr(\n\t\t\t\t\t\t (char *)dep - (char *)hdr));\n\t\toffset = (int)((char *)(tagp + 1) - (char *)hdr);\n\t\tif (++i == sfp->count)\n\t\t\tsfep = NULL;\n\t\telse\n\t\t\tsfep = dp->d_ops->sf_nextentry(sfp, sfep);\n\t}\n\t/* Done with the temporary buffer */\n\tkmem_free(sfp);\n\t/*\n\t * Sort the leaf entries by hash value.\n\t */\n\txfs_sort(blp, be32_to_cpu(btp->count), sizeof(*blp), xfs_dir2_block_sort);\n\t/*\n\t * Log the leaf entry area and tail.\n\t * Already logged the header in data_init, ignore needlog.\n\t */\n\tASSERT(needscan == 0);\n\txfs_dir2_block_log_leaf(tp, bp, 0, be32_to_cpu(btp->count) - 1);\n\txfs_dir2_block_log_tail(tp, bp);\n\txfs_dir3_data_check(dp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dargs",
            "0",
            "sizeof(dargs)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "ip"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_local(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_da_args_t\t\tdargs;\t\t/* args for dir/attr code */\n\n\tif (ip->i_df.if_bytes <= XFS_IFORK_DSIZE(ip))\n\t\treturn 0;\n\n\tif (S_ISDIR(ip->i_d.di_mode)) {\n\t\tmemset(&dargs, 0, sizeof(dargs));\n\t\tdargs.geo = ip->i_mount->m_dir_geo;\n\t\tdargs.dp = ip;\n\t\tdargs.firstblock = firstblock;\n\t\tdargs.flist = flist;\n\t\tdargs.total = dargs.geo->fsbcount;\n\t\tdargs.whichfork = XFS_DATA_FORK;\n\t\tdargs.trans = tp;\n\t\treturn xfs_dir2_sf_to_block(&dargs);\n\t}\n\n\tif (S_ISLNK(ip->i_d.di_mode))\n\t\treturn xfs_bmap_local_to_extents(tp, ip, firstblock, 1,\n\t\t\t\t\t\t flags, XFS_DATA_FORK,\n\t\t\t\t\t\t xfs_symlink_local_to_remote);\n\n\t/* should only be called for types that support local format data */\n\tASSERT(0);\n\treturn -EFSCORRUPTED;\n}"
  },
  {
    "function_name": "xfs_bmap_add_attrfork_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1052-1074",
    "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_extents(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tif (ip->i_d.di_nextents * sizeof(xfs_bmbt_rec_t) <= XFS_IFORK_DSIZE(ip))\n\t\treturn 0;\n\tcur = NULL;\n\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist, &cur, 0,\n\t\tflags, XFS_DATA_FORK);\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "error ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_extents_to_btree",
          "args": [
            "tp",
            "ip",
            "firstblock",
            "flist",
            "&cur",
            "0",
            "flags",
            "XFS_DATA_FORK"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_extents_to_btree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "743-885",
          "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "ip"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_extents(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\tint\t\t\terror;\t\t/* error return value */\n\n\tif (ip->i_d.di_nextents * sizeof(xfs_bmbt_rec_t) <= XFS_IFORK_DSIZE(ip))\n\t\treturn 0;\n\tcur = NULL;\n\terror = xfs_bmap_extents_to_btree(tp, ip, firstblock, flist, &cur, 0,\n\t\tflags, XFS_DATA_FORK);\n\tif (cur) {\n\t\tcur->bc_private.b.allocated = 0;\n\t\txfs_btree_del_cursor(cur,\n\t\t\terror ? XFS_BTREE_ERROR : XFS_BTREE_NOERROR);\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmap_add_attrfork_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "1009-1047",
    "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* btree cursor */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount struct */\n\tint\t\t\tstat;\t\t/* newroot status */\n\n\tmp = ip->i_mount;\n\tif (ip->i_df.if_broot_bytes <= XFS_IFORK_DSIZE(ip))\n\t\t*flags |= XFS_ILOG_DBROOT;\n\telse {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, XFS_DATA_FORK);\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tif ((error = xfs_bmbt_lookup_ge(cur, 0, 0, 0, &stat)))\n\t\t\tgoto error0;\n\t\t/* must be at least one entry */\n\t\tXFS_WANT_CORRUPTED_GOTO(stat == 1, error0);\n\t\tif ((error = xfs_btree_new_iroot(cur, flags, &stat)))\n\t\t\tgoto error0;\n\t\tif (stat == 0) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\tcur->bc_private.b.allocated = 0;\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t}\n\treturn 0;\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_ERROR"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_new_iroot",
          "args": [
            "cur",
            "flags",
            "&stat"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_new_iroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "2588-2693",
          "snippet": "int\t\t\t\t\t\t/* error */\nxfs_btree_new_iroot(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\t*logflags,\t/* logging flags for inode */\n\tint\t\t\t*stat)\t\t/* return status - 0 fail */\n{\n\tstruct xfs_buf\t\t*cbp;\t\t/* buffer for cblock */\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tstruct xfs_btree_block\t*cblock;\t/* child btree block */\n\tunion xfs_btree_key\t*ckp;\t\t/* child key pointer */\n\tunion xfs_btree_ptr\t*cpp;\t\t/* child ptr pointer */\n\tunion xfs_btree_key\t*kp;\t\t/* pointer to btree key */\n\tunion xfs_btree_ptr\t*pp;\t\t/* pointer to block addr */\n\tunion xfs_btree_ptr\tnptr;\t\t/* new block addr */\n\tint\t\t\tlevel;\t\t/* btree level */\n\tint\t\t\terror;\t\t/* error return code */\n#ifdef DEBUG\n\tint\t\t\ti;\t\t/* loop counter */\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\n\tlevel = cur->bc_nlevels - 1;\n\n\tblock = xfs_btree_get_iroot(cur);\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, pp, &nptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn 0;\n\t}\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Copy the root into a real block. */\n\terror = xfs_btree_get_buf_block(cur, &nptr, 0, &cblock, &cbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * we can't just memcpy() the root in for CRC enabled btree blocks.\n\t * In that case have to also ensure the blkno remains correct\n\t */\n\tmemcpy(cblock, block, xfs_btree_block_len(cur));\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\t\tcblock->bb_u.l.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t\telse\n\t\t\tcblock->bb_u.s.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t}\n\n\tbe16_add_cpu(&block->bb_level, 1);\n\txfs_btree_set_numrecs(block, 1);\n\tcur->bc_nlevels++;\n\tcur->bc_ptrs[level + 1] = 1;\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, ckp, kp, xfs_btree_get_numrecs(cblock));\n\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < be16_to_cpu(cblock->bb_numrecs); i++) {\n\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, cpp, pp, xfs_btree_get_numrecs(cblock));\n\n#ifdef DEBUG\n\terror = xfs_btree_check_ptr(cur, &nptr, 0, level);\n\tif (error)\n\t\tgoto error0;\n#endif\n\txfs_btree_copy_ptrs(cur, pp, &nptr, 1);\n\n\txfs_iroot_realloc(cur->bc_private.b.ip,\n\t\t\t  1 - xfs_btree_get_numrecs(cblock),\n\t\t\t  cur->bc_private.b.whichfork);\n\n\txfs_btree_setbuf(cur, level, cbp);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, cbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_keys(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\txfs_btree_log_ptrs(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\n\t*logflags |=\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork);\n\t*stat = 1;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t\t/* error */\nxfs_btree_new_iroot(\n\tstruct xfs_btree_cur\t*cur,\t\t/* btree cursor */\n\tint\t\t\t*logflags,\t/* logging flags for inode */\n\tint\t\t\t*stat)\t\t/* return status - 0 fail */\n{\n\tstruct xfs_buf\t\t*cbp;\t\t/* buffer for cblock */\n\tstruct xfs_btree_block\t*block;\t\t/* btree block */\n\tstruct xfs_btree_block\t*cblock;\t/* child btree block */\n\tunion xfs_btree_key\t*ckp;\t\t/* child key pointer */\n\tunion xfs_btree_ptr\t*cpp;\t\t/* child ptr pointer */\n\tunion xfs_btree_key\t*kp;\t\t/* pointer to btree key */\n\tunion xfs_btree_ptr\t*pp;\t\t/* pointer to block addr */\n\tunion xfs_btree_ptr\tnptr;\t\t/* new block addr */\n\tint\t\t\tlevel;\t\t/* btree level */\n\tint\t\t\terror;\t\t/* error return code */\n#ifdef DEBUG\n\tint\t\t\ti;\t\t/* loop counter */\n#endif\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_STATS_INC(cur, newroot);\n\n\tASSERT(cur->bc_flags & XFS_BTREE_ROOT_IN_INODE);\n\n\tlevel = cur->bc_nlevels - 1;\n\n\tblock = xfs_btree_get_iroot(cur);\n\tpp = xfs_btree_ptr_addr(cur, 1, block);\n\n\t/* Allocate the new block. If we can't do it, we're toast. Give up. */\n\terror = cur->bc_ops->alloc_block(cur, pp, &nptr, stat);\n\tif (error)\n\t\tgoto error0;\n\tif (*stat == 0) {\n\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\treturn 0;\n\t}\n\tXFS_BTREE_STATS_INC(cur, alloc);\n\n\t/* Copy the root into a real block. */\n\terror = xfs_btree_get_buf_block(cur, &nptr, 0, &cblock, &cbp);\n\tif (error)\n\t\tgoto error0;\n\n\t/*\n\t * we can't just memcpy() the root in for CRC enabled btree blocks.\n\t * In that case have to also ensure the blkno remains correct\n\t */\n\tmemcpy(cblock, block, xfs_btree_block_len(cur));\n\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\t\tcblock->bb_u.l.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t\telse\n\t\t\tcblock->bb_u.s.bb_blkno = cpu_to_be64(cbp->b_bn);\n\t}\n\n\tbe16_add_cpu(&block->bb_level, 1);\n\txfs_btree_set_numrecs(block, 1);\n\tcur->bc_nlevels++;\n\tcur->bc_ptrs[level + 1] = 1;\n\n\tkp = xfs_btree_key_addr(cur, 1, block);\n\tckp = xfs_btree_key_addr(cur, 1, cblock);\n\txfs_btree_copy_keys(cur, ckp, kp, xfs_btree_get_numrecs(cblock));\n\n\tcpp = xfs_btree_ptr_addr(cur, 1, cblock);\n#ifdef DEBUG\n\tfor (i = 0; i < be16_to_cpu(cblock->bb_numrecs); i++) {\n\t\terror = xfs_btree_check_ptr(cur, pp, i, level);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n#endif\n\txfs_btree_copy_ptrs(cur, cpp, pp, xfs_btree_get_numrecs(cblock));\n\n#ifdef DEBUG\n\terror = xfs_btree_check_ptr(cur, &nptr, 0, level);\n\tif (error)\n\t\tgoto error0;\n#endif\n\txfs_btree_copy_ptrs(cur, pp, &nptr, 1);\n\n\txfs_iroot_realloc(cur->bc_private.b.ip,\n\t\t\t  1 - xfs_btree_get_numrecs(cblock),\n\t\t\t  cur->bc_private.b.whichfork);\n\n\txfs_btree_setbuf(cur, level, cbp);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, cbp, XFS_BB_ALL_BITS);\n\txfs_btree_log_keys(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\txfs_btree_log_ptrs(cur, cbp, 1, be16_to_cpu(cblock->bb_numrecs));\n\n\t*logflags |=\n\t\tXFS_ILOG_CORE | xfs_ilog_fbroot(cur->bc_private.b.whichfork);\n\t*stat = 1;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "stat == 1",
            "error0"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_lookup_ge",
          "args": [
            "cur",
            "0",
            "0",
            "0",
            "&stat"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_lookup_ge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "121-133",
          "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_init_cursor",
          "args": [
            "mp",
            "tp",
            "ip",
            "XFS_DATA_FORK"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "776-808",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_DSIZE",
          "args": [
            "ip"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_add_attrfork_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first block allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks to free at commit */\n\tint\t\t\t*flags)\t\t/* inode logging flags */\n{\n\txfs_btree_cur_t\t\t*cur;\t\t/* btree cursor */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_mount_t\t\t*mp;\t\t/* file system mount struct */\n\tint\t\t\tstat;\t\t/* newroot status */\n\n\tmp = ip->i_mount;\n\tif (ip->i_df.if_broot_bytes <= XFS_IFORK_DSIZE(ip))\n\t\t*flags |= XFS_ILOG_DBROOT;\n\telse {\n\t\tcur = xfs_bmbt_init_cursor(mp, tp, ip, XFS_DATA_FORK);\n\t\tcur->bc_private.b.flist = flist;\n\t\tcur->bc_private.b.firstblock = *firstblock;\n\t\tif ((error = xfs_bmbt_lookup_ge(cur, 0, 0, 0, &stat)))\n\t\t\tgoto error0;\n\t\t/* must be at least one entry */\n\t\tXFS_WANT_CORRUPTED_GOTO(stat == 1, error0);\n\t\tif ((error = xfs_btree_new_iroot(cur, flags, &stat)))\n\t\t\tgoto error0;\n\t\tif (stat == 0) {\n\t\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\t*firstblock = cur->bc_private.b.firstblock;\n\t\tcur->bc_private.b.allocated = 0;\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);\n\t}\n\treturn 0;\nerror0:\n\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmap_local_to_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "911-1004",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_local_to_extents(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t*firstblock,\t/* first block allocated in xaction */\n\txfs_extlen_t\ttotal,\t\t/* total blocks needed by transaction */\n\tint\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\twhichfork,\n\tvoid\t\t(*init_fn)(struct xfs_trans *tp,\n\t\t\t\t   struct xfs_buf *bp,\n\t\t\t\t   struct xfs_inode *ip,\n\t\t\t\t   struct xfs_ifork *ifp))\n{\n\tint\t\terror = 0;\n\tint\t\tflags;\t\t/* logging flags returned */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_alloc_arg_t\targs;\t\t/* allocation arguments */\n\txfs_buf_t\t*bp;\t\t/* buffer for extent block */\n\txfs_bmbt_rec_host_t *ep;\t/* extent record pointer */\n\n\t/*\n\t * We don't want to deal with the case of keeping inode data inline yet.\n\t * So sending the data fork of a regular inode is invalid.\n\t */\n\tASSERT(!(S_ISREG(ip->i_d.di_mode) && whichfork == XFS_DATA_FORK));\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\n\tif (!ifp->if_bytes) {\n\t\txfs_bmap_local_to_extents_empty(ip, whichfork);\n\t\tflags = XFS_ILOG_CORE;\n\t\tgoto done;\n\t}\n\n\tflags = 0;\n\terror = 0;\n\tASSERT((ifp->if_flags & (XFS_IFINLINE|XFS_IFEXTENTS|XFS_IFEXTIREC)) ==\n\t\t\t\t\t\t\t\tXFS_IFINLINE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = ip->i_mount;\n\targs.firstblock = *firstblock;\n\t/*\n\t * Allocate a block.  We know we need only one, since the\n\t * file currently fits in an inode.\n\t */\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.fsbno = XFS_INO_TO_FSB(args.mp, ip->i_ino);\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t} else {\n\t\targs.fsbno = *firstblock;\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t}\n\targs.total = total;\n\targs.minlen = args.maxlen = args.prod = 1;\n\terror = xfs_alloc_vextent(&args);\n\tif (error)\n\t\tgoto done;\n\n\t/* Can't fail, the space was reserved. */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(args.len == 1);\n\t*firstblock = args.fsbno;\n\tbp = xfs_btree_get_bufl(args.mp, tp, args.fsbno, 0);\n\n\t/*\n\t * Initialise the block and copy the data\n\t *\n\t * Note: init_fn must set the buffer log item type correctly!\n\t */\n\tinit_fn(tp, bp, ip, ifp);\n\n\t/* account for the change in fork size and log everything */\n\txfs_trans_log_buf(tp, bp, 0, ifp->if_bytes - 1);\n\txfs_idata_realloc(ip, -ifp->if_bytes, whichfork);\n\txfs_bmap_local_to_extents_empty(ip, whichfork);\n\tflags |= XFS_ILOG_CORE;\n\n\txfs_iext_add(ifp, 0, 1);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_set_allf(ep, 0, args.fsbno, 1, XFS_EXT_NORM);\n\ttrace_xfs_bmap_post_update(ip, 0,\n\t\t\twhichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0,\n\t\t\t_THIS_IP_);\n\tXFS_IFORK_NEXT_SET(ip, whichfork, 1);\n\tip->i_d.di_nblocks = 1;\n\txfs_trans_mod_dquot_byino(tp, ip,\n\t\tXFS_TRANS_DQ_BCOUNT, 1L);\n\tflags |= xfs_ilog_fext(whichfork);\n\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ilog_fext",
          "args": [
            "whichfork"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "341-344",
          "snippet": "static inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */",
            "#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */\n#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */\n\nstatic inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "tp",
            "ip",
            "XFS_TRANS_DQ_BCOUNT",
            "1L"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXT_SET",
          "args": [
            "ip",
            "whichfork",
            "1"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_xfs_bmap_post_update",
          "args": [
            "ip",
            "0",
            "whichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0",
            "_THIS_IP_"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_set_allf",
          "args": [
            "ep",
            "0",
            "args.fsbno",
            "1",
            "XFS_EXT_NORM"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "199-221",
          "snippet": "void\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_set_allf(\n\txfs_bmbt_rec_host_t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = ((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t((xfs_bmbt_rec_base_t)startblock >> 43);\n\tr->l1 = ((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t((xfs_bmbt_rec_base_t)blockcount &\n\t\t(xfs_bmbt_rec_base_t)xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "0"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_add",
          "args": [
            "ifp",
            "0",
            "1"
          ],
          "line": 989
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "940-1034",
          "snippet": "void\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iext_add(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx,\t\t/* index to begin adding exts */\n\tint\t\text_diff)\t/* number of extents to add */\n{\n\tint\t\tbyte_diff;\t/* new bytes being added */\n\tint\t\tnew_size;\t/* size of extents after adding */\n\txfs_extnum_t\tnextents;\t/* number of extents in file */\n\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tASSERT((idx >= 0) && (idx <= nextents));\n\tbyte_diff = ext_diff * sizeof(xfs_bmbt_rec_t);\n\tnew_size = ifp->if_bytes + byte_diff;\n\t/*\n\t * If the new number of extents (nextents + ext_diff)\n\t * fits inside the inode, then continue to use the inline\n\t * extent buffer.\n\t */\n\tif (nextents + ext_diff <= XFS_INLINE_EXTS) {\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u2.if_inline_ext[idx + ext_diff],\n\t\t\t\t&ifp->if_u2.if_inline_ext[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u2.if_inline_ext[idx], 0, byte_diff);\n\t\t}\n\t\tifp->if_u1.if_extents = ifp->if_u2.if_inline_ext;\n\t\tifp->if_real_bytes = 0;\n\t}\n\t/*\n\t * Otherwise use a linear (direct) extent list.\n\t * If the extents are currently inside the inode,\n\t * xfs_iext_realloc_direct will switch us from\n\t * inline to direct extent allocation mode.\n\t */\n\telse if (nextents + ext_diff <= XFS_LINEAR_EXTS) {\n\t\txfs_iext_realloc_direct(ifp, new_size);\n\t\tif (idx < nextents) {\n\t\t\tmemmove(&ifp->if_u1.if_extents[idx + ext_diff],\n\t\t\t\t&ifp->if_u1.if_extents[idx],\n\t\t\t\t(nextents - idx) * sizeof(xfs_bmbt_rec_t));\n\t\t\tmemset(&ifp->if_u1.if_extents[idx], 0, byte_diff);\n\t\t}\n\t}\n\t/* Indirection array */\n\telse {\n\t\txfs_ext_irec_t\t*erp;\n\t\tint\t\terp_idx = 0;\n\t\tint\t\tpage_idx = idx;\n\n\t\tASSERT(nextents + ext_diff > XFS_LINEAR_EXTS);\n\t\tif (ifp->if_flags & XFS_IFEXTIREC) {\n\t\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 1);\n\t\t} else {\n\t\t\txfs_iext_irec_init(ifp);\n\t\t\tASSERT(ifp->if_flags & XFS_IFEXTIREC);\n\t\t\terp = ifp->if_u1.if_ext_irec;\n\t\t}\n\t\t/* Extents fit in target extent page */\n\t\tif (erp && erp->er_extcount + ext_diff <= XFS_LINEAR_EXTS) {\n\t\t\tif (page_idx < erp->er_extcount) {\n\t\t\t\tmemmove(&erp->er_extbuf[page_idx + ext_diff],\n\t\t\t\t\t&erp->er_extbuf[page_idx],\n\t\t\t\t\t(erp->er_extcount - page_idx) *\n\t\t\t\t\tsizeof(xfs_bmbt_rec_t));\n\t\t\t\tmemset(&erp->er_extbuf[page_idx], 0, byte_diff);\n\t\t\t}\n\t\t\terp->er_extcount += ext_diff;\n\t\t\txfs_iext_irec_update_extoffs(ifp, erp_idx + 1, ext_diff);\n\t\t}\n\t\t/* Insert a new extent page */\n\t\telse if (erp) {\n\t\t\txfs_iext_add_indirect_multi(ifp,\n\t\t\t\terp_idx, page_idx, ext_diff);\n\t\t}\n\t\t/*\n\t\t * If extent(s) are being appended to the last page in\n\t\t * the indirection array and the new extent(s) don't fit\n\t\t * in the page, then erp is NULL and erp_idx is set to\n\t\t * the next index needed in the indirection array.\n\t\t */\n\t\telse {\n\t\t\tuint\tcount = ext_diff;\n\n\t\t\twhile (count) {\n\t\t\t\terp = xfs_iext_irec_new(ifp, erp_idx);\n\t\t\t\terp->er_extcount = min(count, XFS_LINEAR_EXTS);\n\t\t\t\tcount -= erp->er_extcount;\n\t\t\t\tif (count)\n\t\t\t\t\terp_idx++;\n\t\t\t}\n\t\t}\n\t}\n\tifp->if_bytes = new_size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_local_to_extents_empty",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_local_to_extents_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "893-908",
          "snippet": "void\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_flags &= ~XFS_IFINLINE;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_flags &= ~XFS_IFINLINE;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_idata_realloc",
          "args": [
            "ip",
            "-ifp->if_bytes",
            "whichfork"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_idata_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "601-676",
          "snippet": "void\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_idata_realloc(\n\txfs_inode_t\t*ip,\n\tint\t\tbyte_diff,\n\tint\t\twhichfork)\n{\n\txfs_ifork_t\t*ifp;\n\tint\t\tnew_size;\n\tint\t\treal_size;\n\n\tif (byte_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tnew_size = (int)ifp->if_bytes + byte_diff;\n\tASSERT(new_size >= 0);\n\n\tif (new_size == 0) {\n\t\tif (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t}\n\t\tifp->if_u1.if_data = NULL;\n\t\treal_size = 0;\n\t} else if (new_size <= sizeof(ifp->if_u2.if_inline_data)) {\n\t\t/*\n\t\t * If the valid extents/data can fit in if_inline_ext/data,\n\t\t * copy them from the malloc'd vector and free it.\n\t\t */\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\tASSERT(ifp->if_real_bytes != 0);\n\t\t\tmemcpy(ifp->if_u2.if_inline_data, ifp->if_u1.if_data,\n\t\t\t      new_size);\n\t\t\tkmem_free(ifp->if_u1.if_data);\n\t\t\tifp->if_u1.if_data = ifp->if_u2.if_inline_data;\n\t\t}\n\t\treal_size = 0;\n\t} else {\n\t\t/*\n\t\t * Stuck with malloc/realloc.\n\t\t * For inline data, the underlying buffer must be\n\t\t * a multiple of 4 bytes in size so that it can be\n\t\t * logged and stay on word boundaries.  We enforce\n\t\t * that here.\n\t\t */\n\t\treal_size = roundup(new_size, 4);\n\t\tif (ifp->if_u1.if_data == NULL) {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t} else if (ifp->if_u1.if_data != ifp->if_u2.if_inline_data) {\n\t\t\t/*\n\t\t\t * Only do the realloc if the underlying size\n\t\t\t * is really changing.\n\t\t\t */\n\t\t\tif (ifp->if_real_bytes != real_size) {\n\t\t\t\tifp->if_u1.if_data =\n\t\t\t\t\tkmem_realloc(ifp->if_u1.if_data,\n\t\t\t\t\t\t\treal_size,\n\t\t\t\t\t\t\tifp->if_real_bytes,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\t}\n\t\t} else {\n\t\t\tASSERT(ifp->if_real_bytes == 0);\n\t\t\tifp->if_u1.if_data = kmem_alloc(real_size,\n\t\t\t\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\t\tmemcpy(ifp->if_u1.if_data, ifp->if_u2.if_inline_data,\n\t\t\t\tifp->if_bytes);\n\t\t}\n\t}\n\tifp->if_real_bytes = real_size;\n\tifp->if_bytes = new_size;\n\tASSERT(ifp->if_bytes <= XFS_IFORK_SIZE(ip, whichfork));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "0",
            "ifp->if_bytes - 1"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_fn",
          "args": [
            "tp",
            "bp",
            "ip",
            "ifp"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_bufl",
          "args": [
            "args.mp",
            "tp",
            "args.fsbno",
            "0"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_bufl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "548-560",
          "snippet": "xfs_buf_t *\t\t\t\t/* buffer for fsbno */\nxfs_btree_get_bufl(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\tfsbno,\t\t/* file system block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_buf_t *\t\t\t\t/* buffer for fsbno */\nxfs_btree_get_bufl(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\tfsbno,\t\t/* file system block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args.len == 1"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args.fsbno != NULLFSBLOCK"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alloc_vextent",
          "args": [
            "&args"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_vextent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2371-2580",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_FSB",
          "args": [
            "args.mp",
            "ip->i_ino"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(ifp->if_flags & (XFS_IFINLINE|XFS_IFEXTENTS|XFS_IFEXTIREC)) ==\n\t\t\t\t\t\t\t\tXFS_IFINLINE"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(S_ISREG(ip->i_d.di_mode) && whichfork == XFS_DATA_FORK)"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "ip->i_d.di_mode"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_local_to_extents(\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t*firstblock,\t/* first block allocated in xaction */\n\txfs_extlen_t\ttotal,\t\t/* total blocks needed by transaction */\n\tint\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\twhichfork,\n\tvoid\t\t(*init_fn)(struct xfs_trans *tp,\n\t\t\t\t   struct xfs_buf *bp,\n\t\t\t\t   struct xfs_inode *ip,\n\t\t\t\t   struct xfs_ifork *ifp))\n{\n\tint\t\terror = 0;\n\tint\t\tflags;\t\t/* logging flags returned */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\txfs_alloc_arg_t\targs;\t\t/* allocation arguments */\n\txfs_buf_t\t*bp;\t\t/* buffer for extent block */\n\txfs_bmbt_rec_host_t *ep;\t/* extent record pointer */\n\n\t/*\n\t * We don't want to deal with the case of keeping inode data inline yet.\n\t * So sending the data fork of a regular inode is invalid.\n\t */\n\tASSERT(!(S_ISREG(ip->i_d.di_mode) && whichfork == XFS_DATA_FORK));\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\n\tif (!ifp->if_bytes) {\n\t\txfs_bmap_local_to_extents_empty(ip, whichfork);\n\t\tflags = XFS_ILOG_CORE;\n\t\tgoto done;\n\t}\n\n\tflags = 0;\n\terror = 0;\n\tASSERT((ifp->if_flags & (XFS_IFINLINE|XFS_IFEXTENTS|XFS_IFEXTIREC)) ==\n\t\t\t\t\t\t\t\tXFS_IFINLINE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = ip->i_mount;\n\targs.firstblock = *firstblock;\n\t/*\n\t * Allocate a block.  We know we need only one, since the\n\t * file currently fits in an inode.\n\t */\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.fsbno = XFS_INO_TO_FSB(args.mp, ip->i_ino);\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t} else {\n\t\targs.fsbno = *firstblock;\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t}\n\targs.total = total;\n\targs.minlen = args.maxlen = args.prod = 1;\n\terror = xfs_alloc_vextent(&args);\n\tif (error)\n\t\tgoto done;\n\n\t/* Can't fail, the space was reserved. */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(args.len == 1);\n\t*firstblock = args.fsbno;\n\tbp = xfs_btree_get_bufl(args.mp, tp, args.fsbno, 0);\n\n\t/*\n\t * Initialise the block and copy the data\n\t *\n\t * Note: init_fn must set the buffer log item type correctly!\n\t */\n\tinit_fn(tp, bp, ip, ifp);\n\n\t/* account for the change in fork size and log everything */\n\txfs_trans_log_buf(tp, bp, 0, ifp->if_bytes - 1);\n\txfs_idata_realloc(ip, -ifp->if_bytes, whichfork);\n\txfs_bmap_local_to_extents_empty(ip, whichfork);\n\tflags |= XFS_ILOG_CORE;\n\n\txfs_iext_add(ifp, 0, 1);\n\tep = xfs_iext_get_ext(ifp, 0);\n\txfs_bmbt_set_allf(ep, 0, args.fsbno, 1, XFS_EXT_NORM);\n\ttrace_xfs_bmap_post_update(ip, 0,\n\t\t\twhichfork == XFS_ATTR_FORK ? BMAP_ATTRFORK : 0,\n\t\t\t_THIS_IP_);\n\tXFS_IFORK_NEXT_SET(ip, whichfork, 1);\n\tip->i_d.di_nblocks = 1;\n\txfs_trans_mod_dquot_byino(tp, ip,\n\t\tXFS_TRANS_DQ_BCOUNT, 1L);\n\tflags |= xfs_ilog_fext(whichfork);\n\ndone:\n\t*logflagsp = flags;\n\treturn error;\n}"
  },
  {
    "function_name": "xfs_bmap_local_to_extents_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "893-908",
    "snippet": "void\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_flags &= ~XFS_IFINLINE;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_FMT_SET",
          "args": [
            "ip",
            "whichfork",
            "XFS_DINODE_FMT_EXTENTS"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_forkoff_reset",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_forkoff_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "231-245",
          "snippet": "STATIC void\nxfs_bmap_forkoff_reset(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tif (whichfork == XFS_ATTR_FORK &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_DEV &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_UUID &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE) {\n\t\tuint\tdfl_forkoff = xfs_default_attroffset(ip) >> 3;\n\n\t\tif (dfl_forkoff > ip->i_d.di_forkoff)\n\t\t\tip->i_d.di_forkoff = dfl_forkoff;\n\t}\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_forkoff_reset(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tif (whichfork == XFS_ATTR_FORK &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_DEV &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_UUID &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE) {\n\t\tuint\tdfl_forkoff = xfs_default_attroffset(ip) >> 3;\n\n\t\tif (dfl_forkoff > ip->i_d.di_forkoff)\n\t\t\tip->i_d.di_forkoff = dfl_forkoff;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_NEXTENTS(ip, whichfork) == 0"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_bytes == 0"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_local_to_extents_empty(\n\tstruct xfs_inode\t*ip,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_LOCAL);\n\tASSERT(ifp->if_bytes == 0);\n\tASSERT(XFS_IFORK_NEXTENTS(ip, whichfork) == 0);\n\n\txfs_bmap_forkoff_reset(ip, whichfork);\n\tifp->if_flags &= ~XFS_IFINLINE;\n\tifp->if_flags |= XFS_IFEXTENTS;\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n}"
  },
  {
    "function_name": "xfs_bmap_extents_to_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "743-885",
    "snippet": "STATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ilog_fbroot",
          "args": [
            "whichfork"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fbroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "336-339",
          "snippet": "static inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */",
            "#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_ABROOT\t0x100\t/* log i_af.i_broot */\n#define\tXFS_ILOG_DBROOT\t0x008\t/* log i_df.i_broot */\n\nstatic inline int xfs_ilog_fbroot(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DBROOT : XFS_ILOG_ABROOT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*curp == NULL"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_recs",
          "args": [
            "cur",
            "abp",
            "1",
            "be16_to_cpu(ablock->bb_numrecs)"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_recs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1307-1323",
          "snippet": "void\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_recs(\n\tstruct xfs_btree_cur\t*cur,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tfirst,\n\tint\t\t\tlast)\n{\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBII(cur, bp, first, last);\n\n\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\txfs_trans_log_buf(cur->bc_tp, bp,\n\t\t\t  xfs_btree_rec_offset(cur, first),\n\t\t\t  xfs_btree_rec_offset(cur, last + 1) - 1);\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "ablock->bb_numrecs"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_log_block",
          "args": [
            "cur",
            "abp",
            "XFS_BB_ALL_BITS"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_log_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1357-1425",
          "snippet": "void\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_log_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_buf\t\t*bp,\t/* buffer containing btree block */\n\tint\t\t\tfields)\t/* mask of fields: XFS_BB_... */\n{\n\tint\t\t\tfirst;\t/* first byte offset logged */\n\tint\t\t\tlast;\t/* last byte offset logged */\n\tstatic const short\tsoffsets[] = {\t/* table of offsets (short) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.s.bb_crc),\n\t\tXFS_BTREE_SBLOCK_CRC_LEN\n\t};\n\tstatic const short\tloffsets[] = {\t/* table of offsets (long) */\n\t\toffsetof(struct xfs_btree_block, bb_magic),\n\t\toffsetof(struct xfs_btree_block, bb_level),\n\t\toffsetof(struct xfs_btree_block, bb_numrecs),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_leftsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_rightsib),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_blkno),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_lsn),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_uuid),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_owner),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_crc),\n\t\toffsetof(struct xfs_btree_block, bb_u.l.bb_pad),\n\t\tXFS_BTREE_LBLOCK_CRC_LEN\n\t};\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGBI(cur, bp, fields);\n\n\tif (bp) {\n\t\tint nbits;\n\n\t\tif (cur->bc_flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\t/*\n\t\t\t * We don't log the CRC when updating a btree\n\t\t\t * block but instead recreate it during log\n\t\t\t * recovery.  As the log buffers have checksums\n\t\t\t * of their own this is safe and avoids logging a crc\n\t\t\t * update in a lot of places.\n\t\t\t */\n\t\t\tif (fields == XFS_BB_ALL_BITS)\n\t\t\t\tfields = XFS_BB_ALL_BITS_CRC;\n\t\t\tnbits = XFS_BB_NUM_BITS_CRC;\n\t\t} else {\n\t\t\tnbits = XFS_BB_NUM_BITS;\n\t\t}\n\t\txfs_btree_offsets(fields,\n\t\t\t\t  (cur->bc_flags & XFS_BTREE_LONG_PTRS) ?\n\t\t\t\t\tloffsets : soffsets,\n\t\t\t\t  nbits, &first, &last);\n\t\txfs_trans_buf_set_type(cur->bc_tp, bp, XFS_BLFT_BTREE_BUF);\n\t\txfs_trans_log_buf(cur->bc_tp, bp, first, last);\n\t} else {\n\t\txfs_trans_log_inode(cur->bc_tp, cur->bc_private.b.ip,\n\t\t\txfs_ilog_fbroot(cur->bc_private.b.whichfork));\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "args.fsbno"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "1",
            "xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level))"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_maxrecs",
          "args": [
            "cur",
            "be16_to_cpu(block->bb_level)"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "555-572",
          "snippet": "int\nxfs_bmbt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\tif (level == cur->bc_nlevels - 1) {\n\t\tstruct xfs_ifork\t*ifp;\n\n\t\tifp = XFS_IFORK_PTR(cur->bc_private.b.ip,\n\t\t\t\t    cur->bc_private.b.whichfork);\n\n\t\treturn xfs_bmbt_maxrecs(cur->bc_mp,\n\t\t\t\t\tifp->if_broot_bytes, level == 0);\n\t}\n\n\treturn cur->bc_mp->m_bmap_dmxr[level != 0];\n\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_get_maxrecs(\n\tstruct xfs_btree_cur\t*cur,\n\tint\t\t\tlevel)\n{\n\tif (level == cur->bc_nlevels - 1) {\n\t\tstruct xfs_ifork\t*ifp;\n\n\t\tifp = XFS_IFORK_PTR(cur->bc_private.b.ip,\n\t\t\t\t    cur->bc_private.b.whichfork);\n\n\t\treturn xfs_bmbt_maxrecs(cur->bc_mp,\n\t\t\t\t\tifp->if_broot_bytes, level == 0);\n\t}\n\n\treturn cur->bc_mp->m_bmap_dmxr[level != 0];\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "xfs_bmbt_disk_get_startoff(arp)"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_get_startoff",
          "args": [
            "arp"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "187-193",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_REC_ADDR",
          "args": [
            "mp",
            "ablock",
            "1"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_KEY_ADDR",
          "args": [
            "mp",
            "block",
            "1"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_set_numrecs",
          "args": [
            "ablock",
            "cnt"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_set_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "421-425",
          "snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void xfs_btree_set_numrecs(struct xfs_btree_block *block,\n\t\t__uint16_t numrecs)\n{\n\tblock->bb_numrecs = cpu_to_be16(numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cnt == XFS_IFORK_NEXTENTS(ip, whichfork)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ep->l1"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ep->l0"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "xfs_bmbt_get_startblock(ep)"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_get_startblock",
          "args": [
            "ep"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_get_startblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "144-150",
          "snippet": "xfs_fsblock_t\nxfs_bmbt_get_startblock(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (((xfs_fsblock_t)r->l0 & xfs_mask64lo(9)) << 43) |\n\t       (((xfs_fsblock_t)r->l1) >> 21);\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fsblock_t\nxfs_bmbt_get_startblock(\n\txfs_bmbt_rec_host_t\t*r)\n{\n\treturn (((xfs_fsblock_t)r->l0 & xfs_mask64lo(9)) << 43) |\n\t       (((xfs_fsblock_t)r->l1) >> 21);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iext_get_ext",
          "args": [
            "ifp",
            "i"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iext_get_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "881-903",
          "snippet": "xfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nxfs_bmbt_rec_host_t *\nxfs_iext_get_ext(\n\txfs_ifork_t\t*ifp,\t\t/* inode fork pointer */\n\txfs_extnum_t\tidx)\t\t/* index of target extent */\n{\n\tASSERT(idx >= 0);\n\tASSERT(idx < ifp->if_bytes / sizeof(xfs_bmbt_rec_t));\n\n\tif ((ifp->if_flags & XFS_IFEXTIREC) && (idx == 0)) {\n\t\treturn ifp->if_u1.if_ext_irec->er_extbuf;\n\t} else if (ifp->if_flags & XFS_IFEXTIREC) {\n\t\txfs_ext_irec_t\t*erp;\t\t/* irec pointer */\n\t\tint\t\terp_idx = 0;\t/* irec index */\n\t\txfs_extnum_t\tpage_idx = idx;\t/* ext index in target list */\n\n\t\terp = xfs_iext_idx_to_irec(ifp, &page_idx, &erp_idx, 0);\n\t\treturn &erp->er_extbuf[page_idx];\n\t} else if (ifp->if_bytes) {\n\t\treturn &ifp->if_u1.if_extents[idx];\n\t} else {\n\t\treturn NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_REC_ADDR",
          "args": [
            "mp",
            "ablock",
            "1"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_init_block_int",
          "args": [
            "mp",
            "ablock",
            "abp->b_bn",
            "XFS_BMAP_MAGIC",
            "0",
            "0",
            "ip->i_ino",
            "XFS_BTREE_LONG_PTRS"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_init_block_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "982-1020",
          "snippet": "void\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nvoid\nxfs_btree_init_block_int(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_btree_block\t*buf,\n\txfs_daddr_t\t\tblkno,\n\t__u32\t\t\tmagic,\n\t__u16\t\t\tlevel,\n\t__u16\t\t\tnumrecs,\n\t__u64\t\t\towner,\n\tunsigned int\t\tflags)\n{\n\tbuf->bb_magic = cpu_to_be32(magic);\n\tbuf->bb_level = cpu_to_be16(level);\n\tbuf->bb_numrecs = cpu_to_be16(numrecs);\n\n\tif (flags & XFS_BTREE_LONG_PTRS) {\n\t\tbuf->bb_u.l.bb_leftsib = cpu_to_be64(NULLFSBLOCK);\n\t\tbuf->bb_u.l.bb_rightsib = cpu_to_be64(NULLFSBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.l.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.l.bb_owner = cpu_to_be64(owner);\n\t\t\tuuid_copy(&buf->bb_u.l.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.l.bb_pad = 0;\n\t\t\tbuf->bb_u.l.bb_lsn = 0;\n\t\t}\n\t} else {\n\t\t/* owner is a 32 bit value on short blocks */\n\t\t__u32 __owner = (__u32)owner;\n\n\t\tbuf->bb_u.s.bb_leftsib = cpu_to_be32(NULLAGBLOCK);\n\t\tbuf->bb_u.s.bb_rightsib = cpu_to_be32(NULLAGBLOCK);\n\t\tif (flags & XFS_BTREE_CRC_BLOCKS) {\n\t\t\tbuf->bb_u.s.bb_blkno = cpu_to_be64(blkno);\n\t\t\tbuf->bb_u.s.bb_owner = cpu_to_be32(__owner);\n\t\t\tuuid_copy(&buf->bb_u.s.bb_uuid, &mp->m_sb.sb_uuid);\n\t\t\tbuf->bb_u.s.bb_lsn = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "abp"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_bufl",
          "args": [
            "mp",
            "tp",
            "args.fsbno",
            "0"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_bufl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "548-560",
          "snippet": "xfs_buf_t *\t\t\t\t/* buffer for fsbno */\nxfs_btree_get_bufl(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\tfsbno,\t\t/* file system block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_buf_t *\t\t\t\t/* buffer for fsbno */\nxfs_btree_get_bufl(\n\txfs_mount_t\t*mp,\t\t/* file system mount point */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\tfsbno,\t\t/* file system block number */\n\tuint\t\tlock)\t\t/* lock flags for get_buf */\n{\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\treturn xfs_trans_get_buf(tp, mp->m_ddev_targp, d, mp->m_bsize, lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "tp",
            "ip",
            "XFS_TRANS_DQ_BCOUNT",
            "1L"
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock))"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "*firstblock"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "*firstblock"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "args.fsbno != NULLFSBLOCK"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_del_cursor",
          "args": [
            "cur",
            "XFS_BTREE_ERROR"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_del_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "285-318",
          "snippet": "void\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_btree_cur_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_btree_cur_zone;\n\nvoid\nxfs_btree_del_cursor(\n\txfs_btree_cur_t\t*cur,\t\t/* btree cursor */\n\tint\t\terror)\t\t/* del because of error */\n{\n\tint\t\ti;\t\t/* btree level */\n\n\t/*\n\t * Clear the buffer pointers, and release the buffers.\n\t * If we're doing this in the face of an error, we\n\t * need to make sure to inspect all of the entries\n\t * in the bc_bufs array for buffers to be unlocked.\n\t * This is because some of the btree code works from\n\t * level n down to 0, and if we get an error along\n\t * the way we won't have initialized all the entries\n\t * down to 0.\n\t */\n\tfor (i = 0; i < cur->bc_nlevels; i++) {\n\t\tif (cur->bc_bufs[i])\n\t\t\txfs_trans_brelse(cur->bc_tp, cur->bc_bufs[i]);\n\t\telse if (!error)\n\t\t\tbreak;\n\t}\n\t/*\n\t * Can't free a bmap cursor without having dealt with the\n\t * allocated indirect blocks' accounting.\n\t */\n\tASSERT(cur->bc_btnum != XFS_BTNUM_BMAP ||\n\t       cur->bc_private.b.allocated == 0);\n\t/*\n\t * Free the cursor.\n\t */\n\tkmem_zone_free(xfs_btree_cur_zone, cur);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_iroot_realloc",
          "args": [
            "ip",
            "-1",
            "whichfork"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iroot_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "473-583",
          "snippet": "void\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_vextent",
          "args": [
            "&args"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_vextent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2371-2580",
          "snippet": "int\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);",
            "STATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int xfs_alloc_ag_vextent_exact(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_near(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_size(xfs_alloc_arg_t *);\nSTATIC int xfs_alloc_ag_vextent_small(xfs_alloc_arg_t *,\n\t\txfs_btree_cur_t *, xfs_agblock_t *, xfs_extlen_t *, int *);\n\nint\t\t\t\t/* error */\nxfs_alloc_vextent(\n\txfs_alloc_arg_t\t*args)\t/* allocation argument structure */\n{\n\txfs_agblock_t\tagsize;\t/* allocation group size */\n\tint\t\terror;\n\tint\t\tflags;\t/* XFS_ALLOC_FLAG_... locking flags */\n\txfs_extlen_t\tminleft;/* minimum left value, temp copy */\n\txfs_mount_t\t*mp;\t/* mount structure pointer */\n\txfs_agnumber_t\tsagno;\t/* starting allocation group number */\n\txfs_alloctype_t\ttype;\t/* input allocation type */\n\tint\t\tbump_rotor = 0;\n\tint\t\tno_min = 0;\n\txfs_agnumber_t\trotorstep = xfs_rotorstep; /* inode32 agf stepper */\n\n\tmp = args->mp;\n\ttype = args->otype = args->type;\n\targs->agbno = NULLAGBLOCK;\n\t/*\n\t * Just fix this up, for the case where the last a.g. is shorter\n\t * (or there's only one a.g.) and the caller couldn't easily figure\n\t * that out (xfs_bmap_alloc).\n\t */\n\tagsize = mp->m_sb.sb_agblocks;\n\tif (args->maxlen > agsize)\n\t\targs->maxlen = agsize;\n\tif (args->alignment == 0)\n\t\targs->alignment = 1;\n\tASSERT(XFS_FSB_TO_AGNO(mp, args->fsbno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, args->fsbno) < agsize);\n\tASSERT(args->minlen <= args->maxlen);\n\tASSERT(args->minlen <= agsize);\n\tASSERT(args->mod < args->prod);\n\tif (XFS_FSB_TO_AGNO(mp, args->fsbno) >= mp->m_sb.sb_agcount ||\n\t    XFS_FSB_TO_AGBNO(mp, args->fsbno) >= agsize ||\n\t    args->minlen > args->maxlen || args->minlen > agsize ||\n\t    args->mod >= args->prod) {\n\t\targs->fsbno = NULLFSBLOCK;\n\t\ttrace_xfs_alloc_vextent_badargs(args);\n\t\treturn 0;\n\t}\n\tminleft = args->minleft;\n\n\tswitch (type) {\n\tcase XFS_ALLOCTYPE_THIS_AG:\n\tcase XFS_ALLOCTYPE_NEAR_BNO:\n\tcase XFS_ALLOCTYPE_THIS_BNO:\n\t\t/*\n\t\t * These three force us into a single a.g.\n\t\t */\n\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\targs->minleft = 0;\n\t\terror = xfs_alloc_fix_freelist(args, 0);\n\t\targs->minleft = minleft;\n\t\tif (error) {\n\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\tgoto error0;\n\t\t}\n\t\tif (!args->agbp) {\n\t\t\ttrace_xfs_alloc_vextent_noagbp(args);\n\t\t\tbreak;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\tgoto error0;\n\t\tbreak;\n\tcase XFS_ALLOCTYPE_START_BNO:\n\t\t/*\n\t\t * Try near allocation first, then anywhere-in-ag after\n\t\t * the first a.g. fails.\n\t\t */\n\t\tif ((args->userdata  == XFS_ALLOC_INITIAL_USER_DATA) &&\n\t\t    (mp->m_flags & XFS_MOUNT_32BITINODES)) {\n\t\t\targs->fsbno = XFS_AGB_TO_FSB(mp,\n\t\t\t\t\t((mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount), 0);\n\t\t\tbump_rotor = 1;\n\t\t}\n\t\targs->agbno = XFS_FSB_TO_AGBNO(mp, args->fsbno);\n\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t/* FALLTHROUGH */\n\tcase XFS_ALLOCTYPE_ANY_AG:\n\tcase XFS_ALLOCTYPE_START_AG:\n\tcase XFS_ALLOCTYPE_FIRST_AG:\n\t\t/*\n\t\t * Rotate through the allocation groups looking for a winner.\n\t\t */\n\t\tif (type == XFS_ALLOCTYPE_ANY_AG) {\n\t\t\t/*\n\t\t\t * Start with the last place we left off.\n\t\t\t */\n\t\t\targs->agno = sagno = (mp->m_agfrotor / rotorstep) %\n\t\t\t\t\tmp->m_sb.sb_agcount;\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t} else if (type == XFS_ALLOCTYPE_FIRST_AG) {\n\t\t\t/*\n\t\t\t * Start with allocation group given by bno.\n\t\t\t */\n\t\t\targs->agno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\tsagno = 0;\n\t\t\tflags = 0;\n\t\t} else {\n\t\t\tif (type == XFS_ALLOCTYPE_START_AG)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t * Start with the given allocation group.\n\t\t\t */\n\t\t\targs->agno = sagno = XFS_FSB_TO_AGNO(mp, args->fsbno);\n\t\t\tflags = XFS_ALLOC_FLAG_TRYLOCK;\n\t\t}\n\t\t/*\n\t\t * Loop over allocation groups twice; first time with\n\t\t * trylock set, second time without.\n\t\t */\n\t\tfor (;;) {\n\t\t\targs->pag = xfs_perag_get(mp, args->agno);\n\t\t\tif (no_min) args->minleft = 0;\n\t\t\terror = xfs_alloc_fix_freelist(args, flags);\n\t\t\targs->minleft = minleft;\n\t\t\tif (error) {\n\t\t\t\ttrace_xfs_alloc_vextent_nofix(args);\n\t\t\t\tgoto error0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * If we get a buffer back then the allocation will fly.\n\t\t\t */\n\t\t\tif (args->agbp) {\n\t\t\t\tif ((error = xfs_alloc_ag_vextent(args)))\n\t\t\t\t\tgoto error0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttrace_xfs_alloc_vextent_loopfailed(args);\n\n\t\t\t/*\n\t\t\t * Didn't work, figure out the next iteration.\n\t\t\t */\n\t\t\tif (args->agno == sagno &&\n\t\t\t    type == XFS_ALLOCTYPE_START_BNO)\n\t\t\t\targs->type = XFS_ALLOCTYPE_THIS_AG;\n\t\t\t/*\n\t\t\t* For the first allocation, we can try any AG to get\n\t\t\t* space.  However, if we already have allocated a\n\t\t\t* block, we don't want to try AGs whose number is below\n\t\t\t* sagno. Otherwise, we may end up with out-of-order\n\t\t\t* locking of AGF, which might cause deadlock.\n\t\t\t*/\n\t\t\tif (++(args->agno) == mp->m_sb.sb_agcount) {\n\t\t\t\tif (args->firstblock != NULLFSBLOCK)\n\t\t\t\t\targs->agno = sagno;\n\t\t\t\telse\n\t\t\t\t\targs->agno = 0;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Reached the starting a.g., must either be done\n\t\t\t * or switch to non-trylock mode.\n\t\t\t */\n\t\t\tif (args->agno == sagno) {\n\t\t\t\tif (no_min == 1) {\n\t\t\t\t\targs->agbno = NULLAGBLOCK;\n\t\t\t\t\ttrace_xfs_alloc_vextent_allfailed(args);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (flags == 0) {\n\t\t\t\t\tno_min = 1;\n\t\t\t\t} else {\n\t\t\t\t\tflags = 0;\n\t\t\t\t\tif (type == XFS_ALLOCTYPE_START_BNO) {\n\t\t\t\t\t\targs->agbno = XFS_FSB_TO_AGBNO(mp,\n\t\t\t\t\t\t\targs->fsbno);\n\t\t\t\t\t\targs->type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\txfs_perag_put(args->pag);\n\t\t}\n\t\tif (bump_rotor || (type == XFS_ALLOCTYPE_ANY_AG)) {\n\t\t\tif (args->agno == sagno)\n\t\t\t\tmp->m_agfrotor = (mp->m_agfrotor + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t\telse\n\t\t\t\tmp->m_agfrotor = (args->agno * rotorstep + 1) %\n\t\t\t\t\t(mp->m_sb.sb_agcount * rotorstep);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t\t/* NOTREACHED */\n\t}\n\tif (args->agbno == NULLAGBLOCK)\n\t\targs->fsbno = NULLFSBLOCK;\n\telse {\n\t\targs->fsbno = XFS_AGB_TO_FSB(mp, args->agno, args->agbno);\n#ifdef DEBUG\n\t\tASSERT(args->len >= args->minlen);\n\t\tASSERT(args->len <= args->maxlen);\n\t\tASSERT(args->agbno % args->alignment == 0);\n\t\tXFS_AG_CHECK_DADDR(mp, XFS_FSB_TO_DADDR(mp, args->fsbno),\n\t\t\targs->len);\n#endif\n\t}\n\txfs_perag_put(args->pag);\n\treturn 0;\nerror0:\n\txfs_perag_put(args->pag);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_INO_TO_FSB",
          "args": [
            "mp",
            "ip->i_ino"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FMT_SET",
          "args": [
            "ip",
            "whichfork",
            "XFS_DINODE_FMT_BTREE"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_init_cursor",
          "args": [
            "mp",
            "tp",
            "ip",
            "whichfork"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_init_cursor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "776-808",
          "snippet": "struct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "static const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nstatic const struct xfs_btree_ops xfs_bmbt_ops = {\n\t.rec_len\t\t= sizeof(xfs_bmbt_rec_t),\n\t.key_len\t\t= sizeof(xfs_bmbt_key_t),\n\n\t.dup_cursor\t\t= xfs_bmbt_dup_cursor,\n\t.update_cursor\t\t= xfs_bmbt_update_cursor,\n\t.alloc_block\t\t= xfs_bmbt_alloc_block,\n\t.free_block\t\t= xfs_bmbt_free_block,\n\t.get_maxrecs\t\t= xfs_bmbt_get_maxrecs,\n\t.get_minrecs\t\t= xfs_bmbt_get_minrecs,\n\t.get_dmaxrecs\t\t= xfs_bmbt_get_dmaxrecs,\n\t.init_key_from_rec\t= xfs_bmbt_init_key_from_rec,\n\t.init_rec_from_key\t= xfs_bmbt_init_rec_from_key,\n\t.init_rec_from_cur\t= xfs_bmbt_init_rec_from_cur,\n\t.init_ptr_from_cur\t= xfs_bmbt_init_ptr_from_cur,\n\t.key_diff\t\t= xfs_bmbt_key_diff,\n\t.buf_ops\t\t= &xfs_bmbt_buf_ops,\n#if defined(DEBUG) || defined(XFS_WARN)\n\t.keys_inorder\t\t= xfs_bmbt_keys_inorder,\n\t.recs_inorder\t\t= xfs_bmbt_recs_inorder,\n#endif\n};\n\nstruct xfs_btree_cur *\t\t\t\t/* new bmap btree cursor */\nxfs_bmbt_init_cursor(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\tstruct xfs_inode\t*ip,\t\t/* inode owning the btree */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_ifork\t*ifp = XFS_IFORK_PTR(ip, whichfork);\n\tstruct xfs_btree_cur\t*cur;\n\n\tcur = kmem_zone_zalloc(xfs_btree_cur_zone, KM_SLEEP);\n\n\tcur->bc_tp = tp;\n\tcur->bc_mp = mp;\n\tcur->bc_nlevels = be16_to_cpu(ifp->if_broot->bb_level) + 1;\n\tcur->bc_btnum = XFS_BTNUM_BMAP;\n\tcur->bc_blocklog = mp->m_sb.sb_blocklog;\n\n\tcur->bc_ops = &xfs_bmbt_ops;\n\tcur->bc_flags = XFS_BTREE_LONG_PTRS | XFS_BTREE_ROOT_IN_INODE;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\tcur->bc_flags |= XFS_BTREE_CRC_BLOCKS;\n\n\tcur->bc_private.b.forksize = XFS_IFORK_SIZE(ip, whichfork);\n\tcur->bc_private.b.ip = ip;\n\tcur->bc_private.b.firstblock = NULLFSBLOCK;\n\tcur->bc_private.b.flist = NULL;\n\tcur->bc_private.b.allocated = 0;\n\tcur->bc_private.b.flags = 0;\n\tcur->bc_private.b.whichfork = whichfork;\n\n\treturn cur;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t\t/* error */\nxfs_bmap_extents_to_btree(\n\txfs_trans_t\t\t*tp,\t\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\txfs_fsblock_t\t\t*firstblock,\t/* first-block-allocated */\n\txfs_bmap_free_t\t\t*flist,\t\t/* blocks freed in xaction */\n\txfs_btree_cur_t\t\t**curp,\t\t/* cursor returned to caller */\n\tint\t\t\twasdel,\t\t/* converting a delayed alloc */\n\tint\t\t\t*logflagsp,\t/* inode logging flags */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*ablock;\t/* allocated (child) bt block */\n\txfs_buf_t\t\t*abp;\t\t/* buffer for ablock */\n\txfs_alloc_arg_t\t\targs;\t\t/* allocation arguments */\n\txfs_bmbt_rec_t\t\t*arp;\t\t/* child record pointer */\n\tstruct xfs_btree_block\t*block;\t\t/* btree root block */\n\txfs_btree_cur_t\t\t*cur;\t\t/* bmap btree cursor */\n\txfs_bmbt_rec_host_t\t*ep;\t\t/* extent record pointer */\n\tint\t\t\terror;\t\t/* error return value */\n\txfs_extnum_t\t\ti, cnt;\t\t/* extent record index */\n\txfs_ifork_t\t\t*ifp;\t\t/* inode fork pointer */\n\txfs_bmbt_key_t\t\t*kp;\t\t/* root block key pointer */\n\txfs_mount_t\t\t*mp;\t\t/* mount structure */\n\txfs_extnum_t\t\tnextents;\t/* number of file extents */\n\txfs_bmbt_ptr_t\t\t*pp;\t\t/* root block address pointer */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS);\n\n\t/*\n\t * Make space in the inode incore.\n\t */\n\txfs_iroot_realloc(ip, 1, whichfork);\n\tifp->if_flags |= XFS_IFBROOT;\n\n\t/*\n\t * Fill in the root.\n\t */\n\tblock = ifp->if_broot;\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_CRC_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, block, XFS_BUF_DADDR_NULL,\n\t\t\t\t XFS_BMAP_MAGIC, 1, 1, ip->i_ino,\n\t\t\t\t XFS_BTREE_LONG_PTRS);\n\n\t/*\n\t * Need a cursor.  Can't allocate until bb_level is filled in.\n\t */\n\tcur = xfs_bmbt_init_cursor(mp, tp, ip, whichfork);\n\tcur->bc_private.b.firstblock = *firstblock;\n\tcur->bc_private.b.flist = flist;\n\tcur->bc_private.b.flags = wasdel ? XFS_BTCUR_BPRV_WASDEL : 0;\n\t/*\n\t * Convert to a btree with two levels, one record in root.\n\t */\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_BTREE);\n\tmemset(&args, 0, sizeof(args));\n\targs.tp = tp;\n\targs.mp = mp;\n\targs.firstblock = *firstblock;\n\tif (*firstblock == NULLFSBLOCK) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = XFS_INO_TO_FSB(mp, ip->i_ino);\n\t} else if (flist->xbf_low) {\n\t\targs.type = XFS_ALLOCTYPE_START_BNO;\n\t\targs.fsbno = *firstblock;\n\t} else {\n\t\targs.type = XFS_ALLOCTYPE_NEAR_BNO;\n\t\targs.fsbno = *firstblock;\n\t}\n\targs.minlen = args.maxlen = args.prod = 1;\n\targs.wasdel = wasdel;\n\t*logflagsp = 0;\n\tif ((error = xfs_alloc_vextent(&args))) {\n\t\txfs_iroot_realloc(ip, -1, whichfork);\n\t\txfs_btree_del_cursor(cur, XFS_BTREE_ERROR);\n\t\treturn error;\n\t}\n\t/*\n\t * Allocation can't fail, the space was reserved.\n\t */\n\tASSERT(args.fsbno != NULLFSBLOCK);\n\tASSERT(*firstblock == NULLFSBLOCK ||\n\t       args.agno == XFS_FSB_TO_AGNO(mp, *firstblock) ||\n\t       (flist->xbf_low &&\n\t\targs.agno > XFS_FSB_TO_AGNO(mp, *firstblock)));\n\t*firstblock = cur->bc_private.b.firstblock = args.fsbno;\n\tcur->bc_private.b.allocated++;\n\tip->i_d.di_nblocks++;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, 1L);\n\tabp = xfs_btree_get_bufl(mp, tp, args.fsbno, 0);\n\t/*\n\t * Fill in the child block.\n\t */\n\tabp->b_ops = &xfs_bmbt_buf_ops;\n\tablock = XFS_BUF_TO_BLOCK(abp);\n\tif (xfs_sb_version_hascrc(&mp->m_sb))\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_CRC_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS | XFS_BTREE_CRC_BLOCKS);\n\telse\n\t\txfs_btree_init_block_int(mp, ablock, abp->b_bn,\n\t\t\t\tXFS_BMAP_MAGIC, 0, 0, ip->i_ino,\n\t\t\t\tXFS_BTREE_LONG_PTRS);\n\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tnextents = ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t);\n\tfor (cnt = i = 0; i < nextents; i++) {\n\t\tep = xfs_iext_get_ext(ifp, i);\n\t\tif (!isnullstartblock(xfs_bmbt_get_startblock(ep))) {\n\t\t\tarp->l0 = cpu_to_be64(ep->l0);\n\t\t\tarp->l1 = cpu_to_be64(ep->l1);\n\t\t\tarp++; cnt++;\n\t\t}\n\t}\n\tASSERT(cnt == XFS_IFORK_NEXTENTS(ip, whichfork));\n\txfs_btree_set_numrecs(ablock, cnt);\n\n\t/*\n\t * Fill in the root key and pointer.\n\t */\n\tkp = XFS_BMBT_KEY_ADDR(mp, block, 1);\n\tarp = XFS_BMBT_REC_ADDR(mp, ablock, 1);\n\tkp->br_startoff = cpu_to_be64(xfs_bmbt_disk_get_startoff(arp));\n\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, xfs_bmbt_get_maxrecs(cur,\n\t\t\t\t\t\tbe16_to_cpu(block->bb_level)));\n\t*pp = cpu_to_be64(args.fsbno);\n\n\t/*\n\t * Do all this logging at the end so that\n\t * the root is at the right level.\n\t */\n\txfs_btree_log_block(cur, abp, XFS_BB_ALL_BITS);\n\txfs_btree_log_recs(cur, abp, 1, be16_to_cpu(ablock->bb_numrecs));\n\tASSERT(*curp == NULL);\n\t*curp = cur;\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_btree_to_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "685-737",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmap_btree_to_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork)  /* data or attr fork */\n{\n\t/* REFERENCED */\n\tstruct xfs_btree_block\t*cblock;/* child btree block */\n\txfs_fsblock_t\t\tcbno;\t/* child block number */\n\txfs_buf_t\t\t*cbp;\t/* child block's buffer */\n\tint\t\t\terror;\t/* error return value */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork data */\n\txfs_mount_t\t\t*mp;\t/* mount point structure */\n\t__be64\t\t\t*pp;\t/* ptr to block address */\n\tstruct xfs_btree_block\t*rblock;/* root btree block */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\trblock = ifp->if_broot;\n\tASSERT(be16_to_cpu(rblock->bb_level) == 1);\n\tASSERT(be16_to_cpu(rblock->bb_numrecs) == 1);\n\tASSERT(xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0) == 1);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, ifp->if_broot_bytes);\n\tcbno = be64_to_cpu(*pp);\n\t*logflagsp = 0;\n#ifdef DEBUG\n\tif ((error = xfs_btree_check_lptr(cur, cbno, 1)))\n\t\treturn error;\n#endif\n\terror = xfs_btree_read_bufl(mp, tp, cbno, 0, &cbp, XFS_BMAP_BTREE_REF,\n\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\tcblock = XFS_BUF_TO_BLOCK(cbp);\n\tif ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))\n\t\treturn error;\n\txfs_bmap_add_free(cbno, 1, cur->bc_private.b.flist, mp);\n\tip->i_d.di_nblocks--;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, cbp);\n\tif (cur->bc_bufs[0] == cbp)\n\t\tcur->bc_bufs[0] = NULL;\n\txfs_iroot_realloc(ip, -1, whichfork);\n\tASSERT(ifp->if_broot == NULL);\n\tASSERT((ifp->if_flags & XFS_IFBROOT) == 0);\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_ilog_fext",
          "args": [
            "whichfork"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ilog_fext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_log_format.h",
          "lines": "341-344",
          "snippet": "static inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */",
            "#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_ILOG_AEXT\t0x080\t/* log i_af.if_extents */\n#define\tXFS_ILOG_DEXT\t0x004\t/* log i_df.if_extents */\n\nstatic inline int xfs_ilog_fext(int w)\n{\n\treturn (w == XFS_DATA_FORK ? XFS_ILOG_DEXT : XFS_ILOG_AEXT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FMT_SET",
          "args": [
            "ip",
            "whichfork",
            "XFS_DINODE_FMT_EXTENTS"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "(ifp->if_flags & XFS_IFBROOT) == 0"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_broot == NULL"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_iroot_realloc",
          "args": [
            "ip",
            "-1",
            "whichfork"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_iroot_realloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_inode_fork.c",
          "lines": "473-583",
          "snippet": "void\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}",
          "includes": [
            "#include \"xfs_attr_sf.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\"",
            "#include <linux/log2.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_attr_sf.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n#include <linux/log2.h>\n\nvoid\nxfs_iroot_realloc(\n\txfs_inode_t\t\t*ip,\n\tint\t\t\trec_diff,\n\tint\t\t\twhichfork)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tint\t\t\tcur_max;\n\txfs_ifork_t\t\t*ifp;\n\tstruct xfs_btree_block\t*new_broot;\n\tint\t\t\tnew_max;\n\tsize_t\t\t\tnew_size;\n\tchar\t\t\t*np;\n\tchar\t\t\t*op;\n\n\t/*\n\t * Handle the degenerate case quietly.\n\t */\n\tif (rec_diff == 0) {\n\t\treturn;\n\t}\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tif (rec_diff > 0) {\n\t\t/*\n\t\t * If there wasn't any memory allocated before, just\n\t\t * allocate it now and get out.\n\t\t */\n\t\tif (ifp->if_broot_bytes == 0) {\n\t\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, rec_diff);\n\t\t\tifp->if_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t\tifp->if_broot_bytes = (int)new_size;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * If there is already an existing if_broot, then we need\n\t\t * to realloc() it and shift the pointers to their new\n\t\t * location.  The records don't change location because\n\t\t * they are kept butted up against the btree block header.\n\t\t */\n\t\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\t\tnew_max = cur_max + rec_diff;\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\t\tifp->if_broot = kmem_realloc(ifp->if_broot, new_size,\n\t\t\t\tXFS_BMAP_BROOT_SPACE_CALC(mp, cur_max),\n\t\t\t\tKM_SLEEP | KM_NOFS);\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tifp->if_broot_bytes = (int)new_size;\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\t\tmemmove(np, op, cur_max * (uint)sizeof(xfs_fsblock_t));\n\t\treturn;\n\t}\n\n\t/*\n\t * rec_diff is less than 0.  In this case, we are shrinking the\n\t * if_broot buffer.  It must already exist.  If we go to zero\n\t * records, just get rid of the root and clear the status bit.\n\t */\n\tASSERT((ifp->if_broot != NULL) && (ifp->if_broot_bytes > 0));\n\tcur_max = xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0);\n\tnew_max = cur_max + rec_diff;\n\tASSERT(new_max >= 0);\n\tif (new_max > 0)\n\t\tnew_size = XFS_BMAP_BROOT_SPACE_CALC(mp, new_max);\n\telse\n\t\tnew_size = 0;\n\tif (new_size > 0) {\n\t\tnew_broot = kmem_alloc(new_size, KM_SLEEP | KM_NOFS);\n\t\t/*\n\t\t * First copy over the btree block header.\n\t\t */\n\t\tmemcpy(new_broot, ifp->if_broot,\n\t\t\tXFS_BMBT_BLOCK_LEN(ip->i_mount));\n\t} else {\n\t\tnew_broot = NULL;\n\t\tifp->if_flags &= ~XFS_IFBROOT;\n\t}\n\n\t/*\n\t * Only copy the records and pointers if there are any.\n\t */\n\tif (new_max > 0) {\n\t\t/*\n\t\t * First copy the records.\n\t\t */\n\t\top = (char *)XFS_BMBT_REC_ADDR(mp, ifp->if_broot, 1);\n\t\tnp = (char *)XFS_BMBT_REC_ADDR(mp, new_broot, 1);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_bmbt_rec_t));\n\n\t\t/*\n\t\t * Then copy the pointers.\n\t\t */\n\t\top = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, ifp->if_broot, 1,\n\t\t\t\t\t\t     ifp->if_broot_bytes);\n\t\tnp = (char *)XFS_BMAP_BROOT_PTR_ADDR(mp, new_broot, 1,\n\t\t\t\t\t\t     (int)new_size);\n\t\tmemcpy(np, op, new_max * (uint)sizeof(xfs_fsblock_t));\n\t}\n\tkmem_free(ifp->if_broot);\n\tifp->if_broot = new_broot;\n\tifp->if_broot_bytes = (int)new_size;\n\tif (ifp->if_broot)\n\t\tASSERT(XFS_BMAP_BMDR_SPACE(ifp->if_broot) <=\n\t\t\tXFS_IFORK_SIZE(ip, whichfork));\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_binval",
          "args": [
            "tp",
            "cbp"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_binval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "584-626",
          "snippet": "void\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_binval(\n\txfs_trans_t\t*tp,\n\txfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\tint\t\t\ti;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_binval(bip);\n\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\t/*\n\t\t * If the buffer is already invalidated, then\n\t\t * just return.\n\t\t */\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tASSERT(!(bip->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY)));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_INODE_BUF));\n\t\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLFT_MASK));\n\t\tASSERT(bip->__bli_format.blf_flags & XFS_BLF_CANCEL);\n\t\tASSERT(bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY);\n\t\tASSERT(tp->t_flags & XFS_TRANS_DIRTY);\n\t\treturn;\n\t}\n\n\txfs_buf_stale(bp);\n\n\tbip->bli_flags |= XFS_BLI_STALE;\n\tbip->bli_flags &= ~(XFS_BLI_INODE_BUF | XFS_BLI_LOGGED | XFS_BLI_DIRTY);\n\tbip->__bli_format.blf_flags &= ~XFS_BLF_INODE_BUF;\n\tbip->__bli_format.blf_flags |= XFS_BLF_CANCEL;\n\tbip->__bli_format.blf_flags &= ~XFS_BLFT_MASK;\n\tfor (i = 0; i < bip->bli_format_count; i++) {\n\t\tmemset(bip->bli_formats[i].blf_data_map, 0,\n\t\t       (bip->bli_formats[i].blf_map_size * sizeof(uint)));\n\t}\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_mod_dquot_byino",
          "args": [
            "tp",
            "ip",
            "XFS_TRANS_DQ_BCOUNT",
            "-1L"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_mod_dquot_byino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_dquot.c",
          "lines": "141-164",
          "snippet": "void\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}",
          "includes": [
            "#include \"xfs_qm.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_qm.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\txfs_trans_alloc_dqinfo(xfs_trans_t *);\n\nvoid\nxfs_trans_mod_dquot_byino(\n\txfs_trans_t\t*tp,\n\txfs_inode_t\t*ip,\n\tuint\t\tfield,\n\tlong\t\tdelta)\n{\n\txfs_mount_t\t*mp = tp->t_mountp;\n\n\tif (!XFS_IS_QUOTA_RUNNING(mp) ||\n\t    !XFS_IS_QUOTA_ON(mp) ||\n\t    xfs_is_quota_inode(&mp->m_sb, ip->i_ino))\n\t\treturn;\n\n\tif (tp->t_dqinfo == NULL)\n\t\txfs_trans_alloc_dqinfo(tp);\n\n\tif (XFS_IS_UQUOTA_ON(mp) && ip->i_udquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_udquot, field, delta);\n\tif (XFS_IS_GQUOTA_ON(mp) && ip->i_gdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_gdquot, field, delta);\n\tif (XFS_IS_PQUOTA_ON(mp) && ip->i_pdquot)\n\t\t(void) xfs_trans_mod_dquot(tp, ip->i_pdquot, field, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_add_free",
          "args": [
            "cbno",
            "1",
            "cur->bc_private.b.flist",
            "mp"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_add_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "594-635",
          "snippet": "void\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t\t*xfs_bmap_free_item_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t\t*xfs_bmap_free_item_zone;\n\nvoid\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_block",
          "args": [
            "cur",
            "cblock",
            "0",
            "cbp"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "149-160",
          "snippet": "int\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_check_block(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\tstruct xfs_btree_block\t*block,\t/* generic btree block pointer */\n\tint\t\t\tlevel,\t/* level of the btree block */\n\tstruct xfs_buf\t\t*bp)\t/* buffer containing block, if any */\n{\n\tif (cur->bc_flags & XFS_BTREE_LONG_PTRS)\n\t\treturn xfs_btree_check_lblock(cur, block, level, bp);\n\telse\n\t\treturn xfs_btree_check_sblock(cur, block, level, bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "cbp"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_bufl",
          "args": [
            "mp",
            "tp",
            "cbno",
            "0",
            "&cbp",
            "XFS_BMAP_BTREE_REF",
            "&xfs_bmbt_buf_ops"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_bufl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "699-723",
          "snippet": "int\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_btree_check_lptr",
          "args": [
            "cur",
            "cbno",
            "1"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_check_lptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "165-176",
          "snippet": "int\t\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_fsblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLFSBLOCK &&\n\t\tXFS_FSB_SANITY_CHECK(cur->bc_mp, bno));\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\t\t\t\t\t/* error (0 or EFSCORRUPTED) */\nxfs_btree_check_lptr(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_fsblock_t\t\tbno,\t/* btree block disk address */\n\tint\t\t\tlevel)\t/* btree block level */\n{\n\tXFS_WANT_CORRUPTED_RETURN(\n\t\tlevel > 0 &&\n\t\tbno != NULLFSBLOCK &&\n\t\tXFS_FSB_SANITY_CHECK(cur->bc_mp, bno));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*pp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "rblock",
            "1",
            "ifp->if_broot_bytes"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0) == 1"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_maxrecs",
          "args": [
            "mp",
            "ifp->if_broot_bytes",
            "0"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "813-824",
          "snippet": "int\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(rblock->bb_numrecs) == 1"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "rblock->bb_numrecs"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(rblock->bb_level) == 1"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "rblock->bb_level"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ifp->if_flags & XFS_IFEXTENTS"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmap_btree_to_extents(\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_inode_t\t\t*ip,\t/* incore inode pointer */\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor */\n\tint\t\t\t*logflagsp, /* inode logging flags */\n\tint\t\t\twhichfork)  /* data or attr fork */\n{\n\t/* REFERENCED */\n\tstruct xfs_btree_block\t*cblock;/* child btree block */\n\txfs_fsblock_t\t\tcbno;\t/* child block number */\n\txfs_buf_t\t\t*cbp;\t/* child block's buffer */\n\tint\t\t\terror;\t/* error return value */\n\txfs_ifork_t\t\t*ifp;\t/* inode fork data */\n\txfs_mount_t\t\t*mp;\t/* mount point structure */\n\t__be64\t\t\t*pp;\t/* ptr to block address */\n\tstruct xfs_btree_block\t*rblock;/* root btree block */\n\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(ifp->if_flags & XFS_IFEXTENTS);\n\tASSERT(XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE);\n\trblock = ifp->if_broot;\n\tASSERT(be16_to_cpu(rblock->bb_level) == 1);\n\tASSERT(be16_to_cpu(rblock->bb_numrecs) == 1);\n\tASSERT(xfs_bmbt_maxrecs(mp, ifp->if_broot_bytes, 0) == 1);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, rblock, 1, ifp->if_broot_bytes);\n\tcbno = be64_to_cpu(*pp);\n\t*logflagsp = 0;\n#ifdef DEBUG\n\tif ((error = xfs_btree_check_lptr(cur, cbno, 1)))\n\t\treturn error;\n#endif\n\terror = xfs_btree_read_bufl(mp, tp, cbno, 0, &cbp, XFS_BMAP_BTREE_REF,\n\t\t\t\t&xfs_bmbt_buf_ops);\n\tif (error)\n\t\treturn error;\n\tcblock = XFS_BUF_TO_BLOCK(cbp);\n\tif ((error = xfs_btree_check_block(cur, cblock, 0, cbp)))\n\t\treturn error;\n\txfs_bmap_add_free(cbno, 1, cur->bc_private.b.flist, mp);\n\tip->i_d.di_nblocks--;\n\txfs_trans_mod_dquot_byino(tp, ip, XFS_TRANS_DQ_BCOUNT, -1L);\n\txfs_trans_binval(tp, cbp);\n\tif (cur->bc_bufs[0] == cbp)\n\t\tcur->bc_bufs[0] = NULL;\n\txfs_iroot_realloc(ip, -1, whichfork);\n\tASSERT(ifp->if_broot == NULL);\n\tASSERT((ifp->if_flags & XFS_IFBROOT) == 0);\n\tXFS_IFORK_FMT_SET(ip, whichfork, XFS_DINODE_FMT_EXTENTS);\n\t*logflagsp = XFS_ILOG_CORE | xfs_ilog_fext(whichfork);\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_bmap_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "658-673",
    "snippet": "void\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flist->xbf_count == 0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_del_free",
          "args": [
            "flist",
            "NULL",
            "free"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_del_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "641-653",
          "snippet": "void\nxfs_bmap_del_free(\n\txfs_bmap_free_t\t\t*flist,\t/* free item list header */\n\txfs_bmap_free_item_t\t*prev,\t/* previous item on list, if any */\n\txfs_bmap_free_item_t\t*free)\t/* list item to be freed */\n{\n\tif (prev)\n\t\tprev->xbfi_next = free->xbfi_next;\n\telse\n\t\tflist->xbf_first = free->xbfi_next;\n\tflist->xbf_count--;\n\tkmem_zone_free(xfs_bmap_free_item_zone, free);\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t\t*xfs_bmap_free_item_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t\t*xfs_bmap_free_item_zone;\n\nvoid\nxfs_bmap_del_free(\n\txfs_bmap_free_t\t\t*flist,\t/* free item list header */\n\txfs_bmap_free_item_t\t*prev,\t/* previous item on list, if any */\n\txfs_bmap_free_item_t\t*free)\t/* list item to be freed */\n{\n\tif (prev)\n\t\tprev->xbfi_next = free->xbfi_next;\n\telse\n\t\tflist->xbf_first = free->xbfi_next;\n\tflist->xbf_count--;\n\tkmem_zone_free(xfs_bmap_free_item_zone, free);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "flist->xbf_first != NULL"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_cancel(\n\txfs_bmap_free_t\t\t*flist)\t/* list of bmap_free_items */\n{\n\txfs_bmap_free_item_t\t*free;\t/* free list item */\n\txfs_bmap_free_item_t\t*next;\n\n\tif (flist->xbf_count == 0)\n\t\treturn;\n\tASSERT(flist->xbf_first != NULL);\n\tfor (free = flist->xbf_first; free; free = next) {\n\t\tnext = free->xbfi_next;\n\t\txfs_bmap_del_free(flist, NULL, free);\n\t}\n\tASSERT(flist->xbf_count == 0);\n}"
  },
  {
    "function_name": "xfs_bmap_del_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "641-653",
    "snippet": "void\nxfs_bmap_del_free(\n\txfs_bmap_free_t\t\t*flist,\t/* free item list header */\n\txfs_bmap_free_item_t\t*prev,\t/* previous item on list, if any */\n\txfs_bmap_free_item_t\t*free)\t/* list item to be freed */\n{\n\tif (prev)\n\t\tprev->xbfi_next = free->xbfi_next;\n\telse\n\t\tflist->xbf_first = free->xbfi_next;\n\tflist->xbf_count--;\n\tkmem_zone_free(xfs_bmap_free_item_zone, free);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t\t*xfs_bmap_free_item_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_free",
          "args": [
            "xfs_bmap_free_item_zone",
            "free"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.h",
          "lines": "104-108",
          "snippet": "static inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}",
          "includes": [
            "#include <linux/vmalloc.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define kmem_zone_t\tstruct kmem_cache"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#define kmem_zone_t\tstruct kmem_cache\n\nstatic inline void\nkmem_zone_free(kmem_zone_t *zone, void *ptr)\n{\n\tkmem_cache_free(zone, ptr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t\t*xfs_bmap_free_item_zone;\n\nvoid\nxfs_bmap_del_free(\n\txfs_bmap_free_t\t\t*flist,\t/* free item list header */\n\txfs_bmap_free_item_t\t*prev,\t/* previous item on list, if any */\n\txfs_bmap_free_item_t\t*free)\t/* list item to be freed */\n{\n\tif (prev)\n\t\tprev->xbfi_next = free->xbfi_next;\n\telse\n\t\tflist->xbf_first = free->xbfi_next;\n\tflist->xbf_count--;\n\tkmem_zone_free(xfs_bmap_free_item_zone, free);\n}"
  },
  {
    "function_name": "xfs_bmap_add_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "594-635",
    "snippet": "void\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "kmem_zone_t\t\t*xfs_bmap_free_item_zone;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_zone_alloc",
          "args": [
            "xfs_bmap_free_item_zone",
            "KM_SLEEP"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "kmem_zone_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/kmem.c",
          "lines": "110-127",
          "snippet": "void *\nkmem_zone_alloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmem_cache_alloc(zone, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"kmem.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"kmem.h\"\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nvoid *\nkmem_zone_alloc(kmem_zone_t *zone, xfs_km_flags_t flags)\n{\n\tint\tretries = 0;\n\tgfp_t\tlflags = kmem_flags_convert(flags);\n\tvoid\t*ptr;\n\n\tdo {\n\t\tptr = kmem_cache_alloc(zone, lflags);\n\t\tif (ptr || (flags & (KM_MAYFAIL|KM_NOSLEEP)))\n\t\t\treturn ptr;\n\t\tif (!(++retries % 100))\n\t\t\txfs_err(NULL,\n\t\t\"possible memory allocation deadlock in %s (mode:0x%x)\",\n\t\t\t\t\t__func__, lflags);\n\t\tcongestion_wait(BLK_RW_ASYNC, HZ/50);\n\t} while (1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_bmap_free_item_zone != NULL"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agbno + len <= mp->m_sb.sb_agblocks"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len < mp->m_sb.sb_agblocks"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agbno < mp->m_sb.sb_agblocks"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "agno < mp->m_sb.sb_agcount"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "bno"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "bno"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!isnullstartblock(bno)"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isnullstartblock",
          "args": [
            "bno"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "isnullstartblock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "1378-1381",
          "snippet": "static inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}",
          "includes": [],
          "macros_used": [
            "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define STARTBLOCKMASK\t\t\\\n\t(((((xfs_fsblock_t)1) << STARTBLOCKMASKBITS) - 1) << STARTBLOCKVALBITS)\n\nstatic inline int isnullstartblock(xfs_fsblock_t x)\n{\n\treturn ((x) & STARTBLOCKMASK) == STARTBLOCKMASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len <= MAXEXTLEN"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "len > 0"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno != NULLFSBLOCK"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t\t*xfs_bmap_free_item_zone;\n\nvoid\nxfs_bmap_add_free(\n\txfs_fsblock_t\t\tbno,\t\t/* fs block number of extent */\n\txfs_filblks_t\t\tlen,\t\t/* length of extent */\n\txfs_bmap_free_t\t\t*flist,\t\t/* list of extents */\n\txfs_mount_t\t\t*mp)\t\t/* mount point structure */\n{\n\txfs_bmap_free_item_t\t*cur;\t\t/* current (next) element */\n\txfs_bmap_free_item_t\t*new;\t\t/* new element */\n\txfs_bmap_free_item_t\t*prev;\t\t/* previous element */\n#ifdef DEBUG\n\txfs_agnumber_t\t\tagno;\n\txfs_agblock_t\t\tagbno;\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(len > 0);\n\tASSERT(len <= MAXEXTLEN);\n\tASSERT(!isnullstartblock(bno));\n\tagno = XFS_FSB_TO_AGNO(mp, bno);\n\tagbno = XFS_FSB_TO_AGBNO(mp, bno);\n\tASSERT(agno < mp->m_sb.sb_agcount);\n\tASSERT(agbno < mp->m_sb.sb_agblocks);\n\tASSERT(len < mp->m_sb.sb_agblocks);\n\tASSERT(agbno + len <= mp->m_sb.sb_agblocks);\n#endif\n\tASSERT(xfs_bmap_free_item_zone != NULL);\n\tnew = kmem_zone_alloc(xfs_bmap_free_item_zone, KM_SLEEP);\n\tnew->xbfi_startblock = bno;\n\tnew->xbfi_blockcount = (xfs_extlen_t)len;\n\tfor (prev = NULL, cur = flist->xbf_first;\n\t     cur != NULL;\n\t     prev = cur, cur = cur->xbfi_next) {\n\t\tif (cur->xbfi_startblock >= bno)\n\t\t\tbreak;\n\t}\n\tif (prev)\n\t\tprev->xbfi_next = new;\n\telse\n\t\tflist->xbf_first = new;\n\tnew->xbfi_next = cur;\n\tflist->xbf_count++;\n}"
  },
  {
    "function_name": "xfs_bmap_validate_ret",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "546-579",
    "snippet": "STATIC void\nxfs_bmap_validate_ret(\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags,\n\txfs_bmbt_irec_t\t\t*mval,\n\tint\t\t\tnmap,\n\tint\t\t\tret_nmap)\n{\n\tint\t\t\ti;\t\t/* index to map values */\n\n\tASSERT(ret_nmap <= nmap);\n\n\tfor (i = 0; i < ret_nmap; i++) {\n\t\tASSERT(mval[i].br_blockcount > 0);\n\t\tif (!(flags & XFS_BMAPI_ENTIRE)) {\n\t\t\tASSERT(mval[i].br_startoff >= bno);\n\t\t\tASSERT(mval[i].br_blockcount <= len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount <=\n\t\t\t       bno + len);\n\t\t} else {\n\t\t\tASSERT(mval[i].br_startoff < bno + len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount >\n\t\t\t       bno);\n\t\t}\n\t\tASSERT(i == 0 ||\n\t\t       mval[i - 1].br_startoff + mval[i - 1].br_blockcount ==\n\t\t       mval[i].br_startoff);\n\t\tASSERT(mval[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       mval[i].br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(mval[i].br_state == XFS_EXT_NORM ||\n\t\t       mval[i].br_state == XFS_EXT_UNWRITTEN);\n\t}\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval[i].br_state == XFS_EXT_NORM ||\n\t\t       mval[i].br_state == XFS_EXT_UNWRITTEN"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       mval[i].br_startblock != HOLESTARTBLOCK"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "i == 0 ||\n\t\t       mval[i - 1].br_startoff + mval[i - 1].br_blockcount ==\n\t\t       mval[i].br_startoff"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval[i].br_startoff + mval[i].br_blockcount >\n\t\t\t       bno"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval[i].br_startoff < bno + len"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval[i].br_startoff + mval[i].br_blockcount <=\n\t\t\t       bno + len"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval[i].br_blockcount <= len"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval[i].br_startoff >= bno"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "mval[i].br_blockcount > 0"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ret_nmap <= nmap"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_validate_ret(\n\txfs_fileoff_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\tflags,\n\txfs_bmbt_irec_t\t\t*mval,\n\tint\t\t\tnmap,\n\tint\t\t\tret_nmap)\n{\n\tint\t\t\ti;\t\t/* index to map values */\n\n\tASSERT(ret_nmap <= nmap);\n\n\tfor (i = 0; i < ret_nmap; i++) {\n\t\tASSERT(mval[i].br_blockcount > 0);\n\t\tif (!(flags & XFS_BMAPI_ENTIRE)) {\n\t\t\tASSERT(mval[i].br_startoff >= bno);\n\t\t\tASSERT(mval[i].br_blockcount <= len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount <=\n\t\t\t       bno + len);\n\t\t} else {\n\t\t\tASSERT(mval[i].br_startoff < bno + len);\n\t\t\tASSERT(mval[i].br_startoff + mval[i].br_blockcount >\n\t\t\t       bno);\n\t\t}\n\t\tASSERT(i == 0 ||\n\t\t       mval[i - 1].br_startoff + mval[i - 1].br_blockcount ==\n\t\t       mval[i].br_startoff);\n\t\tASSERT(mval[i].br_startblock != DELAYSTARTBLOCK &&\n\t\t       mval[i].br_startblock != HOLESTARTBLOCK);\n\t\tASSERT(mval[i].br_state == XFS_EXT_NORM ||\n\t\t       mval[i].br_state == XFS_EXT_UNWRITTEN);\n\t}\n}"
  },
  {
    "function_name": "xfs_bmap_trace_exlist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "520-538",
    "snippet": "void\nxfs_bmap_trace_exlist(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tcnt,\t\t/* count of entries in the list */\n\tint\t\twhichfork,\t/* data or attr fork */\n\tunsigned long\tcaller_ip)\n{\n\txfs_extnum_t\tidx;\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\tstate = 0;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(cnt == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)));\n\tfor (idx = 0; idx < cnt; idx++)\n\t\ttrace_xfs_extlist(ip, idx, whichfork, caller_ip);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_extlist",
          "args": [
            "ip",
            "idx",
            "whichfork",
            "caller_ip"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "cnt == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t))"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_trace_exlist(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_extnum_t\tcnt,\t\t/* count of entries in the list */\n\tint\t\twhichfork,\t/* data or attr fork */\n\tunsigned long\tcaller_ip)\n{\n\txfs_extnum_t\tidx;\t\t/* extent record index */\n\txfs_ifork_t\t*ifp;\t\t/* inode fork pointer */\n\tint\t\tstate = 0;\n\n\tif (whichfork == XFS_ATTR_FORK)\n\t\tstate |= BMAP_ATTRFORK;\n\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tASSERT(cnt == (ifp->if_bytes / (uint)sizeof(xfs_bmbt_rec_t)));\n\tfor (idx = 0; idx < cnt; idx++)\n\t\ttrace_xfs_extlist(ip, idx, whichfork, caller_ip);\n}"
  },
  {
    "function_name": "xfs_bmap_check_leaf_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "355-515",
    "snippet": "STATIC void\nxfs_bmap_check_leaf_extents(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor or null */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_extnum_t\t\ti=0, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\txfs_bmbt_rec_t\t\t*ep;\t/* pointer to current extent */\n\txfs_bmbt_rec_t\t\tlast = {0, 0}; /* last extent in prev block */\n\txfs_bmbt_rec_t\t\t*nextp;\t/* pointer to next extent */\n\tint\t\t\tbp_release = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE) {\n\t\treturn;\n\t}\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\t/* See if buf is in cur first */\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this block for basic sanity (increasing keys and\n\t\t * no duplicate blocks).\n\t\t */\n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\ti = 0;\n\n\t/*\n\t * Loop over all leaf nodes checking that all extents are in the right order.\n\t */\n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t/*\n\t\t * Check all the extents to make sure they are OK.\n\t\t * If we had a previous block, the last entry should\n\t\t * conform with the first entry in this one.\n\t\t */\n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tif (bp_release) {\n\t\tbp_release = 0;\n\t\txfs_trans_brelse(NULL, bp);\n\t}\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %d extents\",\n\t\t__func__, i);\n\tpanic(\"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\treturn;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: CORRUPTED BTREE OR SOMETHING\"",
            "__func__"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: BAD after btree leaves for %d extents\"",
            "__func__",
            "i"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_brelse",
          "args": [
            "NULL",
            "bp"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "354-443",
          "snippet": "void\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_brelse(xfs_trans_t\t*tp,\n\t\t xfs_buf_t\t*bp)\n{\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to a normal brelse() call if the tp is NULL.\n\t */\n\tif (tp == NULL) {\n\t\tASSERT(bp->b_transp == NULL);\n\t\txfs_buf_relse(bp);\n\t\treturn;\n\t}\n\n\tASSERT(bp->b_transp == tp);\n\tbip = bp->b_fspriv;\n\tASSERT(bip->bli_item.li_type == XFS_LI_BUF);\n\tASSERT(!(bip->bli_flags & XFS_BLI_STALE));\n\tASSERT(!(bip->__bli_format.blf_flags & XFS_BLF_CANCEL));\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\ttrace_xfs_trans_brelse(bip);\n\n\t/*\n\t * If the release is just for a recursive lock,\n\t * then decrement the count and return.\n\t */\n\tif (bip->bli_recur > 0) {\n\t\tbip->bli_recur--;\n\t\treturn;\n\t}\n\n\t/*\n\t * If the buffer is dirty within this transaction, we can't\n\t * release it until we commit.\n\t */\n\tif (bip->bli_item.li_desc->lid_flags & XFS_LID_DIRTY)\n\t\treturn;\n\n\t/*\n\t * If the buffer has been invalidated, then we can't release\n\t * it until the transaction commits to disk unless it is re-dirtied\n\t * as part of this transaction.  This prevents us from pulling\n\t * the item from the AIL before we should.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE)\n\t\treturn;\n\n\tASSERT(!(bip->bli_flags & XFS_BLI_LOGGED));\n\n\t/*\n\t * Free up the log item descriptor tracking the released item.\n\t */\n\txfs_trans_del_item(&bip->bli_item);\n\n\t/*\n\t * Clear the hold flag in the buf log item if it is set.\n\t * We wouldn't want the next user of the buffer to\n\t * get confused.\n\t */\n\tif (bip->bli_flags & XFS_BLI_HOLD) {\n\t\tbip->bli_flags &= ~XFS_BLI_HOLD;\n\t}\n\n\t/*\n\t * Drop our reference to the buf log item.\n\t */\n\tatomic_dec(&bip->bli_refcount);\n\n\t/*\n\t * If the buf item is not tracking data in the log, then\n\t * we must free it before releasing the buffer back to the\n\t * free pool.  Before releasing the buffer to the free pool,\n\t * clear the transaction pointer in b_fsprivate2 to dissolve\n\t * its relation to this transaction.\n\t */\n\tif (!xfs_buf_item_dirty(bip)) {\n/***\n\t\tASSERT(bp->b_pincount == 0);\n***/\n\t\tASSERT(atomic_read(&bip->bli_refcount) == 0);\n\t\tASSERT(!(bip->bli_item.li_flags & XFS_LI_IN_AIL));\n\t\tASSERT(!(bip->bli_flags & XFS_BLI_INODE_ALLOC_BUF));\n\t\txfs_buf_item_relse(bp);\n\t}\n\n\tbp->b_transp = NULL;\n\txfs_buf_relse(bp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: at error0\"",
            "__func__"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_read_bufl",
          "args": [
            "mp",
            "NULL",
            "bno",
            "0",
            "&bp",
            "XFS_BMAP_BTREE_REF",
            "&xfs_bmbt_buf_ops"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_read_bufl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "699-723",
          "snippet": "int\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC struct;\n\nint\nxfs_btree_read_bufl(\n\tstruct xfs_mount\t*mp,\t\t/* file system mount point */\n\tstruct xfs_trans\t*tp,\t\t/* transaction pointer */\n\txfs_fsblock_t\t\tfsbno,\t\t/* file system block number */\n\tuint\t\t\tlock,\t\t/* lock flags for read_buf */\n\tstruct xfs_buf\t\t**bpp,\t\t/* buffer for fsbno */\n\tint\t\t\trefval,\t\t/* ref count value for buffer */\n\tconst struct xfs_buf_ops *ops)\n{\n\tstruct xfs_buf\t\t*bp;\t\t/* return value */\n\txfs_daddr_t\t\td;\t\t/* real disk block address */\n\tint\t\t\terror;\n\n\tASSERT(fsbno != NULLFSBLOCK);\n\td = XFS_FSB_TO_DADDR(mp, fsbno);\n\terror = xfs_trans_read_buf(mp, tp, mp->m_ddev_targp, d,\n\t\t\t\t   mp->m_bsize, lock, &bp, ops);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_buf_set_ref(bp, refval);\n\t*bpp = bp;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmap_get_bp",
          "args": [
            "cur",
            "XFS_FSB_TO_DADDR(mp, bno)"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_get_bp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "272-300",
          "snippet": "xfs_buf *\nxfs_bmap_get_bp(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fsblock_t\t\tbno)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tint\t\t\ti;\n\n\tif (!cur)\n\t\treturn NULL;\n\n\tfor (i = 0; i < XFS_BTREE_MAXLEVELS; i++) {\n\t\tif (!cur->bc_bufs[i])\n\t\t\tbreak;\n\t\tif (XFS_BUF_ADDR(cur->bc_bufs[i]) == bno)\n\t\t\treturn cur->bc_bufs[i];\n\t}\n\n\t/* Chase down all the log items to see if the bp is there */\n\tlist_for_each_entry(lidp, &cur->bc_tp->t_items, lid_trans) {\n\t\tstruct xfs_buf_log_item\t*bip;\n\t\tbip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (bip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    XFS_BUF_ADDR(bip->bli_buf) == bno)\n\t\t\treturn bip->bli_buf;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_buf *\nxfs_bmap_get_bp(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fsblock_t\t\tbno)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tint\t\t\ti;\n\n\tif (!cur)\n\t\treturn NULL;\n\n\tfor (i = 0; i < XFS_BTREE_MAXLEVELS; i++) {\n\t\tif (!cur->bc_bufs[i])\n\t\t\tbreak;\n\t\tif (XFS_BUF_ADDR(cur->bc_bufs[i]) == bno)\n\t\t\treturn cur->bc_bufs[i];\n\t}\n\n\t/* Chase down all the log items to see if the bp is there */\n\tlist_for_each_entry(lidp, &cur->bc_tp->t_items, lid_trans) {\n\t\tstruct xfs_buf_log_item\t*bip;\n\t\tbip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (bip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    XFS_BUF_ADDR(bip->bli_buf) == bno)\n\t\t\treturn bip->bli_buf;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "bno"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp)"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_get_startoff",
          "args": [
            "nextp"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_get_startoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "187-193",
          "snippet": "xfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_fileoff_t\nxfs_bmbt_disk_get_startoff(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn ((xfs_fileoff_t)be64_to_cpu(r->l0) &\n\t\t xfs_mask64lo(64 - BMBT_EXNTFLAG_BITLEN)) >> 9;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_get_blockcount",
          "args": [
            "ep"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_get_blockcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "177-182",
          "snippet": "xfs_filblks_t\nxfs_bmbt_disk_get_blockcount(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_filblks_t\nxfs_bmbt_disk_get_blockcount(\n\txfs_bmbt_rec_t\t*r)\n{\n\treturn (xfs_filblks_t)(be64_to_cpu(r->l1) & xfs_mask64lo(21));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_REC_ADDR",
          "args": [
            "mp",
            "block",
            "j + 1"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep)"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_REC_ADDR",
          "args": [
            "mp",
            "block",
            "1"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "block->bb_u.l.bb_rightsib"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "XFS_FSB_SANITY_CHECK(mp, bno)",
            "error0"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_SANITY_CHECK",
          "args": [
            "mp",
            "bno"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*pp"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "1",
            "mp->m_bmap_dmxr[1]"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_check_block",
          "args": [
            "block",
            "mp",
            "0",
            "0"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_check_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "302-348",
          "snippet": "STATIC void\nxfs_check_block(\n\tstruct xfs_btree_block\t*block,\n\txfs_mount_t\t\t*mp,\n\tint\t\t\troot,\n\tshort\t\t\tsz)\n{\n\tint\t\t\ti, j, dmxr;\n\t__be64\t\t\t*pp, *thispa;\t/* pointer to block address */\n\txfs_bmbt_key_t\t\t*prevp, *keyp;\n\n\tASSERT(be16_to_cpu(block->bb_level) > 0);\n\n\tprevp = NULL;\n\tfor( i = 1; i <= xfs_btree_get_numrecs(block); i++) {\n\t\tdmxr = mp->m_bmap_dmxr[0];\n\t\tkeyp = XFS_BMBT_KEY_ADDR(mp, block, i);\n\n\t\tif (prevp) {\n\t\t\tASSERT(be64_to_cpu(prevp->br_startoff) <\n\t\t\t       be64_to_cpu(keyp->br_startoff));\n\t\t}\n\t\tprevp = keyp;\n\n\t\t/*\n\t\t * Compare the block numbers to see if there are dups.\n\t\t */\n\t\tif (root)\n\t\t\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, i, sz);\n\t\telse\n\t\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, i, dmxr);\n\n\t\tfor (j = i+1; j <= be16_to_cpu(block->bb_numrecs); j++) {\n\t\t\tif (root)\n\t\t\t\tthispa = XFS_BMAP_BROOT_PTR_ADDR(mp, block, j, sz);\n\t\t\telse\n\t\t\t\tthispa = XFS_BMBT_PTR_ADDR(mp, block, j, dmxr);\n\t\t\tif (*thispa == *pp) {\n\t\t\t\txfs_warn(mp, \"%s: thispa(%d) == pp(%d) %Ld\",\n\t\t\t\t\t__func__, j, i,\n\t\t\t\t\t(unsigned long long)be64_to_cpu(*thispa));\n\t\t\t\tpanic(\"%s: ptrs are equal in node\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_check_block(\n\tstruct xfs_btree_block\t*block,\n\txfs_mount_t\t\t*mp,\n\tint\t\t\troot,\n\tshort\t\t\tsz)\n{\n\tint\t\t\ti, j, dmxr;\n\t__be64\t\t\t*pp, *thispa;\t/* pointer to block address */\n\txfs_bmbt_key_t\t\t*prevp, *keyp;\n\n\tASSERT(be16_to_cpu(block->bb_level) > 0);\n\n\tprevp = NULL;\n\tfor( i = 1; i <= xfs_btree_get_numrecs(block); i++) {\n\t\tdmxr = mp->m_bmap_dmxr[0];\n\t\tkeyp = XFS_BMBT_KEY_ADDR(mp, block, i);\n\n\t\tif (prevp) {\n\t\t\tASSERT(be64_to_cpu(prevp->br_startoff) <\n\t\t\t       be64_to_cpu(keyp->br_startoff));\n\t\t}\n\t\tprevp = keyp;\n\n\t\t/*\n\t\t * Compare the block numbers to see if there are dups.\n\t\t */\n\t\tif (root)\n\t\t\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, i, sz);\n\t\telse\n\t\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, i, dmxr);\n\n\t\tfor (j = i+1; j <= be16_to_cpu(block->bb_numrecs); j++) {\n\t\t\tif (root)\n\t\t\t\tthispa = XFS_BMAP_BROOT_PTR_ADDR(mp, block, j, sz);\n\t\t\telse\n\t\t\t\tthispa = XFS_BMBT_PTR_ADDR(mp, block, j, dmxr);\n\t\t\tif (*thispa == *pp) {\n\t\t\t\txfs_warn(mp, \"%s: thispa(%d) == pp(%d) %Ld\",\n\t\t\t\t\t__func__, j, i,\n\t\t\t\t\t(unsigned long long)be64_to_cpu(*thispa));\n\t\t\t\tpanic(\"%s: ptrs are equal in node\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_WANT_CORRUPTED_GOTO",
          "args": [
            "xfs_bmap_sanity_check(mp, bp, level)",
            "error0"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmap_sanity_check",
          "args": [
            "mp",
            "bp",
            "level"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmap_sanity_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "251-269",
          "snippet": "STATIC int\nxfs_bmap_sanity_check(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block  *block = XFS_BUF_TO_BLOCK(bp);\n\n\tif (block->bb_magic != cpu_to_be32(XFS_BMAP_CRC_MAGIC) &&\n\t    block->bb_magic != cpu_to_be32(XFS_BMAP_MAGIC))\n\t\treturn 0;\n\n\tif (be16_to_cpu(block->bb_level) != level ||\n\t    be16_to_cpu(block->bb_numrecs) == 0 ||\n\t    be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_sanity_check(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block  *block = XFS_BUF_TO_BLOCK(bp);\n\n\tif (block->bb_magic != cpu_to_be32(XFS_BMAP_CRC_MAGIC) &&\n\t    block->bb_magic != cpu_to_be32(XFS_BMAP_MAGIC))\n\t\treturn 0;\n\n\tif (be16_to_cpu(block->bb_level) != level ||\n\t    be16_to_cpu(block->bb_numrecs) == 0 ||\n\t    be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_DADDR",
          "args": [
            "mp",
            "bno"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGBNO",
          "args": [
            "mp",
            "bno"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_AGNO",
          "args": [
            "mp",
            "bno"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "bno != NULLFSBLOCK"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*pp"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "1",
            "ifp->if_broot_bytes"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "level > 0"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_PTR",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_check_leaf_extents(\n\txfs_btree_cur_t\t\t*cur,\t/* btree cursor or null */\n\txfs_inode_t\t\t*ip,\t\t/* incore inode pointer */\n\tint\t\t\twhichfork)\t/* data or attr fork */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\txfs_fsblock_t\t\tbno;\t/* block # of \"block\" */\n\txfs_buf_t\t\t*bp;\t/* buffer for \"block\" */\n\tint\t\t\terror;\t/* error return value */\n\txfs_extnum_t\t\ti=0, j;\t/* index into the extents list */\n\txfs_ifork_t\t\t*ifp;\t/* fork structure */\n\tint\t\t\tlevel;\t/* btree level, for checking */\n\txfs_mount_t\t\t*mp;\t/* file system mount structure */\n\t__be64\t\t\t*pp;\t/* pointer to block address */\n\txfs_bmbt_rec_t\t\t*ep;\t/* pointer to current extent */\n\txfs_bmbt_rec_t\t\tlast = {0, 0}; /* last extent in prev block */\n\txfs_bmbt_rec_t\t\t*nextp;\t/* pointer to next extent */\n\tint\t\t\tbp_release = 0;\n\n\tif (XFS_IFORK_FORMAT(ip, whichfork) != XFS_DINODE_FMT_BTREE) {\n\t\treturn;\n\t}\n\n\tbno = NULLFSBLOCK;\n\tmp = ip->i_mount;\n\tifp = XFS_IFORK_PTR(ip, whichfork);\n\tblock = ifp->if_broot;\n\t/*\n\t * Root level must use BMAP_BROOT_PTR_ADDR macro to get ptr out.\n\t */\n\tlevel = be16_to_cpu(block->bb_level);\n\tASSERT(level > 0);\n\txfs_check_block(block, mp, 1, ifp->if_broot_bytes);\n\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, 1, ifp->if_broot_bytes);\n\tbno = be64_to_cpu(*pp);\n\n\tASSERT(bno != NULLFSBLOCK);\n\tASSERT(XFS_FSB_TO_AGNO(mp, bno) < mp->m_sb.sb_agcount);\n\tASSERT(XFS_FSB_TO_AGBNO(mp, bno) < mp->m_sb.sb_agblocks);\n\n\t/*\n\t * Go down the tree until leaf level is reached, following the first\n\t * pointer (leftmost) at each level.\n\t */\n\twhile (level-- > 0) {\n\t\t/* See if buf is in cur first */\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t\tXFS_WANT_CORRUPTED_GOTO(\n\t\t\txfs_bmap_sanity_check(mp, bp, level),\n\t\t\terror0);\n\t\tif (level == 0)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check this block for basic sanity (increasing keys and\n\t\t * no duplicate blocks).\n\t\t */\n\n\t\txfs_check_block(block, mp, 0, 0);\n\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, 1, mp->m_bmap_dmxr[1]);\n\t\tbno = be64_to_cpu(*pp);\n\t\tXFS_WANT_CORRUPTED_GOTO(XFS_FSB_SANITY_CHECK(mp, bno), error0);\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t}\n\n\t/*\n\t * Here with bp and block set to the leftmost leaf node in the tree.\n\t */\n\ti = 0;\n\n\t/*\n\t * Loop over all leaf nodes checking that all extents are in the right order.\n\t */\n\tfor (;;) {\n\t\txfs_fsblock_t\tnextbno;\n\t\txfs_extnum_t\tnum_recs;\n\n\n\t\tnum_recs = xfs_btree_get_numrecs(block);\n\n\t\t/*\n\t\t * Read-ahead the next leaf block, if any.\n\t\t */\n\n\t\tnextbno = be64_to_cpu(block->bb_u.l.bb_rightsib);\n\n\t\t/*\n\t\t * Check all the extents to make sure they are OK.\n\t\t * If we had a previous block, the last entry should\n\t\t * conform with the first entry in this one.\n\t\t */\n\n\t\tep = XFS_BMBT_REC_ADDR(mp, block, 1);\n\t\tif (i) {\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(&last) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(&last) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(ep));\n\t\t}\n\t\tfor (j = 1; j < num_recs; j++) {\n\t\t\tnextp = XFS_BMBT_REC_ADDR(mp, block, j + 1);\n\t\t\tASSERT(xfs_bmbt_disk_get_startoff(ep) +\n\t\t\t       xfs_bmbt_disk_get_blockcount(ep) <=\n\t\t\t       xfs_bmbt_disk_get_startoff(nextp));\n\t\t\tep = nextp;\n\t\t}\n\n\t\tlast = *ep;\n\t\ti += num_recs;\n\t\tif (bp_release) {\n\t\t\tbp_release = 0;\n\t\t\txfs_trans_brelse(NULL, bp);\n\t\t}\n\t\tbno = nextbno;\n\t\t/*\n\t\t * If we've reached the end, stop.\n\t\t */\n\t\tif (bno == NULLFSBLOCK)\n\t\t\tbreak;\n\n\t\tbp_release = 0;\n\t\tbp = xfs_bmap_get_bp(cur, XFS_FSB_TO_DADDR(mp, bno));\n\t\tif (!bp) {\n\t\t\tbp_release = 1;\n\t\t\terror = xfs_btree_read_bufl(mp, NULL, bno, 0, &bp,\n\t\t\t\t\t\tXFS_BMAP_BTREE_REF,\n\t\t\t\t\t\t&xfs_bmbt_buf_ops);\n\t\t\tif (error)\n\t\t\t\tgoto error_norelse;\n\t\t}\n\t\tblock = XFS_BUF_TO_BLOCK(bp);\n\t}\n\tif (bp_release) {\n\t\tbp_release = 0;\n\t\txfs_trans_brelse(NULL, bp);\n\t}\n\treturn;\n\nerror0:\n\txfs_warn(mp, \"%s: at error0\", __func__);\n\tif (bp_release)\n\t\txfs_trans_brelse(NULL, bp);\nerror_norelse:\n\txfs_warn(mp, \"%s: BAD after btree leaves for %d extents\",\n\t\t__func__, i);\n\tpanic(\"%s: CORRUPTED BTREE OR SOMETHING\", __func__);\n\treturn;\n}"
  },
  {
    "function_name": "xfs_check_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "302-348",
    "snippet": "STATIC void\nxfs_check_block(\n\tstruct xfs_btree_block\t*block,\n\txfs_mount_t\t\t*mp,\n\tint\t\t\troot,\n\tshort\t\t\tsz)\n{\n\tint\t\t\ti, j, dmxr;\n\t__be64\t\t\t*pp, *thispa;\t/* pointer to block address */\n\txfs_bmbt_key_t\t\t*prevp, *keyp;\n\n\tASSERT(be16_to_cpu(block->bb_level) > 0);\n\n\tprevp = NULL;\n\tfor( i = 1; i <= xfs_btree_get_numrecs(block); i++) {\n\t\tdmxr = mp->m_bmap_dmxr[0];\n\t\tkeyp = XFS_BMBT_KEY_ADDR(mp, block, i);\n\n\t\tif (prevp) {\n\t\t\tASSERT(be64_to_cpu(prevp->br_startoff) <\n\t\t\t       be64_to_cpu(keyp->br_startoff));\n\t\t}\n\t\tprevp = keyp;\n\n\t\t/*\n\t\t * Compare the block numbers to see if there are dups.\n\t\t */\n\t\tif (root)\n\t\t\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, i, sz);\n\t\telse\n\t\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, i, dmxr);\n\n\t\tfor (j = i+1; j <= be16_to_cpu(block->bb_numrecs); j++) {\n\t\t\tif (root)\n\t\t\t\tthispa = XFS_BMAP_BROOT_PTR_ADDR(mp, block, j, sz);\n\t\t\telse\n\t\t\t\tthispa = XFS_BMBT_PTR_ADDR(mp, block, j, dmxr);\n\t\t\tif (*thispa == *pp) {\n\t\t\t\txfs_warn(mp, \"%s: thispa(%d) == pp(%d) %Ld\",\n\t\t\t\t\t__func__, j, i,\n\t\t\t\t\t(unsigned long long)be64_to_cpu(*thispa));\n\t\t\t\tpanic(\"%s: ptrs are equal in node\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"%s: ptrs are equal in node\\n\"",
            "__func__"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_tree_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "553-558",
          "snippet": "static void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic void extent_io_tree_panic(struct extent_io_tree *tree, int err)\n{\n\tbtrfs_panic(tree_fs_info(tree), err, \"Locking error: \"\n\t\t    \"Extent tree was modified by another \"\n\t\t    \"thread while locked.\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"%s: thispa(%d) == pp(%d) %Ld\"",
            "__func__",
            "j",
            "i",
            "(unsigned long long)be64_to_cpu(*thispa)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "*thispa"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "j",
            "dmxr"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "j",
            "sz"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "i",
            "dmxr"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMAP_BROOT_PTR_ADDR",
          "args": [
            "mp",
            "block",
            "i",
            "sz"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be64_to_cpu(prevp->br_startoff) <\n\t\t\t       be64_to_cpu(keyp->br_startoff)"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "keyp->br_startoff"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "prevp->br_startoff"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMBT_KEY_ADDR",
          "args": [
            "mp",
            "block",
            "i"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_btree_get_numrecs",
          "args": [
            "block"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_get_numrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.h",
          "lines": "416-419",
          "snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_btree_get_numrecs(struct xfs_btree_block *block)\n{\n\treturn be16_to_cpu(block->bb_numrecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "be16_to_cpu(block->bb_level) > 0"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_check_block(\n\tstruct xfs_btree_block\t*block,\n\txfs_mount_t\t\t*mp,\n\tint\t\t\troot,\n\tshort\t\t\tsz)\n{\n\tint\t\t\ti, j, dmxr;\n\t__be64\t\t\t*pp, *thispa;\t/* pointer to block address */\n\txfs_bmbt_key_t\t\t*prevp, *keyp;\n\n\tASSERT(be16_to_cpu(block->bb_level) > 0);\n\n\tprevp = NULL;\n\tfor( i = 1; i <= xfs_btree_get_numrecs(block); i++) {\n\t\tdmxr = mp->m_bmap_dmxr[0];\n\t\tkeyp = XFS_BMBT_KEY_ADDR(mp, block, i);\n\n\t\tif (prevp) {\n\t\t\tASSERT(be64_to_cpu(prevp->br_startoff) <\n\t\t\t       be64_to_cpu(keyp->br_startoff));\n\t\t}\n\t\tprevp = keyp;\n\n\t\t/*\n\t\t * Compare the block numbers to see if there are dups.\n\t\t */\n\t\tif (root)\n\t\t\tpp = XFS_BMAP_BROOT_PTR_ADDR(mp, block, i, sz);\n\t\telse\n\t\t\tpp = XFS_BMBT_PTR_ADDR(mp, block, i, dmxr);\n\n\t\tfor (j = i+1; j <= be16_to_cpu(block->bb_numrecs); j++) {\n\t\t\tif (root)\n\t\t\t\tthispa = XFS_BMAP_BROOT_PTR_ADDR(mp, block, j, sz);\n\t\t\telse\n\t\t\t\tthispa = XFS_BMBT_PTR_ADDR(mp, block, j, dmxr);\n\t\t\tif (*thispa == *pp) {\n\t\t\t\txfs_warn(mp, \"%s: thispa(%d) == pp(%d) %Ld\",\n\t\t\t\t\t__func__, j, i,\n\t\t\t\t\t(unsigned long long)be64_to_cpu(*thispa));\n\t\t\t\tpanic(\"%s: ptrs are equal in node\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "xfs_bmap_get_bp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "272-300",
    "snippet": "xfs_buf *\nxfs_bmap_get_bp(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fsblock_t\t\tbno)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tint\t\t\ti;\n\n\tif (!cur)\n\t\treturn NULL;\n\n\tfor (i = 0; i < XFS_BTREE_MAXLEVELS; i++) {\n\t\tif (!cur->bc_bufs[i])\n\t\t\tbreak;\n\t\tif (XFS_BUF_ADDR(cur->bc_bufs[i]) == bno)\n\t\t\treturn cur->bc_bufs[i];\n\t}\n\n\t/* Chase down all the log items to see if the bp is there */\n\tlist_for_each_entry(lidp, &cur->bc_tp->t_items, lid_trans) {\n\t\tstruct xfs_buf_log_item\t*bip;\n\t\tbip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (bip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    XFS_BUF_ADDR(bip->bli_buf) == bno)\n\t\t\treturn bip->bli_buf;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "bip->bli_buf"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "lidp",
            "&cur->bc_tp->t_items",
            "lid_trans"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_ADDR",
          "args": [
            "cur->bc_bufs[i]"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nxfs_buf *\nxfs_bmap_get_bp(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fsblock_t\t\tbno)\n{\n\tstruct xfs_log_item_desc *lidp;\n\tint\t\t\ti;\n\n\tif (!cur)\n\t\treturn NULL;\n\n\tfor (i = 0; i < XFS_BTREE_MAXLEVELS; i++) {\n\t\tif (!cur->bc_bufs[i])\n\t\t\tbreak;\n\t\tif (XFS_BUF_ADDR(cur->bc_bufs[i]) == bno)\n\t\t\treturn cur->bc_bufs[i];\n\t}\n\n\t/* Chase down all the log items to see if the bp is there */\n\tlist_for_each_entry(lidp, &cur->bc_tp->t_items, lid_trans) {\n\t\tstruct xfs_buf_log_item\t*bip;\n\t\tbip = (struct xfs_buf_log_item *)lidp->lid_item;\n\t\tif (bip->bli_item.li_type == XFS_LI_BUF &&\n\t\t    XFS_BUF_ADDR(bip->bli_buf) == bno)\n\t\t\treturn bip->bli_buf;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "xfs_bmap_sanity_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "251-269",
    "snippet": "STATIC int\nxfs_bmap_sanity_check(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block  *block = XFS_BUF_TO_BLOCK(bp);\n\n\tif (block->bb_magic != cpu_to_be32(XFS_BMAP_CRC_MAGIC) &&\n\t    block->bb_magic != cpu_to_be32(XFS_BMAP_MAGIC))\n\t\treturn 0;\n\n\tif (be16_to_cpu(block->bb_level) != level ||\n\t    be16_to_cpu(block->bb_numrecs) == 0 ||\n\t    be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_numrecs"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "block->bb_level"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_BMAP_MAGIC"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_BMAP_CRC_MAGIC"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_BLOCK",
          "args": [
            "bp"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmap_sanity_check(\n\tstruct xfs_mount\t*mp,\n\tstruct xfs_buf\t\t*bp,\n\tint\t\t\tlevel)\n{\n\tstruct xfs_btree_block  *block = XFS_BUF_TO_BLOCK(bp);\n\n\tif (block->bb_magic != cpu_to_be32(XFS_BMAP_CRC_MAGIC) &&\n\t    block->bb_magic != cpu_to_be32(XFS_BMAP_MAGIC))\n\t\treturn 0;\n\n\tif (be16_to_cpu(block->bb_level) != level ||\n\t    be16_to_cpu(block->bb_numrecs) == 0 ||\n\t    be16_to_cpu(block->bb_numrecs) > mp->m_bmap_dmxr[level != 0])\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "xfs_bmap_forkoff_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "231-245",
    "snippet": "STATIC void\nxfs_bmap_forkoff_reset(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tif (whichfork == XFS_ATTR_FORK &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_DEV &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_UUID &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE) {\n\t\tuint\tdfl_forkoff = xfs_default_attroffset(ip) >> 3;\n\n\t\tif (dfl_forkoff > ip->i_d.di_forkoff)\n\t\t\tip->i_d.di_forkoff = dfl_forkoff;\n\t}\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_default_attroffset",
          "args": [
            "ip"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_default_attroffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
          "lines": "208-224",
          "snippet": "uint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\toffset;\n\n\tif (mp->m_sb.sb_inodesize == 256) {\n\t\toffset = XFS_LITINO(mp, ip->i_d.di_version) -\n\t\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t} else {\n\t\toffset = XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n\t}\n\n\tASSERT(offset < XFS_LITINO(mp, ip->i_d.di_version));\n\treturn offset;\n}",
          "includes": [
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_attr_leaf.h\"",
            "#include \"xfs_symlink.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans_space.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_bmap_util.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nuint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\toffset;\n\n\tif (mp->m_sb.sb_inodesize == 256) {\n\t\toffset = XFS_LITINO(mp, ip->i_d.di_version) -\n\t\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t} else {\n\t\toffset = XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n\t}\n\n\tASSERT(offset < XFS_LITINO(mp, ip->i_d.di_version));\n\treturn offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC void\nxfs_bmap_forkoff_reset(\n\txfs_inode_t\t*ip,\n\tint\t\twhichfork)\n{\n\tif (whichfork == XFS_ATTR_FORK &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_DEV &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_UUID &&\n\t    ip->i_d.di_format != XFS_DINODE_FMT_BTREE) {\n\t\tuint\tdfl_forkoff = xfs_default_attroffset(ip) >> 3;\n\n\t\tif (dfl_forkoff > ip->i_d.di_forkoff)\n\t\t\tip->i_d.di_forkoff = dfl_forkoff;\n\t}\n}"
  },
  {
    "function_name": "xfs_default_attroffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "208-224",
    "snippet": "uint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\toffset;\n\n\tif (mp->m_sb.sb_inodesize == 256) {\n\t\toffset = XFS_LITINO(mp, ip->i_d.di_version) -\n\t\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t} else {\n\t\toffset = XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n\t}\n\n\tASSERT(offset < XFS_LITINO(mp, ip->i_d.di_version));\n\treturn offset;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "offset < XFS_LITINO(mp, ip->i_d.di_version)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LITINO",
          "args": [
            "mp",
            "ip->i_d.di_version"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_SPACE_CALC",
          "args": [
            "6 * MINABTPTRS"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_SPACE_CALC",
          "args": [
            "MINABTPTRS"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_LITINO",
          "args": [
            "mp",
            "ip->i_d.di_version"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nuint\nxfs_default_attroffset(\n\tstruct xfs_inode\t*ip)\n{\n\tstruct xfs_mount\t*mp = ip->i_mount;\n\tuint\t\t\toffset;\n\n\tif (mp->m_sb.sb_inodesize == 256) {\n\t\toffset = XFS_LITINO(mp, ip->i_d.di_version) -\n\t\t\t\tXFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t} else {\n\t\toffset = XFS_BMDR_SPACE_CALC(6 * MINABTPTRS);\n\t}\n\n\tASSERT(offset < XFS_LITINO(mp, ip->i_d.di_version));\n\treturn offset;\n}"
  },
  {
    "function_name": "xfs_bmap_worst_indlen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "178-203",
    "snippet": "STATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_BM_MAXLEVELS",
          "args": [
            "mp",
            "XFS_DATA_FORK"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "len",
            "maxrecs"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BM_MAXLEVELS",
          "args": [
            "mp",
            "XFS_DATA_FORK"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC xfs_filblks_t\nxfs_bmap_worst_indlen(\n\txfs_inode_t\t*ip,\t\t/* incore inode pointer */\n\txfs_filblks_t\tlen)\t\t/* delayed extent length */\n{\n\tint\t\tlevel;\t\t/* btree level number */\n\tint\t\tmaxrecs;\t/* maximum record count at this level */\n\txfs_mount_t\t*mp;\t\t/* mount structure */\n\txfs_filblks_t\trval;\t\t/* return value */\n\n\tmp = ip->i_mount;\n\tmaxrecs = mp->m_bmap_dmxr[0];\n\tfor (level = 0, rval = 0;\n\t     level < XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK);\n\t     level++) {\n\t\tlen += maxrecs - 1;\n\t\tdo_div(len, maxrecs);\n\t\trval += len;\n\t\tif (len == 1)\n\t\t\treturn rval + XFS_BM_MAXLEVELS(mp, XFS_DATA_FORK) -\n\t\t\t\tlevel - 1;\n\t\tif (level == 0)\n\t\t\tmaxrecs = mp->m_bmap_dmxr[1];\n\t}\n\treturn rval;\n}"
  },
  {
    "function_name": "xfs_bmbt_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "160-172",
    "snippet": "STATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_update",
          "args": [
            "cur",
            "&rec"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1904-1959",
          "snippet": "int\nxfs_btree_update(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\tptr;\n\tunion xfs_btree_rec\t*rp;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGR(cur, rec);\n\n\t/* Pick up the current block. */\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\t/* Get the address of the rec to be updated. */\n\tptr = cur->bc_ptrs[0];\n\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t/* Fill in the new contents and log them. */\n\txfs_btree_copy_recs(cur, rp, rec, 1);\n\txfs_btree_log_recs(cur, bp, ptr, ptr);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, 0)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, rec,\n\t\t\t\t\t    ptr, LASTREC_UPDATE);\n\t}\n\n\t/* Updating first rec in leaf. Pass new key value up to our parent. */\n\tif (ptr == 1) {\n\t\tunion xfs_btree_key\tkey;\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rec);\n\t\terror = xfs_btree_updkey(cur, &key, 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\nxfs_btree_update(\n\tstruct xfs_btree_cur\t*cur,\n\tunion xfs_btree_rec\t*rec)\n{\n\tstruct xfs_btree_block\t*block;\n\tstruct xfs_buf\t\t*bp;\n\tint\t\t\terror;\n\tint\t\t\tptr;\n\tunion xfs_btree_rec\t*rp;\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGR(cur, rec);\n\n\t/* Pick up the current block. */\n\tblock = xfs_btree_get_block(cur, 0, &bp);\n\n#ifdef DEBUG\n\terror = xfs_btree_check_block(cur, block, 0, bp);\n\tif (error)\n\t\tgoto error0;\n#endif\n\t/* Get the address of the rec to be updated. */\n\tptr = cur->bc_ptrs[0];\n\trp = xfs_btree_rec_addr(cur, ptr, block);\n\n\t/* Fill in the new contents and log them. */\n\txfs_btree_copy_recs(cur, rp, rec, 1);\n\txfs_btree_log_recs(cur, bp, ptr, ptr);\n\n\t/*\n\t * If we are tracking the last record in the tree and\n\t * we are at the far right edge of the tree, update it.\n\t */\n\tif (xfs_btree_is_lastrec(cur, block, 0)) {\n\t\tcur->bc_ops->update_lastrec(cur, block, rec,\n\t\t\t\t\t    ptr, LASTREC_UPDATE);\n\t}\n\n\t/* Updating first rec in leaf. Pass new key value up to our parent. */\n\tif (ptr == 1) {\n\t\tunion xfs_btree_key\tkey;\n\n\t\tcur->bc_ops->init_key_from_rec(&key, rec);\n\t\terror = xfs_btree_updkey(cur, &key, 1);\n\t\tif (error)\n\t\t\tgoto error0;\n\t}\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_disk_set_allf",
          "args": [
            "&rec.bmbt",
            "off",
            "bno",
            "len",
            "state"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_disk_set_allf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "239-262",
          "snippet": "void\nxfs_bmbt_disk_set_allf(\n\txfs_bmbt_rec_t\t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43));\n\tr->l1 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmbt_disk_set_allf(\n\txfs_bmbt_rec_t\t\t*r,\n\txfs_fileoff_t\t\tstartoff,\n\txfs_fsblock_t\t\tstartblock,\n\txfs_filblks_t\t\tblockcount,\n\txfs_exntst_t\t\tstate)\n{\n\tint\t\t\textent_flag = (state == XFS_EXT_NORM) ? 0 : 1;\n\n\tASSERT(state == XFS_EXT_NORM || state == XFS_EXT_UNWRITTEN);\n\tASSERT((startoff & xfs_mask64hi(64-BMBT_STARTOFF_BITLEN)) == 0);\n\tASSERT((blockcount & xfs_mask64hi(64-BMBT_BLOCKCOUNT_BITLEN)) == 0);\n\tASSERT((startblock & xfs_mask64hi(64-BMBT_STARTBLOCK_BITLEN)) == 0);\n\n\tr->l0 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)extent_flag << 63) |\n\t\t ((xfs_bmbt_rec_base_t)startoff << 9) |\n\t\t ((xfs_bmbt_rec_base_t)startblock >> 43));\n\tr->l1 = cpu_to_be64(\n\t\t((xfs_bmbt_rec_base_t)startblock << 21) |\n\t\t ((xfs_bmbt_rec_base_t)blockcount &\n\t\t  (xfs_bmbt_rec_base_t)xfs_mask64lo(21)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_bmbt_update(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\txfs_exntst_t\t\tstate)\n{\n\tunion xfs_btree_rec\trec;\n\n\txfs_bmbt_disk_set_allf(&rec.bmbt, off, bno, len, state);\n\treturn xfs_btree_update(cur, &rec);\n}"
  },
  {
    "function_name": "xfs_bmap_wants_extents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "148-153",
    "snippet": "static inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline bool xfs_bmap_wants_extents(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_BTREE &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) <=\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}"
  },
  {
    "function_name": "xfs_bmap_needs_btree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "138-143",
    "snippet": "static inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "XFS_IFORK_MAXEXT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_NEXTENTS",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_IFORK_FORMAT",
          "args": [
            "ip",
            "whichfork"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic inline bool xfs_bmap_needs_btree(struct xfs_inode *ip, int whichfork)\n{\n\treturn XFS_IFORK_FORMAT(ip, whichfork) == XFS_DINODE_FMT_EXTENTS &&\n\t\tXFS_IFORK_NEXTENTS(ip, whichfork) >\n\t\t\tXFS_IFORK_MAXEXT(ip, whichfork);\n}"
  },
  {
    "function_name": "xfs_bmbt_lookup_ge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "121-133",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_lookup",
          "args": [
            "cur",
            "XFS_LOOKUP_GE",
            "stat"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1696-1850",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_ge(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_GE, stat);\n}"
  },
  {
    "function_name": "xfs_bmbt_lookup_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "107-119",
    "snippet": "STATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_btree_lookup",
          "args": [
            "cur",
            "XFS_LOOKUP_EQ",
            "stat"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_btree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_btree.c",
          "lines": "1696-1850",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC union",
            "STATIC union",
            "STATIC union",
            "STATIC struct",
            "STATIC struct",
            "STATIC union"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_alloc.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC union;\nSTATIC union;\nSTATIC union;\nSTATIC struct;\nSTATIC struct;\nSTATIC union;\n\nint\t\t\t\t\t/* error */\nxfs_btree_lookup(\n\tstruct xfs_btree_cur\t*cur,\t/* btree cursor */\n\txfs_lookup_t\t\tdir,\t/* <=, ==, or >= */\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tstruct xfs_btree_block\t*block;\t/* current btree block */\n\t__int64_t\t\tdiff;\t/* difference for the current key */\n\tint\t\t\terror;\t/* error return value */\n\tint\t\t\tkeyno;\t/* current key number */\n\tint\t\t\tlevel;\t/* level in the btree */\n\tunion xfs_btree_ptr\t*pp;\t/* ptr to btree block */\n\tunion xfs_btree_ptr\tptr;\t/* ptr to btree block */\n\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ENTRY);\n\tXFS_BTREE_TRACE_ARGI(cur, dir);\n\n\tXFS_BTREE_STATS_INC(cur, lookup);\n\n\tblock = NULL;\n\tkeyno = 0;\n\n\t/* initialise start pointer from cursor */\n\tcur->bc_ops->init_ptr_from_cur(cur, &ptr);\n\tpp = &ptr;\n\n\t/*\n\t * Iterate over each level in the btree, starting at the root.\n\t * For each level above the leaves, find the key we need, based\n\t * on the lookup record, then follow the corresponding block\n\t * pointer down to the next level.\n\t */\n\tfor (level = cur->bc_nlevels - 1, diff = 1; level >= 0; level--) {\n\t\t/* Get the block we need to do the lookup on. */\n\t\terror = xfs_btree_lookup_get_block(cur, level, pp, &block);\n\t\tif (error)\n\t\t\tgoto error0;\n\n\t\tif (diff == 0) {\n\t\t\t/*\n\t\t\t * If we already had a key match at a higher level, we\n\t\t\t * know we need to use the first entry in this block.\n\t\t\t */\n\t\t\tkeyno = 1;\n\t\t} else {\n\t\t\t/* Otherwise search this block. Do a binary search. */\n\n\t\t\tint\thigh;\t/* high entry number */\n\t\t\tint\tlow;\t/* low entry number */\n\n\t\t\t/* Set low and high entry numbers, 1-based. */\n\t\t\tlow = 1;\n\t\t\thigh = xfs_btree_get_numrecs(block);\n\t\t\tif (!high) {\n\t\t\t\t/* Block is empty, must be an empty leaf. */\n\t\t\t\tASSERT(level == 0 && cur->bc_nlevels == 1);\n\n\t\t\t\tcur->bc_ptrs[0] = dir != XFS_LOOKUP_LE;\n\t\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t\t*stat = 0;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Binary search the block. */\n\t\t\twhile (low <= high) {\n\t\t\t\tunion xfs_btree_key\tkey;\n\t\t\t\tunion xfs_btree_key\t*kp;\n\n\t\t\t\tXFS_BTREE_STATS_INC(cur, compare);\n\n\t\t\t\t/* keyno is average of low and high. */\n\t\t\t\tkeyno = (low + high) >> 1;\n\n\t\t\t\t/* Get current search key */\n\t\t\t\tkp = xfs_lookup_get_search_key(cur, level,\n\t\t\t\t\t\tkeyno, block, &key);\n\n\t\t\t\t/*\n\t\t\t\t * Compute difference to get next direction:\n\t\t\t\t *  - less than, move right\n\t\t\t\t *  - greater than, move left\n\t\t\t\t *  - equal, we're done\n\t\t\t\t */\n\t\t\t\tdiff = cur->bc_ops->key_diff(cur, kp);\n\t\t\t\tif (diff < 0)\n\t\t\t\t\tlow = keyno + 1;\n\t\t\t\telse if (diff > 0)\n\t\t\t\t\thigh = keyno - 1;\n\t\t\t\telse\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If there are more levels, set up for the next level\n\t\t * by getting the block number and filling in the cursor.\n\t\t */\n\t\tif (level > 0) {\n\t\t\t/*\n\t\t\t * If we moved left, need the previous key number,\n\t\t\t * unless there isn't one.\n\t\t\t */\n\t\t\tif (diff > 0 && --keyno < 1)\n\t\t\t\tkeyno = 1;\n\t\t\tpp = xfs_btree_ptr_addr(cur, keyno, block);\n\n#ifdef DEBUG\n\t\t\terror = xfs_btree_check_ptr(cur, pp, 0, level);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n#endif\n\t\t\tcur->bc_ptrs[level] = keyno;\n\t\t}\n\t}\n\n\t/* Done with the search. See if we need to adjust the results. */\n\tif (dir != XFS_LOOKUP_LE && diff < 0) {\n\t\tkeyno++;\n\t\t/*\n\t\t * If ge search and we went off the end of the block, but it's\n\t\t * not the last block, we're in the wrong block.\n\t\t */\n\t\txfs_btree_get_sibling(cur, block, &ptr, XFS_BB_RIGHTSIB);\n\t\tif (dir == XFS_LOOKUP_GE &&\n\t\t    keyno > xfs_btree_get_numrecs(block) &&\n\t\t    !xfs_btree_ptr_is_null(cur, &ptr)) {\n\t\t\tint\ti;\n\n\t\t\tcur->bc_ptrs[0] = keyno;\n\t\t\terror = xfs_btree_increment(cur, 0, &i);\n\t\t\tif (error)\n\t\t\t\tgoto error0;\n\t\t\tXFS_WANT_CORRUPTED_RETURN(i == 1);\n\t\t\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\t\t\t*stat = 1;\n\t\t\treturn 0;\n\t\t}\n\t} else if (dir == XFS_LOOKUP_LE && diff > 0)\n\t\tkeyno--;\n\tcur->bc_ptrs[0] = keyno;\n\n\t/* Return if we succeeded or not. */\n\tif (keyno == 0 || keyno > xfs_btree_get_numrecs(block))\n\t\t*stat = 0;\n\telse if (dir != XFS_LOOKUP_EQ || diff == 0)\n\t\t*stat = 1;\n\telse\n\t\t*stat = 0;\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_EXIT);\n\treturn 0;\n\nerror0:\n\tXFS_BTREE_TRACE_CURSOR(cur, XBT_ERROR);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\t\t\t\t/* error */\nxfs_bmbt_lookup_eq(\n\tstruct xfs_btree_cur\t*cur,\n\txfs_fileoff_t\t\toff,\n\txfs_fsblock_t\t\tbno,\n\txfs_filblks_t\t\tlen,\n\tint\t\t\t*stat)\t/* success/failure */\n{\n\tcur->bc_rec.b.br_startoff = off;\n\tcur->bc_rec.b.br_startblock = bno;\n\tcur->bc_rec.b.br_blockcount = len;\n\treturn xfs_btree_lookup(cur, XFS_LOOKUP_EQ, stat);\n}"
  },
  {
    "function_name": "xfs_bmap_compute_maxlevels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap.c",
    "lines": "60-105",
    "snippet": "void\nxfs_bmap_compute_maxlevels(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\tint\t\tlevel;\t\t/* btree level */\n\tuint\t\tmaxblocks;\t/* max blocks at this level */\n\tuint\t\tmaxleafents;\t/* max leaf entries possible */\n\tint\t\tmaxrootrecs;\t/* max records in root block */\n\tint\t\tminleafrecs;\t/* min records in leaf block */\n\tint\t\tminnoderecs;\t/* min records in node block */\n\tint\t\tsz;\t\t/* root block size */\n\n\t/*\n\t * The maximum number of extents in a file, hence the maximum\n\t * number of leaf entries, is controlled by the type of di_nextents\n\t * (a signed 32-bit number, xfs_extnum_t), or by di_anextents\n\t * (a signed 16-bit number, xfs_aextnum_t).\n\t *\n\t * Note that we can no longer assume that if we are in ATTR1 that\n\t * the fork offset of all the inodes will be\n\t * (xfs_default_attroffset(ip) >> 3) because we could have mounted\n\t * with ATTR2 and then mounted back with ATTR1, keeping the\n\t * di_forkoff's fixed but probably at various positions. Therefore,\n\t * for both ATTR1 and ATTR2 we have to assume the worst case scenario\n\t * of a minimum size available.\n\t */\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tmaxleafents = MAXEXTNUM;\n\t\tsz = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t} else {\n\t\tmaxleafents = MAXAEXTNUM;\n\t\tsz = XFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t}\n\tmaxrootrecs = xfs_bmdr_maxrecs(sz, 0);\n\tminleafrecs = mp->m_bmap_dmnr[0];\n\tminnoderecs = mp->m_bmap_dmnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++) {\n\t\tif (maxblocks <= maxrootrecs)\n\t\t\tmaxblocks = 1;\n\t\telse\n\t\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\t}\n\tmp->m_bm_maxlevels[whichfork] = level;\n}",
    "includes": [
      "#include \"xfs_filestream.h\"",
      "#include \"xfs_attr_leaf.h\"",
      "#include \"xfs_symlink.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans_space.h\"",
      "#include \"xfs_quota.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_rtalloc.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_bmap_util.h\"",
      "#include \"xfs_bmap.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_extfree_item.h\"",
      "#include \"xfs_inode_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_btree.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_dir2.h\"",
      "#include \"xfs_da_btree.h\"",
      "#include \"xfs_da_format.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_bmdr_maxrecs",
          "args": [
            "sz",
            "0"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmdr_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "829-839",
          "snippet": "int\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_bmdr_maxrecs(\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= sizeof(xfs_bmdr_block_t);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmdr_rec_t);\n\treturn blocklen / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_SPACE_CALC",
          "args": [
            "MINABTPTRS"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BMDR_SPACE_CALC",
          "args": [
            "MINDBTPTRS"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_filestream.h\"\n#include \"xfs_attr_leaf.h\"\n#include \"xfs_symlink.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans_space.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_bmap_util.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_bmap_compute_maxlevels(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\tint\t\twhichfork)\t/* data or attr fork */\n{\n\tint\t\tlevel;\t\t/* btree level */\n\tuint\t\tmaxblocks;\t/* max blocks at this level */\n\tuint\t\tmaxleafents;\t/* max leaf entries possible */\n\tint\t\tmaxrootrecs;\t/* max records in root block */\n\tint\t\tminleafrecs;\t/* min records in leaf block */\n\tint\t\tminnoderecs;\t/* min records in node block */\n\tint\t\tsz;\t\t/* root block size */\n\n\t/*\n\t * The maximum number of extents in a file, hence the maximum\n\t * number of leaf entries, is controlled by the type of di_nextents\n\t * (a signed 32-bit number, xfs_extnum_t), or by di_anextents\n\t * (a signed 16-bit number, xfs_aextnum_t).\n\t *\n\t * Note that we can no longer assume that if we are in ATTR1 that\n\t * the fork offset of all the inodes will be\n\t * (xfs_default_attroffset(ip) >> 3) because we could have mounted\n\t * with ATTR2 and then mounted back with ATTR1, keeping the\n\t * di_forkoff's fixed but probably at various positions. Therefore,\n\t * for both ATTR1 and ATTR2 we have to assume the worst case scenario\n\t * of a minimum size available.\n\t */\n\tif (whichfork == XFS_DATA_FORK) {\n\t\tmaxleafents = MAXEXTNUM;\n\t\tsz = XFS_BMDR_SPACE_CALC(MINDBTPTRS);\n\t} else {\n\t\tmaxleafents = MAXAEXTNUM;\n\t\tsz = XFS_BMDR_SPACE_CALC(MINABTPTRS);\n\t}\n\tmaxrootrecs = xfs_bmdr_maxrecs(sz, 0);\n\tminleafrecs = mp->m_bmap_dmnr[0];\n\tminnoderecs = mp->m_bmap_dmnr[1];\n\tmaxblocks = (maxleafents + minleafrecs - 1) / minleafrecs;\n\tfor (level = 1; maxblocks > 1; level++) {\n\t\tif (maxblocks <= maxrootrecs)\n\t\t\tmaxblocks = 1;\n\t\telse\n\t\t\tmaxblocks = (maxblocks + minnoderecs - 1) / minnoderecs;\n\t}\n\tmp->m_bm_maxlevels[whichfork] = level;\n}"
  }
]