[
  {
    "function_name": "proc_task_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "3177-3189",
    "snippet": "static int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_threads",
          "args": [
            "p"
          ],
          "line": 3184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 3181
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_task_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *p = get_proc_task(inode);\n\tgeneric_fillattr(inode, stat);\n\n\tif (p) {\n\t\tstat->nlink += get_nr_threads(p);\n\t\tput_task_struct(p);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_task_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "3138-3175",
    "snippet": "static int proc_task_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *task;\n\tstruct pid_namespace *ns;\n\tint tid;\n\n\tif (proc_inode_is_dead(inode))\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\t/* f_version caches the tgid value that the last readdir call couldn't\n\t * return. lseek aka telldir automagically resets f_version to 0.\n\t */\n\tns = inode->i_sb->s_fs_info;\n\ttid = (int)file->f_version;\n\tfile->f_version = 0;\n\tfor (task = first_tid(proc_pid(inode), tid, ctx->pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tlen = snprintf(name, sizeof(name), \"%d\", tid);\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL)) {\n\t\t\t/* returning this tgid failed, save it as the first\n\t\t\t * pid for the next readir call */\n\t\t\tfile->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 3169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_fill_cache",
          "args": [
            "file",
            "ctx",
            "name",
            "len",
            "proc_task_instantiate",
            "task",
            "NULL"
          ],
          "line": 3164
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1605-1633",
          "snippet": "bool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"%d\"",
            "tid"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "task",
            "ns"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_tid",
          "args": [
            "task"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "next_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "3121-3135",
          "snippet": "static struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "first_tid",
          "args": [
            "proc_pid(inode)",
            "tid",
            "ctx->pos - 2",
            "ns"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "first_tid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "3072-3113",
          "snippet": "static struct task_struct *first_tid(struct pid *pid, int tid, loff_t f_pos,\n\t\t\t\t\tstruct pid_namespace *ns)\n{\n\tstruct task_struct *pos, *task;\n\tunsigned long nr = f_pos;\n\n\tif (nr != f_pos)\t/* 32bit overflow? */\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\tgoto fail;\n\n\t/* Attempt to start with the tid of a thread */\n\tif (tid && nr) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && same_thread_group(pos, task))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tif (nr >= get_nr_threads(task))\n\t\tgoto fail;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tpos = task = task->group_leader;\n\tdo {\n\t\tif (!nr--)\n\t\t\tgoto found;\n\t} while_each_thread(task, pos);\nfail:\n\tpos = NULL;\n\tgoto out;\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct task_struct *first_tid(struct pid *pid, int tid, loff_t f_pos,\n\t\t\t\t\tstruct pid_namespace *ns)\n{\n\tstruct task_struct *pos, *task;\n\tunsigned long nr = f_pos;\n\n\tif (nr != f_pos)\t/* 32bit overflow? */\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\tgoto fail;\n\n\t/* Attempt to start with the tid of a thread */\n\tif (tid && nr) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && same_thread_group(pos, task))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tif (nr >= get_nr_threads(task))\n\t\tgoto fail;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tpos = task = task->group_leader;\n\tdo {\n\t\tif (!nr--)\n\t\t\tgoto found;\n\t} while_each_thread(task, pos);\nfail:\n\tpos = NULL;\n\tgoto out;\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 3148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_inode_is_dead",
          "args": [
            "inode"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "proc_inode_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1571-1574",
          "snippet": "static inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_task_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *task;\n\tstruct pid_namespace *ns;\n\tint tid;\n\n\tif (proc_inode_is_dead(inode))\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\treturn 0;\n\n\t/* f_version caches the tgid value that the last readdir call couldn't\n\t * return. lseek aka telldir automagically resets f_version to 0.\n\t */\n\tns = inode->i_sb->s_fs_info;\n\ttid = (int)file->f_version;\n\tfile->f_version = 0;\n\tfor (task = first_tid(proc_pid(inode), tid, ctx->pos - 2, ns);\n\t     task;\n\t     task = next_tid(task), ctx->pos++) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\ttid = task_pid_nr_ns(task, ns);\n\t\tlen = snprintf(name, sizeof(name), \"%d\", tid);\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\tproc_task_instantiate, task, NULL)) {\n\t\t\t/* returning this tgid failed, save it as the first\n\t\t\t * pid for the next readir call */\n\t\t\tfile->f_version = (u64)tid;\n\t\t\tput_task_struct(task);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "next_tid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "3121-3135",
    "snippet": "static struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "start"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "pos"
          ],
          "line": 3130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "pos"
          ],
          "line": 3127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_thread",
          "args": [
            "start"
          ],
          "line": 3126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_alive",
          "args": [
            "start"
          ],
          "line": 3125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct task_struct *next_tid(struct task_struct *start)\n{\n\tstruct task_struct *pos = NULL;\n\trcu_read_lock();\n\tif (pid_alive(start)) {\n\t\tpos = next_thread(start);\n\t\tif (thread_group_leader(pos))\n\t\t\tpos = NULL;\n\t\telse\n\t\t\tget_task_struct(pos);\n\t}\n\trcu_read_unlock();\n\tput_task_struct(start);\n\treturn pos;\n}"
  },
  {
    "function_name": "first_tid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "3072-3113",
    "snippet": "static struct task_struct *first_tid(struct pid *pid, int tid, loff_t f_pos,\n\t\t\t\t\tstruct pid_namespace *ns)\n{\n\tstruct task_struct *pos, *task;\n\tunsigned long nr = f_pos;\n\n\tif (nr != f_pos)\t/* 32bit overflow? */\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\tgoto fail;\n\n\t/* Attempt to start with the tid of a thread */\n\tif (tid && nr) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && same_thread_group(pos, task))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tif (nr >= get_nr_threads(task))\n\t\tgoto fail;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tpos = task = task->group_leader;\n\tdo {\n\t\tif (!nr--)\n\t\t\tgoto found;\n\t} while_each_thread(task, pos);\nfail:\n\tpos = NULL;\n\tgoto out;\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "pos"
          ],
          "line": 3109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "task",
            "pos"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nr_threads",
          "args": [
            "task"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "pos",
            "task"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "tid",
            "ns"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 3082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct task_struct *first_tid(struct pid *pid, int tid, loff_t f_pos,\n\t\t\t\t\tstruct pid_namespace *ns)\n{\n\tstruct task_struct *pos, *task;\n\tunsigned long nr = f_pos;\n\n\tif (nr != f_pos)\t/* 32bit overflow? */\n\t\treturn NULL;\n\n\trcu_read_lock();\n\ttask = pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\tgoto fail;\n\n\t/* Attempt to start with the tid of a thread */\n\tif (tid && nr) {\n\t\tpos = find_task_by_pid_ns(tid, ns);\n\t\tif (pos && same_thread_group(pos, task))\n\t\t\tgoto found;\n\t}\n\n\t/* If nr exceeds the number of threads there is nothing todo */\n\tif (nr >= get_nr_threads(task))\n\t\tgoto fail;\n\n\t/* If we haven't found our starting place yet start\n\t * with the leader and walk nr threads forward.\n\t */\n\tpos = task = task->group_leader;\n\tdo {\n\t\tif (!nr--)\n\t\t\tgoto found;\n\t} while_each_thread(task, pos);\nfail:\n\tpos = NULL;\n\tgoto out;\nfound:\n\tget_task_struct(pos);\nout:\n\trcu_read_unlock();\n\treturn pos;\n}"
  },
  {
    "function_name": "proc_task_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "3025-3058",
    "snippet": "static struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct pid_namespace *ns;\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(&dentry->d_name);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dir, dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn ERR_PTR(result);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "result"
          ],
          "line": 3057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "leader"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 3053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_task_instantiate",
          "args": [
            "dir",
            "dentry",
            "task",
            "NULL"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "proc_task_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2999-3023",
          "snippet": "static int proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};",
            "static const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};",
            "static const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "leader",
            "task"
          ],
          "line": 3048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "tid",
            "ns"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_to_int",
          "args": [
            "&dentry->d_name"
          ],
          "line": 3036
        },
        "resolved": true,
        "details": {
          "function_name": "name_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "115-135",
          "snippet": "static inline unsigned name_to_int(const struct qstr *qstr)\n{\n\tconst char *name = qstr->name;\n\tint len = qstr->len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline unsigned name_to_int(const struct qstr *qstr)\n{\n\tconst char *name = qstr->name;\n\tint len = qstr->len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dir"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_task_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tstruct task_struct *leader = get_proc_task(dir);\n\tunsigned tid;\n\tstruct pid_namespace *ns;\n\n\tif (!leader)\n\t\tgoto out_no_task;\n\n\ttid = name_to_int(&dentry->d_name);\n\tif (tid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\tif (!same_thread_group(leader, task))\n\t\tgoto out_drop_task;\n\n\tresult = proc_task_instantiate(dir, dentry, task, NULL);\nout_drop_task:\n\tput_task_struct(task);\nout:\n\tput_task_struct(leader);\nout_no_task:\n\treturn ERR_PTR(result);\n}"
  },
  {
    "function_name": "proc_task_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2999-3023",
    "snippet": "static int proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};",
      "static const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};",
      "static const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_revalidate",
          "args": [
            "dentry",
            "0"
          ],
          "line": 3019
        },
        "resolved": true,
        "details": {
          "function_name": "pid_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1539-1569",
          "snippet": "int pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 3017
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&pid_dentry_operations"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff))"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_entry_count_dirs",
          "args": [
            "tid_base_stuff",
            "ARRAY_SIZE(tid_base_stuff)"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "pid_entry_count_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "142-155",
          "snippet": "static unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tid_base_stuff"
          ],
          "line": 3013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pid_make_inode",
          "args": [
            "dir->i_sb",
            "task"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1447-1487",
          "snippet": "struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "proc_tid_base_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2981-2985",
    "snippet": "static struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pident_lookup",
          "args": [
            "dir",
            "dentry",
            "tid_base_stuff",
            "ARRAY_SIZE(tid_base_stuff)"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pident_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2074-2107",
          "snippet": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tid_base_stuff"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};\n\nstatic struct dentry *proc_tid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}"
  },
  {
    "function_name": "proc_tid_base_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2975-2979",
    "snippet": "static int proc_tid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pident_readdir",
          "args": [
            "file",
            "ctx",
            "tid_base_stuff",
            "ARRAY_SIZE(tid_base_stuff)"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pident_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2109-2133",
          "snippet": "static int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tid_base_stuff"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};\n\nstatic int proc_tid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tid_base_stuff, ARRAY_SIZE(tid_base_stuff));\n}"
  },
  {
    "function_name": "proc_pid_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2844-2885",
    "snippet": "int proc_pid_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns = file_inode(file)->i_sb->s_fs_info;\n\tloff_t pos = ctx->pos;\n\n\tif (pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\treturn 0;\n\n\tif (pos == TGID_OFFSET - 2) {\n\t\tstruct inode *inode = ns->proc_self->d_inode;\n\t\tif (!dir_emit(ctx, \"self\", 4, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\tif (pos == TGID_OFFSET - 1) {\n\t\tstruct inode *inode = ns->proc_thread_self->d_inode;\n\t\tif (!dir_emit(ctx, \"thread-self\", 11, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\titer.tgid = pos - TGID_OFFSET;\n\titer.task = NULL;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\tif (!has_pid_permissions(ns, iter.task, 2))\n\t\t\tcontinue;\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\t\tctx->pos = iter.tgid + TGID_OFFSET;\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\t     proc_pid_instantiate, iter.task, NULL)) {\n\t\t\tput_task_struct(iter.task);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tctx->pos = PID_MAX_LIMIT + TGID_OFFSET;\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [
      "#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "iter.task"
          ],
          "line": 2879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_fill_cache",
          "args": [
            "file",
            "ctx",
            "name",
            "len",
            "proc_pid_instantiate",
            "iter.task",
            "NULL"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1605-1633",
          "snippet": "bool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"%d\"",
            "iter.tgid"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pid_permissions",
          "args": [
            "ns",
            "iter.task",
            "2"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "has_pid_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "526-535",
          "snippet": "static bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_tgid",
          "args": [
            "ns",
            "iter"
          ],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "next_tgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2806-2839",
          "snippet": "static struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"thread-self\"",
            "11",
            "inode->i_ino",
            "DT_LNK"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "\"self\"",
            "4",
            "inode->i_ino",
            "DT_LNK"
          ],
          "line": 2855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\n#define TGID_OFFSET (FIRST_PROCESS_ENTRY + 2)\n\nint proc_pid_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct tgid_iter iter;\n\tstruct pid_namespace *ns = file_inode(file)->i_sb->s_fs_info;\n\tloff_t pos = ctx->pos;\n\n\tif (pos >= PID_MAX_LIMIT + TGID_OFFSET)\n\t\treturn 0;\n\n\tif (pos == TGID_OFFSET - 2) {\n\t\tstruct inode *inode = ns->proc_self->d_inode;\n\t\tif (!dir_emit(ctx, \"self\", 4, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\tif (pos == TGID_OFFSET - 1) {\n\t\tstruct inode *inode = ns->proc_thread_self->d_inode;\n\t\tif (!dir_emit(ctx, \"thread-self\", 11, inode->i_ino, DT_LNK))\n\t\t\treturn 0;\n\t\tctx->pos = pos = pos + 1;\n\t}\n\titer.tgid = pos - TGID_OFFSET;\n\titer.task = NULL;\n\tfor (iter = next_tgid(ns, iter);\n\t     iter.task;\n\t     iter.tgid += 1, iter = next_tgid(ns, iter)) {\n\t\tchar name[PROC_NUMBUF];\n\t\tint len;\n\t\tif (!has_pid_permissions(ns, iter.task, 2))\n\t\t\tcontinue;\n\n\t\tlen = snprintf(name, sizeof(name), \"%d\", iter.tgid);\n\t\tctx->pos = iter.tgid + TGID_OFFSET;\n\t\tif (!proc_fill_cache(file, ctx, name, len,\n\t\t\t\t     proc_pid_instantiate, iter.task, NULL)) {\n\t\t\tput_task_struct(iter.task);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tctx->pos = PID_MAX_LIMIT + TGID_OFFSET;\n\treturn 0;\n}"
  },
  {
    "function_name": "next_tgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2806-2839",
    "snippet": "static struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "iter.task"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_group_leader_pid",
          "args": [
            "iter.task"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 2818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_nr_ns",
          "args": [
            "pid",
            "ns"
          ],
          "line": 2817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_ge_pid",
          "args": [
            "iter.tgid",
            "ns"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "iter.task"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct tgid_iter next_tgid(struct pid_namespace *ns, struct tgid_iter iter)\n{\n\tstruct pid *pid;\n\n\tif (iter.task)\n\t\tput_task_struct(iter.task);\n\trcu_read_lock();\nretry:\n\titer.task = NULL;\n\tpid = find_ge_pid(iter.tgid, ns);\n\tif (pid) {\n\t\titer.tgid = pid_nr_ns(pid, ns);\n\t\titer.task = pid_task(pid, PIDTYPE_PID);\n\t\t/* What we to know is if the pid we have find is the\n\t\t * pid of a thread_group_leader.  Testing for task\n\t\t * being a thread_group_leader is the obvious thing\n\t\t * todo but there is a window when it fails, due to\n\t\t * the pid transfer logic in de_thread.\n\t\t *\n\t\t * So we perform the straight forward test of seeing\n\t\t * if the pid we have found is the pid of a thread\n\t\t * group leader, and don't worry if the task we have\n\t\t * found doesn't happen to be a thread group leader.\n\t\t * As we don't care in the case of readdir.\n\t\t */\n\t\tif (!iter.task || !has_group_leader_pid(iter.task)) {\n\t\t\titer.tgid += 1;\n\t\t\tgoto retry;\n\t\t}\n\t\tget_task_struct(iter.task);\n\t}\n\trcu_read_unlock();\n\treturn iter;\n}"
  },
  {
    "function_name": "proc_pid_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2772-2796",
    "snippet": "struct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\ttgid = name_to_int(&dentry->d_name);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "result"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pid_instantiate",
          "args": [
            "dir",
            "dentry",
            "task",
            "NULL"
          ],
          "line": 2792
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2744-2770",
          "snippet": "static int proc_pid_instantiate(struct inode *dir,\n\t\t\t\t   struct dentry * dentry,\n\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tgid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};",
            "static const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n#endif\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n};",
            "static const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tgid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n#endif\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n};\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tgid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};\n\nstatic int proc_pid_instantiate(struct inode *dir,\n\t\t\t\t   struct dentry * dentry,\n\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tgid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "task"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "tgid",
            "ns"
          ],
          "line": 2785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_to_int",
          "args": [
            "&dentry->d_name"
          ],
          "line": 2779
        },
        "resolved": true,
        "details": {
          "function_name": "name_to_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "115-135",
          "snippet": "static inline unsigned name_to_int(const struct qstr *qstr)\n{\n\tconst char *name = qstr->name;\n\tint len = qstr->len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline unsigned name_to_int(const struct qstr *qstr)\n{\n\tconst char *name = qstr->name;\n\tint len = qstr->len;\n\tunsigned n = 0;\n\n\tif (len > 1 && *name == '0')\n\t\tgoto out;\n\twhile (len-- > 0) {\n\t\tunsigned c = *name++ - '0';\n\t\tif (c > 9)\n\t\t\tgoto out;\n\t\tif (n >= (~0U-9)/10)\n\t\t\tgoto out;\n\t\tn *= 10;\n\t\tn += c;\n\t}\n\treturn n;\nout:\n\treturn ~0U;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct dentry *proc_pid_lookup(struct inode *dir, struct dentry * dentry, unsigned int flags)\n{\n\tint result = -ENOENT;\n\tstruct task_struct *task;\n\tunsigned tgid;\n\tstruct pid_namespace *ns;\n\n\ttgid = name_to_int(&dentry->d_name);\n\tif (tgid == ~0U)\n\t\tgoto out;\n\n\tns = dentry->d_sb->s_fs_info;\n\trcu_read_lock();\n\ttask = find_task_by_pid_ns(tgid, ns);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\tif (!task)\n\t\tgoto out;\n\n\tresult = proc_pid_instantiate(dir, dentry, task, NULL);\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}"
  },
  {
    "function_name": "proc_pid_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2744-2770",
    "snippet": "static int proc_pid_instantiate(struct inode *dir,\n\t\t\t\t   struct dentry * dentry,\n\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tgid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};",
      "static const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n#endif\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n};",
      "static const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tgid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_revalidate",
          "args": [
            "dentry",
            "0"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "pid_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1539-1569",
          "snippet": "int pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&pid_dentry_operations"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tgid_base_stuff))"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_entry_count_dirs",
          "args": [
            "tgid_base_stuff",
            "ARRAY_SIZE(tgid_base_stuff)"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "pid_entry_count_dirs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "142-155",
          "snippet": "static unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tgid_base_stuff"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pid_make_inode",
          "args": [
            "dir->i_sb",
            "task"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1447-1487",
          "snippet": "struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n#endif\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n};\nstatic const struct file_operations proc_tgid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tgid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations proc_tgid_base_inode_operations = {\n\t.lookup\t\t= proc_tgid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n\t.permission\t= proc_pid_permission,\n};\n\nstatic int proc_pid_instantiate(struct inode *dir,\n\t\t\t\t   struct dentry * dentry,\n\t\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tgid_base_inode_operations;\n\tinode->i_fop = &proc_tgid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tgid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tgid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "proc_flush_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2728-2742",
    "snippet": "void proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid;\n\tstruct upid *upid;\n\n\tpid = task_pid(task);\n\ttgid = task_tgid(task);\n\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\t\t\ttgid->numbers[i].nr);\n\t}\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_flush_task_mnt",
          "args": [
            "upid->ns->proc_mnt",
            "upid->nr",
            "tgid->numbers[i].nr"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "proc_flush_task_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2658-2701",
          "snippet": "static void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\t/* no ->d_hash() rejects on procfs */\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tif (pid == tgid)\n\t\treturn;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\t/* no ->d_hash() rejects on procfs */\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tif (pid == tgid)\n\t\treturn;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "task"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "task"
          ],
          "line": 2734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nvoid proc_flush_task(struct task_struct *task)\n{\n\tint i;\n\tstruct pid *pid, *tgid;\n\tstruct upid *upid;\n\n\tpid = task_pid(task);\n\ttgid = task_tgid(task);\n\n\tfor (i = 0; i <= pid->level; i++) {\n\t\tupid = &pid->numbers[i];\n\t\tproc_flush_task_mnt(upid->ns->proc_mnt, upid->nr,\n\t\t\t\t\ttgid->numbers[i].nr);\n\t}\n}"
  },
  {
    "function_name": "proc_flush_task_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2658-2701",
    "snippet": "static void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\t/* no ->d_hash() rejects on procfs */\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tif (pid == tgid)\n\t\treturn;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "leader"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_invalidate",
          "args": [
            "dentry"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "d_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1465-1506",
          "snippet": "void d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_invalidate(struct dentry *dentry)\n{\n\t/*\n\t * If it's already been dropped, return OK.\n\t */\n\tspin_lock(&dentry->d_lock);\n\tif (d_unhashed(dentry)) {\n\t\tspin_unlock(&dentry->d_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&dentry->d_lock);\n\n\t/* Negative dentries can be dropped without further checks */\n\tif (!dentry->d_inode) {\n\t\td_drop(dentry);\n\t\treturn;\n\t}\n\n\tfor (;;) {\n\t\tstruct detach_data data;\n\n\t\tdata.mountpoint = NULL;\n\t\tINIT_LIST_HEAD(&data.select.dispose);\n\t\tdata.select.start = dentry;\n\t\tdata.select.found = 0;\n\n\t\td_walk(dentry, &data, detach_and_collect, check_and_drop);\n\n\t\tif (data.select.found)\n\t\t\tshrink_dentry_list(&data.select.dispose);\n\n\t\tif (data.mountpoint) {\n\t\t\tdetach_mounts(data.mountpoint);\n\t\t\tdput(data.mountpoint);\n\t\t}\n\n\t\tif (!data.mountpoint && !data.select.found)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_hash_and_lookup",
          "args": [
            "dir",
            "&name"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%d\"",
            "pid"
          ],
          "line": 2689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name.name"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%d\"",
            "tgid"
          ],
          "line": 2677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "sizeof(buf)",
            "\"%d\"",
            "pid"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void proc_flush_task_mnt(struct vfsmount *mnt, pid_t pid, pid_t tgid)\n{\n\tstruct dentry *dentry, *leader, *dir;\n\tchar buf[PROC_NUMBUF];\n\tstruct qstr name;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\t/* no ->d_hash() rejects on procfs */\n\tdentry = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tif (pid == tgid)\n\t\treturn;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", tgid);\n\tleader = d_hash_and_lookup(mnt->mnt_root, &name);\n\tif (!leader)\n\t\tgoto out;\n\n\tname.name = \"task\";\n\tname.len = strlen(name.name);\n\tdir = d_hash_and_lookup(leader, &name);\n\tif (!dir)\n\t\tgoto out_put_leader;\n\n\tname.name = buf;\n\tname.len = snprintf(buf, sizeof(buf), \"%d\", pid);\n\tdentry = d_hash_and_lookup(dir, &name);\n\tif (dentry) {\n\t\td_invalidate(dentry);\n\t\tdput(dentry);\n\t}\n\n\tdput(dir);\nout_put_leader:\n\tdput(leader);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "proc_tgid_base_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2645-2649",
    "snippet": "static struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n#endif\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pident_lookup",
          "args": [
            "dir",
            "dentry",
            "tgid_base_stuff",
            "ARRAY_SIZE(tgid_base_stuff)"
          ],
          "line": 2647
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pident_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2074-2107",
          "snippet": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tgid_base_stuff"
          ],
          "line": 2648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n#endif\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n};\n\nstatic struct dentry *proc_tgid_base_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}"
  },
  {
    "function_name": "proc_tgid_base_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2633-2637",
    "snippet": "static int proc_tgid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n#endif\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pident_readdir",
          "args": [
            "file",
            "ctx",
            "tgid_base_stuff",
            "ARRAY_SIZE(tgid_base_stuff)"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pident_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2109-2133",
          "snippet": "static int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tgid_base_stuff"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct pid_entry tgid_base_stuff[] = {\n\tDIR(\"task\",       S_IRUGO|S_IXUGO, proc_task_inode_operations, proc_task_operations),\n\tDIR(\"fd\",         S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tDIR(\"map_files\",  S_IRUSR|S_IXUSR, proc_map_files_inode_operations, proc_map_files_operations),\n#endif\n\tDIR(\"fdinfo\",     S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t  S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",    S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",       S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",     S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t  S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",      S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n#ifdef CONFIG_SCHED_AUTOGROUP\n\tREG(\"autogroup\",  S_IRUGO|S_IWUSR, proc_pid_sched_autogroup_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",    S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",    S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",       S_IRUGO, proc_tgid_stat),\n\tONE(\"statm\",      S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",       S_IRUGO, proc_pid_maps_operations),\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\",  S_IRUGO, proc_pid_numa_maps_operations),\n#endif\n\tREG(\"mem\",        S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",        proc_cwd_link),\n\tLNK(\"root\",       proc_root_link),\n\tLNK(\"exe\",        proc_exe_link),\n\tREG(\"mounts\",     S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n\tREG(\"mountstats\", S_IRUSR, proc_mountstats_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",      S_IRUGO, proc_pid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",      S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\",  S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",     S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\",  S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",    S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",   S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_ELF_CORE\n\tREG(\"coredump_filter\", S_IRUGO|S_IWUSR, proc_coredump_filter_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tgid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"timers\",\t  S_IRUGO, proc_timers_operations),\n#endif\n};\n\nstatic int proc_tgid_base_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx,\n\t\t\t\t   tgid_base_stuff, ARRAY_SIZE(tgid_base_stuff));\n}"
  },
  {
    "function_name": "proc_pid_personality",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2520-2529",
    "snippet": "static int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tint err = lock_trace(task);\n\tif (!err) {\n\t\tseq_printf(m, \"%08x\\n\", task->personality);\n\t\tunlock_trace(task);\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_trace",
          "args": [
            "task"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "263-266",
          "snippet": "static void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%08x\\n\"",
            "task->personality"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pid_personality(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\tstruct pid *pid, struct task_struct *task)\n{\n\tint err = lock_trace(task);\n\tif (!err) {\n\t\tseq_printf(m, \"%08x\\n\", task->personality);\n\t\tunlock_trace(task);\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "proc_setgroups_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2502-2509",
    "snippet": "static int proc_setgroups_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tint ret = single_release(inode, file);\n\tput_user_ns(ns);\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "single_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "single_release_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "99-104",
          "snippet": "int single_release_net(struct inode *ino, struct file *f)\n{\n\tstruct seq_file *seq = f->private_data;\n\tput_net(seq->private);\n\treturn single_release(ino, f);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_release_net(struct inode *ino, struct file *f)\n{\n\tstruct seq_file *seq = f->private_data;\n\tput_net(seq->private);\n\treturn single_release(ino, f);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_setgroups_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tint ret = single_release(inode, file);\n\tput_user_ns(ns);\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_setgroups_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2468-2500",
    "snippet": "static int proc_setgroups_open(struct inode *inode, struct file *file)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tint ret;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tret = -EACCES;\n\t\tif (!ns_capable(ns, CAP_SYS_ADMIN))\n\t\t\tgoto err_put_ns;\n\t}\n\n\tret = single_open(file, &proc_setgroups_show, ns);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "&proc_setgroups_show",
            "ns"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "single_open_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "63-84",
          "snippet": "int single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 2487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "task_cred_xxx(task, user_ns)"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "task",
            "user_ns"
          ],
          "line": 2478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_setgroups_open(struct inode *inode, struct file *file)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tint ret;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tret = -EACCES;\n\t\tif (!ns_capable(ns, CAP_SYS_ADMIN))\n\t\t\tgoto err_put_ns;\n\t}\n\n\tret = single_open(file, &proc_setgroups_show, ns);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_projid_map_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2439-2442",
    "snippet": "static int proc_projid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_projid_seq_operations);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_id_map_open",
          "args": [
            "inode",
            "file",
            "&proc_projid_seq_operations"
          ],
          "line": 2441
        },
        "resolved": true,
        "details": {
          "function_name": "proc_id_map_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2389-2419",
          "snippet": "static int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_projid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_projid_seq_operations);\n}"
  },
  {
    "function_name": "proc_gid_map_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2434-2437",
    "snippet": "static int proc_gid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_gid_seq_operations);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_id_map_open",
          "args": [
            "inode",
            "file",
            "&proc_gid_seq_operations"
          ],
          "line": 2436
        },
        "resolved": true,
        "details": {
          "function_name": "proc_id_map_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2389-2419",
          "snippet": "static int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_gid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_gid_seq_operations);\n}"
  },
  {
    "function_name": "proc_uid_map_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2429-2432",
    "snippet": "static int proc_uid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_uid_seq_operations);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_id_map_open",
          "args": [
            "inode",
            "file",
            "&proc_uid_seq_operations"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "proc_id_map_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2389-2419",
          "snippet": "static int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_uid_map_open(struct inode *inode, struct file *file)\n{\n\treturn proc_id_map_open(inode, file, &proc_uid_seq_operations);\n}"
  },
  {
    "function_name": "proc_id_map_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2421-2427",
    "snippet": "static int proc_id_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tput_user_ns(ns);\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "87-96",
          "snippet": "int seq_release_net(struct inode *ino, struct file *f)\n{\n\tstruct seq_file *seq;\n\n\tseq = f->private_data;\n\n\tput_net(seq_file_net(seq));\n\tseq_release_private(ino, f);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint seq_release_net(struct inode *ino, struct file *f)\n{\n\tstruct seq_file *seq;\n\n\tseq = f->private_data;\n\n\tput_net(seq_file_net(seq));\n\tseq_release_private(ino, f);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns"
          ],
          "line": 2425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_id_map_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\tstruct user_namespace *ns = seq->private;\n\tput_user_ns(ns);\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "proc_id_map_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2389-2419",
    "snippet": "static int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "seq_ops"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "task_cred_xxx(task, user_ns)"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "task",
            "user_ns"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_id_map_open(struct inode *inode, struct file *file,\n\tconst struct seq_operations *seq_ops)\n{\n\tstruct user_namespace *ns = NULL;\n\tstruct task_struct *task;\n\tstruct seq_file *seq;\n\tint ret = -EINVAL;\n\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\trcu_read_lock();\n\t\tns = get_user_ns(task_cred_xxx(task, user_ns));\n\t\trcu_read_unlock();\n\t\tput_task_struct(task);\n\t}\n\tif (!ns)\n\t\tgoto err;\n\n\tret = seq_open(file, seq_ops);\n\tif (ret)\n\t\tgoto err_put_ns;\n\n\tseq = file->private_data;\n\tseq->private = ns;\n\n\treturn 0;\nerr_put_ns:\n\tput_user_ns(ns);\nerr:\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_tgid_io_accounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2381-2385",
    "snippet": "static int proc_tgid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 1);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_io_accounting",
          "args": [
            "task",
            "m",
            "1"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "do_io_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2331-2373",
          "snippet": "static int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tresult = seq_printf(m,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tresult = seq_printf(m,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_tgid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 1);\n}"
  },
  {
    "function_name": "proc_tid_io_accounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2375-2379",
    "snippet": "static int proc_tid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 0);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_io_accounting",
          "args": [
            "task",
            "m",
            "0"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "do_io_accounting",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2331-2373",
          "snippet": "static int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tresult = seq_printf(m,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tresult = seq_printf(m,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_tid_io_accounting(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\treturn do_io_accounting(task, m, 0);\n}"
  },
  {
    "function_name": "do_io_accounting",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2331-2373",
    "snippet": "static int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tresult = seq_printf(m,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\"",
            "(unsigned long long)acct.rchar",
            "(unsigned long long)acct.wchar",
            "(unsigned long long)acct.syscr",
            "(unsigned long long)acct.syscw",
            "(unsigned long long)acct.read_bytes",
            "(unsigned long long)acct.write_bytes",
            "(unsigned long long)acct.cancelled_write_bytes"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_accounting_add",
          "args": [
            "&acct",
            "&t->ioac"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "task",
            "t"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_io_accounting_add",
          "args": [
            "&acct",
            "&task->signal->ioac"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 2341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 2337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int do_io_accounting(struct task_struct *task, struct seq_file *m, int whole)\n{\n\tstruct task_io_accounting acct = task->ioac;\n\tunsigned long flags;\n\tint result;\n\n\tresult = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (result)\n\t\treturn result;\n\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ)) {\n\t\tresult = -EACCES;\n\t\tgoto out_unlock;\n\t}\n\n\tif (whole && lock_task_sighand(task, &flags)) {\n\t\tstruct task_struct *t = task;\n\n\t\ttask_io_accounting_add(&acct, &task->signal->ioac);\n\t\twhile_each_thread(task, t)\n\t\t\ttask_io_accounting_add(&acct, &t->ioac);\n\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tresult = seq_printf(m,\n\t\t\t\"rchar: %llu\\n\"\n\t\t\t\"wchar: %llu\\n\"\n\t\t\t\"syscr: %llu\\n\"\n\t\t\t\"syscw: %llu\\n\"\n\t\t\t\"read_bytes: %llu\\n\"\n\t\t\t\"write_bytes: %llu\\n\"\n\t\t\t\"cancelled_write_bytes: %llu\\n\",\n\t\t\t(unsigned long long)acct.rchar,\n\t\t\t(unsigned long long)acct.wchar,\n\t\t\t(unsigned long long)acct.syscr,\n\t\t\t(unsigned long long)acct.syscw,\n\t\t\t(unsigned long long)acct.read_bytes,\n\t\t\t(unsigned long long)acct.write_bytes,\n\t\t\t(unsigned long long)acct.cancelled_write_bytes);\nout_unlock:\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n\treturn result;\n}"
  },
  {
    "function_name": "proc_coredump_filter_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2272-2321",
    "snippet": "static ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF], *end;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = -EFAULT;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\tgoto out_no_task;\n\n\tret = -EINVAL;\n\tval = (unsigned int)simple_strtoul(buffer, &end, 0);\n\tif (*end == '\\n')\n\t\tend++;\n\tif (end - buffer == 0)\n\t\tgoto out_no_task;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = end - buffer;\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "i + MMF_DUMP_FILTER_SHIFT",
            "&mm->flags"
          ],
          "line": 2313
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "i + MMF_DUMP_FILTER_SHIFT",
            "&mm->flags"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 2305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "buffer",
            "&end",
            "0"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buffer",
            "buf",
            "count"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t proc_coredump_filter_write(struct file *file,\n\t\t\t\t\t  const char __user *buf,\n\t\t\t\t\t  size_t count,\n\t\t\t\t\t  loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF], *end;\n\tunsigned int val;\n\tint ret;\n\tint i;\n\tunsigned long mask;\n\n\tret = -EFAULT;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\tgoto out_no_task;\n\n\tret = -EINVAL;\n\tval = (unsigned int)simple_strtoul(buffer, &end, 0);\n\tif (*end == '\\n')\n\t\tend++;\n\tif (end - buffer == 0)\n\t\tgoto out_no_task;\n\n\tret = -ESRCH;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out_no_task;\n\n\tret = end - buffer;\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_no_mm;\n\n\tfor (i = 0, mask = 1; i < MMF_DUMP_FILTER_BITS; i++, mask <<= 1) {\n\t\tif (val & mask)\n\t\t\tset_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t\telse\n\t\t\tclear_bit(i + MMF_DUMP_FILTER_SHIFT, &mm->flags);\n\t}\n\n\tmmput(mm);\n out_no_mm:\n\tput_task_struct(task);\n out_no_task:\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_coredump_filter_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2245-2270",
    "snippet": "static ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "buffer",
            "len"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%08lx\\n\"",
            "((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT)"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t proc_coredump_filter_read(struct file *file, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tstruct mm_struct *mm;\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint ret;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = 0;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tlen = snprintf(buffer, sizeof(buffer), \"%08lx\\n\",\n\t\t\t       ((mm->flags & MMF_DUMP_FILTER_MASK) >>\n\t\t\t\tMMF_DUMP_FILTER_SHIFT));\n\t\tmmput(mm);\n\t\tret = simple_read_from_buffer(buf, count, ppos, buffer, len);\n\t}\n\n\tput_task_struct(task);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_attr_dir_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2229-2234",
    "snippet": "static struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pident_lookup",
          "args": [
            "dir",
            "dentry",
            "attr_dir_stuff",
            "ARRAY_SIZE(attr_dir_stuff)"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pident_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2074-2107",
          "snippet": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "attr_dir_stuff"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_attr_dir_lookup(struct inode *dir,\n\t\t\t\tstruct dentry *dentry, unsigned int flags)\n{\n\treturn proc_pident_lookup(dir, dentry,\n\t\t\t\t  attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}"
  },
  {
    "function_name": "proc_attr_dir_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2217-2221",
    "snippet": "static int proc_attr_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx, \n\t\t\t\t   attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pident_readdir",
          "args": [
            "file",
            "ctx",
            "attr_dir_stuff",
            "ARRAY_SIZE(attr_dir_stuff)"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pident_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2109-2133",
          "snippet": "static int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "attr_dir_stuff"
          ],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_attr_dir_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn proc_pident_readdir(file, ctx, \n\t\t\t\t   attr_dir_stuff, ARRAY_SIZE(attr_dir_stuff));\n}"
  },
  {
    "function_name": "proc_pid_attr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2157-2200",
    "snippet": "static ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free;\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      (void*)page, count);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) page"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_setprocattr",
          "args": [
            "task",
            "(char*)file->f_path.dentry->d_name.name",
            "(void*)page",
            "count"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "page",
            "buf",
            "count"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_TEMPORARY"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *page;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tlength = -ESRCH;\n\tif (!task)\n\t\tgoto out_no_task;\n\tif (count > PAGE_SIZE)\n\t\tcount = PAGE_SIZE;\n\n\t/* No partial writes. */\n\tlength = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tlength = -ENOMEM;\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\tgoto out;\n\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free;\n\n\t/* Guard against adverse ptrace interaction */\n\tlength = mutex_lock_interruptible(&task->signal->cred_guard_mutex);\n\tif (length < 0)\n\t\tgoto out_free;\n\n\tlength = security_setprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      (void*)page, count);\n\tmutex_unlock(&task->signal->cred_guard_mutex);\nout_free:\n\tfree_page((unsigned long) page);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn length;\n}"
  },
  {
    "function_name": "proc_pid_attr_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2136-2155",
    "snippet": "static ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 2153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "p",
            "length"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_getprocattr",
          "args": [
            "task",
            "(char*)file->f_path.dentry->d_name.name",
            "&p"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2139
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t proc_pid_attr_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *p = NULL;\n\tssize_t length;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tlength = security_getprocattr(task,\n\t\t\t\t      (char*)file->f_path.dentry->d_name.name,\n\t\t\t\t      &p);\n\tput_task_struct(task);\n\tif (length > 0)\n\t\tlength = simple_read_from_buffer(buf, count, ppos, p, length);\n\tkfree(p);\n\treturn length;\n}"
  },
  {
    "function_name": "proc_pident_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2109-2133",
    "snippet": "static int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_fill_cache",
          "args": [
            "file",
            "ctx",
            "p->name",
            "p->len",
            "proc_pident_instantiate",
            "task",
            "p"
          ],
          "line": 2125
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1605-1633",
          "snippet": "bool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pident_readdir(struct file *file, struct dir_context *ctx,\n\t\tconst struct pid_entry *ents, unsigned int nents)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tconst struct pid_entry *p;\n\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out;\n\n\tif (ctx->pos >= nents + 2)\n\t\tgoto out;\n\n\tfor (p = ents + (ctx->pos - 2); p <= ents + nents - 1; p++) {\n\t\tif (!proc_fill_cache(file, ctx, p->name, p->len,\n\t\t\t\tproc_pident_instantiate, task, p))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\nout:\n\tput_task_struct(task);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_pident_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2074-2107",
    "snippet": "static struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pident_instantiate",
          "args": [
            "dir",
            "dentry",
            "task",
            "p"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pident_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2045-2072",
          "snippet": "static int proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tset_nlink(inode, 2);\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tset_nlink(inode, 2);\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "dentry->d_name.name",
            "p->name",
            "p->len"
          ],
          "line": 2096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dir"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_pident_lookup(struct inode *dir, \n\t\t\t\t\t struct dentry *dentry,\n\t\t\t\t\t const struct pid_entry *ents,\n\t\t\t\t\t unsigned int nents)\n{\n\tint error;\n\tstruct task_struct *task = get_proc_task(dir);\n\tconst struct pid_entry *p, *last;\n\n\terror = -ENOENT;\n\n\tif (!task)\n\t\tgoto out_no_task;\n\n\t/*\n\t * Yes, it does not scale. And it should not. Don't add\n\t * new entries into /proc/<tgid>/ without very good reasons.\n\t */\n\tlast = &ents[nents - 1];\n\tfor (p = ents; p <= last; p++) {\n\t\tif (p->len != dentry->d_name.len)\n\t\t\tcontinue;\n\t\tif (!memcmp(dentry->d_name.name, p->name, p->len))\n\t\t\tbreak;\n\t}\n\tif (p > last)\n\t\tgoto out;\n\n\terror = proc_pident_instantiate(dir, dentry, task, p);\nout:\n\tput_task_struct(task);\nout_no_task:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "proc_pident_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2045-2072",
    "snippet": "static int proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tset_nlink(inode, 2);\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_revalidate",
          "args": [
            "dentry",
            "0"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "pid_revalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1539-1569",
          "snippet": "int pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 2066
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&pid_dentry_operations"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "2"
          ],
          "line": 2059
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_pid_make_inode",
          "args": [
            "dir->i_sb",
            "task"
          ],
          "line": 2052
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1447-1487",
          "snippet": "struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\n\nstatic int proc_pident_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tconst struct pid_entry *p = ptr;\n\tstruct inode *inode;\n\tstruct proc_inode *ei;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\tgoto out;\n\n\tei = PROC_I(inode);\n\tinode->i_mode = p->mode;\n\tif (S_ISDIR(inode->i_mode))\n\t\tset_nlink(inode, 2);\t/* Use getattr to fix if necessary */\n\tif (p->iop)\n\t\tinode->i_op = p->iop;\n\tif (p->fop)\n\t\tinode->i_fop = p->fop;\n\tei->op = p->op;\n\td_set_d_op(dentry, &pid_dentry_operations);\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "proc_timers_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "2023-2035",
    "snippet": "static int proc_timers_open(struct inode *inode, struct file *file)\n{\n\tstruct timers_private *tp;\n\n\ttp = __seq_open_private(file, &proc_timers_seq_ops,\n\t\t\tsizeof(struct timers_private));\n\tif (!tp)\n\t\treturn -ENOMEM;\n\n\ttp->pid = proc_pid(inode);\n\ttp->ns = inode->i_sb->s_fs_info;\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__seq_open_private",
          "args": [
            "file",
            "&proc_timers_seq_ops",
            "sizeof(struct timers_private)"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "__seq_open_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "615-638",
          "snippet": "void *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid *__seq_open_private(struct file *f, const struct seq_operations *ops,\n\t\tint psize)\n{\n\tint rc;\n\tvoid *private;\n\tstruct seq_file *seq;\n\n\tprivate = kzalloc(psize, GFP_KERNEL);\n\tif (private == NULL)\n\t\tgoto out;\n\n\trc = seq_open(f, ops);\n\tif (rc < 0)\n\t\tgoto out_free;\n\n\tseq = f->private_data;\n\tseq->private = private;\n\treturn private;\n\nout_free:\n\tkfree(private);\nout:\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_timers_open(struct inode *inode, struct file *file)\n{\n\tstruct timers_private *tp;\n\n\ttp = __seq_open_private(file, &proc_timers_seq_ops,\n\t\t\tsizeof(struct timers_private));\n\tif (!tp)\n\t\treturn -ENOMEM;\n\n\ttp->pid = proc_pid(inode);\n\ttp->ns = inode->i_sb->s_fs_info;\n\treturn 0;\n}"
  },
  {
    "function_name": "show_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1990-2014",
    "snippet": "static int show_timer(struct seq_file *m, void *v)\n{\n\tstruct k_itimer *timer;\n\tstruct timers_private *tp = m->private;\n\tint notify;\n\tstatic const char * const nstr[] = {\n\t\t[SIGEV_SIGNAL] = \"signal\",\n\t\t[SIGEV_NONE] = \"none\",\n\t\t[SIGEV_THREAD] = \"thread\",\n\t};\n\n\ttimer = list_entry((struct list_head *)v, struct k_itimer, list);\n\tnotify = timer->it_sigev_notify;\n\n\tseq_printf(m, \"ID: %d\\n\", timer->it_id);\n\tseq_printf(m, \"signal: %d/%p\\n\", timer->sigq->info.si_signo,\n\t\t\ttimer->sigq->info.si_value.sival_ptr);\n\tseq_printf(m, \"notify: %s/%s.%d\\n\",\n\t\tnstr[notify & ~SIGEV_THREAD_ID],\n\t\t(notify & SIGEV_THREAD_ID) ? \"tid\" : \"pid\",\n\t\tpid_nr_ns(timer->it_pid, tp->ns));\n\tseq_printf(m, \"ClockID: %d\\n\", timer->it_clock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"ClockID: %d\\n\"",
            "timer->it_clock"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_nr_ns",
          "args": [
            "timer->it_pid",
            "tp->ns"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "(struct list_head *)v",
            "structk_itimer",
            "list"
          ],
          "line": 2001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int show_timer(struct seq_file *m, void *v)\n{\n\tstruct k_itimer *timer;\n\tstruct timers_private *tp = m->private;\n\tint notify;\n\tstatic const char * const nstr[] = {\n\t\t[SIGEV_SIGNAL] = \"signal\",\n\t\t[SIGEV_NONE] = \"none\",\n\t\t[SIGEV_THREAD] = \"thread\",\n\t};\n\n\ttimer = list_entry((struct list_head *)v, struct k_itimer, list);\n\tnotify = timer->it_sigev_notify;\n\n\tseq_printf(m, \"ID: %d\\n\", timer->it_id);\n\tseq_printf(m, \"signal: %d/%p\\n\", timer->sigq->info.si_signo,\n\t\t\ttimer->sigq->info.si_value.sival_ptr);\n\tseq_printf(m, \"notify: %s/%s.%d\\n\",\n\t\tnstr[notify & ~SIGEV_THREAD_ID],\n\t\t(notify & SIGEV_THREAD_ID) ? \"tid\" : \"pid\",\n\t\tpid_nr_ns(timer->it_pid, tp->ns));\n\tseq_printf(m, \"ClockID: %d\\n\", timer->it_clock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "timers_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1975-1988",
    "snippet": "static void timers_stop(struct seq_file *m, void *v)\n{\n\tstruct timers_private *tp = m->private;\n\n\tif (tp->sighand) {\n\t\tunlock_task_sighand(tp->task, &tp->flags);\n\t\ttp->sighand = NULL;\n\t}\n\n\tif (tp->task) {\n\t\tput_task_struct(tp->task);\n\t\ttp->task = NULL;\n\t}\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tp->task"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "tp->task",
            "&tp->flags"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void timers_stop(struct seq_file *m, void *v)\n{\n\tstruct timers_private *tp = m->private;\n\n\tif (tp->sighand) {\n\t\tunlock_task_sighand(tp->task, &tp->flags);\n\t\ttp->sighand = NULL;\n\t}\n\n\tif (tp->task) {\n\t\tput_task_struct(tp->task);\n\t\ttp->task = NULL;\n\t}\n}"
  },
  {
    "function_name": "timers_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1969-1973",
    "snippet": "static void *timers_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\treturn seq_list_next(v, &tp->task->signal->posix_timers, pos);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&tp->task->signal->posix_timers",
            "pos"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "779-786",
          "snippet": "struct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_next(void *v, struct list_head *head, loff_t *ppos)\n{\n\tstruct list_head *lh;\n\n\tlh = ((struct list_head *)v)->next;\n\t++*ppos;\n\treturn lh == head ? NULL : lh;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void *timers_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\treturn seq_list_next(v, &tp->task->signal->posix_timers, pos);\n}"
  },
  {
    "function_name": "timers_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1954-1967",
    "snippet": "static void *timers_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\n\ttp->task = get_pid_task(tp->pid, PIDTYPE_PID);\n\tif (!tp->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\ttp->sighand = lock_task_sighand(tp->task, &tp->flags);\n\tif (!tp->sighand)\n\t\treturn ERR_PTR(-ESRCH);\n\n\treturn seq_list_start(&tp->task->signal->posix_timers, *pos);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&tp->task->signal->posix_timers",
            "*pos"
          ],
          "line": 1966
        },
        "resolved": true,
        "details": {
          "function_name": "seq_list_start_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "770-776",
          "snippet": "struct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstruct list_head *seq_list_start_head(struct list_head *head, loff_t pos)\n{\n\tif (!pos)\n\t\treturn head;\n\n\treturn seq_list_start(head, pos - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESRCH"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "tp->task",
            "&tp->flags"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESRCH"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid_task",
          "args": [
            "tp->pid",
            "PIDTYPE_PID"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void *timers_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct timers_private *tp = m->private;\n\n\ttp->task = get_pid_task(tp->pid, PIDTYPE_PID);\n\tif (!tp->task)\n\t\treturn ERR_PTR(-ESRCH);\n\n\ttp->sighand = lock_task_sighand(tp->task, &tp->flags);\n\tif (!tp->sighand)\n\t\treturn ERR_PTR(-ESRCH);\n\n\treturn seq_list_start(&tp->task->signal->posix_timers, *pos);\n}"
  },
  {
    "function_name": "proc_map_files_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1840-1938",
    "snippet": "static int\nproc_map_files_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned long nr_files, pos, i;\n\tstruct flex_array *fa = NULL;\n\tstruct map_files_info info;\n\tstruct map_files_info *p;\n\tint ret;\n\n\tret = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -ENOENT;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\tgoto out_put_task;\n\n\tret = 0;\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\tdown_read(&mm->mmap_sem);\n\n\tnr_files = 0;\n\n\t/*\n\t * We need two passes here:\n\t *\n\t *  1) Collect vmas of mapped files with mmap_sem taken\n\t *  2) Release mmap_sem and instantiate entries\n\t *\n\t * otherwise we get lockdep complained, since filldir()\n\t * routine might require mmap_sem taken in might_fault().\n\t */\n\n\tfor (vma = mm->mmap, pos = 2; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_file && ++pos > ctx->pos)\n\t\t\tnr_files++;\n\t}\n\n\tif (nr_files) {\n\t\tfa = flex_array_alloc(sizeof(info), nr_files,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!fa || flex_array_prealloc(fa, 0, nr_files,\n\t\t\t\t\t\tGFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tif (fa)\n\t\t\t\tflex_array_free(fa);\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\tmmput(mm);\n\t\t\tgoto out_put_task;\n\t\t}\n\t\tfor (i = 0, vma = mm->mmap, pos = 2; vma;\n\t\t\t\tvma = vma->vm_next) {\n\t\t\tif (!vma->vm_file)\n\t\t\t\tcontinue;\n\t\t\tif (++pos <= ctx->pos)\n\t\t\t\tcontinue;\n\n\t\t\tinfo.mode = vma->vm_file->f_mode;\n\t\t\tinfo.len = snprintf(info.name,\n\t\t\t\t\tsizeof(info.name), \"%lx-%lx\",\n\t\t\t\t\tvma->vm_start, vma->vm_end);\n\t\t\tif (flex_array_put(fa, i++, &info, GFP_KERNEL))\n\t\t\t\tBUG();\n\t\t}\n\t}\n\tup_read(&mm->mmap_sem);\n\n\tfor (i = 0; i < nr_files; i++) {\n\t\tp = flex_array_get(fa, i);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t      p->name, p->len,\n\t\t\t\t      proc_map_files_instantiate,\n\t\t\t\t      task,\n\t\t\t\t      (void *)(unsigned long)p->mode))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\n\tif (fa)\n\t\tflex_array_free(fa);\n\tmmput(mm);\n\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_free",
          "args": [
            "fa"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_fill_cache",
          "args": [
            "file",
            "ctx",
            "p->name",
            "p->len",
            "proc_map_files_instantiate",
            "task",
            "(void *)(unsigned long)p->mode"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fill_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1605-1633",
          "snippet": "bool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flex_array_get",
          "args": [
            "fa",
            "i"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put",
          "args": [
            "fa",
            "i++",
            "&info",
            "GFP_KERNEL"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "info.name",
            "sizeof(info.name)",
            "\"%lx-%lx\"",
            "vma->vm_start",
            "vma->vm_end"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_free",
          "args": [
            "fa"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_prealloc",
          "args": [
            "fa",
            "0",
            "nr_files",
            "GFP_KERNEL"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_alloc",
          "args": [
            "sizeof(info)",
            "nr_files",
            "GFP_KERNEL"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit_dots",
          "args": [
            "file",
            "ctx"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1857
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int\nproc_map_files_readdir(struct file *file, struct dir_context *ctx)\n{\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tunsigned long nr_files, pos, i;\n\tstruct flex_array *fa = NULL;\n\tstruct map_files_info info;\n\tstruct map_files_info *p;\n\tint ret;\n\n\tret = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tret = -ENOENT;\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\tgoto out;\n\n\tret = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\tgoto out_put_task;\n\n\tret = 0;\n\tif (!dir_emit_dots(file, ctx))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\tdown_read(&mm->mmap_sem);\n\n\tnr_files = 0;\n\n\t/*\n\t * We need two passes here:\n\t *\n\t *  1) Collect vmas of mapped files with mmap_sem taken\n\t *  2) Release mmap_sem and instantiate entries\n\t *\n\t * otherwise we get lockdep complained, since filldir()\n\t * routine might require mmap_sem taken in might_fault().\n\t */\n\n\tfor (vma = mm->mmap, pos = 2; vma; vma = vma->vm_next) {\n\t\tif (vma->vm_file && ++pos > ctx->pos)\n\t\t\tnr_files++;\n\t}\n\n\tif (nr_files) {\n\t\tfa = flex_array_alloc(sizeof(info), nr_files,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!fa || flex_array_prealloc(fa, 0, nr_files,\n\t\t\t\t\t\tGFP_KERNEL)) {\n\t\t\tret = -ENOMEM;\n\t\t\tif (fa)\n\t\t\t\tflex_array_free(fa);\n\t\t\tup_read(&mm->mmap_sem);\n\t\t\tmmput(mm);\n\t\t\tgoto out_put_task;\n\t\t}\n\t\tfor (i = 0, vma = mm->mmap, pos = 2; vma;\n\t\t\t\tvma = vma->vm_next) {\n\t\t\tif (!vma->vm_file)\n\t\t\t\tcontinue;\n\t\t\tif (++pos <= ctx->pos)\n\t\t\t\tcontinue;\n\n\t\t\tinfo.mode = vma->vm_file->f_mode;\n\t\t\tinfo.len = snprintf(info.name,\n\t\t\t\t\tsizeof(info.name), \"%lx-%lx\",\n\t\t\t\t\tvma->vm_start, vma->vm_end);\n\t\t\tif (flex_array_put(fa, i++, &info, GFP_KERNEL))\n\t\t\t\tBUG();\n\t\t}\n\t}\n\tup_read(&mm->mmap_sem);\n\n\tfor (i = 0; i < nr_files; i++) {\n\t\tp = flex_array_get(fa, i);\n\t\tif (!proc_fill_cache(file, ctx,\n\t\t\t\t      p->name, p->len,\n\t\t\t\t      proc_map_files_instantiate,\n\t\t\t\t      task,\n\t\t\t\t      (void *)(unsigned long)p->mode))\n\t\t\tbreak;\n\t\tctx->pos++;\n\t}\n\tif (fa)\n\t\tflex_array_free(fa);\n\tmmput(mm);\n\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_map_files_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1786-1832",
    "snippet": "static struct dentry *proc_map_files_lookup(struct inode *dir,\n\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tint result;\n\tstruct mm_struct *mm;\n\n\tresult = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tresult = -ENOENT;\n\ttask = get_proc_task(dir);\n\tif (!task)\n\t\tgoto out;\n\n\tresult = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\tgoto out_put_task;\n\n\tresult = -ENOENT;\n\tif (dname_to_vma_addr(dentry, &vm_start, &vm_end))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (!vma)\n\t\tgoto out_no_vma;\n\n\tif (vma->vm_file)\n\t\tresult = proc_map_files_instantiate(dir, dentry, task,\n\t\t\t\t(void *)(unsigned long)vma->vm_file->f_mode);\n\nout_no_vma:\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "result"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_map_files_instantiate",
          "args": [
            "dir",
            "dentry",
            "task",
            "(void *)(unsigned long)vma->vm_file->f_mode"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "proc_map_files_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1756-1784",
          "snippet": "static int\nproc_map_files_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tfmode_t mode = (fmode_t)(unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tei = PROC_I(inode);\n\tei->op.proc_get_link = proc_map_files_get_link;\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\tinode->i_mode = S_IFLNK;\n\n\tif (mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR;\n\tif (mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR;\n\n\td_set_d_op(dentry, &tid_map_files_dentry_operations);\n\td_add(dentry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.follow_link\t= proc_pid_follow_link,\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.follow_link\t= proc_pid_follow_link,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int\nproc_map_files_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tfmode_t mode = (fmode_t)(unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tei = PROC_I(inode);\n\tei->op.proc_get_link = proc_map_files_get_link;\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\tinode->i_mode = S_IFLNK;\n\n\tif (mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR;\n\tif (mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR;\n\n\td_set_d_op(dentry, &tid_map_files_dentry_operations);\n\td_add(dentry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_exact_vma",
          "args": [
            "mm",
            "vm_start",
            "vm_end"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname_to_vma_addr",
          "args": [
            "dentry",
            "&vm_start",
            "&vm_end"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "dname_to_vma_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1641-1648",
          "snippet": "static int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dir"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic struct dentry *proc_map_files_lookup(struct inode *dir,\n\t\tstruct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tint result;\n\tstruct mm_struct *mm;\n\n\tresult = -EPERM;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tgoto out;\n\n\tresult = -ENOENT;\n\ttask = get_proc_task(dir);\n\tif (!task)\n\t\tgoto out;\n\n\tresult = -EACCES;\n\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\tgoto out_put_task;\n\n\tresult = -ENOENT;\n\tif (dname_to_vma_addr(dentry, &vm_start, &vm_end))\n\t\tgoto out_put_task;\n\n\tmm = get_task_mm(task);\n\tif (!mm)\n\t\tgoto out_put_task;\n\n\tdown_read(&mm->mmap_sem);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (!vma)\n\t\tgoto out_no_vma;\n\n\tif (vma->vm_file)\n\t\tresult = proc_map_files_instantiate(dir, dentry, task,\n\t\t\t\t(void *)(unsigned long)vma->vm_file->f_mode);\n\nout_no_vma:\n\tup_read(&mm->mmap_sem);\n\tmmput(mm);\nout_put_task:\n\tput_task_struct(task);\nout:\n\treturn ERR_PTR(result);\n}"
  },
  {
    "function_name": "proc_map_files_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1756-1784",
    "snippet": "static int\nproc_map_files_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tfmode_t mode = (fmode_t)(unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tei = PROC_I(inode);\n\tei->op.proc_get_link = proc_map_files_get_link;\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\tinode->i_mode = S_IFLNK;\n\n\tif (mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR;\n\tif (mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR;\n\n\td_set_d_op(dentry, &tid_map_files_dentry_operations);\n\td_add(dentry, inode);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.follow_link\t= proc_pid_follow_link,\n\t.setattr\t= proc_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_set_d_op",
          "args": [
            "dentry",
            "&tid_map_files_dentry_operations"
          ],
          "line": 1780
        },
        "resolved": true,
        "details": {
          "function_name": "d_set_d_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1635-1659",
          "snippet": "void d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_set_d_op(struct dentry *dentry, const struct dentry_operations *op)\n{\n\tWARN_ON_ONCE(dentry->d_op);\n\tWARN_ON_ONCE(dentry->d_flags & (DCACHE_OP_HASH\t|\n\t\t\t\tDCACHE_OP_COMPARE\t|\n\t\t\t\tDCACHE_OP_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_WEAK_REVALIDATE\t|\n\t\t\t\tDCACHE_OP_DELETE ));\n\tdentry->d_op = op;\n\tif (!op)\n\t\treturn;\n\tif (op->d_hash)\n\t\tdentry->d_flags |= DCACHE_OP_HASH;\n\tif (op->d_compare)\n\t\tdentry->d_flags |= DCACHE_OP_COMPARE;\n\tif (op->d_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_REVALIDATE;\n\tif (op->d_weak_revalidate)\n\t\tdentry->d_flags |= DCACHE_OP_WEAK_REVALIDATE;\n\tif (op->d_delete)\n\t\tdentry->d_flags |= DCACHE_OP_DELETE;\n\tif (op->d_prune)\n\t\tdentry->d_flags |= DCACHE_OP_PRUNE;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_pid_make_inode",
          "args": [
            "dir->i_sb",
            "task"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid_make_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1447-1487",
          "snippet": "struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct inode_operations proc_pid_link_inode_operations = {\n\t.readlink\t= proc_pid_readlink,\n\t.follow_link\t= proc_pid_follow_link,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int\nproc_map_files_instantiate(struct inode *dir, struct dentry *dentry,\n\t\t\t   struct task_struct *task, const void *ptr)\n{\n\tfmode_t mode = (fmode_t)(unsigned long)ptr;\n\tstruct proc_inode *ei;\n\tstruct inode *inode;\n\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\tei = PROC_I(inode);\n\tei->op.proc_get_link = proc_map_files_get_link;\n\n\tinode->i_op = &proc_pid_link_inode_operations;\n\tinode->i_size = 64;\n\tinode->i_mode = S_IFLNK;\n\n\tif (mode & FMODE_READ)\n\t\tinode->i_mode |= S_IRUSR;\n\tif (mode & FMODE_WRITE)\n\t\tinode->i_mode |= S_IWUSR;\n\n\td_set_d_op(dentry, &tid_map_files_dentry_operations);\n\td_add(dentry, inode);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_map_files_get_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1712-1748",
    "snippet": "static int proc_map_files_get_link(struct dentry *dentry, struct path *path)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint rc;\n\n\trc = -ENOENT;\n\ttask = get_proc_task(dentry->d_inode);\n\tif (!task)\n\t\tgoto out;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\tgoto out;\n\n\trc = dname_to_vma_addr(dentry, &vm_start, &vm_end);\n\tif (rc)\n\t\tgoto out_mmput;\n\n\trc = -ENOENT;\n\tdown_read(&mm->mmap_sem);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (vma && vma->vm_file) {\n\t\t*path = vma->vm_file->f_path;\n\t\tpath_get(path);\n\t\trc = 0;\n\t}\n\tup_read(&mm->mmap_sem);\n\nout_mmput:\n\tmmput(mm);\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "path"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_exact_vma",
          "args": [
            "mm",
            "vm_start",
            "vm_end"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname_to_vma_addr",
          "args": [
            "dentry",
            "&vm_start",
            "&vm_end"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "dname_to_vma_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1641-1648",
          "snippet": "static int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_map_files_get_link(struct dentry *dentry, struct path *path)\n{\n\tunsigned long vm_start, vm_end;\n\tstruct vm_area_struct *vma;\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tint rc;\n\n\trc = -ENOENT;\n\ttask = get_proc_task(dentry->d_inode);\n\tif (!task)\n\t\tgoto out;\n\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\tgoto out;\n\n\trc = dname_to_vma_addr(dentry, &vm_start, &vm_end);\n\tif (rc)\n\t\tgoto out_mmput;\n\n\trc = -ENOENT;\n\tdown_read(&mm->mmap_sem);\n\tvma = find_exact_vma(mm, vm_start, vm_end);\n\tif (vma && vma->vm_file) {\n\t\t*path = vma->vm_file->f_path;\n\t\tpath_get(path);\n\t\trc = 0;\n\t}\n\tup_read(&mm->mmap_sem);\n\nout_mmput:\n\tmmput(mm);\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "map_files_d_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1650-1705",
    "snippet": "static int map_files_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tbool exact_vma_exists = false;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint status = 0;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_notask;\n\t}\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_notask;\n\n\tmm = mm_access(task, PTRACE_MODE_READ);\n\tif (IS_ERR_OR_NULL(mm))\n\t\tgoto out;\n\n\tif (!dname_to_vma_addr(dentry, &vm_start, &vm_end)) {\n\t\tdown_read(&mm->mmap_sem);\n\t\texact_vma_exists = !!find_exact_vma(mm, vm_start, vm_end);\n\t\tup_read(&mm->mmap_sem);\n\t}\n\n\tmmput(mm);\n\n\tif (exact_vma_exists) {\n\t\tif (task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tsecurity_task_to_inode(task, inode);\n\t\tstatus = 1;\n\t}\n\nout:\n\tput_task_struct(task);\n\nout_notask:\n\treturn status;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_to_inode",
          "args": [
            "task",
            "inode"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "task"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dumpable",
          "args": [
            "task"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "task_dumpable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "100-113",
          "snippet": "static inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);",
            "extern unsigned long task_vsize(struct mm_struct *);",
            "extern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);",
            "extern void task_mem(struct seq_file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\nextern unsigned long task_vsize(struct mm_struct *);\nextern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);\nextern void task_mem(struct seq_file *, struct mm_struct *);\n\nstatic inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_exact_vma",
          "args": [
            "mm",
            "vm_start",
            "vm_end"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dname_to_vma_addr",
          "args": [
            "dentry",
            "&vm_start",
            "&vm_end"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "dname_to_vma_addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1641-1648",
          "snippet": "static int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "mm"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int map_files_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tunsigned long vm_start, vm_end;\n\tbool exact_vma_exists = false;\n\tstruct mm_struct *mm = NULL;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct inode *inode;\n\tint status = 0;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tstatus = -EPERM;\n\t\tgoto out_notask;\n\t}\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\tgoto out_notask;\n\n\tmm = mm_access(task, PTRACE_MODE_READ);\n\tif (IS_ERR_OR_NULL(mm))\n\t\tgoto out;\n\n\tif (!dname_to_vma_addr(dentry, &vm_start, &vm_end)) {\n\t\tdown_read(&mm->mmap_sem);\n\t\texact_vma_exists = !!find_exact_vma(mm, vm_start, vm_end);\n\t\tup_read(&mm->mmap_sem);\n\t}\n\n\tmmput(mm);\n\n\tif (exact_vma_exists) {\n\t\tif (task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tsecurity_task_to_inode(task, inode);\n\t\tstatus = 1;\n\t}\n\nout:\n\tput_task_struct(task);\n\nout_notask:\n\treturn status;\n}"
  },
  {
    "function_name": "dname_to_vma_addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1641-1648",
    "snippet": "static int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "dentry->d_name.name",
            "\"%lx-%lx\"",
            "start",
            "end"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int dname_to_vma_addr(struct dentry *dentry,\n\t\t\t     unsigned long *start, unsigned long *end)\n{\n\tif (sscanf(dentry->d_name.name, \"%lx-%lx\", start, end) != 2)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_fill_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1605-1633",
    "snippet": "bool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "len",
            "1",
            "DT_UNKNOWN"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "name",
            "len",
            "ino",
            "type"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "child"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instantiate",
          "args": [
            "dir->d_inode",
            "child",
            "task",
            "ptr"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "proc_task_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "2999-3023",
          "snippet": "static int proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};",
            "static const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};",
            "static const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};",
            "static const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nconst struct dentry_operations pid_dentry_operations =\n{\n\t.d_revalidate\t= pid_revalidate,\n\t.d_delete\t= pid_delete_dentry,\n};\nstatic const struct pid_entry tid_base_stuff[] = {\n\tDIR(\"fd\",        S_IRUSR|S_IXUSR, proc_fd_inode_operations, proc_fd_operations),\n\tDIR(\"fdinfo\",    S_IRUSR|S_IXUSR, proc_fdinfo_inode_operations, proc_fdinfo_operations),\n\tDIR(\"ns\",\t S_IRUSR|S_IXUGO, proc_ns_dir_inode_operations, proc_ns_dir_operations),\n#ifdef CONFIG_NET\n\tDIR(\"net\",        S_IRUGO|S_IXUGO, proc_net_inode_operations, proc_net_operations),\n#endif\n\tREG(\"environ\",   S_IRUSR, proc_environ_operations),\n\tONE(\"auxv\",      S_IRUSR, proc_pid_auxv),\n\tONE(\"status\",    S_IRUGO, proc_pid_status),\n\tONE(\"personality\", S_IRUSR, proc_pid_personality),\n\tONE(\"limits\",\t S_IRUGO, proc_pid_limits),\n#ifdef CONFIG_SCHED_DEBUG\n\tREG(\"sched\",     S_IRUGO|S_IWUSR, proc_pid_sched_operations),\n#endif\n\tREG(\"comm\",      S_IRUGO|S_IWUSR, proc_pid_set_comm_operations),\n#ifdef CONFIG_HAVE_ARCH_TRACEHOOK\n\tONE(\"syscall\",   S_IRUSR, proc_pid_syscall),\n#endif\n\tONE(\"cmdline\",   S_IRUGO, proc_pid_cmdline),\n\tONE(\"stat\",      S_IRUGO, proc_tid_stat),\n\tONE(\"statm\",     S_IRUGO, proc_pid_statm),\n\tREG(\"maps\",      S_IRUGO, proc_tid_maps_operations),\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tREG(\"children\",  S_IRUGO, proc_tid_children_operations),\n#endif\n#ifdef CONFIG_NUMA\n\tREG(\"numa_maps\", S_IRUGO, proc_tid_numa_maps_operations),\n#endif\n\tREG(\"mem\",       S_IRUSR|S_IWUSR, proc_mem_operations),\n\tLNK(\"cwd\",       proc_cwd_link),\n\tLNK(\"root\",      proc_root_link),\n\tLNK(\"exe\",       proc_exe_link),\n\tREG(\"mounts\",    S_IRUGO, proc_mounts_operations),\n\tREG(\"mountinfo\",  S_IRUGO, proc_mountinfo_operations),\n#ifdef CONFIG_PROC_PAGE_MONITOR\n\tREG(\"clear_refs\", S_IWUSR, proc_clear_refs_operations),\n\tREG(\"smaps\",     S_IRUGO, proc_tid_smaps_operations),\n\tREG(\"pagemap\",    S_IRUSR, proc_pagemap_operations),\n#endif\n#ifdef CONFIG_SECURITY\n\tDIR(\"attr\",      S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),\n#endif\n#ifdef CONFIG_KALLSYMS\n\tONE(\"wchan\",     S_IRUGO, proc_pid_wchan),\n#endif\n#ifdef CONFIG_STACKTRACE\n\tONE(\"stack\",      S_IRUSR, proc_pid_stack),\n#endif\n#ifdef CONFIG_SCHEDSTATS\n\tONE(\"schedstat\", S_IRUGO, proc_pid_schedstat),\n#endif\n#ifdef CONFIG_LATENCYTOP\n\tREG(\"latency\",  S_IRUGO, proc_lstats_operations),\n#endif\n#ifdef CONFIG_PROC_PID_CPUSET\n\tONE(\"cpuset\",    S_IRUGO, proc_cpuset_show),\n#endif\n#ifdef CONFIG_CGROUPS\n\tONE(\"cgroup\",  S_IRUGO, proc_cgroup_show),\n#endif\n\tONE(\"oom_score\", S_IRUGO, proc_oom_score),\n\tREG(\"oom_adj\",   S_IRUGO|S_IWUSR, proc_oom_adj_operations),\n\tREG(\"oom_score_adj\", S_IRUGO|S_IWUSR, proc_oom_score_adj_operations),\n#ifdef CONFIG_AUDITSYSCALL\n\tREG(\"loginuid\",  S_IWUSR|S_IRUGO, proc_loginuid_operations),\n\tREG(\"sessionid\",  S_IRUGO, proc_sessionid_operations),\n#endif\n#ifdef CONFIG_FAULT_INJECTION\n\tREG(\"make-it-fail\", S_IRUGO|S_IWUSR, proc_fault_inject_operations),\n#endif\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tONE(\"io\",\tS_IRUSR, proc_tid_io_accounting),\n#endif\n#ifdef CONFIG_HARDWALL\n\tONE(\"hardwall\",   S_IRUGO, proc_pid_hardwall),\n#endif\n#ifdef CONFIG_USER_NS\n\tREG(\"uid_map\",    S_IRUGO|S_IWUSR, proc_uid_map_operations),\n\tREG(\"gid_map\",    S_IRUGO|S_IWUSR, proc_gid_map_operations),\n\tREG(\"projid_map\", S_IRUGO|S_IWUSR, proc_projid_map_operations),\n\tREG(\"setgroups\",  S_IRUGO|S_IWUSR, proc_setgroups_operations),\n#endif\n};\nstatic const struct file_operations proc_tid_base_operations = {\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= proc_tid_base_readdir,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct inode_operations proc_tid_base_inode_operations = {\n\t.lookup\t\t= proc_tid_base_lookup,\n\t.getattr\t= pid_getattr,\n\t.setattr\t= proc_setattr,\n};\n\nstatic int proc_task_instantiate(struct inode *dir,\n\tstruct dentry *dentry, struct task_struct *task, const void *ptr)\n{\n\tstruct inode *inode;\n\tinode = proc_pid_make_inode(dir->i_sb, task);\n\n\tif (!inode)\n\t\tgoto out;\n\tinode->i_mode = S_IFDIR|S_IRUGO|S_IXUGO;\n\tinode->i_op = &proc_tid_base_inode_operations;\n\tinode->i_fop = &proc_tid_base_operations;\n\tinode->i_flags|=S_IMMUTABLE;\n\n\tset_nlink(inode, 2 + pid_entry_count_dirs(tid_base_stuff,\n\t\t\t\t\t\t  ARRAY_SIZE(tid_base_stuff)));\n\n\td_set_d_op(dentry, &pid_dentry_operations);\n\n\td_add(dentry, inode);\n\t/* Close the race of the process dying before we return the dentry */\n\tif (pid_revalidate(dentry, 0))\n\t\treturn 0;\nout:\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc",
          "args": [
            "dir",
            "&qname"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_hash_and_lookup",
          "args": [
            "dir",
            "&qname"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "d_hash_and_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2312-2326",
          "snippet": "struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)\n{\n\t/*\n\t * Check for a fs-specific hash function. Note that we must\n\t * calculate the standard hash first, as the d_op->d_hash()\n\t * routine may choose to leave the hash value unchanged.\n\t */\n\tname->hash = full_name_hash(name->name, name->len);\n\tif (dir->d_flags & DCACHE_OP_HASH) {\n\t\tint err = dir->d_op->d_hash(dir, name);\n\t\tif (unlikely(err < 0))\n\t\t\treturn ERR_PTR(err);\n\t}\n\treturn d_lookup(dir, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QSTR_INIT",
          "args": [
            "name",
            "len"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nbool proc_fill_cache(struct file *file, struct dir_context *ctx,\n\tconst char *name, int len,\n\tinstantiate_t instantiate, struct task_struct *task, const void *ptr)\n{\n\tstruct dentry *child, *dir = file->f_path.dentry;\n\tstruct qstr qname = QSTR_INIT(name, len);\n\tstruct inode *inode;\n\tunsigned type;\n\tino_t ino;\n\n\tchild = d_hash_and_lookup(dir, &qname);\n\tif (!child) {\n\t\tchild = d_alloc(dir, &qname);\n\t\tif (!child)\n\t\t\tgoto end_instantiate;\n\t\tif (instantiate(dir->d_inode, child, task, ptr) < 0) {\n\t\t\tdput(child);\n\t\t\tgoto end_instantiate;\n\t\t}\n\t}\n\tinode = child->d_inode;\n\tino = inode->i_ino;\n\ttype = inode->i_mode >> 12;\n\tdput(child);\n\treturn dir_emit(ctx, name, len, ino, type);\n\nend_instantiate:\n\treturn dir_emit(ctx, name, len, 1, DT_UNKNOWN);\n}"
  },
  {
    "function_name": "pid_delete_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1576-1583",
    "snippet": "int pid_delete_dentry(const struct dentry *dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn proc_inode_is_dead(dentry->d_inode);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_inode_is_dead",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "proc_inode_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1571-1574",
          "snippet": "static inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint pid_delete_dentry(const struct dentry *dentry)\n{\n\t/* Is the task we represent dead?\n\t * If so, then don't put the dentry on the lru list,\n\t * kill it immediately.\n\t */\n\treturn proc_inode_is_dead(dentry->d_inode);\n}"
  },
  {
    "function_name": "proc_inode_is_dead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1571-1574",
    "snippet": "static inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic inline bool proc_inode_is_dead(struct inode *inode)\n{\n\treturn !proc_pid(inode)->tasks[PIDTYPE_PID].first;\n}"
  },
  {
    "function_name": "pid_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1539-1569",
    "snippet": "int pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_to_inode",
          "args": [
            "task",
            "inode"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "task"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dumpable",
          "args": [
            "task"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "task_dumpable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "100-113",
          "snippet": "static inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);",
            "extern unsigned long task_vsize(struct mm_struct *);",
            "extern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);",
            "extern void task_mem(struct seq_file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\nextern unsigned long task_vsize(struct mm_struct *);\nextern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);\nextern void task_mem(struct seq_file *, struct mm_struct *);\n\nstatic inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint pid_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct inode *inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tinode = dentry->d_inode;\n\ttask = get_proc_task(inode);\n\n\tif (task) {\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\trcu_read_lock();\n\t\t\tcred = __task_cred(task);\n\t\t\tinode->i_uid = cred->euid;\n\t\t\tinode->i_gid = cred->egid;\n\t\t\trcu_read_unlock();\n\t\t} else {\n\t\t\tinode->i_uid = GLOBAL_ROOT_UID;\n\t\t\tinode->i_gid = GLOBAL_ROOT_GID;\n\t\t}\n\t\tinode->i_mode &= ~(S_ISUID | S_ISGID);\n\t\tsecurity_task_to_inode(task, inode);\n\t\tput_task_struct(task);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "pid_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1489-1520",
    "snippet": "int pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = GLOBAL_ROOT_UID;\n\tstat->gid = GLOBAL_ROOT_GID;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * This doesn't prevent learning whether PID exists,\n\t\t\t * it only makes getattr() consistent with readdir().\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "task"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dumpable",
          "args": [
            "task"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "task_dumpable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "100-113",
          "snippet": "static inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);",
            "extern unsigned long task_vsize(struct mm_struct *);",
            "extern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);",
            "extern void task_mem(struct seq_file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\nextern unsigned long task_vsize(struct mm_struct *);\nextern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);\nextern void task_mem(struct seq_file *, struct mm_struct *);\n\nstatic inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pid_permissions",
          "args": [
            "pid",
            "task",
            "2"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "has_pid_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "526-535",
          "snippet": "static bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "proc_pid(inode)",
            "PIDTYPE_PID"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "inode",
            "stat"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint pid_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct task_struct *task;\n\tconst struct cred *cred;\n\tstruct pid_namespace *pid = dentry->d_sb->s_fs_info;\n\n\tgeneric_fillattr(inode, stat);\n\n\trcu_read_lock();\n\tstat->uid = GLOBAL_ROOT_UID;\n\tstat->gid = GLOBAL_ROOT_GID;\n\ttask = pid_task(proc_pid(inode), PIDTYPE_PID);\n\tif (task) {\n\t\tif (!has_pid_permissions(pid, task, 2)) {\n\t\t\trcu_read_unlock();\n\t\t\t/*\n\t\t\t * This doesn't prevent learning whether PID exists,\n\t\t\t * it only makes getattr() consistent with readdir().\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif ((inode->i_mode == (S_IFDIR|S_IRUGO|S_IXUGO)) ||\n\t\t    task_dumpable(task)) {\n\t\t\tcred = __task_cred(task);\n\t\t\tstat->uid = cred->euid;\n\t\t\tstat->gid = cred->egid;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_pid_make_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1447-1487",
    "snippet": "struct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_to_inode",
          "args": [
            "task",
            "inode"
          ],
          "line": 1479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "task"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_dumpable",
          "args": [
            "task"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "task_dumpable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "100-113",
          "snippet": "static inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);",
            "extern unsigned long task_vsize(struct mm_struct *);",
            "extern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);",
            "extern void task_mem(struct seq_file *, struct mm_struct *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\nextern unsigned long task_vsize(struct mm_struct *);\nextern unsigned long task_statm(struct mm_struct *,\n\t\t\t\tunsigned long *, unsigned long *,\n\t\t\t\tunsigned long *, unsigned long *);\nextern void task_mem(struct seq_file *, struct mm_struct *);\n\nstatic inline int task_dumpable(struct task_struct *task)\n{\n\tint dumpable = 0;\n\tstruct mm_struct *mm;\n\n\ttask_lock(task);\n\tmm = task->mm;\n\tif (mm)\n\t\tdumpable = get_dumpable(mm);\n\ttask_unlock(task);\n\tif (dumpable == SUID_DUMP_USER)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_pid",
          "args": [
            "task",
            "PIDTYPE_PID"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct inode_operations proc_def_inode_operations = {\n\t.setattr\t= proc_setattr,\n};\n\nstruct inode *proc_pid_make_inode(struct super_block * sb, struct task_struct *task)\n{\n\tstruct inode * inode;\n\tstruct proc_inode *ei;\n\tconst struct cred *cred;\n\n\t/* We need a new inode */\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t/* Common stuff */\n\tei = PROC_I(inode);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &proc_def_inode_operations;\n\n\t/*\n\t * grab the reference to task.\n\t */\n\tei->pid = get_task_pid(task, PIDTYPE_PID);\n\tif (!ei->pid)\n\t\tgoto out_unlock;\n\n\tif (task_dumpable(task)) {\n\t\trcu_read_lock();\n\t\tcred = __task_cred(task);\n\t\tinode->i_uid = cred->euid;\n\t\tinode->i_gid = cred->egid;\n\t\trcu_read_unlock();\n\t}\n\tsecurity_task_to_inode(task, inode);\n\nout:\n\treturn inode;\n\nout_unlock:\n\tiput(inode);\n\treturn NULL;\n}"
  },
  {
    "function_name": "proc_pid_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1418-1436",
    "snippet": "static int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path path;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&path"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_proc_readlink",
          "args": [
            "&path",
            "buffer",
            "buflen"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "do_proc_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "1394-1416",
          "snippet": "static int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "dentry",
            "&path"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_fd_access_allowed",
          "args": [
            "inode"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fd_access_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "489-503",
          "snippet": "static int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pid_readlink(struct dentry * dentry, char __user * buffer, int buflen)\n{\n\tint error = -EACCES;\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path path;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\terror = do_proc_readlink(&path, buffer, buflen);\n\tpath_put(&path);\nout:\n\treturn error;\n}"
  },
  {
    "function_name": "do_proc_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1394-1416",
    "snippet": "static int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)tmp"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "pathname",
            "len"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pathname"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "pathname"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_path",
          "args": [
            "path",
            "tmp",
            "PAGE_SIZE"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "append_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1258-1269",
          "snippet": "static char *append_path(const char *path, char *pos, const char *name)\n{\n\tint namelen;\n\tnamelen = strlen(name);\n\tif (((pos - path) + namelen + 2) >= PATH_MAX)\n\t\treturn NULL;\n\tmemcpy(pos, name, namelen);\n\tpos[namelen] = '/';\n\tpos[namelen + 1] = '\\0';\n\tpos += namelen + 1;\n\treturn pos;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nstatic char *append_path(const char *path, char *pos, const char *name)\n{\n\tint namelen;\n\tnamelen = strlen(name);\n\tif (((pos - path) + namelen + 2) >= PATH_MAX)\n\t\treturn NULL;\n\tmemcpy(pos, name, namelen);\n\tpos[namelen] = '/';\n\tpos[namelen + 1] = '\\0';\n\tpos += namelen + 1;\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_TEMPORARY"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int do_proc_readlink(struct path *path, char __user *buffer, int buflen)\n{\n\tchar *tmp = (char*)__get_free_page(GFP_TEMPORARY);\n\tchar *pathname;\n\tint len;\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tpathname = d_path(path, tmp, PAGE_SIZE);\n\tlen = PTR_ERR(pathname);\n\tif (IS_ERR(pathname))\n\t\tgoto out;\n\tlen = tmp + PAGE_SIZE - 1 - pathname;\n\n\tif (len > buflen)\n\t\tlen = buflen;\n\tif (copy_to_user(buffer, pathname, len))\n\t\tlen = -EFAULT;\n out:\n\tfree_page((unsigned long)tmp);\n\treturn len;\n}"
  },
  {
    "function_name": "proc_pid_follow_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1374-1392",
    "snippet": "static void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path path;\n\tint error = -EACCES;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\tnd_jump_link(nd, &path);\n\treturn NULL;\nout:\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nd_jump_link",
          "args": [
            "nd",
            "&path"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "nd_jump_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "708-715",
          "snippet": "void nd_jump_link(struct nameidata *nd, struct path *path)\n{\n\tpath_put(&nd->path);\n\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nvoid nd_jump_link(struct nameidata *nd, struct path *path)\n{\n\tpath_put(&nd->path);\n\n\tnd->path = *path;\n\tnd->inode = nd->path.dentry->d_inode;\n\tnd->flags |= LOOKUP_JUMPED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "dentry",
            "&path"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_fd_access_allowed",
          "args": [
            "inode"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "proc_fd_access_allowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "489-503",
          "snippet": "static int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void *proc_pid_follow_link(struct dentry *dentry, struct nameidata *nd)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tstruct path path;\n\tint error = -EACCES;\n\n\t/* Are we allowed to snoop on the tasks file descriptors? */\n\tif (!proc_fd_access_allowed(inode))\n\t\tgoto out;\n\n\terror = PROC_I(inode)->op.proc_get_link(dentry, &path);\n\tif (error)\n\t\tgoto out;\n\n\tnd_jump_link(nd, &path);\n\treturn NULL;\nout:\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "proc_exe_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1350-1372",
    "snippet": "static int proc_exe_link(struct dentry *dentry, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(dentry->d_inode);\n\tif (!task)\n\t\treturn -ENOENT;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -ENOENT;\n\texe_file = get_mm_exe_file(mm);\n\tmmput(mm);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "exe_file"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "&exe_file->f_path"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "path_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "476-480",
          "snippet": "void path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_get(const struct path *path)\n{\n\tmntget(path->mnt);\n\tdget(path->dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mm_exe_file",
          "args": [
            "mm"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_mm",
          "args": [
            "task"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_exe_link(struct dentry *dentry, struct path *exe_path)\n{\n\tstruct task_struct *task;\n\tstruct mm_struct *mm;\n\tstruct file *exe_file;\n\n\ttask = get_proc_task(dentry->d_inode);\n\tif (!task)\n\t\treturn -ENOENT;\n\tmm = get_task_mm(task);\n\tput_task_struct(task);\n\tif (!mm)\n\t\treturn -ENOENT;\n\texe_file = get_mm_exe_file(mm);\n\tmmput(mm);\n\tif (exe_file) {\n\t\t*exe_path = exe_file->f_path;\n\t\tpath_get(&exe_file->f_path);\n\t\tfput(exe_file);\n\t\treturn 0;\n\t} else\n\t\treturn -ENOENT;\n}"
  },
  {
    "function_name": "comm_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1337-1340",
    "snippet": "static int comm_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, comm_show, inode);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "filp",
            "comm_show",
            "inode"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "single_open_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "63-84",
          "snippet": "int single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int comm_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, comm_show, inode);\n}"
  },
  {
    "function_name": "comm_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1319-1335",
    "snippet": "static int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\ttask_lock(p);\n\tseq_printf(m, \"%s\\n\", p->comm);\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "p"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\n\"",
            "p->comm"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "p"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int comm_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\ttask_lock(p);\n\tseq_printf(m, \"%s\\n\", p->comm);\n\ttask_unlock(p);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "comm_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1293-1317",
    "snippet": "static ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\tconst size_t maxlen = sizeof(buffer) - 1;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (copy_from_user(buffer, buf, count > maxlen ? maxlen : count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p))\n\t\tset_task_comm(p, buffer);\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_task_comm",
          "args": [
            "p",
            "buffer"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "current",
            "p"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buffer",
            "buf",
            "count > maxlen ? maxlen : count"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t comm_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[TASK_COMM_LEN];\n\tconst size_t maxlen = sizeof(buffer) - 1;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (copy_from_user(buffer, buf, count > maxlen ? maxlen : count))\n\t\treturn -EFAULT;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\tif (same_thread_group(current, p))\n\t\tset_task_comm(p, buffer);\n\telse\n\t\tcount = -EINVAL;\n\n\tput_task_struct(p);\n\n\treturn count;\n}"
  },
  {
    "function_name": "sched_autogroup_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1270-1281",
    "snippet": "static int sched_autogroup_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_autogroup_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "filp",
            "sched_autogroup_show",
            "NULL"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "single_open_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "63-84",
          "snippet": "int single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int sched_autogroup_open(struct inode *inode, struct file *filp)\n{\n\tint ret;\n\n\tret = single_open(filp, sched_autogroup_show, NULL);\n\tif (!ret) {\n\t\tstruct seq_file *m = filp->private_data;\n\n\t\tm->private = inode;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sched_autogroup_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1237-1268",
    "snippet": "static ssize_t\nsched_autogroup_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[PROC_NUMBUF];\n\tint nice;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = kstrtoint(strstrip(buffer), 0, &nice);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\terr = proc_sched_autogroup_set_nice(p, nice);\n\tif (err)\n\t\tcount = err;\n\n\tput_task_struct(p);\n\n\treturn count;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_sched_autogroup_set_nice",
          "args": [
            "p",
            "nice"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "strstrip(buffer)",
            "0",
            "&nice"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buffer"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buffer",
            "buf",
            "count"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1241
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t\nsched_autogroup_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\tchar buffer[PROC_NUMBUF];\n\tint nice;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\n\terr = kstrtoint(strstrip(buffer), 0, &nice);\n\tif (err < 0)\n\t\treturn err;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\n\terr = proc_sched_autogroup_set_nice(p, nice);\n\tif (err)\n\t\tcount = err;\n\n\tput_task_struct(p);\n\n\treturn count;\n}"
  },
  {
    "function_name": "sched_autogroup_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1222-1235",
    "snippet": "static int sched_autogroup_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_autogroup_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_sched_autogroup_show_task",
          "args": [
            "p",
            "m"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int sched_autogroup_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_autogroup_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1203-1206",
    "snippet": "static int sched_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_show, inode);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "filp",
            "sched_show",
            "inode"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "single_open_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "63-84",
          "snippet": "int single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int sched_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, sched_show, inode);\n}"
  },
  {
    "function_name": "sched_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1186-1201",
    "snippet": "static ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_sched_set_task",
          "args": [
            "p"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t\nsched_write(struct file *file, const char __user *buf,\n\t    size_t count, loff_t *offset)\n{\n\tstruct inode *inode = file_inode(file);\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_set_task(p);\n\n\tput_task_struct(p);\n\n\treturn count;\n}"
  },
  {
    "function_name": "sched_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1171-1184",
    "snippet": "static int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_sched_show_task",
          "args": [
            "p",
            "m"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int sched_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct task_struct *p;\n\n\tp = get_proc_task(inode);\n\tif (!p)\n\t\treturn -ESRCH;\n\tproc_sched_show_task(p, m);\n\n\tput_task_struct(p);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_fault_inject_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1130-1157",
    "snippet": "static ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF], *end;\n\tint make_it_fail;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\tmake_it_fail = simple_strtol(strstrip(buffer), &end, 0);\n\tif (*end)\n\t\treturn -EINVAL;\n\tif (make_it_fail < 0 || make_it_fail > 1)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "strstrip(buffer)",
            "&end",
            "0"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buffer"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buffer",
            "buf",
            "count"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t proc_fault_inject_write(struct file * file,\n\t\t\tconst char __user * buf, size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF], *end;\n\tint make_it_fail;\n\n\tif (!capable(CAP_SYS_RESOURCE))\n\t\treturn -EPERM;\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\tmake_it_fail = simple_strtol(strstrip(buffer), &end, 0);\n\tif (*end)\n\t\treturn -EINVAL;\n\tif (make_it_fail < 0 || make_it_fail > 1)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\ttask->make_it_fail = make_it_fail;\n\tput_task_struct(task);\n\n\treturn count;\n}"
  },
  {
    "function_name": "proc_fault_inject_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1112-1128",
    "snippet": "static ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "buffer",
            "len"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%i\\n\"",
            "make_it_fail"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1115
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t proc_fault_inject_read(struct file * file, char __user * buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tsize_t len;\n\tint make_it_fail;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tmake_it_fail = task->make_it_fail;\n\tput_task_struct(task);\n\n\tlen = snprintf(buffer, sizeof(buffer), \"%i\\n\", make_it_fail);\n\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}"
  },
  {
    "function_name": "proc_sessionid_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1089-1103",
    "snippet": "static ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN 21"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%u\"",
            "audit_get_sessionid(task)"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "task"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\n#define TMPBUFLEN 21\n\nstatic ssize_t proc_sessionid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t\taudit_get_sessionid(task));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "proc_loginuid_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1025-1081",
    "snippet": "static ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *page, *tmp;\n\tssize_t length;\n\tuid_t loginuid;\n\tkuid_t kloginuid;\n\n\trcu_read_lock();\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\tif (count >= PAGE_SIZE)\n\t\tcount = PAGE_SIZE - 1;\n\n\tif (*ppos != 0) {\n\t\t/* No partial writes. */\n\t\treturn -EINVAL;\n\t}\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free_page;\n\n\tpage[count] = '\\0';\n\tloginuid = simple_strtoul(page, &tmp, 10);\n\tif (tmp == page) {\n\t\tlength = -EINVAL;\n\t\tgoto out_free_page;\n\n\t}\n\n\t/* is userspace tring to explicitly UNSET the loginuid? */\n\tif (loginuid == AUDIT_UID_UNSET) {\n\t\tkloginuid = INVALID_UID;\n\t} else {\n\t\tkloginuid = make_kuid(file->f_cred->user_ns, loginuid);\n\t\tif (!uid_valid(kloginuid)) {\n\t\t\tlength = -EINVAL;\n\t\t\tgoto out_free_page;\n\t\t}\n\t}\n\n\tlength = audit_set_loginuid(kloginuid);\n\tif (likely(length == 0))\n\t\tlength = count;\n\nout_free_page:\n\tfree_page((unsigned long) page);\n\treturn length;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) page"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "length == 0"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_loginuid",
          "args": [
            "kloginuid"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "kloginuid"
          ],
          "line": 1068
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "file->f_cred->user_ns",
            "loginuid"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "page",
            "&tmp",
            "10"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "page",
            "buf",
            "count"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_TEMPORARY"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "proc_pid(inode)",
            "PIDTYPE_PID"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t proc_loginuid_write(struct file * file, const char __user * buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tchar *page, *tmp;\n\tssize_t length;\n\tuid_t loginuid;\n\tkuid_t kloginuid;\n\n\trcu_read_lock();\n\tif (current != pid_task(proc_pid(inode), PIDTYPE_PID)) {\n\t\trcu_read_unlock();\n\t\treturn -EPERM;\n\t}\n\trcu_read_unlock();\n\n\tif (count >= PAGE_SIZE)\n\t\tcount = PAGE_SIZE - 1;\n\n\tif (*ppos != 0) {\n\t\t/* No partial writes. */\n\t\treturn -EINVAL;\n\t}\n\tpage = (char*)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tlength = -EFAULT;\n\tif (copy_from_user(page, buf, count))\n\t\tgoto out_free_page;\n\n\tpage[count] = '\\0';\n\tloginuid = simple_strtoul(page, &tmp, 10);\n\tif (tmp == page) {\n\t\tlength = -EINVAL;\n\t\tgoto out_free_page;\n\n\t}\n\n\t/* is userspace tring to explicitly UNSET the loginuid? */\n\tif (loginuid == AUDIT_UID_UNSET) {\n\t\tkloginuid = INVALID_UID;\n\t} else {\n\t\tkloginuid = make_kuid(file->f_cred->user_ns, loginuid);\n\t\tif (!uid_valid(kloginuid)) {\n\t\t\tlength = -EINVAL;\n\t\t\tgoto out_free_page;\n\t\t}\n\t}\n\n\tlength = audit_set_loginuid(kloginuid);\n\tif (likely(length == 0))\n\t\tlength = count;\n\nout_free_page:\n\tfree_page((unsigned long) page);\n\treturn length;\n}"
  },
  {
    "function_name": "proc_loginuid_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "1008-1023",
    "snippet": "static ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t   from_kuid(file->f_cred->user_ns,\n\t\t\t\t     audit_get_loginuid(task)));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN 21"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "length"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%u\"",
            "from_kuid(file->f_cred->user_ns,\n\t\t\t\t     audit_get_loginuid(task))"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "file->f_cred->user_ns",
            "audit_get_loginuid(task)"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "task"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\n#define TMPBUFLEN 21\n\nstatic ssize_t proc_loginuid_read(struct file * file, char __user * buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct inode * inode = file_inode(file);\n\tstruct task_struct *task = get_proc_task(inode);\n\tssize_t length;\n\tchar tmpbuf[TMPBUFLEN];\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tlength = scnprintf(tmpbuf, TMPBUFLEN, \"%u\",\n\t\t\t   from_kuid(file->f_cred->user_ns,\n\t\t\t\t     audit_get_loginuid(task)));\n\tput_task_struct(task);\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, length);\n}"
  },
  {
    "function_name": "oom_score_adj_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "937-998",
    "snippet": "static ssize_t oom_score_adj_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tunsigned long flags;\n\tint oom_score_adj;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_score_adj);\n\tif (err)\n\t\tgoto out;\n\tif (oom_score_adj < OOM_SCORE_ADJ_MIN ||\n\t\t\toom_score_adj > OOM_SCORE_ADJ_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\tif ((short)oom_score_adj < task->signal->oom_score_adj_min &&\n\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\ttask->signal->oom_score_adj = (short)oom_score_adj;\n\tif (has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\ttask->signal->oom_score_adj_min = (short)oom_score_adj;\n\ttrace_oom_score_adj_update(task);\n\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_oom_score_adj_update",
          "args": [
            "task"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_capability_noaudit",
          "args": [
            "current",
            "CAP_SYS_RESOURCE"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "strstrip(buffer)",
            "0",
            "&oom_score_adj"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buffer"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buffer",
            "buf",
            "count"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t oom_score_adj_write(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tunsigned long flags;\n\tint oom_score_adj;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_score_adj);\n\tif (err)\n\t\tgoto out;\n\tif (oom_score_adj < OOM_SCORE_ADJ_MIN ||\n\t\t\toom_score_adj > OOM_SCORE_ADJ_MAX) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\tif ((short)oom_score_adj < task->signal->oom_score_adj_min &&\n\t\t\t!capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\ttask->signal->oom_score_adj = (short)oom_score_adj;\n\tif (has_capability_noaudit(current, CAP_SYS_RESOURCE))\n\t\ttask->signal->oom_score_adj_min = (short)oom_score_adj;\n\ttrace_oom_score_adj_update(task);\n\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}"
  },
  {
    "function_name": "oom_score_adj_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "917-935",
    "snippet": "static ssize_t oom_score_adj_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tshort oom_score_adj = OOM_SCORE_ADJ_MIN;\n\tunsigned long flags;\n\tsize_t len;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_score_adj = task->signal->oom_score_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%hd\\n\", oom_score_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "buffer",
            "len"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%hd\\n\"",
            "oom_score_adj"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t oom_score_adj_read(struct file *file, char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tshort oom_score_adj = OOM_SCORE_ADJ_MIN;\n\tunsigned long flags;\n\tsize_t len;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\toom_score_adj = task->signal->oom_score_adj;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%hd\\n\", oom_score_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}"
  },
  {
    "function_name": "oom_adj_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "834-909",
    "snippet": "static ssize_t oom_adj_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj;\n\tunsigned long flags;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_adj);\n\tif (err)\n\t\tgoto out;\n\tif ((oom_adj < OOM_ADJUST_MIN || oom_adj > OOM_ADJUST_MAX) &&\n\t     oom_adj != OOM_DISABLE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\t/*\n\t * Scale /proc/pid/oom_score_adj appropriately ensuring that a maximum\n\t * value is always attainable.\n\t */\n\tif (oom_adj == OOM_ADJUST_MAX)\n\t\toom_adj = OOM_SCORE_ADJ_MAX;\n\telse\n\t\toom_adj = (oom_adj * OOM_SCORE_ADJ_MAX) / -OOM_DISABLE;\n\n\tif (oom_adj < task->signal->oom_score_adj &&\n\t    !capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\t/*\n\t * /proc/pid/oom_adj is provided for legacy purposes, ask users to use\n\t * /proc/pid/oom_score_adj instead.\n\t */\n\tpr_warn_once(\"%s (%d): /proc/%d/oom_adj is deprecated, please use /proc/%d/oom_score_adj instead.\\n\",\n\t\t  current->comm, task_pid_nr(current), task_pid_nr(task),\n\t\t  task_pid_nr(task));\n\n\ttask->signal->oom_score_adj = oom_adj;\n\ttrace_oom_score_adj_update(task);\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_oom_score_adj_update",
          "args": [
            "task"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"%s (%d): /proc/%d/oom_adj is deprecated, please use /proc/%d/oom_score_adj instead.\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "task_pid_nr(task)",
            "task_pid_nr(task)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "task"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "task"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "strstrip(buffer)",
            "0",
            "&oom_adj"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "suffix_kstrtoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_super.c",
          "lines": "140-164",
          "snippet": "STATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/parser.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mempool.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/namei.h>",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_filestream.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_mru_cache.h\"",
            "#include \"xfs_extfree_item.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC int",
            "STATIC int",
            "STATIC int",
            "STATIC void"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/parser.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/writeback.h>\n#include <linux/mempool.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n#include \"xfs_sysfs.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_filestream.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_mru_cache.h\"\n#include \"xfs_extfree_item.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs.h\"\n\nSTATIC int;\nSTATIC int;\nSTATIC int;\nSTATIC void;\n\nSTATIC unsigned long\nsuffix_kstrtoint(char *s, unsigned int base, int *res)\n{\n\tint\tlast, shift_left_factor = 0, _res;\n\tchar\t*value = s;\n\n\tlast = strlen(value) - 1;\n\tif (value[last] == 'K' || value[last] == 'k') {\n\t\tshift_left_factor = 10;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'M' || value[last] == 'm') {\n\t\tshift_left_factor = 20;\n\t\tvalue[last] = '\\0';\n\t}\n\tif (value[last] == 'G' || value[last] == 'g') {\n\t\tshift_left_factor = 30;\n\t\tvalue[last] = '\\0';\n\t}\n\n\tif (kstrtoint(s, base, &_res))\n\t\treturn -EINVAL;\n\t*res = _res << shift_left_factor;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "buffer"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "buffer",
            "buf",
            "count"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buffer",
            "0",
            "sizeof(buffer)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t oom_adj_write(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj;\n\tunsigned long flags;\n\tint err;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\terr = kstrtoint(strstrip(buffer), 0, &oom_adj);\n\tif (err)\n\t\tgoto out;\n\tif ((oom_adj < OOM_ADJUST_MIN || oom_adj > OOM_ADJUST_MAX) &&\n\t     oom_adj != OOM_DISABLE) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task) {\n\t\terr = -ESRCH;\n\t\tgoto out;\n\t}\n\n\ttask_lock(task);\n\tif (!task->mm) {\n\t\terr = -EINVAL;\n\t\tgoto err_task_lock;\n\t}\n\n\tif (!lock_task_sighand(task, &flags)) {\n\t\terr = -ESRCH;\n\t\tgoto err_task_lock;\n\t}\n\n\t/*\n\t * Scale /proc/pid/oom_score_adj appropriately ensuring that a maximum\n\t * value is always attainable.\n\t */\n\tif (oom_adj == OOM_ADJUST_MAX)\n\t\toom_adj = OOM_SCORE_ADJ_MAX;\n\telse\n\t\toom_adj = (oom_adj * OOM_SCORE_ADJ_MAX) / -OOM_DISABLE;\n\n\tif (oom_adj < task->signal->oom_score_adj &&\n\t    !capable(CAP_SYS_RESOURCE)) {\n\t\terr = -EACCES;\n\t\tgoto err_sighand;\n\t}\n\n\t/*\n\t * /proc/pid/oom_adj is provided for legacy purposes, ask users to use\n\t * /proc/pid/oom_score_adj instead.\n\t */\n\tpr_warn_once(\"%s (%d): /proc/%d/oom_adj is deprecated, please use /proc/%d/oom_score_adj instead.\\n\",\n\t\t  current->comm, task_pid_nr(current), task_pid_nr(task),\n\t\t  task_pid_nr(task));\n\n\ttask->signal->oom_score_adj = oom_adj;\n\ttrace_oom_score_adj_update(task);\nerr_sighand:\n\tunlock_task_sighand(task, &flags);\nerr_task_lock:\n\ttask_unlock(task);\n\tput_task_struct(task);\nout:\n\treturn err < 0 ? err : count;\n}"
  },
  {
    "function_name": "oom_adj_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "810-832",
    "snippet": "static ssize_t oom_adj_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj = OOM_ADJUST_MIN;\n\tsize_t len;\n\tunsigned long flags;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MAX)\n\t\t\toom_adj = OOM_ADJUST_MAX;\n\t\telse\n\t\t\toom_adj = (task->signal->oom_score_adj * -OOM_DISABLE) /\n\t\t\t\t  OOM_SCORE_ADJ_MAX;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%d\\n\", oom_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "buffer",
            "len"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "\"%d\\n\"",
            "oom_adj"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t oom_adj_read(struct file *file, char __user *buf, size_t count,\n\t\t\t    loff_t *ppos)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\tchar buffer[PROC_NUMBUF];\n\tint oom_adj = OOM_ADJUST_MIN;\n\tsize_t len;\n\tunsigned long flags;\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tif (lock_task_sighand(task, &flags)) {\n\t\tif (task->signal->oom_score_adj == OOM_SCORE_ADJ_MAX)\n\t\t\toom_adj = OOM_ADJUST_MAX;\n\t\telse\n\t\t\toom_adj = (task->signal->oom_score_adj * -OOM_DISABLE) /\n\t\t\t\t  OOM_SCORE_ADJ_MAX;\n\t\tunlock_task_sighand(task, &flags);\n\t}\n\tput_task_struct(task);\n\tlen = snprintf(buffer, sizeof(buffer), \"%d\\n\", oom_adj);\n\treturn simple_read_from_buffer(buf, count, ppos, buffer, len);\n}"
  },
  {
    "function_name": "environ_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "747-801",
    "snippet": "static ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (mm->env_end - mm->env_start))\n\t\t\tbreak;\n\n\t\tthis_len = mm->env_end - (mm->env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (mm->env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) page"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "page",
            "retval"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_remote_vm",
          "args": [
            "mm",
            "(mm->env_start + src)",
            "page",
            "this_len",
            "0"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_len",
            "this_len"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "meminfo_proc_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/meminfo.c",
          "lines": "217-220",
          "snippet": "static int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/pgtable.h>",
            "#include <asm/page.h>",
            "#include <linux/cma.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/swap.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/quicklist.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mman.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/pgtable.h>\n#include <asm/page.h>\n#include <linux/cma.h>\n#include <linux/vmalloc.h>\n#include <linux/atomic.h>\n#include <linux/vmstat.h>\n#include <linux/swap.h>\n#include <linux/seq_file.h>\n#include <linux/quicklist.h>\n#include <linux/proc_fs.h>\n#include <linux/mmzone.h>\n#include <linux/mman.h>\n#include <linux/hugetlb.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nstatic int meminfo_proc_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, meminfo_proc_show, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "PAGE_SIZE",
            "count"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&mm->mm_users"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_TEMPORARY"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t environ_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *page;\n\tunsigned long src = *ppos;\n\tint ret = 0;\n\tstruct mm_struct *mm = file->private_data;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tret = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\twhile (count > 0) {\n\t\tsize_t this_len, max_len;\n\t\tint retval;\n\n\t\tif (src >= (mm->env_end - mm->env_start))\n\t\t\tbreak;\n\n\t\tthis_len = mm->env_end - (mm->env_start + src);\n\n\t\tmax_len = min_t(size_t, PAGE_SIZE, count);\n\t\tthis_len = min(max_len, this_len);\n\n\t\tretval = access_remote_vm(mm, (mm->env_start + src),\n\t\t\tpage, this_len, 0);\n\n\t\tif (retval <= 0) {\n\t\t\tret = retval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (copy_to_user(buf, page, retval)) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret += retval;\n\t\tsrc += retval;\n\t\tbuf += retval;\n\t\tcount -= retval;\n\t}\n\t*ppos = src;\n\tmmput(mm);\n\nfree:\n\tfree_page((unsigned long) page);\n\treturn ret;\n}"
  },
  {
    "function_name": "environ_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "742-745",
    "snippet": "static int environ_open(struct inode *inode, struct file *file)\n{\n\treturn __mem_open(inode, file, PTRACE_MODE_READ);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mem_open",
          "args": [
            "inode",
            "file",
            "PTRACE_MODE_READ"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "625-634",
          "snippet": "static int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int environ_open(struct inode *inode, struct file *file)\n{\n\treturn __mem_open(inode, file, PTRACE_MODE_READ);\n}"
  },
  {
    "function_name": "mem_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "726-732",
    "snippet": "static int mem_release(struct inode *inode, struct file *file)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tif (mm)\n\t\tmmdrop(mm);\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int mem_release(struct inode *inode, struct file *file)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tif (mm)\n\t\tmmdrop(mm);\n\treturn 0;\n}"
  },
  {
    "function_name": "mem_lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "710-724",
    "snippet": "loff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_successful_syscall_return",
          "args": [],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nloff_t mem_lseek(struct file *file, loff_t offset, int orig)\n{\n\tswitch (orig) {\n\tcase 0:\n\t\tfile->f_pos = offset;\n\t\tbreak;\n\tcase 1:\n\t\tfile->f_pos += offset;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tforce_successful_syscall_return();\n\treturn file->f_pos;\n}"
  },
  {
    "function_name": "mem_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "704-708",
    "snippet": "static ssize_t mem_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, (char __user*)buf, count, ppos, 1);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_rw",
          "args": [
            "file",
            "(char __user*)buf",
            "count",
            "ppos",
            "1"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "mem_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "646-696",
          "snippet": "static ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\twhile (count > 0) {\n\t\tint this_len = min_t(int, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\twhile (count > 0) {\n\t\tint this_len = min_t(int, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t mem_write(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, (char __user*)buf, count, ppos, 1);\n}"
  },
  {
    "function_name": "mem_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "698-702",
    "snippet": "static ssize_t mem_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, buf, count, ppos, 0);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mem_rw",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "0"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "mem_rw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "646-696",
          "snippet": "static ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\twhile (count > 0) {\n\t\tint this_len = min_t(int, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\twhile (count > 0) {\n\t\tint this_len = min_t(int, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t mem_read(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn mem_rw(file, buf, count, ppos, 0);\n}"
  },
  {
    "function_name": "mem_rw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "646-696",
    "snippet": "static ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\twhile (count > 0) {\n\t\tint this_len = min_t(int, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long) page"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_buf_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "238-246",
          "snippet": "STATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nSTATIC void\n_xfs_buf_free_pages(\n\txfs_buf_t\t*bp)\n{\n\tif (bp->b_pages != bp->b_page_array) {\n\t\tkmem_free(bp->b_pages);\n\t\tbp->b_pages = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "page",
            "this_len"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_remote_vm",
          "args": [
            "mm",
            "addr",
            "page",
            "this_len",
            "write"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "page",
            "buf",
            "this_len"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "count",
            "PAGE_SIZE"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&mm->mm_users"
          ],
          "line": 662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_TEMPORARY"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t mem_rw(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos, int write)\n{\n\tstruct mm_struct *mm = file->private_data;\n\tunsigned long addr = *ppos;\n\tssize_t copied;\n\tchar *page;\n\n\tif (!mm)\n\t\treturn 0;\n\n\tpage = (char *)__get_free_page(GFP_TEMPORARY);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tcopied = 0;\n\tif (!atomic_inc_not_zero(&mm->mm_users))\n\t\tgoto free;\n\n\twhile (count > 0) {\n\t\tint this_len = min_t(int, count, PAGE_SIZE);\n\n\t\tif (write && copy_from_user(page, buf, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis_len = access_remote_vm(mm, addr, page, this_len, write);\n\t\tif (!this_len) {\n\t\t\tif (!copied)\n\t\t\t\tcopied = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!write && copy_to_user(buf, page, this_len)) {\n\t\t\tcopied = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += this_len;\n\t\taddr += this_len;\n\t\tcopied += this_len;\n\t\tcount -= this_len;\n\t}\n\t*ppos = addr;\n\n\tmmput(mm);\nfree:\n\tfree_page((unsigned long) page);\n\treturn copied;\n}"
  },
  {
    "function_name": "mem_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "636-644",
    "snippet": "static int mem_open(struct inode *inode, struct file *file)\n{\n\tint ret = __mem_open(inode, file, PTRACE_MODE_ATTACH);\n\n\t/* OK to pass negative loff_t, we can catch out-of-range */\n\tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mem_open",
          "args": [
            "inode",
            "file",
            "PTRACE_MODE_ATTACH"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "__mem_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "625-634",
          "snippet": "static int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int mem_open(struct inode *inode, struct file *file)\n{\n\tint ret = __mem_open(inode, file, PTRACE_MODE_ATTACH);\n\n\t/* OK to pass negative loff_t, we can catch out-of-range */\n\tfile->f_mode |= FMODE_UNSIGNED_OFFSET;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__mem_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "625-634",
    "snippet": "static int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mm"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mm"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mem_open",
          "args": [
            "inode",
            "mode"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "proc_mem_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "605-623",
          "snippet": "struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int __mem_open(struct inode *inode, struct file *file, unsigned int mode)\n{\n\tstruct mm_struct *mm = proc_mem_open(inode, mode);\n\n\tif (IS_ERR(mm))\n\t\treturn PTR_ERR(mm);\n\n\tfile->private_data = mm;\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_mem_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "605-623",
    "snippet": "struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&mm->mm_count"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "mm"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_access",
          "args": [
            "task",
            "mode"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESRCH"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstruct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct mm_struct *mm = ERR_PTR(-ESRCH);\n\n\tif (task) {\n\t\tmm = mm_access(task, mode);\n\t\tput_task_struct(task);\n\n\t\tif (!IS_ERR_OR_NULL(mm)) {\n\t\t\t/* ensure this mm_struct can't be freed */\n\t\t\tatomic_inc(&mm->mm_count);\n\t\t\t/* but do not pin its memory */\n\t\t\tmmput(mm);\n\t\t}\n\t}\n\n\treturn mm;\n}"
  },
  {
    "function_name": "proc_single_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "592-595",
    "snippet": "static int proc_single_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, proc_single_show, inode);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "filp",
            "proc_single_show",
            "inode"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "single_open_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "63-84",
          "snippet": "int single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_single_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, proc_single_show, inode);\n}"
  },
  {
    "function_name": "proc_single_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "572-590",
    "snippet": "static int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tint ret;\n\n\tns = inode->i_sb->s_fs_info;\n\tpid = proc_pid(inode);\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "m",
            "ns",
            "pid",
            "task"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROC_I",
          "args": [
            "inode"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "PROC_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "75-78",
          "snippet": "static inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct proc_inode *PROC_I(const struct inode *inode)\n{\n\treturn container_of(inode, struct proc_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_pid",
          "args": [
            "inode"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "proc_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "90-93",
          "snippet": "static inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nstatic inline struct pid *proc_pid(struct inode *inode)\n{\n\treturn PROC_I(inode)->pid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_single_show(struct seq_file *m, void *v)\n{\n\tstruct inode *inode = m->private;\n\tstruct pid_namespace *ns;\n\tstruct pid *pid;\n\tstruct task_struct *task;\n\tint ret;\n\n\tns = inode->i_sb->s_fs_info;\n\tpid = proc_pid(inode);\n\ttask = get_pid_task(pid, PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ESRCH;\n\n\tret = PROC_I(inode)->op.proc_show(m, ns, pid, task);\n\n\tput_task_struct(task);\n\treturn ret;\n}"
  },
  {
    "function_name": "proc_pid_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "538-564",
    "snippet": "static int proc_pid_permission(struct inode *inode, int mask)\n{\n\tstruct pid_namespace *pid = inode->i_sb->s_fs_info;\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\thas_perms = has_pid_permissions(pid, task, 1);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (pid->hide_pid == 2) {\n\t\t\t/*\n\t\t\t * Let's make getdents(), stat(), and open()\n\t\t\t * consistent with each other.  If a process\n\t\t\t * may not stat() a file, it shouldn't be seen\n\t\t\t * in procfs at all.\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(inode, mask);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_permission",
          "args": [
            "inode",
            "mask"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "generic_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "329-368",
          "snippet": "int generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint generic_permission(struct inode *inode, int mask)\n{\n\tint ret;\n\n\t/*\n\t * Do the basic permission checks.\n\t */\n\tret = acl_permission_check(inode, mask);\n\tif (ret != -EACCES)\n\t\treturn ret;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\t/* DACs are overridable for directories */\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\t\tif (!(mask & MAY_WRITE))\n\t\t\tif (capable_wrt_inode_uidgid(inode,\n\t\t\t\t\t\t     CAP_DAC_READ_SEARCH))\n\t\t\t\treturn 0;\n\t\treturn -EACCES;\n\t}\n\t/*\n\t * Read/write DACs are always overridable.\n\t * Executable DACs are overridable when there is\n\t * at least one exec bit set.\n\t */\n\tif (!(mask & MAY_EXEC) || (inode->i_mode & S_IXUGO))\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_OVERRIDE))\n\t\t\treturn 0;\n\n\t/*\n\t * Searching includes executable on directories, else just read.\n\t */\n\tmask &= MAY_READ | MAY_WRITE | MAY_EXEC;\n\tif (mask == MAY_READ)\n\t\tif (capable_wrt_inode_uidgid(inode, CAP_DAC_READ_SEARCH))\n\t\t\treturn 0;\n\n\treturn -EACCES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pid_permissions",
          "args": [
            "pid",
            "task",
            "1"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "has_pid_permissions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "526-535",
          "snippet": "static bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pid_permission(struct inode *inode, int mask)\n{\n\tstruct pid_namespace *pid = inode->i_sb->s_fs_info;\n\tstruct task_struct *task;\n\tbool has_perms;\n\n\ttask = get_proc_task(inode);\n\tif (!task)\n\t\treturn -ESRCH;\n\thas_perms = has_pid_permissions(pid, task, 1);\n\tput_task_struct(task);\n\n\tif (!has_perms) {\n\t\tif (pid->hide_pid == 2) {\n\t\t\t/*\n\t\t\t * Let's make getdents(), stat(), and open()\n\t\t\t * consistent with each other.  If a process\n\t\t\t * may not stat() a file, it shouldn't be seen\n\t\t\t * in procfs at all.\n\t\t\t */\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\treturn generic_permission(inode, mask);\n}"
  },
  {
    "function_name": "has_pid_permissions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "526-535",
    "snippet": "static bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "pid->pid_gid"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic bool has_pid_permissions(struct pid_namespace *pid,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t int hide_pid_min)\n{\n\tif (pid->hide_pid < hide_pid_min)\n\t\treturn true;\n\tif (in_group_p(pid->pid_gid))\n\t\treturn true;\n\treturn ptrace_may_access(task, PTRACE_MODE_READ);\n}"
  },
  {
    "function_name": "proc_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "505-520",
    "snippet": "int proc_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "setattr_copy",
          "args": [
            "inode",
            "attr"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "setattr_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "142-167",
          "snippet": "void setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nvoid setattr_copy(struct inode *inode, const struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\tif (ia_valid & ATTR_UID)\n\t\tinode->i_uid = attr->ia_uid;\n\tif (ia_valid & ATTR_GID)\n\t\tinode->i_gid = attr->ia_gid;\n\tif (ia_valid & ATTR_ATIME)\n\t\tinode->i_atime = timespec_trunc(attr->ia_atime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MTIME)\n\t\tinode->i_mtime = timespec_trunc(attr->ia_mtime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_CTIME)\n\t\tinode->i_ctime = timespec_trunc(attr->ia_ctime,\n\t\t\t\t\t\tinode->i_sb->s_time_gran);\n\tif (ia_valid & ATTR_MODE) {\n\t\tumode_t mode = attr->ia_mode;\n\n\t\tif (!in_group_p(inode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t\tinode->i_mode = mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_change_ok",
          "args": [
            "inode",
            "attr"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "inode_change_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/attr.c",
          "lines": "31-81",
          "snippet": "int inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ima.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/string.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ima.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/fcntl.h>\n#include <linux/fsnotify.h>\n#include <linux/capability.h>\n#include <linux/string.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/export.h>\n\nint inode_change_ok(const struct inode *inode, struct iattr *attr)\n{\n\tunsigned int ia_valid = attr->ia_valid;\n\n\t/*\n\t * First check size constraints.  These can't be overriden using\n\t * ATTR_FORCE.\n\t */\n\tif (ia_valid & ATTR_SIZE) {\n\t\tint error = inode_newsize_ok(inode, attr->ia_size);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\t/* If force is set do it anyway. */\n\tif (ia_valid & ATTR_FORCE)\n\t\treturn 0;\n\n\t/* Make sure a caller can chown. */\n\tif ((ia_valid & ATTR_UID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t     !uid_eq(attr->ia_uid, inode->i_uid)) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure caller can chgrp. */\n\tif ((ia_valid & ATTR_GID) &&\n\t    (!uid_eq(current_fsuid(), inode->i_uid) ||\n\t    (!in_group_p(attr->ia_gid) && !gid_eq(attr->ia_gid, inode->i_gid))) &&\n\t    !capable_wrt_inode_uidgid(inode, CAP_CHOWN))\n\t\treturn -EPERM;\n\n\t/* Make sure a caller can chmod. */\n\tif (ia_valid & ATTR_MODE) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t\t/* Also check the setgid bit! */\n\t\tif (!in_group_p((ia_valid & ATTR_GID) ? attr->ia_gid :\n\t\t\t\tinode->i_gid) &&\n\t\t    !capable_wrt_inode_uidgid(inode, CAP_FSETID))\n\t\t\tattr->ia_mode &= ~S_ISGID;\n\t}\n\n\t/* Check for setting the inode time. */\n\tif (ia_valid & (ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET)) {\n\t\tif (!inode_owner_or_capable(inode))\n\t\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint proc_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tint error;\n\tstruct inode *inode = dentry->d_inode;\n\n\tif (attr->ia_valid & ATTR_MODE)\n\t\treturn -EPERM;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tsetattr_copy(inode, attr);\n\tmark_inode_dirty(inode);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_fd_access_allowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "489-503",
    "snippet": "static int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_fd_access_allowed(struct inode *inode)\n{\n\tstruct task_struct *task;\n\tint allowed = 0;\n\t/* Allow access to a task's file descriptors if it is us or we\n\t * may use ptrace attach to the process and find out that\n\t * information.\n\t */\n\ttask = get_proc_task(inode);\n\tif (task) {\n\t\tallowed = ptrace_may_access(task, PTRACE_MODE_READ);\n\t\tput_task_struct(task);\n\t}\n\treturn allowed;\n}"
  },
  {
    "function_name": "proc_pid_syscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "460-481",
    "snippet": "static int proc_pid_syscall(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t    struct pid *pid, struct task_struct *task)\n{\n\tlong nr;\n\tunsigned long args[6], sp, pc;\n\tint res = lock_trace(task);\n\tif (res)\n\t\treturn res;\n\n\tif (task_current_syscall(task, &nr, args, 6, &sp, &pc))\n\t\tseq_puts(m, \"running\\n\");\n\telse if (nr < 0)\n\t\tseq_printf(m, \"%ld 0x%lx 0x%lx\\n\", nr, sp, pc);\n\telse\n\t\tseq_printf(m,\n\t\t       \"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t       nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       sp, pc);\n\tunlock_trace(task);\n\treturn res;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_trace",
          "args": [
            "task"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "263-266",
          "snippet": "static void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\"",
            "nr",
            "args[0]",
            "args[1]",
            "args[2]",
            "args[3]",
            "args[4]",
            "args[5]",
            "sp",
            "pc"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"running\\n\""
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current_syscall",
          "args": [
            "task",
            "&nr",
            "args",
            "6",
            "&sp",
            "&pc"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pid_syscall(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t    struct pid *pid, struct task_struct *task)\n{\n\tlong nr;\n\tunsigned long args[6], sp, pc;\n\tint res = lock_trace(task);\n\tif (res)\n\t\treturn res;\n\n\tif (task_current_syscall(task, &nr, args, 6, &sp, &pc))\n\t\tseq_puts(m, \"running\\n\");\n\telse if (nr < 0)\n\t\tseq_printf(m, \"%ld 0x%lx 0x%lx\\n\", nr, sp, pc);\n\telse\n\t\tseq_printf(m,\n\t\t       \"%ld 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx 0x%lx\\n\",\n\t\t       nr,\n\t\t       args[0], args[1], args[2], args[3], args[4], args[5],\n\t\t       sp, pc);\n\tunlock_trace(task);\n\treturn res;\n}"
  },
  {
    "function_name": "proc_pid_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "418-457",
    "snippet": "static int proc_pid_limits(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t/*\n\t * print the file header\n\t */\n       seq_printf(m, \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-20lu \", rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tseq_printf(m, \"%-10s\\n\", lnames[i].unit);\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%-10s\\n\"",
            "lnames[i].unit"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rlim",
            "task->signal->rlim",
            "sizeof(struct rlimit) * RLIM_NLIMITS"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "task",
            "&flags"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic const struct limit_names lnames[RLIM_NLIMITS] = {\n\t[RLIMIT_CPU] = {\"Max cpu time\", \"seconds\"},\n\t[RLIMIT_FSIZE] = {\"Max file size\", \"bytes\"},\n\t[RLIMIT_DATA] = {\"Max data size\", \"bytes\"},\n\t[RLIMIT_STACK] = {\"Max stack size\", \"bytes\"},\n\t[RLIMIT_CORE] = {\"Max core file size\", \"bytes\"},\n\t[RLIMIT_RSS] = {\"Max resident set\", \"bytes\"},\n\t[RLIMIT_NPROC] = {\"Max processes\", \"processes\"},\n\t[RLIMIT_NOFILE] = {\"Max open files\", \"files\"},\n\t[RLIMIT_MEMLOCK] = {\"Max locked memory\", \"bytes\"},\n\t[RLIMIT_AS] = {\"Max address space\", \"bytes\"},\n\t[RLIMIT_LOCKS] = {\"Max file locks\", \"locks\"},\n\t[RLIMIT_SIGPENDING] = {\"Max pending signals\", \"signals\"},\n\t[RLIMIT_MSGQUEUE] = {\"Max msgqueue size\", \"bytes\"},\n\t[RLIMIT_NICE] = {\"Max nice priority\", NULL},\n\t[RLIMIT_RTPRIO] = {\"Max realtime priority\", NULL},\n\t[RLIMIT_RTTIME] = {\"Max realtime timeout\", \"us\"},\n};\n\nstatic int proc_pid_limits(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t   struct pid *pid, struct task_struct *task)\n{\n\tunsigned int i;\n\tunsigned long flags;\n\n\tstruct rlimit rlim[RLIM_NLIMITS];\n\n\tif (!lock_task_sighand(task, &flags))\n\t\treturn 0;\n\tmemcpy(rlim, task->signal->rlim, sizeof(struct rlimit) * RLIM_NLIMITS);\n\tunlock_task_sighand(task, &flags);\n\n\t/*\n\t * print the file header\n\t */\n       seq_printf(m, \"%-25s %-20s %-20s %-10s\\n\",\n\t\t\t\"Limit\", \"Soft Limit\", \"Hard Limit\", \"Units\");\n\n\tfor (i = 0; i < RLIM_NLIMITS; i++) {\n\t\tif (rlim[i].rlim_cur == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-25s %-20s \",\n\t\t\t\t\t lnames[i].name, \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-25s %-20lu \",\n\t\t\t\t\t lnames[i].name, rlim[i].rlim_cur);\n\n\t\tif (rlim[i].rlim_max == RLIM_INFINITY)\n\t\t\tseq_printf(m, \"%-20s \", \"unlimited\");\n\t\telse\n\t\t\tseq_printf(m, \"%-20lu \", rlim[i].rlim_max);\n\n\t\tif (lnames[i].unit)\n\t\t\tseq_printf(m, \"%-10s\\n\", lnames[i].unit);\n\t\telse\n\t\t\tseq_putc(m, '\\n');\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_oom_score",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "379-391",
    "snippet": "static int proc_oom_score(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long totalpages = totalram_pages + total_swap_pages;\n\tunsigned long points = 0;\n\n\tread_lock(&tasklist_lock);\n\tif (pid_alive(task))\n\t\tpoints = oom_badness(task, NULL, NULL, totalpages) *\n\t\t\t\t\t\t1000 / totalpages;\n\tread_unlock(&tasklist_lock);\n\treturn seq_printf(m, \"%lu\\n\", points);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%lu\\n\"",
            "points"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "oom_badness",
          "args": [
            "task",
            "NULL",
            "NULL",
            "totalpages"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_alive",
          "args": [
            "task"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_oom_score(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long totalpages = totalram_pages + total_swap_pages;\n\tunsigned long points = 0;\n\n\tread_lock(&tasklist_lock);\n\tif (pid_alive(task))\n\t\tpoints = oom_badness(task, NULL, NULL, totalpages) *\n\t\t\t\t\t\t1000 / totalpages;\n\tread_unlock(&tasklist_lock);\n\treturn seq_printf(m, \"%lu\\n\", points);\n}"
  },
  {
    "function_name": "lstats_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "356-367",
    "snippet": "static ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_all_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_all_latency_tracing",
          "args": [
            "task"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "file_inode(file)"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic ssize_t lstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tstruct task_struct *task = get_proc_task(file_inode(file));\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tclear_all_latency_tracing(task);\n\tput_task_struct(task);\n\n\treturn count;\n}"
  },
  {
    "function_name": "lstats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "351-354",
    "snippet": "static int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "lstats_show_proc",
            "inode"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "single_open_net",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_net.c",
          "lines": "63-84",
          "snippet": "int single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/seq_file.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mount.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/seq_file.h>\n#include <net/net_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/mount.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nint single_open_net(struct inode *inode, struct file *file,\n\t\tint (*show)(struct seq_file *, void *))\n{\n\tint err;\n\tstruct net *net;\n\n\terr = -ENXIO;\n\tnet = get_proc_net(inode);\n\tif (net == NULL)\n\t\tgoto err_net;\n\n\terr = single_open(file, show, net);\n\tif (err < 0)\n\t\tgoto err_open;\n\n\treturn 0;\n\nerr_open:\n\tput_net(net);\nerr_net:\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int lstats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, lstats_show_proc, inode);\n}"
  },
  {
    "function_name": "lstats_show_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "320-349",
    "snippet": "static int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tstruct latency_record *lr = &task->latency_record[i];\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (bt == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %ps\"",
            "(void *)bt"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"Latency Top version : v0.1\\n\""
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int lstats_show_proc(struct seq_file *m, void *v)\n{\n\tint i;\n\tstruct inode *inode = m->private;\n\tstruct task_struct *task = get_proc_task(inode);\n\n\tif (!task)\n\t\treturn -ESRCH;\n\tseq_puts(m, \"Latency Top version : v0.1\\n\");\n\tfor (i = 0; i < 32; i++) {\n\t\tstruct latency_record *lr = &task->latency_record[i];\n\t\tif (lr->backtrace[0]) {\n\t\t\tint q;\n\t\t\tseq_printf(m, \"%i %li %li\",\n\t\t\t\t   lr->count, lr->time, lr->max);\n\t\t\tfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\n\t\t\t\tunsigned long bt = lr->backtrace[q];\n\t\t\t\tif (!bt)\n\t\t\t\t\tbreak;\n\t\t\t\tif (bt == ULONG_MAX)\n\t\t\t\t\tbreak;\n\t\t\t\tseq_printf(m, \" %ps\", (void *)bt);\n\t\t\t}\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\n\t}\n\tput_task_struct(task);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_pid_schedstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "309-316",
    "snippet": "static int proc_pid_schedstat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t      struct pid *pid, struct task_struct *task)\n{\n\treturn seq_printf(m, \"%llu %llu %lu\\n\",\n\t\t\t(unsigned long long)task->se.sum_exec_runtime,\n\t\t\t(unsigned long long)task->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%llu %llu %lu\\n\"",
            "(unsigned long long)task->se.sum_exec_runtime",
            "(unsigned long long)task->sched_info.run_delay",
            "task->sched_info.pcount"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pid_schedstat(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t      struct pid *pid, struct task_struct *task)\n{\n\treturn seq_printf(m, \"%llu %llu %lu\\n\",\n\t\t\t(unsigned long long)task->se.sum_exec_runtime,\n\t\t\t(unsigned long long)task->sched_info.run_delay,\n\t\t\ttask->sched_info.pcount);\n}"
  },
  {
    "function_name": "proc_pid_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "272-302",
    "snippet": "static int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tstruct stack_trace trace;\n\tunsigned long *entries;\n\tint err;\n\tint i;\n\n\tentries = kmalloc(MAX_STACK_TRACE_DEPTH * sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= MAX_STACK_TRACE_DEPTH;\n\ttrace.entries\t\t= entries;\n\ttrace.skip\t\t= 0;\n\n\terr = lock_trace(task);\n\tif (!err) {\n\t\tsave_stack_trace_tsk(task, &trace);\n\n\t\tfor (i = 0; i < trace.nr_entries; i++) {\n\t\t\tseq_printf(m, \"[<%pK>] %pS\\n\",\n\t\t\t\t   (void *)entries[i], (void *)entries[i]);\n\t\t}\n\t\tunlock_trace(task);\n\t}\n\tkfree(entries);\n\n\treturn err;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [
      "#define MAX_STACK_TRACE_DEPTH\t64"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entries"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_trace",
          "args": [
            "task"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_trace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "263-266",
          "snippet": "static void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"[<%pK>] %pS\\n\"",
            "(void *)entries[i]",
            "(void *)entries[i]"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_stack_trace_tsk",
          "args": [
            "task",
            "&trace"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAX_STACK_TRACE_DEPTH * sizeof(*entries)",
            "GFP_KERNEL"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\n#define MAX_STACK_TRACE_DEPTH\t64\n\nstatic int proc_pid_stack(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tstruct stack_trace trace;\n\tunsigned long *entries;\n\tint err;\n\tint i;\n\n\tentries = kmalloc(MAX_STACK_TRACE_DEPTH * sizeof(*entries), GFP_KERNEL);\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= MAX_STACK_TRACE_DEPTH;\n\ttrace.entries\t\t= entries;\n\ttrace.skip\t\t= 0;\n\n\terr = lock_trace(task);\n\tif (!err) {\n\t\tsave_stack_trace_tsk(task, &trace);\n\n\t\tfor (i = 0; i < trace.nr_entries; i++) {\n\t\t\tseq_printf(m, \"[<%pK>] %pS\\n\",\n\t\t\t\t   (void *)entries[i], (void *)entries[i]);\n\t\t}\n\t\tunlock_trace(task);\n\t}\n\tkfree(entries);\n\n\treturn err;\n}"
  },
  {
    "function_name": "unlock_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "263-266",
    "snippet": "static void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic void unlock_trace(struct task_struct *task)\n{\n\tmutex_unlock(&task->signal->cred_guard_mutex);\n}"
  },
  {
    "function_name": "lock_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "251-261",
    "snippet": "static int lock_trace(struct task_struct *task)\n{\n\tint err = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn err;\n\tif (!ptrace_may_access(task, PTRACE_MODE_ATTACH)) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_ATTACH"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_killable",
          "args": [
            "&task->signal->cred_guard_mutex"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int lock_trace(struct task_struct *task)\n{\n\tint err = mutex_lock_killable(&task->signal->cred_guard_mutex);\n\tif (err)\n\t\treturn err;\n\tif (!ptrace_may_access(task, PTRACE_MODE_ATTACH)) {\n\t\tmutex_unlock(&task->signal->cred_guard_mutex);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_pid_wchan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "233-248",
    "snippet": "static int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\twchan = get_wchan(task);\n\n\tif (lookup_symbol_name(wchan, symname) < 0)\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn seq_printf(m, \"%lu\", wchan);\n\telse\n\t\treturn seq_printf(m, \"%s\", symname);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\"",
            "symname"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_may_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_symbol_name",
          "args": [
            "wchan",
            "symname"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_wchan",
          "args": [
            "task"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t  struct pid *pid, struct task_struct *task)\n{\n\tunsigned long wchan;\n\tchar symname[KSYM_NAME_LEN];\n\n\twchan = get_wchan(task);\n\n\tif (lookup_symbol_name(wchan, symname) < 0)\n\t\tif (!ptrace_may_access(task, PTRACE_MODE_READ))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn seq_printf(m, \"%lu\", wchan);\n\telse\n\t\treturn seq_printf(m, \"%s\", symname);\n}"
  },
  {
    "function_name": "proc_pid_auxv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "211-225",
    "snippet": "static int proc_pid_auxv(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t struct pid *pid, struct task_struct *task)\n{\n\tstruct mm_struct *mm = mm_access(task, PTRACE_MODE_READ);\n\tif (mm && !IS_ERR(mm)) {\n\t\tunsigned int nwords = 0;\n\t\tdo {\n\t\t\tnwords += 2;\n\t\t} while (mm->saved_auxv[nwords - 2] != 0); /* AT_NULL */\n\t\tseq_write(m, mm->saved_auxv, nwords * sizeof(mm->saved_auxv[0]));\n\t\tmmput(mm);\n\t\treturn 0;\n\t} else\n\t\treturn PTR_ERR(mm);\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mm"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "mm"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_write",
          "args": [
            "m",
            "mm->saved_auxv",
            "nwords * sizeof(mm->saved_auxv[0])"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "seq_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "731-740",
          "snippet": "int seq_write(struct seq_file *seq, const void *data, size_t len)\n{\n\tif (seq->count + len < seq->size) {\n\t\tmemcpy(seq->buf + seq->count, data, len);\n\t\tseq->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(seq);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_write(struct seq_file *seq, const void *data, size_t len)\n{\n\tif (seq->count + len < seq->size) {\n\t\tmemcpy(seq->buf + seq->count, data, len);\n\t\tseq->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(seq);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mm"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_access",
          "args": [
            "task",
            "PTRACE_MODE_READ"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pid_auxv(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t struct pid *pid, struct task_struct *task)\n{\n\tstruct mm_struct *mm = mm_access(task, PTRACE_MODE_READ);\n\tif (mm && !IS_ERR(mm)) {\n\t\tunsigned int nwords = 0;\n\t\tdo {\n\t\t\tnwords += 2;\n\t\t} while (mm->saved_auxv[nwords - 2] != 0); /* AT_NULL */\n\t\tseq_write(m, mm->saved_auxv, nwords * sizeof(mm->saved_auxv[0]));\n\t\tmmput(mm);\n\t\treturn 0;\n\t} else\n\t\treturn PTR_ERR(mm);\n}"
  },
  {
    "function_name": "proc_pid_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "199-209",
    "snippet": "static int proc_pid_cmdline(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t    struct pid *pid, struct task_struct *task)\n{\n\t/*\n\t * Rely on struct seq_operations::show() being called once\n\t * per internal buffer allocation. See single_open(), traverse().\n\t */\n\tBUG_ON(m->size < PAGE_SIZE);\n\tm->count += get_cmdline(task, m->buf, PAGE_SIZE);\n\treturn 0;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cmdline",
          "args": [
            "task",
            "m->buf",
            "PAGE_SIZE"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "m->size < PAGE_SIZE"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_pid_cmdline(struct seq_file *m, struct pid_namespace *ns,\n\t\t\t    struct pid *pid, struct task_struct *task)\n{\n\t/*\n\t * Rely on struct seq_operations::show() being called once\n\t * per internal buffer allocation. See single_open(), traverse().\n\t */\n\tBUG_ON(m->size < PAGE_SIZE);\n\tm->count += get_cmdline(task, m->buf, PAGE_SIZE);\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_root_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "187-197",
    "snippet": "static int proc_root_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(dentry->d_inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_task_root(task, path);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_root",
          "args": [
            "task",
            "path"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
          "lines": "157-168",
          "snippet": "static int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}",
          "includes": [
            "#include \"fd.h\"",
            "#include \"internal.h\"",
            "#include <trace/events/oom.h>",
            "#include <asm/hardwall.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/elf.h>",
            "#include <linux/oom.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/poll.h>",
            "#include <linux/audit.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/printk.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/resource.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/namei.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/init.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/stat.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dentry->d_inode"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_root_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(dentry->d_inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\tresult = get_task_root(task, path);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "proc_cwd_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "170-185",
    "snippet": "static int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(dentry->d_inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_pwd",
          "args": [
            "task->fs",
            "path"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "dentry->d_inode"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int proc_cwd_link(struct dentry *dentry, struct path *path)\n{\n\tstruct task_struct *task = get_proc_task(dentry->d_inode);\n\tint result = -ENOENT;\n\n\tif (task) {\n\t\ttask_lock(task);\n\t\tif (task->fs) {\n\t\t\tget_fs_pwd(task->fs, path);\n\t\t\tresult = 0;\n\t\t}\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "get_task_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "157-168",
    "snippet": "static int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_root",
          "args": [
            "task->fs",
            "root"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "get_fs_root_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3021-3029",
          "snippet": "static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic int get_task_root(struct task_struct *task, struct path *root)\n{\n\tint result = -ENOENT;\n\n\ttask_lock(task);\n\tif (task->fs) {\n\t\tget_fs_root(task->fs, root);\n\t\tresult = 0;\n\t}\n\ttask_unlock(task);\n\treturn result;\n}"
  },
  {
    "function_name": "pid_entry_count_dirs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/base.c",
    "lines": "142-155",
    "snippet": "static unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"fd.h\"",
      "#include \"internal.h\"",
      "#include <trace/events/oom.h>",
      "#include <asm/hardwall.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/flex_array.h>",
      "#include <linux/slab.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/elf.h>",
      "#include <linux/oom.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/poll.h>",
      "#include <linux/audit.h>",
      "#include <linux/cpuset.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/printk.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/module.h>",
      "#include <linux/resource.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/mnt_namespace.h>",
      "#include <linux/namei.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/string.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/capability.h>",
      "#include <linux/init.h>",
      "#include <linux/task_io_accounting_ops.h>",
      "#include <linux/stat.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <asm/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "entries[i].mode"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"fd.h\"\n#include \"internal.h\"\n#include <trace/events/oom.h>\n#include <asm/hardwall.h>\n#include <linux/posix-timers.h>\n#include <linux/flex_array.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/elf.h>\n#include <linux/oom.h>\n#include <linux/nsproxy.h>\n#include <linux/poll.h>\n#include <linux/audit.h>\n#include <linux/cpuset.h>\n#include <linux/cgroup.h>\n#include <linux/printk.h>\n#include <linux/tracehook.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/resource.h>\n#include <linux/stacktrace.h>\n#include <linux/kallsyms.h>\n#include <linux/rcupdate.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/mnt_namespace.h>\n#include <linux/namei.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/init.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/stat.h>\n#include <linux/proc_fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n\nstatic unsigned int pid_entry_count_dirs(const struct pid_entry *entries,\n\tunsigned int n)\n{\n\tunsigned int i;\n\tunsigned int count;\n\n\tcount = 0;\n\tfor (i = 0; i < n; ++i) {\n\t\tif (S_ISDIR(entries[i].mode))\n\t\t\t++count;\n\t}\n\n\treturn count;\n}"
  }
]