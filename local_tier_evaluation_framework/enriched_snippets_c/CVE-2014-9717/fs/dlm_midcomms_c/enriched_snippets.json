[
  {
    "function_name": "dlm_process_incoming_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/midcomms.c",
    "lines": "58-136",
    "snippet": "int dlm_process_incoming_buffer(int nodeid, const void *base,\n\t\t\t\tunsigned offset, unsigned len, unsigned limit)\n{\n\tunion {\n\t\tunsigned char __buf[DLM_INBUF_LEN];\n\t\t/* this is to force proper alignment on some arches */\n\t\tunion dlm_packet p;\n\t} __tmp;\n\tunion dlm_packet *p = &__tmp.p;\n\tint ret = 0;\n\tint err = 0;\n\tuint16_t msglen;\n\tuint32_t lockspace;\n\n\twhile (len > sizeof(struct dlm_header)) {\n\n\t\t/* Copy just the header to check the total length.  The\n\t\t   message may wrap around the end of the buffer back to the\n\t\t   start, so we need to use a temp buffer and copy_from_cb. */\n\n\t\tcopy_from_cb(p, base, offset, sizeof(struct dlm_header),\n\t\t\t     limit);\n\n\t\tmsglen = le16_to_cpu(p->header.h_length);\n\t\tlockspace = p->header.h_lockspace;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < sizeof(struct dlm_header))\n\t\t\tbreak;\n\t\tif (p->header.h_cmd == DLM_MSG) {\n\t\t\tif (msglen < sizeof(struct dlm_message))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (msglen < sizeof(struct dlm_rcom))\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -E2BIG;\n\t\tif (msglen > dlm_config.ci_buffer_size) {\n\t\t\tlog_print(\"message size %d from %d too big, buf len %d\",\n\t\t\t\t  msglen, nodeid, len);\n\t\t\tbreak;\n\t\t}\n\t\terr = 0;\n\n\t\t/* If only part of the full message is contained in this\n\t\t   buffer, then do nothing and wait for lowcomms to call\n\t\t   us again later with more data.  We return 0 meaning\n\t\t   we've consumed none of the input buffer. */\n\n\t\tif (msglen > len)\n\t\t\tbreak;\n\n\t\t/* Allocate a larger temp buffer if the full message won't fit\n\t\t   in the buffer on the stack (which should work for most\n\t\t   ordinary messages). */\n\n\t\tif (msglen > sizeof(__tmp) && p == &__tmp.p) {\n\t\t\tp = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);\n\t\t\tif (p == NULL)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcopy_from_cb(p, base, offset, msglen, limit);\n\n\t\tBUG_ON(lockspace != p->header.h_lockspace);\n\n\t\tret += msglen;\n\t\toffset += msglen;\n\t\toffset &= (limit - 1);\n\t\tlen -= msglen;\n\n\t\tdlm_receive_buffer(p, nodeid);\n\t}\n\n\tif (p != &__tmp.p)\n\t\tkfree(p);\n\n\treturn err ? err : ret;\n}",
    "includes": [
      "#include \"midcomms.h\"",
      "#include \"lock.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_receive_buffer",
          "args": [
            "p",
            "nodeid"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_receive_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5018-5068",
          "snippet": "void dlm_receive_buffer(union dlm_packet *p, int nodeid)\n{\n\tstruct dlm_header *hd = &p->header;\n\tstruct dlm_ls *ls;\n\tint type = 0;\n\n\tswitch (hd->h_cmd) {\n\tcase DLM_MSG:\n\t\tdlm_message_in(&p->message);\n\t\ttype = p->message.m_type;\n\t\tbreak;\n\tcase DLM_RCOM:\n\t\tdlm_rcom_in(&p->rcom);\n\t\ttype = p->rcom.rc_type;\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"invalid h_cmd %d from %u\", hd->h_cmd, nodeid);\n\t\treturn;\n\t}\n\n\tif (hd->h_nodeid != nodeid) {\n\t\tlog_print(\"invalid h_nodeid %d from %d lockspace %x\",\n\t\t\t  hd->h_nodeid, nodeid, hd->h_lockspace);\n\t\treturn;\n\t}\n\n\tls = dlm_find_lockspace_global(hd->h_lockspace);\n\tif (!ls) {\n\t\tif (dlm_config.ci_log_debug) {\n\t\t\tprintk_ratelimited(KERN_DEBUG \"dlm: invalid lockspace \"\n\t\t\t\t\"%u from %d cmd %d type %d\\n\",\n\t\t\t\thd->h_lockspace, nodeid, hd->h_cmd, type);\n\t\t}\n\n\t\tif (hd->h_cmd == DLM_RCOM && type == DLM_RCOM_STATUS)\n\t\t\tdlm_send_ls_not_ready(nodeid, &p->rcom);\n\t\treturn;\n\t}\n\n\t/* this rwsem allows dlm_ls_stop() to wait for all dlm_recv threads to\n\t   be inactive (in this ls) before transitioning to recovery mode */\n\n\tdown_read(&ls->ls_recv_active);\n\tif (hd->h_cmd == DLM_MSG)\n\t\tdlm_receive_message(ls, &p->message, nodeid);\n\telse\n\t\tdlm_receive_rcom(ls, &p->rcom, nodeid);\n\tup_read(&ls->ls_recv_active);\n\n\tdlm_put_lockspace(ls);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\n\nvoid dlm_receive_buffer(union dlm_packet *p, int nodeid)\n{\n\tstruct dlm_header *hd = &p->header;\n\tstruct dlm_ls *ls;\n\tint type = 0;\n\n\tswitch (hd->h_cmd) {\n\tcase DLM_MSG:\n\t\tdlm_message_in(&p->message);\n\t\ttype = p->message.m_type;\n\t\tbreak;\n\tcase DLM_RCOM:\n\t\tdlm_rcom_in(&p->rcom);\n\t\ttype = p->rcom.rc_type;\n\t\tbreak;\n\tdefault:\n\t\tlog_print(\"invalid h_cmd %d from %u\", hd->h_cmd, nodeid);\n\t\treturn;\n\t}\n\n\tif (hd->h_nodeid != nodeid) {\n\t\tlog_print(\"invalid h_nodeid %d from %d lockspace %x\",\n\t\t\t  hd->h_nodeid, nodeid, hd->h_lockspace);\n\t\treturn;\n\t}\n\n\tls = dlm_find_lockspace_global(hd->h_lockspace);\n\tif (!ls) {\n\t\tif (dlm_config.ci_log_debug) {\n\t\t\tprintk_ratelimited(KERN_DEBUG \"dlm: invalid lockspace \"\n\t\t\t\t\"%u from %d cmd %d type %d\\n\",\n\t\t\t\thd->h_lockspace, nodeid, hd->h_cmd, type);\n\t\t}\n\n\t\tif (hd->h_cmd == DLM_RCOM && type == DLM_RCOM_STATUS)\n\t\t\tdlm_send_ls_not_ready(nodeid, &p->rcom);\n\t\treturn;\n\t}\n\n\t/* this rwsem allows dlm_ls_stop() to wait for all dlm_recv threads to\n\t   be inactive (in this ls) before transitioning to recovery mode */\n\n\tdown_read(&ls->ls_recv_active);\n\tif (hd->h_cmd == DLM_MSG)\n\t\tdlm_receive_message(ls, &p->message, nodeid);\n\telse\n\t\tdlm_receive_rcom(ls, &p->rcom, nodeid);\n\tup_read(&ls->ls_recv_active);\n\n\tdlm_put_lockspace(ls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lockspace != p->header.h_lockspace"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_cb",
          "args": [
            "p",
            "base",
            "offset",
            "msglen",
            "limit"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/midcomms.c",
          "lines": "34-45",
          "snippet": "static void copy_from_cb(void *dst, const void *base, unsigned offset,\n\t\t\t unsigned len, unsigned limit)\n{\n\tunsigned copy = len;\n\n\tif ((copy + offset) > limit)\n\t\tcopy = limit - offset;\n\tmemcpy(dst, base + offset, copy);\n\tlen -= copy;\n\tif (len)\n\t\tmemcpy(dst + copy, base, len);\n}",
          "includes": [
            "#include \"midcomms.h\"",
            "#include \"lock.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"midcomms.h\"\n#include \"lock.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n\nstatic void copy_from_cb(void *dst, const void *base, unsigned offset,\n\t\t\t unsigned len, unsigned limit)\n{\n\tunsigned copy = len;\n\n\tif ((copy + offset) > limit)\n\t\tcopy = limit - offset;\n\tmemcpy(dst, base + offset, copy);\n\tlen -= copy;\n\tif (len)\n\t\tmemcpy(dst + copy, base, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "dlm_config.ci_buffer_size",
            "GFP_NOFS"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"message size %d from %d too big, buf len %d\"",
            "msglen",
            "nodeid",
            "len"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->header.h_length"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"midcomms.h\"\n#include \"lock.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n\nint dlm_process_incoming_buffer(int nodeid, const void *base,\n\t\t\t\tunsigned offset, unsigned len, unsigned limit)\n{\n\tunion {\n\t\tunsigned char __buf[DLM_INBUF_LEN];\n\t\t/* this is to force proper alignment on some arches */\n\t\tunion dlm_packet p;\n\t} __tmp;\n\tunion dlm_packet *p = &__tmp.p;\n\tint ret = 0;\n\tint err = 0;\n\tuint16_t msglen;\n\tuint32_t lockspace;\n\n\twhile (len > sizeof(struct dlm_header)) {\n\n\t\t/* Copy just the header to check the total length.  The\n\t\t   message may wrap around the end of the buffer back to the\n\t\t   start, so we need to use a temp buffer and copy_from_cb. */\n\n\t\tcopy_from_cb(p, base, offset, sizeof(struct dlm_header),\n\t\t\t     limit);\n\n\t\tmsglen = le16_to_cpu(p->header.h_length);\n\t\tlockspace = p->header.h_lockspace;\n\n\t\terr = -EINVAL;\n\t\tif (msglen < sizeof(struct dlm_header))\n\t\t\tbreak;\n\t\tif (p->header.h_cmd == DLM_MSG) {\n\t\t\tif (msglen < sizeof(struct dlm_message))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (msglen < sizeof(struct dlm_rcom))\n\t\t\t\tbreak;\n\t\t}\n\t\terr = -E2BIG;\n\t\tif (msglen > dlm_config.ci_buffer_size) {\n\t\t\tlog_print(\"message size %d from %d too big, buf len %d\",\n\t\t\t\t  msglen, nodeid, len);\n\t\t\tbreak;\n\t\t}\n\t\terr = 0;\n\n\t\t/* If only part of the full message is contained in this\n\t\t   buffer, then do nothing and wait for lowcomms to call\n\t\t   us again later with more data.  We return 0 meaning\n\t\t   we've consumed none of the input buffer. */\n\n\t\tif (msglen > len)\n\t\t\tbreak;\n\n\t\t/* Allocate a larger temp buffer if the full message won't fit\n\t\t   in the buffer on the stack (which should work for most\n\t\t   ordinary messages). */\n\n\t\tif (msglen > sizeof(__tmp) && p == &__tmp.p) {\n\t\t\tp = kmalloc(dlm_config.ci_buffer_size, GFP_NOFS);\n\t\t\tif (p == NULL)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tcopy_from_cb(p, base, offset, msglen, limit);\n\n\t\tBUG_ON(lockspace != p->header.h_lockspace);\n\n\t\tret += msglen;\n\t\toffset += msglen;\n\t\toffset &= (limit - 1);\n\t\tlen -= msglen;\n\n\t\tdlm_receive_buffer(p, nodeid);\n\t}\n\n\tif (p != &__tmp.p)\n\t\tkfree(p);\n\n\treturn err ? err : ret;\n}"
  },
  {
    "function_name": "copy_from_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/midcomms.c",
    "lines": "34-45",
    "snippet": "static void copy_from_cb(void *dst, const void *base, unsigned offset,\n\t\t\t unsigned len, unsigned limit)\n{\n\tunsigned copy = len;\n\n\tif ((copy + offset) > limit)\n\t\tcopy = limit - offset;\n\tmemcpy(dst, base + offset, copy);\n\tlen -= copy;\n\tif (len)\n\t\tmemcpy(dst + copy, base, len);\n}",
    "includes": [
      "#include \"midcomms.h\"",
      "#include \"lock.h\"",
      "#include \"config.h\"",
      "#include \"lowcomms.h\"",
      "#include \"dlm_internal.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst + copy",
            "base",
            "len"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "base + offset",
            "copy"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"midcomms.h\"\n#include \"lock.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dlm_internal.h\"\n\nstatic void copy_from_cb(void *dst, const void *base, unsigned offset,\n\t\t\t unsigned len, unsigned limit)\n{\n\tunsigned copy = len;\n\n\tif ((copy + offset) > limit)\n\t\tcopy = limit - offset;\n\tmemcpy(dst, base + offset, copy);\n\tlen -= copy;\n\tif (len)\n\t\tmemcpy(dst + copy, base, len);\n}"
  }
]