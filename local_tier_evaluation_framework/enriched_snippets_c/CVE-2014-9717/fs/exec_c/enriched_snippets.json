[
  {
    "function_name": "set_dumpable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1658-1669",
    "snippet": "void set_dumpable(struct mm_struct *mm, int value)\n{\n\tunsigned long old, new;\n\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tdo {\n\t\told = ACCESS_ONCE(mm->flags);\n\t\tnew = (old & ~MMF_DUMPABLE_MASK) | value;\n\t} while (cmpxchg(&mm->flags, old, new) != old);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg",
          "args": [
            "&mm->flags",
            "old",
            "new"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "mm->flags"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(unsigned)value > SUID_DUMP_ROOT"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_dumpable(struct mm_struct *mm, int value)\n{\n\tunsigned long old, new;\n\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tdo {\n\t\told = ACCESS_ONCE(mm->flags);\n\t\tnew = (old & ~MMF_DUMPABLE_MASK) | value;\n\t} while (cmpxchg(&mm->flags, old, new) != old);\n}"
  },
  {
    "function_name": "set_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1642-1652",
    "snippet": "void set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__module_get",
          "args": [
            "new->module"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "mm->binfmt->module"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_binfmt(struct linux_binfmt *new)\n{\n\tstruct mm_struct *mm = current->mm;\n\n\tif (mm->binfmt)\n\t\tmodule_put(mm->binfmt->module);\n\n\tmm->binfmt = new;\n\tif (new)\n\t\t__module_get(new->module);\n}"
  },
  {
    "function_name": "compat_do_execveat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1625-1639",
    "snippet": "static int compat_do_execveat(int fd, struct filename *filename,\n\t\t\t      const compat_uptr_t __user *__argv,\n\t\t\t      const compat_uptr_t __user *__envp,\n\t\t\t      int flags)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_execveat_common",
          "args": [
            "fd",
            "filename",
            "argv",
            "envp",
            "flags"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "do_execveat_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1445-1587",
          "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int compat_do_execveat(int fd, struct filename *filename,\n\t\t\t      const compat_uptr_t __user *__argv,\n\t\t\t      const compat_uptr_t __user *__envp,\n\t\t\t      int flags)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}"
  },
  {
    "function_name": "compat_do_execve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1610-1623",
    "snippet": "static int compat_do_execve(struct filename *filename,\n\tconst compat_uptr_t __user *__argv,\n\tconst compat_uptr_t __user *__envp)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_execveat_common",
          "args": [
            "AT_FDCWD",
            "filename",
            "argv",
            "envp",
            "0"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "do_execveat_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1445-1587",
          "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int compat_do_execve(struct filename *filename,\n\tconst compat_uptr_t __user *__argv,\n\tconst compat_uptr_t __user *__envp)\n{\n\tstruct user_arg_ptr argv = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __argv,\n\t};\n\tstruct user_arg_ptr envp = {\n\t\t.is_compat = true,\n\t\t.ptr.compat = __envp,\n\t};\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}"
  },
  {
    "function_name": "do_execveat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1598-1607",
    "snippet": "int do_execveat(int fd, struct filename *filename,\n\t\tconst char __user *const __user *__argv,\n\t\tconst char __user *const __user *__envp,\n\t\tint flags)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_execveat_common",
          "args": [
            "fd",
            "filename",
            "argv",
            "envp",
            "flags"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "do_execveat_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1445-1587",
          "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint do_execveat(int fd, struct filename *filename,\n\t\tconst char __user *const __user *__argv,\n\t\tconst char __user *const __user *__envp,\n\t\tint flags)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\n\treturn do_execveat_common(fd, filename, argv, envp, flags);\n}"
  },
  {
    "function_name": "do_execve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1589-1596",
    "snippet": "int do_execve(struct filename *filename,\n\tconst char __user *const __user *__argv,\n\tconst char __user *const __user *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_execveat_common",
          "args": [
            "AT_FDCWD",
            "filename",
            "argv",
            "envp",
            "0"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "do_execveat_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1445-1587",
          "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint do_execve(struct filename *filename,\n\tconst char __user *const __user *__argv,\n\tconst char __user *const __user *__envp)\n{\n\tstruct user_arg_ptr argv = { .ptr.native = __argv };\n\tstruct user_arg_ptr envp = { .ptr.native = __envp };\n\treturn do_execveat_common(AT_FDCWD, filename, argv, envp, 0);\n}"
  },
  {
    "function_name": "do_execveat_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1445-1587",
    "snippet": "static int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "filename"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "putname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "245-257",
          "snippet": "void putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_files_struct",
          "args": [
            "displaced"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "reset_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "406-416",
          "snippet": "void reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid reset_files_struct(struct files_struct *files)\n{\n\tstruct task_struct *tsk = current;\n\tstruct files_struct *old;\n\n\told = tsk->files;\n\ttask_lock(tsk);\n\ttsk->files = files;\n\ttask_unlock(tsk);\n\tput_files_struct(old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathbuf"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_bprm",
          "args": [
            "bprm"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "free_bprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1170-1185",
          "snippet": "static void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\t/* If a binfmt changed the interp, free it. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\t/* If a binfmt changed the interp, free it. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "bprm->mm"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_arg_size",
          "args": [
            "bprm",
            "0"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "acct_arg_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "298-300",
          "snippet": "static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "displaced"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "put_files_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "394-404",
          "snippet": "void put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid put_files_struct(struct files_struct *files)\n{\n\tif (atomic_dec_and_test(&files->count)) {\n\t\tstruct fdtable *fdt = close_files(files);\n\n\t\t/* free the arrays if they are not embedded */\n\t\tif (fdt != &files->fdtab)\n\t\t\t__free_fdtable(fdt);\n\t\tkmem_cache_free(files_cachep, files);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathbuf"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_numa_free",
          "args": [
            "current"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_update_integrals",
          "args": [
            "current"
          ],
          "line": 1558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exec_binprm",
          "args": [
            "bprm"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "exec_binprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1420-1440",
          "snippet": "static int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_strings",
          "args": [
            "bprm->argc",
            "argv",
            "bprm"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "copy_strings_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "545-559",
          "snippet": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_binprm",
          "args": [
            "bprm"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_binprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1274-1315",
          "snippet": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\n\n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\n\n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "count",
          "args": [
            "envp",
            "MAX_ARG_STRINGS"
          ],
          "line": 1530
        },
        "resolved": true,
        "details": {
          "function_name": "count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "423-447",
          "snippet": "static int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bprm_mm_init",
          "args": [
            "bprm"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "bprm_mm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "362-385",
          "snippet": "static int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close_on_exec",
          "args": [
            "fd",
            "rcu_dereference_raw(current->files->fdt)"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "set_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "726-737",
          "snippet": "void set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid set_close_on_exec(unsigned int fd, int flag)\n{\n\tstruct files_struct *files = current->files;\n\tstruct fdtable *fdt;\n\tspin_lock(&files->file_lock);\n\tfdt = files_fdtable(files);\n\tif (flag)\n\t\t__set_close_on_exec(fd, fdt);\n\telse\n\t\t__clear_close_on_exec(fd, fdt);\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_raw",
          "args": [
            "current->files->fdt"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_TEMPORARY",
            "\"/dev/fd/%d/%s\"",
            "fd",
            "filename->name"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_TEMPORARY",
            "\"/dev/fd/%d\"",
            "fd"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_exec",
          "args": [],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_open_execat",
          "args": [
            "fd",
            "filename",
            "flags"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "do_open_execat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "751-793",
          "snippet": "static struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC | MAY_OPEN,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC | MAY_OPEN,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_unsafe_exec",
          "args": [
            "bprm"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "check_unsafe_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1232-1266",
          "snippet": "static void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace) {\n\t\tif (p->ptrace & PT_PTRACE_CAP)\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\n\t\telse\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\t}\n\n\t/*\n\t * This isn't strictly necessary, but it makes it harder for LSMs to\n\t * mess up.\n\t */\n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace) {\n\t\tif (p->ptrace & PT_PTRACE_CAP)\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\n\t\telse\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\t}\n\n\t/*\n\t * This isn't strictly necessary, but it makes it harder for LSMs to\n\t * mess up.\n\t */\n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_bprm_creds",
          "args": [
            "bprm"
          ],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_bprm_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1157-1168",
          "snippet": "int prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*bprm)",
            "GFP_KERNEL"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare_files",
          "args": [
            "&displaced"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_NPROC"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&current_user()->processes"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user",
          "args": [],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "filename"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filename"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int do_execveat_common(int fd, struct filename *filename,\n\t\t\t      struct user_arg_ptr argv,\n\t\t\t      struct user_arg_ptr envp,\n\t\t\t      int flags)\n{\n\tchar *pathbuf = NULL;\n\tstruct linux_binprm *bprm;\n\tstruct file *file;\n\tstruct files_struct *displaced;\n\tint retval;\n\n\tif (IS_ERR(filename))\n\t\treturn PTR_ERR(filename);\n\n\t/*\n\t * We move the actual failure in case of RLIMIT_NPROC excess from\n\t * set*uid() to execve() because too many poorly written programs\n\t * don't check setuid() return code.  Here we additionally recheck\n\t * whether NPROC limit is still exceeded.\n\t */\n\tif ((current->flags & PF_NPROC_EXCEEDED) &&\n\t    atomic_read(&current_user()->processes) > rlimit(RLIMIT_NPROC)) {\n\t\tretval = -EAGAIN;\n\t\tgoto out_ret;\n\t}\n\n\t/* We're below the limit (still or again), so we don't want to make\n\t * further execve() calls fail. */\n\tcurrent->flags &= ~PF_NPROC_EXCEEDED;\n\n\tretval = unshare_files(&displaced);\n\tif (retval)\n\t\tgoto out_ret;\n\n\tretval = -ENOMEM;\n\tbprm = kzalloc(sizeof(*bprm), GFP_KERNEL);\n\tif (!bprm)\n\t\tgoto out_files;\n\n\tretval = prepare_bprm_creds(bprm);\n\tif (retval)\n\t\tgoto out_free;\n\n\tcheck_unsafe_exec(bprm);\n\tcurrent->in_execve = 1;\n\n\tfile = do_open_execat(fd, filename, flags);\n\tretval = PTR_ERR(file);\n\tif (IS_ERR(file))\n\t\tgoto out_unmark;\n\n\tsched_exec();\n\n\tbprm->file = file;\n\tif (fd == AT_FDCWD || filename->name[0] == '/') {\n\t\tbprm->filename = filename->name;\n\t} else {\n\t\tif (filename->name[0] == '\\0')\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d\", fd);\n\t\telse\n\t\t\tpathbuf = kasprintf(GFP_TEMPORARY, \"/dev/fd/%d/%s\",\n\t\t\t\t\t    fd, filename->name);\n\t\tif (!pathbuf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_unmark;\n\t\t}\n\t\t/*\n\t\t * Record that a name derived from an O_CLOEXEC fd will be\n\t\t * inaccessible after exec. Relies on having exclusive access to\n\t\t * current->files (due to unshare_files above).\n\t\t */\n\t\tif (close_on_exec(fd, rcu_dereference_raw(current->files->fdt)))\n\t\t\tbprm->interp_flags |= BINPRM_FLAGS_PATH_INACCESSIBLE;\n\t\tbprm->filename = pathbuf;\n\t}\n\tbprm->interp = bprm->filename;\n\n\tretval = bprm_mm_init(bprm);\n\tif (retval)\n\t\tgoto out_unmark;\n\n\tbprm->argc = count(argv, MAX_ARG_STRINGS);\n\tif ((retval = bprm->argc) < 0)\n\t\tgoto out;\n\n\tbprm->envc = count(envp, MAX_ARG_STRINGS);\n\tif ((retval = bprm->envc) < 0)\n\t\tgoto out;\n\n\tretval = prepare_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings_kernel(1, &bprm->filename, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tbprm->exec = bprm->p;\n\tretval = copy_strings(bprm->envc, envp, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = copy_strings(bprm->argc, argv, bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = exec_binprm(bprm);\n\tif (retval < 0)\n\t\tgoto out;\n\n\t/* execve succeeded */\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\tacct_update_integrals(current);\n\ttask_numa_free(current);\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\tputname(filename);\n\tif (displaced)\n\t\tput_files_struct(displaced);\n\treturn retval;\n\nout:\n\tif (bprm->mm) {\n\t\tacct_arg_size(bprm, 0);\n\t\tmmput(bprm->mm);\n\t}\n\nout_unmark:\n\tcurrent->fs->in_exec = 0;\n\tcurrent->in_execve = 0;\n\nout_free:\n\tfree_bprm(bprm);\n\tkfree(pathbuf);\n\nout_files:\n\tif (displaced)\n\t\treset_files_struct(displaced);\nout_ret:\n\tputname(filename);\n\treturn retval;\n}"
  },
  {
    "function_name": "exec_binprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1420-1440",
    "snippet": "static int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_exec_connector",
          "args": [
            "current"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_event",
          "args": [
            "PTRACE_EVENT_EXEC",
            "old_vpid"
          ],
          "line": 1435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_sched_process_exec",
          "args": [
            "current",
            "old_pid",
            "bprm"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_bprm",
          "args": [
            "bprm"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_binary_handler",
          "args": [
            "bprm"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "search_binary_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1367-1417",
          "snippet": "int search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(formats);",
            "static DEFINE_RWLOCK(binfmt_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nint search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "task_active_pid_ns(current->parent)"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current->parent"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int exec_binprm(struct linux_binprm *bprm)\n{\n\tpid_t old_pid, old_vpid;\n\tint ret;\n\n\t/* Need to fetch pid before load_binary changes it */\n\told_pid = current->pid;\n\trcu_read_lock();\n\told_vpid = task_pid_nr_ns(current, task_active_pid_ns(current->parent));\n\trcu_read_unlock();\n\n\tret = search_binary_handler(bprm);\n\tif (ret >= 0) {\n\t\taudit_bprm(bprm);\n\t\ttrace_sched_process_exec(current, old_pid, bprm);\n\t\tptrace_event(PTRACE_EVENT_EXEC, old_vpid);\n\t\tproc_exec_connector(current);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "search_binary_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1367-1417",
    "snippet": "int search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(formats);",
      "static DEFINE_RWLOCK(binfmt_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "request_module",
          "args": [
            "\"binfmt-%04x\"",
            "*(ushort *)(bprm->buf + 2)"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable",
          "args": [
            "bprm->buf[3]"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable",
          "args": [
            "bprm->buf[2]"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable",
          "args": [
            "bprm->buf[1]"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable",
          "args": [
            "bprm->buf[0]"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_sigsegv",
          "args": [
            "SIGSEGV",
            "current"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_binfmt",
          "args": [
            "fmt"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "put_binfmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "96-99",
          "snippet": "static inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fmt->load_binary",
          "args": [
            "bprm"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "fmt->module"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fmt",
            "&formats",
            "lh"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_check",
          "args": [
            "bprm"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_MODULES"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nint search_binary_handler(struct linux_binprm *bprm)\n{\n\tbool need_retry = IS_ENABLED(CONFIG_MODULES);\n\tstruct linux_binfmt *fmt;\n\tint retval;\n\n\t/* This allows 4 levels of binfmt rewrites before failing hard. */\n\tif (bprm->recursion_depth > 5)\n\t\treturn -ELOOP;\n\n\tretval = security_bprm_check(bprm);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = -ENOENT;\n retry:\n\tread_lock(&binfmt_lock);\n\tlist_for_each_entry(fmt, &formats, lh) {\n\t\tif (!try_module_get(fmt->module))\n\t\t\tcontinue;\n\t\tread_unlock(&binfmt_lock);\n\t\tbprm->recursion_depth++;\n\t\tretval = fmt->load_binary(bprm);\n\t\tread_lock(&binfmt_lock);\n\t\tput_binfmt(fmt);\n\t\tbprm->recursion_depth--;\n\t\tif (retval < 0 && !bprm->mm) {\n\t\t\t/* we got to flush_old_exec() and failed after it */\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\tforce_sigsegv(SIGSEGV, current);\n\t\t\treturn retval;\n\t\t}\n\t\tif (retval != -ENOEXEC || !bprm->file) {\n\t\t\tread_unlock(&binfmt_lock);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tread_unlock(&binfmt_lock);\n\n\tif (need_retry) {\n\t\tif (printable(bprm->buf[0]) && printable(bprm->buf[1]) &&\n\t\t    printable(bprm->buf[2]) && printable(bprm->buf[3]))\n\t\t\treturn retval;\n\t\tif (request_module(\"binfmt-%04x\", *(ushort *)(bprm->buf + 2)) < 0)\n\t\t\treturn retval;\n\t\tneed_retry = false;\n\t\tgoto retry;\n\t}\n\n\treturn retval;\n}"
  },
  {
    "function_name": "remove_arg_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1324-1360",
    "snippet": "int remove_arg_zero(struct linux_binprm *bprm)\n{\n\tint ret = 0;\n\tunsigned long offset;\n\tchar *kaddr;\n\tstruct page *page;\n\n\tif (!bprm->argc)\n\t\treturn 0;\n\n\tdo {\n\t\toffset = bprm->p & ~PAGE_MASK;\n\t\tpage = get_arg_page(bprm, bprm->p, 0);\n\t\tif (!page) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\n\t\tfor (; offset < PAGE_SIZE && kaddr[offset];\n\t\t\t\toffset++, bprm->p++)\n\t\t\t;\n\n\t\tkunmap_atomic(kaddr);\n\t\tput_arg_page(page);\n\n\t\tif (offset == PAGE_SIZE)\n\t\t\tfree_arg_page(bprm, (bprm->p >> PAGE_SHIFT) - 1);\n\t} while (offset == PAGE_SIZE);\n\n\tbprm->p++;\n\tbprm->argc--;\n\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_arg_page",
          "args": [
            "bprm",
            "(bprm->p >> PAGE_SHIFT) - 1"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "free_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "322-328",
          "snippet": "static void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_arg_page",
          "args": [
            "page"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "put_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "318-320",
          "snippet": "static void put_arg_page(struct page *page)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void put_arg_page(struct page *page)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_arg_page",
          "args": [
            "bprm",
            "bprm->p",
            "0"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "get_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "302-316",
          "snippet": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint remove_arg_zero(struct linux_binprm *bprm)\n{\n\tint ret = 0;\n\tunsigned long offset;\n\tchar *kaddr;\n\tstruct page *page;\n\n\tif (!bprm->argc)\n\t\treturn 0;\n\n\tdo {\n\t\toffset = bprm->p & ~PAGE_MASK;\n\t\tpage = get_arg_page(bprm, bprm->p, 0);\n\t\tif (!page) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkaddr = kmap_atomic(page);\n\n\t\tfor (; offset < PAGE_SIZE && kaddr[offset];\n\t\t\t\toffset++, bprm->p++)\n\t\t\t;\n\n\t\tkunmap_atomic(kaddr);\n\t\tput_arg_page(page);\n\n\t\tif (offset == PAGE_SIZE)\n\t\t\tfree_arg_page(bprm, (bprm->p >> PAGE_SHIFT) - 1);\n\t} while (offset == PAGE_SIZE);\n\n\tbprm->p++;\n\tbprm->argc--;\n\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "prepare_binprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1274-1315",
    "snippet": "int prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\n\n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "bprm->file",
            "0",
            "bprm->buf",
            "BINPRM_BUF_SIZE"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "808-821",
          "snippet": "int kernel_read(struct file *file, loff_t offset,\n\t\tchar *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tint result;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tresult = vfs_read(file, (void __user *)addr, count, &pos);\n\tset_fs(old_fs);\n\treturn result;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint kernel_read(struct file *file, loff_t offset,\n\t\tchar *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tint result;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tresult = vfs_read(file, (void __user *)addr, count, &pos);\n\tset_fs(old_fs);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bprm->buf",
            "0",
            "BINPRM_BUF_SIZE"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_set_creds",
          "args": [
            "bprm"
          ],
          "line": 1308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kgid_has_mapping",
          "args": [
            "bprm->cred->user_ns",
            "inode->i_gid"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "bprm->cred->user_ns",
            "inode->i_uid"
          ],
          "line": 1287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "current"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_egid",
          "args": [],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "bprm->file"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_binprm(struct linux_binprm *bprm)\n{\n\tstruct inode *inode = file_inode(bprm->file);\n\tumode_t mode = inode->i_mode;\n\tint retval;\n\n\n\t/* clear any previous set[ug]id data from a previous binary */\n\tbprm->cred->euid = current_euid();\n\tbprm->cred->egid = current_egid();\n\n\tif (!(bprm->file->f_path.mnt->mnt_flags & MNT_NOSUID) &&\n\t    !task_no_new_privs(current) &&\n\t    kuid_has_mapping(bprm->cred->user_ns, inode->i_uid) &&\n\t    kgid_has_mapping(bprm->cred->user_ns, inode->i_gid)) {\n\t\t/* Set-uid? */\n\t\tif (mode & S_ISUID) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->euid = inode->i_uid;\n\t\t}\n\n\t\t/* Set-gid? */\n\t\t/*\n\t\t * If setgid is set but no group execute bit then this\n\t\t * is a candidate for mandatory locking, not a setgid\n\t\t * executable.\n\t\t */\n\t\tif ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n\t\t\tbprm->per_clear |= PER_CLEAR_ON_SETID;\n\t\t\tbprm->cred->egid = inode->i_gid;\n\t\t}\n\t}\n\n\t/* fill in binprm security blob */\n\tretval = security_bprm_set_creds(bprm);\n\tif (retval)\n\t\treturn retval;\n\tbprm->cred_prepared = 1;\n\n\tmemset(bprm->buf, 0, BINPRM_BUF_SIZE);\n\treturn kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);\n}"
  },
  {
    "function_name": "check_unsafe_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1232-1266",
    "snippet": "static void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace) {\n\t\tif (p->ptrace & PT_PTRACE_CAP)\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\n\t\telse\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\t}\n\n\t/*\n\t * This isn't strictly necessary, but it makes it harder for LSMs to\n\t * mess up.\n\t */\n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&p->fs->lock"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&p->fs->lock"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_no_new_privs",
          "args": [
            "current"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void check_unsafe_exec(struct linux_binprm *bprm)\n{\n\tstruct task_struct *p = current, *t;\n\tunsigned n_fs;\n\n\tif (p->ptrace) {\n\t\tif (p->ptrace & PT_PTRACE_CAP)\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE_CAP;\n\t\telse\n\t\t\tbprm->unsafe |= LSM_UNSAFE_PTRACE;\n\t}\n\n\t/*\n\t * This isn't strictly necessary, but it makes it harder for LSMs to\n\t * mess up.\n\t */\n\tif (task_no_new_privs(current))\n\t\tbprm->unsafe |= LSM_UNSAFE_NO_NEW_PRIVS;\n\n\tt = p;\n\tn_fs = 1;\n\tspin_lock(&p->fs->lock);\n\trcu_read_lock();\n\twhile_each_thread(p, t) {\n\t\tif (t->fs == p->fs)\n\t\t\tn_fs++;\n\t}\n\trcu_read_unlock();\n\n\tif (p->fs->users > n_fs)\n\t\tbprm->unsafe |= LSM_UNSAFE_SHARE;\n\telse\n\t\tp->fs->in_exec = 1;\n\tspin_unlock(&p->fs->lock);\n}"
  },
  {
    "function_name": "install_exec_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1202-1224",
    "snippet": "void install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_committed_creds",
          "args": [
            "bprm"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_exit_task",
          "args": [
            "current"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_dumpable",
          "args": [
            "current->mm"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "bprm->cred"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bprm_committing_creds",
          "args": [
            "bprm"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid install_exec_creds(struct linux_binprm *bprm)\n{\n\tsecurity_bprm_committing_creds(bprm);\n\n\tcommit_creds(bprm->cred);\n\tbprm->cred = NULL;\n\n\t/*\n\t * Disable monitoring for regular users\n\t * when executing setuid binaries. Must\n\t * wait until new credentials are committed\n\t * by commit_creds() above\n\t */\n\tif (get_dumpable(current->mm) != SUID_DUMP_USER)\n\t\tperf_event_exit_task(current);\n\t/*\n\t * cred_guard_mutex must be held at least to this point to prevent\n\t * ptrace_attach() from altering our determination of the task's\n\t * credentials; any time after this it may be unlocked.\n\t */\n\tsecurity_bprm_committed_creds(bprm);\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n}"
  },
  {
    "function_name": "bprm_change_interp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1187-1196",
    "snippet": "int bprm_change_interp(char *interp, struct linux_binprm *bprm)\n{\n\t/* If a binfmt changed the interp, free it first. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "interp",
            "GFP_KERNEL"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bprm->interp"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint bprm_change_interp(char *interp, struct linux_binprm *bprm)\n{\n\t/* If a binfmt changed the interp, free it first. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tbprm->interp = kstrdup(interp, GFP_KERNEL);\n\tif (!bprm->interp)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "free_bprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1170-1185",
    "snippet": "static void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\t/* If a binfmt changed the interp, free it. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bprm"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bprm->interp"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "bprm->file"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "allow_write_access",
          "args": [
            "bprm->file"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "bprm->cred"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_arg_pages",
          "args": [
            "bprm"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "free_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "330-336",
          "snippet": "static void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_bprm(struct linux_binprm *bprm)\n{\n\tfree_arg_pages(bprm);\n\tif (bprm->cred) {\n\t\tmutex_unlock(&current->signal->cred_guard_mutex);\n\t\tabort_creds(bprm->cred);\n\t}\n\tif (bprm->file) {\n\t\tallow_write_access(bprm->file);\n\t\tfput(bprm->file);\n\t}\n\t/* If a binfmt changed the interp, free it. */\n\tif (bprm->interp != bprm->filename)\n\t\tkfree(bprm->interp);\n\tkfree(bprm);\n}"
  },
  {
    "function_name": "prepare_bprm_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1157-1168",
    "snippet": "int prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "bprm->cred"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_exec_creds",
          "args": [],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&current->signal->cred_guard_mutex"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint prepare_bprm_creds(struct linux_binprm *bprm)\n{\n\tif (mutex_lock_interruptible(&current->signal->cred_guard_mutex))\n\t\treturn -ERESTARTNOINTR;\n\n\tbprm->cred = prepare_exec_creds();\n\tif (likely(bprm->cred))\n\t\treturn 0;\n\n\tmutex_unlock(&current->signal->cred_guard_mutex);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "setup_new_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1112-1148",
    "snippet": "void setup_new_exec(struct linux_binprm * bprm)\n{\n\tarch_pick_mmap_layout(current->mm);\n\n\t/* This is the point of no return */\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\tif (uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\telse\n\t\tset_dumpable(current->mm, suid_dumpable);\n\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* install the new credentials */\n\tif (!uid_eq(bprm->cred->uid, current_euid()) ||\n\t    !gid_eq(bprm->cred->gid, current_egid())) {\n\t\tcurrent->pdeath_signal = 0;\n\t} else {\n\t\twould_dump(bprm, bprm->file);\n\t\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)\n\t\t\tset_dumpable(current->mm, suid_dumpable);\n\t}\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n\tdo_close_on_exec(current->files);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int suid_dumpable = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_close_on_exec",
          "args": [
            "current->files"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "do_close_on_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file.c",
          "lines": "596-630",
          "snippet": "void do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t/* exec unshares first */\n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}",
          "includes": [
            "#include <linux/workqueue.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/bitops.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/time.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/workqueue.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/bitops.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/time.h>\n#include <linux/mmzone.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid do_close_on_exec(struct files_struct *files)\n{\n\tunsigned i;\n\tstruct fdtable *fdt;\n\n\t/* exec unshares first */\n\tspin_lock(&files->file_lock);\n\tfor (i = 0; ; i++) {\n\t\tunsigned long set;\n\t\tunsigned fd = i * BITS_PER_LONG;\n\t\tfdt = files_fdtable(files);\n\t\tif (fd >= fdt->max_fds)\n\t\t\tbreak;\n\t\tset = fdt->close_on_exec[i];\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tfdt->close_on_exec[i] = 0;\n\t\tfor ( ; set ; fd++, set >>= 1) {\n\t\t\tstruct file *file;\n\t\t\tif (!(set & 1))\n\t\t\t\tcontinue;\n\t\t\tfile = fdt->fd[fd];\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\trcu_assign_pointer(fdt->fd[fd], NULL);\n\t\t\t__put_unused_fd(files, fd);\n\t\t\tspin_unlock(&files->file_lock);\n\t\t\tfilp_close(file, files);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&files->file_lock);\n\t\t}\n\n\t}\n\tspin_unlock(&files->file_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_signal_handlers",
          "args": [
            "current",
            "0"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dumpable",
          "args": [
            "current->mm",
            "suid_dumpable"
          ],
          "line": 1140
        },
        "resolved": true,
        "details": {
          "function_name": "set_dumpable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1658-1669",
          "snippet": "void set_dumpable(struct mm_struct *mm, int value)\n{\n\tunsigned long old, new;\n\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tdo {\n\t\told = ACCESS_ONCE(mm->flags);\n\t\tnew = (old & ~MMF_DUMPABLE_MASK) | value;\n\t} while (cmpxchg(&mm->flags, old, new) != old);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid set_dumpable(struct mm_struct *mm, int value)\n{\n\tunsigned long old, new;\n\n\tif (WARN_ON((unsigned)value > SUID_DUMP_ROOT))\n\t\treturn;\n\n\tdo {\n\t\told = ACCESS_ONCE(mm->flags);\n\t\tnew = (old & ~MMF_DUMPABLE_MASK) | value;\n\t} while (cmpxchg(&mm->flags, old, new) != old);\n}"
        }
      },
      {
        "call_info": {
          "callee": "would_dump",
          "args": [
            "bprm",
            "bprm->file"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "would_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1105-1109",
          "snippet": "void would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tif (inode_permission(file_inode(file), MAY_READ) < 0)\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tif (inode_permission(file_inode(file), MAY_READ) < 0)\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "bprm->cred->gid",
            "current_egid()"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_egid",
          "args": [],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "bprm->cred->uid",
            "current_euid()"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_task_comm",
          "args": [
            "current",
            "kbasename(bprm->filename)",
            "true"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "1060-1067",
          "snippet": "void __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kbasename",
          "args": [
            "bprm->filename"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_event_exec",
          "args": [],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "current_egid()",
            "current_gid()"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_egid",
          "args": [],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_pick_mmap_layout",
          "args": [
            "current->mm"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint suid_dumpable = 0;\n\nvoid setup_new_exec(struct linux_binprm * bprm)\n{\n\tarch_pick_mmap_layout(current->mm);\n\n\t/* This is the point of no return */\n\tcurrent->sas_ss_sp = current->sas_ss_size = 0;\n\n\tif (uid_eq(current_euid(), current_uid()) && gid_eq(current_egid(), current_gid()))\n\t\tset_dumpable(current->mm, SUID_DUMP_USER);\n\telse\n\t\tset_dumpable(current->mm, suid_dumpable);\n\n\tperf_event_exec();\n\t__set_task_comm(current, kbasename(bprm->filename), true);\n\n\t/* Set the new mm task size. We have to do that late because it may\n\t * depend on TIF_32BIT which is only updated in flush_thread() on\n\t * some architectures like powerpc\n\t */\n\tcurrent->mm->task_size = TASK_SIZE;\n\n\t/* install the new credentials */\n\tif (!uid_eq(bprm->cred->uid, current_euid()) ||\n\t    !gid_eq(bprm->cred->gid, current_egid())) {\n\t\tcurrent->pdeath_signal = 0;\n\t} else {\n\t\twould_dump(bprm, bprm->file);\n\t\tif (bprm->interp_flags & BINPRM_FLAGS_ENFORCE_NONDUMP)\n\t\t\tset_dumpable(current->mm, suid_dumpable);\n\t}\n\n\t/* An exec changes our domain. We are no longer part of the thread\n\t   group */\n\tcurrent->self_exec_id++;\n\tflush_signal_handlers(current, 0);\n\tdo_close_on_exec(current->files);\n}"
  },
  {
    "function_name": "would_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1105-1109",
    "snippet": "void would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tif (inode_permission(file_inode(file), MAY_READ) < 0)\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "file_inode(file)",
            "MAY_READ"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid would_dump(struct linux_binprm *bprm, struct file *file)\n{\n\tif (inode_permission(file_inode(file), MAY_READ) < 0)\n\t\tbprm->interp_flags |= BINPRM_FLAGS_ENFORCE_NONDUMP;\n}"
  },
  {
    "function_name": "flush_old_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1069-1102",
    "snippet": "int flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\tbprm->mm = NULL;\t\t/* We're using it now */\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\treturn 0;\n\nout:\n\treturn retval;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_thread",
          "args": [],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "USER_DS"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exec_mmap",
          "args": [
            "bprm->mm"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "exec_mmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "834-876",
          "snippet": "static int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\n\t/* Notify parent that we're no longer interested in the old VM */\n\ttsk = current;\n\told_mm = current->mm;\n\tmm_release(tsk, old_mm);\n\n\tif (old_mm) {\n\t\tsync_mm_rss(old_mm);\n\t\t/*\n\t\t * Make sure that if there is a core dump in progress\n\t\t * for the old mm, we get out and die instead of going\n\t\t * through with the exec.  We must hold mmap_sem around\n\t\t * checking core_state and changing tsk->mm.\n\t\t */\n\t\tdown_read(&old_mm->mmap_sem);\n\t\tif (unlikely(old_mm->core_state)) {\n\t\t\tup_read(&old_mm->mmap_sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\ttask_lock(tsk);\n\tactive_mm = tsk->active_mm;\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tactivate_mm(active_mm, mm);\n\ttsk->mm->vmacache_seqnum = 0;\n\tvmacache_flush(tsk);\n\ttask_unlock(tsk);\n\tif (old_mm) {\n\t\tup_read(&old_mm->mmap_sem);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop(active_mm);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\n\t/* Notify parent that we're no longer interested in the old VM */\n\ttsk = current;\n\told_mm = current->mm;\n\tmm_release(tsk, old_mm);\n\n\tif (old_mm) {\n\t\tsync_mm_rss(old_mm);\n\t\t/*\n\t\t * Make sure that if there is a core dump in progress\n\t\t * for the old mm, we get out and die instead of going\n\t\t * through with the exec.  We must hold mmap_sem around\n\t\t * checking core_state and changing tsk->mm.\n\t\t */\n\t\tdown_read(&old_mm->mmap_sem);\n\t\tif (unlikely(old_mm->core_state)) {\n\t\t\tup_read(&old_mm->mmap_sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\ttask_lock(tsk);\n\tactive_mm = tsk->active_mm;\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tactivate_mm(active_mm, mm);\n\ttsk->mm->vmacache_seqnum = 0;\n\tvmacache_flush(tsk);\n\ttask_unlock(tsk);\n\tif (old_mm) {\n\t\tup_read(&old_mm->mmap_sem);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop(active_mm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acct_arg_size",
          "args": [
            "bprm",
            "0"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "acct_arg_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "298-300",
          "snippet": "static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_mm_exe_file",
          "args": [
            "bprm->mm",
            "bprm->file"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de_thread",
          "args": [
            "current"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "de_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "884-1043",
          "snippet": "static int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tschedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tsig->notify_count = -1;\t/* for exit_notify() */\n\t\tfor (;;) {\n\t\t\tthreadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tthreadgroup_change_end(tsk);\n\t\t\tschedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->real_start_time = leader->real_start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\ttsk->pid = leader->pid;\n\t\tchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tthreadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n\texit_itimers(sig);\n\tflush_itimer_signals();\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tschedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tsig->notify_count = -1;\t/* for exit_notify() */\n\t\tfor (;;) {\n\t\t\tthreadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tthreadgroup_change_end(tsk);\n\t\t\tschedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->real_start_time = leader->real_start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\ttsk->pid = leader->pid;\n\t\tchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tthreadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n\texit_itimers(sig);\n\tflush_itimer_signals();\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint flush_old_exec(struct linux_binprm * bprm)\n{\n\tint retval;\n\n\t/*\n\t * Make sure we have a private signal table and that\n\t * we are unassociated from the previous thread group.\n\t */\n\tretval = de_thread(current);\n\tif (retval)\n\t\tgoto out;\n\n\tset_mm_exe_file(bprm->mm, bprm->file);\n\t/*\n\t * Release all of the old mmap stuff\n\t */\n\tacct_arg_size(bprm, 0);\n\tretval = exec_mmap(bprm->mm);\n\tif (retval)\n\t\tgoto out;\n\n\tbprm->mm = NULL;\t\t/* We're using it now */\n\n\tset_fs(USER_DS);\n\tcurrent->flags &= ~(PF_RANDOMIZE | PF_FORKNOEXEC | PF_KTHREAD |\n\t\t\t\t\tPF_NOFREEZE | PF_NO_SETAFFINITY);\n\tflush_thread();\n\tcurrent->personality &= ~bprm->per_clear;\n\n\treturn 0;\n\nout:\n\treturn retval;\n}"
  },
  {
    "function_name": "__set_task_comm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1060-1067",
    "snippet": "void __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_event_comm",
          "args": [
            "tsk",
            "exec"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "tsk->comm",
            "buf",
            "sizeof(tsk->comm)"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_task_rename",
          "args": [
            "tsk",
            "buf"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nvoid __set_task_comm(struct task_struct *tsk, const char *buf, bool exec)\n{\n\ttask_lock(tsk);\n\ttrace_task_rename(tsk, buf);\n\tstrlcpy(tsk->comm, buf, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\tperf_event_comm(tsk, exec);\n}"
  },
  {
    "function_name": "get_task_comm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "1045-1052",
    "snippet": "char *get_task_comm(char *buf, struct task_struct *tsk)\n{\n\t/* buf must be at least sizeof(tsk->comm) in size */\n\ttask_lock(tsk);\n\tstrncpy(buf, tsk->comm, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\treturn buf;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf",
            "tsk->comm",
            "sizeof(tsk->comm)"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nchar *get_task_comm(char *buf, struct task_struct *tsk)\n{\n\t/* buf must be at least sizeof(tsk->comm) in size */\n\ttask_lock(tsk);\n\tstrncpy(buf, tsk->comm, sizeof(tsk->comm));\n\ttask_unlock(tsk);\n\treturn buf;\n}"
  },
  {
    "function_name": "de_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "884-1043",
    "snippet": "static int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tschedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tsig->notify_count = -1;\t/* for exit_notify() */\n\t\tfor (;;) {\n\t\t\tthreadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tthreadgroup_change_end(tsk);\n\t\t\tschedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->real_start_time = leader->real_start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\ttsk->pid = leader->pid;\n\t\tchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tthreadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n\texit_itimers(sig);\n\tflush_itimer_signals();\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!thread_group_leader(tsk)"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__cleanup_sighand",
          "args": [
            "oldsighand"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oldsighand->siglock"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tsk->sighand",
            "newsighand"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oldsighand->siglock"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "newsighand->action",
            "oldsighand->action",
            "sizeof(newsighand->action)"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&newsighand->count",
            "1"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "sighand_cachep",
            "GFP_KERNEL"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&oldsighand->count"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_itimer_signals",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit_itimers",
          "args": [
            "sig"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_task",
          "args": [
            "leader"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "release_task_mempolicy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/task_mmu.c",
          "lines": "112-114",
          "snippet": "static void release_task_mempolicy(struct proc_maps_private *priv)\n{\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/tlbflush.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/elf.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/swapops.h>",
            "#include <linux/swap.h>",
            "#include <linux/rmap.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/highmem.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/huge_mm.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/tlbflush.h>\n#include <asm/uaccess.h>\n#include <asm/elf.h>\n#include <linux/mmu_notifier.h>\n#include <linux/swapops.h>\n#include <linux/swap.h>\n#include <linux/rmap.h>\n#include <linux/mempolicy.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/ptrace.h>\n#include <linux/highmem.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/huge_mm.h>\n#include <linux/hugetlb.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n\nstatic void release_task_mempolicy(struct proc_maps_private *priv)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "threadgroup_change_end",
          "args": [
            "tsk"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__wake_up_parent",
          "args": [
            "leader",
            "leader->parent"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "leader->ptrace"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "leader->exit_state != EXIT_ZOMBIE"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&leader->sibling",
            "&tsk->sibling"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_replace_rcu",
          "args": [
            "&leader->tasks",
            "&tsk->tasks"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transfer_pid",
          "args": [
            "leader",
            "tsk",
            "PIDTYPE_SID"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "transfer_pid",
          "args": [
            "leader",
            "tsk",
            "PIDTYPE_PGID"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_pid",
          "args": [
            "tsk",
            "PIDTYPE_PID",
            "task_pid(leader)"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid",
          "args": [
            "leader"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "has_group_leader_pid(tsk)"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_group_leader_pid",
          "args": [
            "tsk"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!same_thread_group(leader, tsk)"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "leader",
            "tsk"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__fatal_signal_pending(tsk)"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "tsk"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "threadgroup_change_end",
          "args": [
            "tsk"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_KILLABLE"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "leader->exit_state"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "threadgroup_change_begin",
          "args": [
            "tsk"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "lock"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "lock"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "__fatal_signal_pending(tsk)"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "tsk"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "lock"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_KILLABLE"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "tsk"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "zap_other_threads",
          "args": [
            "tsk"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "lock"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_group_exit",
          "args": [
            "sig"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "lock"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int de_thread(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct sighand_struct *oldsighand = tsk->sighand;\n\tspinlock_t *lock = &oldsighand->siglock;\n\n\tif (thread_group_empty(tsk))\n\t\tgoto no_thread_group;\n\n\t/*\n\t * Kill all other threads in the thread group.\n\t */\n\tspin_lock_irq(lock);\n\tif (signal_group_exit(sig)) {\n\t\t/*\n\t\t * Another group action in progress, just\n\t\t * return so that the signal is processed.\n\t\t */\n\t\tspin_unlock_irq(lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tsig->group_exit_task = tsk;\n\tsig->notify_count = zap_other_threads(tsk);\n\tif (!thread_group_leader(tsk))\n\t\tsig->notify_count--;\n\n\twhile (sig->notify_count) {\n\t\t__set_current_state(TASK_KILLABLE);\n\t\tspin_unlock_irq(lock);\n\t\tschedule();\n\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\tgoto killed;\n\t\tspin_lock_irq(lock);\n\t}\n\tspin_unlock_irq(lock);\n\n\t/*\n\t * At this point all other threads have exited, all we have to\n\t * do is to wait for the thread group leader to become inactive,\n\t * and to assume its PID:\n\t */\n\tif (!thread_group_leader(tsk)) {\n\t\tstruct task_struct *leader = tsk->group_leader;\n\n\t\tsig->notify_count = -1;\t/* for exit_notify() */\n\t\tfor (;;) {\n\t\t\tthreadgroup_change_begin(tsk);\n\t\t\twrite_lock_irq(&tasklist_lock);\n\t\t\tif (likely(leader->exit_state))\n\t\t\t\tbreak;\n\t\t\t__set_current_state(TASK_KILLABLE);\n\t\t\twrite_unlock_irq(&tasklist_lock);\n\t\t\tthreadgroup_change_end(tsk);\n\t\t\tschedule();\n\t\t\tif (unlikely(__fatal_signal_pending(tsk)))\n\t\t\t\tgoto killed;\n\t\t}\n\n\t\t/*\n\t\t * The only record we have of the real-time age of a\n\t\t * process, regardless of execs it's done, is start_time.\n\t\t * All the past CPU time is accumulated in signal_struct\n\t\t * from sister threads now dead.  But in this non-leader\n\t\t * exec, nothing survives from the original leader thread,\n\t\t * whose birth marks the true age of this process now.\n\t\t * When we take on its identity by switching to its PID, we\n\t\t * also take its birthdate (always earlier than our own).\n\t\t */\n\t\ttsk->start_time = leader->start_time;\n\t\ttsk->real_start_time = leader->real_start_time;\n\n\t\tBUG_ON(!same_thread_group(leader, tsk));\n\t\tBUG_ON(has_group_leader_pid(tsk));\n\t\t/*\n\t\t * An exec() starts a new thread group with the\n\t\t * TGID of the previous thread group. Rehash the\n\t\t * two threads with a switched PID, and release\n\t\t * the former thread group leader:\n\t\t */\n\n\t\t/* Become a process group leader with the old leader's pid.\n\t\t * The old leader becomes a thread of the this thread group.\n\t\t * Note: The old leader also uses this pid until release_task\n\t\t *       is called.  Odd but simple and correct.\n\t\t */\n\t\ttsk->pid = leader->pid;\n\t\tchange_pid(tsk, PIDTYPE_PID, task_pid(leader));\n\t\ttransfer_pid(leader, tsk, PIDTYPE_PGID);\n\t\ttransfer_pid(leader, tsk, PIDTYPE_SID);\n\n\t\tlist_replace_rcu(&leader->tasks, &tsk->tasks);\n\t\tlist_replace_init(&leader->sibling, &tsk->sibling);\n\n\t\ttsk->group_leader = tsk;\n\t\tleader->group_leader = tsk;\n\n\t\ttsk->exit_signal = SIGCHLD;\n\t\tleader->exit_signal = -1;\n\n\t\tBUG_ON(leader->exit_state != EXIT_ZOMBIE);\n\t\tleader->exit_state = EXIT_DEAD;\n\n\t\t/*\n\t\t * We are going to release_task()->ptrace_unlink() silently,\n\t\t * the tracer can sleep in do_wait(). EXIT_DEAD guarantees\n\t\t * the tracer wont't block again waiting for this thread.\n\t\t */\n\t\tif (unlikely(leader->ptrace))\n\t\t\t__wake_up_parent(leader, leader->parent);\n\t\twrite_unlock_irq(&tasklist_lock);\n\t\tthreadgroup_change_end(tsk);\n\n\t\trelease_task(leader);\n\t}\n\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\nno_thread_group:\n\t/* we have changed execution domain */\n\ttsk->exit_signal = SIGCHLD;\n\n\texit_itimers(sig);\n\tflush_itimer_signals();\n\n\tif (atomic_read(&oldsighand->count) != 1) {\n\t\tstruct sighand_struct *newsighand;\n\t\t/*\n\t\t * This ->sighand is shared with the CLONE_SIGHAND\n\t\t * but not CLONE_THREAD task, switch to the new one.\n\t\t */\n\t\tnewsighand = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);\n\t\tif (!newsighand)\n\t\t\treturn -ENOMEM;\n\n\t\tatomic_set(&newsighand->count, 1);\n\t\tmemcpy(newsighand->action, oldsighand->action,\n\t\t       sizeof(newsighand->action));\n\n\t\twrite_lock_irq(&tasklist_lock);\n\t\tspin_lock(&oldsighand->siglock);\n\t\trcu_assign_pointer(tsk->sighand, newsighand);\n\t\tspin_unlock(&oldsighand->siglock);\n\t\twrite_unlock_irq(&tasklist_lock);\n\n\t\t__cleanup_sighand(oldsighand);\n\t}\n\n\tBUG_ON(!thread_group_leader(tsk));\n\treturn 0;\n\nkilled:\n\t/* protects against exit_notify() and __exit_signal() */\n\tread_lock(&tasklist_lock);\n\tsig->group_exit_task = NULL;\n\tsig->notify_count = 0;\n\tread_unlock(&tasklist_lock);\n\treturn -EAGAIN;\n}"
  },
  {
    "function_name": "exec_mmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "834-876",
    "snippet": "static int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\n\t/* Notify parent that we're no longer interested in the old VM */\n\ttsk = current;\n\told_mm = current->mm;\n\tmm_release(tsk, old_mm);\n\n\tif (old_mm) {\n\t\tsync_mm_rss(old_mm);\n\t\t/*\n\t\t * Make sure that if there is a core dump in progress\n\t\t * for the old mm, we get out and die instead of going\n\t\t * through with the exec.  We must hold mmap_sem around\n\t\t * checking core_state and changing tsk->mm.\n\t\t */\n\t\tdown_read(&old_mm->mmap_sem);\n\t\tif (unlikely(old_mm->core_state)) {\n\t\t\tup_read(&old_mm->mmap_sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\ttask_lock(tsk);\n\tactive_mm = tsk->active_mm;\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tactivate_mm(active_mm, mm);\n\ttsk->mm->vmacache_seqnum = 0;\n\tvmacache_flush(tsk);\n\ttask_unlock(tsk);\n\tif (old_mm) {\n\t\tup_read(&old_mm->mmap_sem);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop(active_mm);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "active_mm"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmput",
          "args": [
            "old_mm"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_update_next_owner",
          "args": [
            "old_mm"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setmax_mm_hiwater_rss",
          "args": [
            "&tsk->signal->maxrss",
            "old_mm"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "active_mm != old_mm"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&old_mm->mmap_sem"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "tsk"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmacache_flush",
          "args": [
            "tsk"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "activate_mm",
          "args": [
            "active_mm",
            "mm"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "tsk"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&old_mm->mmap_sem"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "old_mm->core_state"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&old_mm->mmap_sem"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_mm_rss",
          "args": [
            "old_mm"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mm_release",
          "args": [
            "tsk",
            "old_mm"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int exec_mmap(struct mm_struct *mm)\n{\n\tstruct task_struct *tsk;\n\tstruct mm_struct *old_mm, *active_mm;\n\n\t/* Notify parent that we're no longer interested in the old VM */\n\ttsk = current;\n\told_mm = current->mm;\n\tmm_release(tsk, old_mm);\n\n\tif (old_mm) {\n\t\tsync_mm_rss(old_mm);\n\t\t/*\n\t\t * Make sure that if there is a core dump in progress\n\t\t * for the old mm, we get out and die instead of going\n\t\t * through with the exec.  We must hold mmap_sem around\n\t\t * checking core_state and changing tsk->mm.\n\t\t */\n\t\tdown_read(&old_mm->mmap_sem);\n\t\tif (unlikely(old_mm->core_state)) {\n\t\t\tup_read(&old_mm->mmap_sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\ttask_lock(tsk);\n\tactive_mm = tsk->active_mm;\n\ttsk->mm = mm;\n\ttsk->active_mm = mm;\n\tactivate_mm(active_mm, mm);\n\ttsk->mm->vmacache_seqnum = 0;\n\tvmacache_flush(tsk);\n\ttask_unlock(tsk);\n\tif (old_mm) {\n\t\tup_read(&old_mm->mmap_sem);\n\t\tBUG_ON(active_mm != old_mm);\n\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, old_mm);\n\t\tmm_update_next_owner(old_mm);\n\t\tmmput(old_mm);\n\t\treturn 0;\n\t}\n\tmmdrop(active_mm);\n\treturn 0;\n}"
  },
  {
    "function_name": "read_code",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "825-831",
    "snippet": "ssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_icache_range",
          "args": [
            "addr",
            "addr + len"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_read",
          "args": [
            "file",
            "(void __user *)addr",
            "len",
            "&pos"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "917-926",
          "snippet": "ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(READ, file, vec, vlen, pos);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(READ, file, vec, vlen, pos);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nssize_t read_code(struct file *file, unsigned long addr, loff_t pos, size_t len)\n{\n\tssize_t res = vfs_read(file, (void __user *)addr, len, &pos);\n\tif (res > 0)\n\t\tflush_icache_range(addr, addr + len);\n\treturn res;\n}"
  },
  {
    "function_name": "kernel_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "808-821",
    "snippet": "int kernel_read(struct file *file, loff_t offset,\n\t\tchar *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tint result;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tresult = vfs_read(file, (void __user *)addr, count, &pos);\n\tset_fs(old_fs);\n\treturn result;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_read",
          "args": [
            "file",
            "(void __user *)addr",
            "count",
            "&pos"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "917-926",
          "snippet": "ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(READ, file, vec, vlen, pos);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(READ, file, vec, vlen, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "get_ds()"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint kernel_read(struct file *file, loff_t offset,\n\t\tchar *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tint result;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tresult = vfs_read(file, (void __user *)addr, count, &pos);\n\tset_fs(old_fs);\n\treturn result;\n}"
  },
  {
    "function_name": "open_exec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "795-805",
    "snippet": "struct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "filename"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "putname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "245-257",
          "snippet": "void putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid putname(struct filename *name)\n{\n\tBUG_ON(name->refcnt <= 0);\n\n\tif (--name->refcnt > 0)\n\t\treturn;\n\n\tif (name->separate) {\n\t\t__putname(name->name);\n\t\tkfree(name);\n\t} else\n\t\t__putname(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_open_execat",
          "args": [
            "AT_FDCWD",
            "filename",
            "0"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "do_open_execat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "751-793",
          "snippet": "static struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC | MAY_OPEN,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC | MAY_OPEN,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "filename"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "filename"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getname_kernel",
          "args": [
            "name"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "getname_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "208-243",
          "snippet": "struct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)(result) + sizeof(*result);\n\t\tresult->separate = false;\n\t} else if (len <= PATH_MAX) {\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\ttmp->separate = true;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EMBEDDED_NAME_MAX\t(PATH_MAX - sizeof(struct filename))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\n#define EMBEDDED_NAME_MAX\t(PATH_MAX - sizeof(struct filename))\n\nstruct filename *\ngetname_kernel(const char * filename)\n{\n\tstruct filename *result;\n\tint len = strlen(filename) + 1;\n\n\tresult = __getname();\n\tif (unlikely(!result))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (len <= EMBEDDED_NAME_MAX) {\n\t\tresult->name = (char *)(result) + sizeof(*result);\n\t\tresult->separate = false;\n\t} else if (len <= PATH_MAX) {\n\t\tstruct filename *tmp;\n\n\t\ttmp = kmalloc(sizeof(*tmp), GFP_KERNEL);\n\t\tif (unlikely(!tmp)) {\n\t\t\t__putname(result);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\ttmp->name = (char *)result;\n\t\ttmp->separate = true;\n\t\tresult = tmp;\n\t} else {\n\t\t__putname(result);\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\tmemcpy((char *)result->name, filename, len);\n\tresult->uptr = NULL;\n\tresult->aname = NULL;\n\tresult->refcnt = 1;\n\taudit_getname(result);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstruct file *open_exec(const char *name)\n{\n\tstruct filename *filename = getname_kernel(name);\n\tstruct file *f = ERR_CAST(filename);\n\n\tif (!IS_ERR(filename)) {\n\t\tf = do_open_execat(AT_FDCWD, filename, 0);\n\t\tputname(filename);\n\t}\n\treturn f;\n}"
  },
  {
    "function_name": "do_open_execat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "751-793",
    "snippet": "static struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC | MAY_OPEN,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "__fput_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/file_table.c",
          "lines": "293-300",
          "snippet": "void __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/ima.h>",
            "#include <linux/task_work.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/percpu_counter.h>",
            "#include <linux/lglock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/cdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/mount.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/atomic.h>\n#include <linux/ima.h>\n#include <linux/task_work.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/percpu_counter.h>\n#include <linux/lglock.h>\n#include <linux/sysctl.h>\n#include <linux/fsnotify.h>\n#include <linux/cdev.h>\n#include <linux/capability.h>\n#include <linux/mount.h>\n#include <linux/rcupdate.h>\n#include <linux/eventpoll.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid __fput_sync(struct file *file)\n{\n\tif (atomic_long_dec_and_test(&file->f_count)) {\n\t\tstruct task_struct *task = current;\n\t\tBUG_ON(!(task->flags & PF_KTHREAD));\n\t\t__fput(file);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsnotify_open",
          "args": [
            "file"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deny_write_access",
          "args": [
            "file"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "file_inode(file)->i_mode"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_filp_open",
          "args": [
            "fd",
            "name",
            "&open_exec_flags"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "do_filp_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3275-3288",
          "snippet": "struct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);\n\treturn filp;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int link_path_walk(const char *, struct nameidata *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstatic int link_path_walk(const char *, struct nameidata *);\n\nstruct file *do_filp_open(int dfd, struct filename *pathname,\n\t\tconst struct open_flags *op)\n{\n\tstruct nameidata nd;\n\tint flags = op->lookup_flags;\n\tstruct file *filp;\n\n\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_RCU);\n\tif (unlikely(filp == ERR_PTR(-ECHILD)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags);\n\tif (unlikely(filp == ERR_PTR(-ESTALE)))\n\t\tfilp = path_openat(dfd, pathname, &nd, op, flags | LOOKUP_REVAL);\n\treturn filp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct file *do_open_execat(int fd, struct filename *name, int flags)\n{\n\tstruct file *file;\n\tint err;\n\tstruct open_flags open_exec_flags = {\n\t\t.open_flag = O_LARGEFILE | O_RDONLY | __FMODE_EXEC,\n\t\t.acc_mode = MAY_EXEC | MAY_OPEN,\n\t\t.intent = LOOKUP_OPEN,\n\t\t.lookup_flags = LOOKUP_FOLLOW,\n\t};\n\n\tif ((flags & ~(AT_SYMLINK_NOFOLLOW | AT_EMPTY_PATH)) != 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (flags & AT_SYMLINK_NOFOLLOW)\n\t\topen_exec_flags.lookup_flags &= ~LOOKUP_FOLLOW;\n\tif (flags & AT_EMPTY_PATH)\n\t\topen_exec_flags.lookup_flags |= LOOKUP_EMPTY;\n\n\tfile = do_filp_open(fd, name, &open_exec_flags);\n\tif (IS_ERR(file))\n\t\tgoto out;\n\n\terr = -EACCES;\n\tif (!S_ISREG(file_inode(file)->i_mode))\n\t\tgoto exit;\n\n\tif (file->f_path.mnt->mnt_flags & MNT_NOEXEC)\n\t\tgoto exit;\n\n\terr = deny_write_access(file);\n\tif (err)\n\t\tgoto exit;\n\n\tif (name->name[0] != '\\0')\n\t\tfsnotify_open(file);\n\nout:\n\treturn file;\n\nexit:\n\tfput(file);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "setup_arg_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "641-746",
    "snippet": "int setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = rlimit_max(RLIMIT_STACK);\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tdown_write(&mm->mmap_sem);\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = rlimit(RLIMIT_STACK) & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_stack",
          "args": [
            "vma",
            "stack_base"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_STACK"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shift_arg_pages",
          "args": [
            "vma",
            "stack_shift"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "shift_arg_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "576-635",
          "snippet": "static int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, old_start, old_end);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb, old_start, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, old_start, old_end);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb, old_start, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "prev != vma"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mprotect_fixup",
          "args": [
            "vma",
            "&prev",
            "vma->vm_start",
            "vma->vm_end",
            "vm_flags"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "executable_stack == EXSTACK_ENABLE_X"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "stack_top < mmap_min_addr"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "stack_top"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_align_stack",
          "args": [
            "stack_top"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PAGE_ALIGN",
          "args": [
            "stack_top - stack_base"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit_max",
          "args": [
            "RLIMIT_STACK"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint setup_arg_pages(struct linux_binprm *bprm,\n\t\t    unsigned long stack_top,\n\t\t    int executable_stack)\n{\n\tunsigned long ret;\n\tunsigned long stack_shift;\n\tstruct mm_struct *mm = current->mm;\n\tstruct vm_area_struct *vma = bprm->vma;\n\tstruct vm_area_struct *prev = NULL;\n\tunsigned long vm_flags;\n\tunsigned long stack_base;\n\tunsigned long stack_size;\n\tunsigned long stack_expand;\n\tunsigned long rlim_stack;\n\n#ifdef CONFIG_STACK_GROWSUP\n\t/* Limit stack size */\n\tstack_base = rlimit_max(RLIMIT_STACK);\n\tif (stack_base > STACK_SIZE_MAX)\n\t\tstack_base = STACK_SIZE_MAX;\n\n\t/* Make sure we didn't let the argument array grow too large. */\n\tif (vma->vm_end - vma->vm_start > stack_base)\n\t\treturn -ENOMEM;\n\n\tstack_base = PAGE_ALIGN(stack_top - stack_base);\n\n\tstack_shift = vma->vm_start - stack_base;\n\tmm->arg_start = bprm->p - stack_shift;\n\tbprm->p = vma->vm_end - stack_shift;\n#else\n\tstack_top = arch_align_stack(stack_top);\n\tstack_top = PAGE_ALIGN(stack_top);\n\n\tif (unlikely(stack_top < mmap_min_addr) ||\n\t    unlikely(vma->vm_end - vma->vm_start >= stack_top - mmap_min_addr))\n\t\treturn -ENOMEM;\n\n\tstack_shift = vma->vm_end - stack_top;\n\n\tbprm->p -= stack_shift;\n\tmm->arg_start = bprm->p;\n#endif\n\n\tif (bprm->loader)\n\t\tbprm->loader -= stack_shift;\n\tbprm->exec -= stack_shift;\n\n\tdown_write(&mm->mmap_sem);\n\tvm_flags = VM_STACK_FLAGS;\n\n\t/*\n\t * Adjust stack execute permissions; explicitly enable for\n\t * EXSTACK_ENABLE_X, disable for EXSTACK_DISABLE_X and leave alone\n\t * (arch default) otherwise.\n\t */\n\tif (unlikely(executable_stack == EXSTACK_ENABLE_X))\n\t\tvm_flags |= VM_EXEC;\n\telse if (executable_stack == EXSTACK_DISABLE_X)\n\t\tvm_flags &= ~VM_EXEC;\n\tvm_flags |= mm->def_flags;\n\tvm_flags |= VM_STACK_INCOMPLETE_SETUP;\n\n\tret = mprotect_fixup(vma, &prev, vma->vm_start, vma->vm_end,\n\t\t\tvm_flags);\n\tif (ret)\n\t\tgoto out_unlock;\n\tBUG_ON(prev != vma);\n\n\t/* Move stack pages down in memory. */\n\tif (stack_shift) {\n\t\tret = shift_arg_pages(vma, stack_shift);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\t/* mprotect_fixup is overkill to remove the temporary stack flags */\n\tvma->vm_flags &= ~VM_STACK_INCOMPLETE_SETUP;\n\n\tstack_expand = 131072UL; /* randomly 32*4k (or 2*64k) pages */\n\tstack_size = vma->vm_end - vma->vm_start;\n\t/*\n\t * Align this down to a page boundary as expand_stack\n\t * will align it up.\n\t */\n\trlim_stack = rlimit(RLIMIT_STACK) & PAGE_MASK;\n#ifdef CONFIG_STACK_GROWSUP\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_start + rlim_stack;\n\telse\n\t\tstack_base = vma->vm_end + stack_expand;\n#else\n\tif (stack_size + stack_expand > rlim_stack)\n\t\tstack_base = vma->vm_end - rlim_stack;\n\telse\n\t\tstack_base = vma->vm_start - stack_expand;\n#endif\n\tcurrent->mm->start_stack = bprm->p;\n\tret = expand_stack(vma, stack_base);\n\tif (ret)\n\t\tret = -EFAULT;\n\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "shift_arg_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "576-635",
    "snippet": "static int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, old_start, old_end);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb, old_start, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vma_adjust",
          "args": [
            "vma",
            "new_start",
            "new_end",
            "vma->vm_pgoff",
            "NULL"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_finish_mmu",
          "args": [
            "&tlb",
            "old_start",
            "old_end"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pgd_range",
          "args": [
            "&tlb",
            "old_start",
            "old_end",
            "new_end",
            "vma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_pgd_range",
          "args": [
            "&tlb",
            "new_end",
            "old_end",
            "new_end",
            "vma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tlb_gather_mmu",
          "args": [
            "&tlb",
            "mm",
            "old_start",
            "old_end"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lru_add_drain",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "move_page_tables",
          "args": [
            "vma",
            "old_start",
            "vma",
            "new_start",
            "length",
            "false"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vma_adjust",
          "args": [
            "vma",
            "new_start",
            "old_end",
            "vma->vm_pgoff",
            "NULL"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vma",
          "args": [
            "mm",
            "new_start"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "new_start > new_end"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int shift_arg_pages(struct vm_area_struct *vma, unsigned long shift)\n{\n\tstruct mm_struct *mm = vma->vm_mm;\n\tunsigned long old_start = vma->vm_start;\n\tunsigned long old_end = vma->vm_end;\n\tunsigned long length = old_end - old_start;\n\tunsigned long new_start = old_start - shift;\n\tunsigned long new_end = old_end - shift;\n\tstruct mmu_gather tlb;\n\n\tBUG_ON(new_start > new_end);\n\n\t/*\n\t * ensure there are no vmas between where we want to go\n\t * and where we are\n\t */\n\tif (vma != find_vma(mm, new_start))\n\t\treturn -EFAULT;\n\n\t/*\n\t * cover the whole range: [new_start, old_end)\n\t */\n\tif (vma_adjust(vma, new_start, old_end, vma->vm_pgoff, NULL))\n\t\treturn -ENOMEM;\n\n\t/*\n\t * move the page tables downwards, on failure we rely on\n\t * process cleanup to remove whatever mess we made.\n\t */\n\tif (length != move_page_tables(vma, old_start,\n\t\t\t\t       vma, new_start, length, false))\n\t\treturn -ENOMEM;\n\n\tlru_add_drain();\n\ttlb_gather_mmu(&tlb, mm, old_start, old_end);\n\tif (new_end > old_start) {\n\t\t/*\n\t\t * when the old and new regions overlap clear from new_end.\n\t\t */\n\t\tfree_pgd_range(&tlb, new_end, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t} else {\n\t\t/*\n\t\t * otherwise, clean from old_start; this is done to not touch\n\t\t * the address space in [new_end, old_start) some architectures\n\t\t * have constraints on va-space that make this illegal (IA64) -\n\t\t * for the others its just a little faster.\n\t\t */\n\t\tfree_pgd_range(&tlb, old_start, old_end, new_end,\n\t\t\tvma->vm_next ? vma->vm_next->vm_start : USER_PGTABLES_CEILING);\n\t}\n\ttlb_finish_mmu(&tlb, old_start, old_end);\n\n\t/*\n\t * Shrink the vma to just the new range.  Always succeeds.\n\t */\n\tvma_adjust(vma, new_start, new_end, vma->vm_pgoff, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_strings_kernel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "545-559",
    "snippet": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "oldfs"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_strings",
          "args": [
            "argc",
            "argv",
            "bprm"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "copy_strings_kernel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "545-559",
          "snippet": "int copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "KERNEL_DS"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nint copy_strings_kernel(int argc, const char *const *__argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tint r;\n\tmm_segment_t oldfs = get_fs();\n\tstruct user_arg_ptr argv = {\n\t\t.ptr.native = (const char __user *const  __user *)__argv,\n\t};\n\n\tset_fs(KERNEL_DS);\n\tr = copy_strings(argc, argv, bprm);\n\tset_fs(oldfs);\n\n\treturn r;\n}"
  },
  {
    "function_name": "copy_strings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "454-540",
    "snippet": "static int copy_strings(int argc, struct user_arg_ptr argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tstruct page *kmapped_page = NULL;\n\tchar *kaddr = NULL;\n\tunsigned long kpos = 0;\n\tint ret;\n\n\twhile (argc-- > 0) {\n\t\tconst char __user *str;\n\t\tint len;\n\t\tunsigned long pos;\n\n\t\tret = -EFAULT;\n\t\tstr = get_user_arg_ptr(argv, argc);\n\t\tif (IS_ERR(str))\n\t\t\tgoto out;\n\n\t\tlen = strnlen_user(str, MAX_ARG_STRLEN);\n\t\tif (!len)\n\t\t\tgoto out;\n\n\t\tret = -E2BIG;\n\t\tif (!valid_arg_len(bprm, len))\n\t\t\tgoto out;\n\n\t\t/* We're going to work our way backwords. */\n\t\tpos = bprm->p;\n\t\tstr += len;\n\t\tbprm->p -= len;\n\n\t\twhile (len > 0) {\n\t\t\tint offset, bytes_to_copy;\n\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tret = -ERESTARTNOHAND;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\toffset = pos % PAGE_SIZE;\n\t\t\tif (offset == 0)\n\t\t\t\toffset = PAGE_SIZE;\n\n\t\t\tbytes_to_copy = offset;\n\t\t\tif (bytes_to_copy > len)\n\t\t\t\tbytes_to_copy = len;\n\n\t\t\toffset -= bytes_to_copy;\n\t\t\tpos -= bytes_to_copy;\n\t\t\tstr -= bytes_to_copy;\n\t\t\tlen -= bytes_to_copy;\n\n\t\t\tif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = get_arg_page(bprm, pos, 1);\n\t\t\t\tif (!page) {\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (kmapped_page) {\n\t\t\t\t\tflush_kernel_dcache_page(kmapped_page);\n\t\t\t\t\tkunmap(kmapped_page);\n\t\t\t\t\tput_arg_page(kmapped_page);\n\t\t\t\t}\n\t\t\t\tkmapped_page = page;\n\t\t\t\tkaddr = kmap(kmapped_page);\n\t\t\t\tkpos = pos & PAGE_MASK;\n\t\t\t\tflush_arg_page(bprm, kpos, kmapped_page);\n\t\t\t}\n\t\t\tif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nout:\n\tif (kmapped_page) {\n\t\tflush_kernel_dcache_page(kmapped_page);\n\t\tkunmap(kmapped_page);\n\t\tput_arg_page(kmapped_page);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_arg_page",
          "args": [
            "kmapped_page"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "put_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "318-320",
          "snippet": "static void put_arg_page(struct page *page)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void put_arg_page(struct page *page)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "kmapped_page"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_kernel_dcache_page",
          "args": [
            "kmapped_page"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kaddr+offset",
            "str",
            "bytes_to_copy"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_arg_page",
          "args": [
            "bprm",
            "kpos",
            "kmapped_page"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "flush_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "338-341",
          "snippet": "static void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "kmapped_page"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "kmapped_page"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_kernel_dcache_page",
          "args": [
            "kmapped_page"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_arg_page",
          "args": [
            "bprm",
            "pos",
            "1"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "get_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "302-316",
          "snippet": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_arg_len",
          "args": [
            "bprm",
            "len"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "valid_arg_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "349-352",
          "snippet": "static bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "str",
            "MAX_ARG_STRLEN"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "str"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_arg_ptr",
          "args": [
            "argv",
            "argc"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int copy_strings(int argc, struct user_arg_ptr argv,\n\t\t\tstruct linux_binprm *bprm)\n{\n\tstruct page *kmapped_page = NULL;\n\tchar *kaddr = NULL;\n\tunsigned long kpos = 0;\n\tint ret;\n\n\twhile (argc-- > 0) {\n\t\tconst char __user *str;\n\t\tint len;\n\t\tunsigned long pos;\n\n\t\tret = -EFAULT;\n\t\tstr = get_user_arg_ptr(argv, argc);\n\t\tif (IS_ERR(str))\n\t\t\tgoto out;\n\n\t\tlen = strnlen_user(str, MAX_ARG_STRLEN);\n\t\tif (!len)\n\t\t\tgoto out;\n\n\t\tret = -E2BIG;\n\t\tif (!valid_arg_len(bprm, len))\n\t\t\tgoto out;\n\n\t\t/* We're going to work our way backwords. */\n\t\tpos = bprm->p;\n\t\tstr += len;\n\t\tbprm->p -= len;\n\n\t\twhile (len > 0) {\n\t\t\tint offset, bytes_to_copy;\n\n\t\t\tif (fatal_signal_pending(current)) {\n\t\t\t\tret = -ERESTARTNOHAND;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcond_resched();\n\n\t\t\toffset = pos % PAGE_SIZE;\n\t\t\tif (offset == 0)\n\t\t\t\toffset = PAGE_SIZE;\n\n\t\t\tbytes_to_copy = offset;\n\t\t\tif (bytes_to_copy > len)\n\t\t\t\tbytes_to_copy = len;\n\n\t\t\toffset -= bytes_to_copy;\n\t\t\tpos -= bytes_to_copy;\n\t\t\tstr -= bytes_to_copy;\n\t\t\tlen -= bytes_to_copy;\n\n\t\t\tif (!kmapped_page || kpos != (pos & PAGE_MASK)) {\n\t\t\t\tstruct page *page;\n\n\t\t\t\tpage = get_arg_page(bprm, pos, 1);\n\t\t\t\tif (!page) {\n\t\t\t\t\tret = -E2BIG;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\tif (kmapped_page) {\n\t\t\t\t\tflush_kernel_dcache_page(kmapped_page);\n\t\t\t\t\tkunmap(kmapped_page);\n\t\t\t\t\tput_arg_page(kmapped_page);\n\t\t\t\t}\n\t\t\t\tkmapped_page = page;\n\t\t\t\tkaddr = kmap(kmapped_page);\n\t\t\t\tkpos = pos & PAGE_MASK;\n\t\t\t\tflush_arg_page(bprm, kpos, kmapped_page);\n\t\t\t}\n\t\t\tif (copy_from_user(kaddr+offset, str, bytes_to_copy)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nout:\n\tif (kmapped_page) {\n\t\tflush_kernel_dcache_page(kmapped_page);\n\t\tkunmap(kmapped_page);\n\t\tput_arg_page(kmapped_page);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "423-447",
    "snippet": "static int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "current"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_arg_ptr",
          "args": [
            "argv",
            "i"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int count(struct user_arg_ptr argv, int max)\n{\n\tint i = 0;\n\n\tif (argv.ptr.native != NULL) {\n\t\tfor (;;) {\n\t\t\tconst char __user *p = get_user_arg_ptr(argv, i);\n\n\t\t\tif (!p)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR(p))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tif (i >= max)\n\t\t\t\treturn -E2BIG;\n\t\t\t++i;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\treturn -ERESTARTNOHAND;\n\t\t\tcond_resched();\n\t\t}\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "get_user_arg_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "399-418",
    "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "native",
            "argv.ptr.native + nr"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "get_user_arg_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "399-418",
          "snippet": "static const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "compat"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EFAULT"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "argv.is_compat"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic const char __user *get_user_arg_ptr(struct user_arg_ptr argv, int nr)\n{\n\tconst char __user *native;\n\n#ifdef CONFIG_COMPAT\n\tif (unlikely(argv.is_compat)) {\n\t\tcompat_uptr_t compat;\n\n\t\tif (get_user(compat, argv.ptr.compat + nr))\n\t\t\treturn ERR_PTR(-EFAULT);\n\n\t\treturn compat_ptr(compat);\n\t}\n#endif\n\n\tif (get_user(native, argv.ptr.native + nr))\n\t\treturn ERR_PTR(-EFAULT);\n\n\treturn native;\n}"
  },
  {
    "function_name": "bprm_mm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "362-385",
    "snippet": "static int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmdrop",
          "args": [
            "mm"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bprm_mm_init",
          "args": [
            "bprm"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "__bprm_mm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "343-347",
          "snippet": "static int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mm_alloc",
          "args": [],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct mm_struct *mm = NULL;\n\n\tbprm->mm = mm = mm_alloc();\n\terr = -ENOMEM;\n\tif (!mm)\n\t\tgoto err;\n\n\terr = __bprm_mm_init(bprm);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (mm) {\n\t\tbprm->mm = NULL;\n\t\tmmdrop(mm);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "valid_arg_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "349-352",
    "snippet": "static bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= bprm->p;\n}"
  },
  {
    "function_name": "__bprm_mm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "343-347",
    "snippet": "static int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tbprm->p = PAGE_SIZE * MAX_ARG_PAGES - sizeof(void *);\n\treturn 0;\n}"
  },
  {
    "function_name": "flush_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "338-341",
    "snippet": "static void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n}"
  },
  {
    "function_name": "free_arg_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "330-336",
    "snippet": "static void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_arg_page",
          "args": [
            "bprm",
            "i"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "free_arg_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "322-328",
          "snippet": "static void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_pages(struct linux_binprm *bprm)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ARG_PAGES; i++)\n\t\tfree_arg_page(bprm, i);\n}"
  },
  {
    "function_name": "free_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "322-328",
    "snippet": "static void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "bprm->page[i]"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\n{\n\tif (bprm->page[i]) {\n\t\t__free_page(bprm->page[i]);\n\t\tbprm->page[i] = NULL;\n\t}\n}"
  },
  {
    "function_name": "put_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "318-320",
    "snippet": "static void put_arg_page(struct page *page)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void put_arg_page(struct page *page)\n{\n}"
  },
  {
    "function_name": "get_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "302-316",
    "snippet": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_HIGHUSER|__GFP_ZERO"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\n\tpage = bprm->page[pos / PAGE_SIZE];\n\tif (!page && write) {\n\t\tpage = alloc_page(GFP_HIGHUSER|__GFP_ZERO);\n\t\tif (!page)\n\t\t\treturn NULL;\n\t\tbprm->page[pos / PAGE_SIZE] = page;\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "acct_arg_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "298-300",
    "snippet": "static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}"
  },
  {
    "function_name": "valid_arg_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "291-294",
    "snippet": "static bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= MAX_ARG_STRLEN;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic bool valid_arg_len(struct linux_binprm *bprm, long len)\n{\n\treturn len <= MAX_ARG_STRLEN;\n}"
  },
  {
    "function_name": "__bprm_mm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "249-289",
    "snippet": "static int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mm_struct *mm = bprm->mm;\n\n\tbprm->vma = vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\n\tdown_write(&mm->mmap_sem);\n\tvma->vm_mm = mm;\n\n\t/*\n\t * Place the stack at the largest stack address the architecture\n\t * supports. Later, we'll move this to an appropriate place. We don't\n\t * use STACK_TOP because that can depend on attributes which aren't\n\t * configured yet.\n\t */\n\tBUILD_BUG_ON(VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP);\n\tvma->vm_end = STACK_TOP_MAX;\n\tvma->vm_start = vma->vm_end - PAGE_SIZE;\n\tvma->vm_flags = VM_SOFTDIRTY | VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tINIT_LIST_HEAD(&vma->anon_vma_chain);\n\n\terr = insert_vm_struct(mm, vma);\n\tif (err)\n\t\tgoto err;\n\n\tmm->stack_vm = mm->total_vm = 1;\n\tarch_bprm_mm_init(mm, vma);\n\tup_write(&mm->mmap_sem);\n\tbprm->p = vma->vm_end - sizeof(void *);\n\treturn 0;\nerr:\n\tup_write(&mm->mmap_sem);\n\tbprm->vma = NULL;\n\tkmem_cache_free(vm_area_cachep, vma);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "vm_area_cachep",
            "vma"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_bprm_mm_init",
          "args": [
            "mm",
            "vma"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "insert_vm_struct",
          "args": [
            "mm",
            "vma"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&vma->anon_vma_chain"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_get_page_prot",
          "args": [
            "vma->vm_flags"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&mm->mmap_sem"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "vm_area_cachep",
            "GFP_KERNEL"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic int __bprm_mm_init(struct linux_binprm *bprm)\n{\n\tint err;\n\tstruct vm_area_struct *vma = NULL;\n\tstruct mm_struct *mm = bprm->mm;\n\n\tbprm->vma = vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n\tif (!vma)\n\t\treturn -ENOMEM;\n\n\tdown_write(&mm->mmap_sem);\n\tvma->vm_mm = mm;\n\n\t/*\n\t * Place the stack at the largest stack address the architecture\n\t * supports. Later, we'll move this to an appropriate place. We don't\n\t * use STACK_TOP because that can depend on attributes which aren't\n\t * configured yet.\n\t */\n\tBUILD_BUG_ON(VM_STACK_FLAGS & VM_STACK_INCOMPLETE_SETUP);\n\tvma->vm_end = STACK_TOP_MAX;\n\tvma->vm_start = vma->vm_end - PAGE_SIZE;\n\tvma->vm_flags = VM_SOFTDIRTY | VM_STACK_FLAGS | VM_STACK_INCOMPLETE_SETUP;\n\tvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\n\tINIT_LIST_HEAD(&vma->anon_vma_chain);\n\n\terr = insert_vm_struct(mm, vma);\n\tif (err)\n\t\tgoto err;\n\n\tmm->stack_vm = mm->total_vm = 1;\n\tarch_bprm_mm_init(mm, vma);\n\tup_write(&mm->mmap_sem);\n\tbprm->p = vma->vm_end - sizeof(void *);\n\treturn 0;\nerr:\n\tup_write(&mm->mmap_sem);\n\tbprm->vma = NULL;\n\tkmem_cache_free(vm_area_cachep, vma);\n\treturn err;\n}"
  },
  {
    "function_name": "flush_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "243-247",
    "snippet": "static void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n\tflush_cache_page(bprm->vma, pos, page_to_pfn(page));\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_cache_page",
          "args": [
            "bprm->vma",
            "pos",
            "page_to_pfn(page)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void flush_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tstruct page *page)\n{\n\tflush_cache_page(bprm->vma, pos, page_to_pfn(page));\n}"
  },
  {
    "function_name": "free_arg_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "239-241",
    "snippet": "static void free_arg_pages(struct linux_binprm *bprm)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_pages(struct linux_binprm *bprm)\n{\n}"
  },
  {
    "function_name": "free_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "235-237",
    "snippet": "static void free_arg_page(struct linux_binprm *bprm, int i)\n{\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void free_arg_page(struct linux_binprm *bprm, int i)\n{\n}"
  },
  {
    "function_name": "put_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "230-233",
    "snippet": "static void put_arg_page(struct page *page)\n{\n\tput_page(page);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void put_arg_page(struct page *page)\n{\n\tput_page(page);\n}"
  },
  {
    "function_name": "get_arg_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "182-228",
    "snippet": "static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\tint ret;\n\n#ifdef CONFIG_STACK_GROWSUP\n\tif (write) {\n\t\tret = expand_downwards(bprm->vma, pos);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n#endif\n\tret = get_user_pages(current, bprm->mm, pos,\n\t\t\t1, write, 1, &page, NULL);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (write) {\n\t\tunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\n\t\tstruct rlimit *rlim;\n\n\t\tacct_arg_size(bprm, size / PAGE_SIZE);\n\n\t\t/*\n\t\t * We've historically supported up to 32 pages (ARG_MAX)\n\t\t * of argument strings even with small stacks\n\t\t */\n\t\tif (size <= ARG_MAX)\n\t\t\treturn page;\n\n\t\t/*\n\t\t * Limit to 1/4-th the stack size for the argv+env strings.\n\t\t * This ensures that:\n\t\t *  - the remaining binfmt code will not run out of stack space,\n\t\t *  - the program will have a reasonable amount of stack left\n\t\t *    to work from.\n\t\t */\n\t\trlim = current->signal->rlim;\n\t\tif (size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur) / 4) {\n\t\t\tput_page(page);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn page;\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "rlim[RLIMIT_STACK].rlim_cur"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_arg_size",
          "args": [
            "bprm",
            "size / PAGE_SIZE"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "acct_arg_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
          "lines": "298-300",
          "snippet": "static inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include \"internal.h\"",
            "#include <trace/events/task.h>",
            "#include <asm/tlb.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/kmod.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/audit.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/module.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/utsname.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/personality.h>",
            "#include <linux/key.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/highmem.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/init.h>",
            "#include <linux/string.h>",
            "#include <linux/swap.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user_pages",
          "args": [
            "current",
            "bprm->mm",
            "pos",
            "1",
            "write",
            "1",
            "&page",
            "NULL"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expand_downwards",
          "args": [
            "bprm->vma",
            "pos"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\tint ret;\n\n#ifdef CONFIG_STACK_GROWSUP\n\tif (write) {\n\t\tret = expand_downwards(bprm->vma, pos);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n#endif\n\tret = get_user_pages(current, bprm->mm, pos,\n\t\t\t1, write, 1, &page, NULL);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (write) {\n\t\tunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\n\t\tstruct rlimit *rlim;\n\n\t\tacct_arg_size(bprm, size / PAGE_SIZE);\n\n\t\t/*\n\t\t * We've historically supported up to 32 pages (ARG_MAX)\n\t\t * of argument strings even with small stacks\n\t\t */\n\t\tif (size <= ARG_MAX)\n\t\t\treturn page;\n\n\t\t/*\n\t\t * Limit to 1/4-th the stack size for the argv+env strings.\n\t\t * This ensures that:\n\t\t *  - the remaining binfmt code will not run out of stack space,\n\t\t *  - the program will have a reasonable amount of stack left\n\t\t *    to work from.\n\t\t */\n\t\trlim = current->signal->rlim;\n\t\tif (size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur) / 4) {\n\t\t\tput_page(page);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn page;\n}"
  },
  {
    "function_name": "acct_arg_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "170-180",
    "snippet": "static void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n\tstruct mm_struct *mm = current->mm;\n\tlong diff = (long)(pages - bprm->vma_pages);\n\n\tif (!mm || !diff)\n\t\treturn;\n\n\tbprm->vma_pages = pages;\n\tadd_mm_counter(mm, MM_ANONPAGES, diff);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_mm_counter",
          "args": [
            "mm",
            "MM_ANONPAGES",
            "diff"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic void acct_arg_size(struct linux_binprm *bprm, unsigned long pages)\n{\n\tstruct mm_struct *mm = current->mm;\n\tlong diff = (long)(pages - bprm->vma_pages);\n\n\tif (!mm || !diff)\n\t\treturn;\n\n\tbprm->vma_pages = pages;\n\tadd_mm_counter(mm, MM_ANONPAGES, diff);\n}"
  },
  {
    "function_name": "put_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "96-99",
    "snippet": "static inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "fmt->module"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic inline void put_binfmt(struct linux_binfmt * fmt)\n{\n\tmodule_put(fmt->module);\n}"
  },
  {
    "function_name": "unregister_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "87-92",
    "snippet": "void unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(binfmt_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&fmt->lh"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid unregister_binfmt(struct linux_binfmt * fmt)\n{\n\twrite_lock(&binfmt_lock);\n\tlist_del(&fmt->lh);\n\twrite_unlock(&binfmt_lock);\n}"
  },
  {
    "function_name": "__register_binfmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exec.c",
    "lines": "74-83",
    "snippet": "void __register_binfmt(struct linux_binfmt * fmt, int insert)\n{\n\tBUG_ON(!fmt);\n\tif (WARN_ON(!fmt->load_binary))\n\t\treturn;\n\twrite_lock(&binfmt_lock);\n\tinsert ? list_add(&fmt->lh, &formats) :\n\t\t list_add_tail(&fmt->lh, &formats);\n\twrite_unlock(&binfmt_lock);\n}",
    "includes": [
      "#include <trace/events/sched.h>",
      "#include \"internal.h\"",
      "#include <trace/events/task.h>",
      "#include <asm/tlb.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/oom.h>",
      "#include <linux/pipe_fs_i.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/kmod.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/audit.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/module.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/utsname.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/personality.h>",
      "#include <linux/key.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/highmem.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/init.h>",
      "#include <linux/string.h>",
      "#include <linux/swap.h>",
      "#include <linux/fcntl.h>",
      "#include <linux/stat.h>",
      "#include <linux/vmacache.h>",
      "#include <linux/mm.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(formats);",
      "static DEFINE_RWLOCK(binfmt_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&fmt->lh",
            "&formats"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&fmt->lh",
            "&formats"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&binfmt_lock"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!fmt->load_binary"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!fmt"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/sched.h>\n#include \"internal.h\"\n#include <trace/events/task.h>\n#include <asm/tlb.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/compat.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/fs_struct.h>\n#include <linux/fsnotify.h>\n#include <linux/kmod.h>\n#include <linux/tracehook.h>\n#include <linux/audit.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/module.h>\n#include <linux/pid_namespace.h>\n#include <linux/utsname.h>\n#include <linux/binfmts.h>\n#include <linux/personality.h>\n#include <linux/key.h>\n#include <linux/spinlock.h>\n#include <linux/highmem.h>\n#include <linux/perf_event.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/string.h>\n#include <linux/swap.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\nstatic LIST_HEAD(formats);\nstatic DEFINE_RWLOCK(binfmt_lock);\n\nvoid __register_binfmt(struct linux_binfmt * fmt, int insert)\n{\n\tBUG_ON(!fmt);\n\tif (WARN_ON(!fmt->load_binary))\n\t\treturn;\n\twrite_lock(&binfmt_lock);\n\tinsert ? list_add(&fmt->lh, &formats) :\n\t\t list_add_tail(&fmt->lh, &formats);\n\twrite_unlock(&binfmt_lock);\n}"
  }
]