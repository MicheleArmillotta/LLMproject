[
  {
    "function_name": "logfs_destroy_inode_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "418-426",
    "snippet": "void logfs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(logfs_inode_cache);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *logfs_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "logfs_inode_cache"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct kmem_cache *logfs_inode_cache;\n\nvoid logfs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(logfs_inode_cache);\n}"
  },
  {
    "function_name": "logfs_init_inode_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "408-416",
    "snippet": "int logfs_init_inode_cache(void)\n{\n\tlogfs_inode_cache = kmem_cache_create(\"logfs_inode_cache\",\n\t\t\tsizeof(struct logfs_inode), 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\tlogfs_init_once);\n\tif (!logfs_inode_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *logfs_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"logfs_inode_cache\"",
            "sizeof(struct logfs_inode)",
            "0",
            "SLAB_RECLAIM_ACCOUNT",
            "logfs_init_once"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct kmem_cache *logfs_inode_cache;\n\nint logfs_init_inode_cache(void)\n{\n\tlogfs_inode_cache = kmem_cache_create(\"logfs_inode_cache\",\n\t\t\tsizeof(struct logfs_inode), 0, SLAB_RECLAIM_ACCOUNT,\n\t\t\tlogfs_init_once);\n\tif (!logfs_inode_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "388-395",
    "snippet": "static void logfs_put_super(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\t/* kill the meta-inodes */\n\tiput(super->s_segfile_inode);\n\tiput(super->s_master_inode);\n\tiput(super->s_mapping_inode);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "super->s_mapping_inode"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_put_super(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\t/* kill the meta-inodes */\n\tiput(super->s_segfile_inode);\n\tiput(super->s_master_inode);\n\tiput(super->s_mapping_inode);\n}"
  },
  {
    "function_name": "logfs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "380-386",
    "snippet": "static int logfs_sync_fs(struct super_block *sb, int wait)\n{\n\tlogfs_get_wblocks(sb, NULL, WF_LOCK);\n\tlogfs_write_anchor(sb);\n\tlogfs_put_wblocks(sb, NULL, WF_LOCK);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_put_wblocks",
          "args": [
            "sb",
            "NULL",
            "WF_LOCK"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_put_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "262-272",
          "snippet": "void logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_put_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tpreunlock_page(sb, page, lock);\n\t/* Order matters - we must clear PG_pre_locked before releasing\n\t * s_write_mutex or we could race against another task. */\n\tif (lock)\n\t\tmutex_unlock(&super->s_write_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_write_anchor",
          "args": [
            "sb"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_write_anchor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/journal.c",
          "lines": "734-803",
          "snippet": "void logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_write_anchor(struct super_block *sb)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_area *area = super->s_journal_area;\n\tint i, err;\n\n\tif (!(super->s_flags & LOGFS_SB_FLAG_DIRTY))\n\t\treturn;\n\tsuper->s_flags &= ~LOGFS_SB_FLAG_DIRTY;\n\n\tBUG_ON(super->s_flags & LOGFS_SB_FLAG_SHUTDOWN);\n\tmutex_lock(&super->s_journal_mutex);\n\n\t/* Do this first or suffer corruption */\n\tlogfs_sync_segments(sb);\n\taccount_shadows(sb);\n\nagain:\n\tsuper->s_no_je = 0;\n\tfor_each_area(i) {\n\t\tif (!super->s_area[i]->a_is_open)\n\t\t\tcontinue;\n\t\tsuper->s_sum_index = i;\n\t\terr = logfs_write_je(sb, logfs_write_area);\n\t\tif (err)\n\t\t\tgoto again;\n\t}\n\terr = logfs_write_obj_aliases(sb);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_erasecount);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, __logfs_write_anchor);\n\tif (err)\n\t\tgoto again;\n\terr = logfs_write_je(sb, logfs_write_dynsb);\n\tif (err)\n\t\tgoto again;\n\t/*\n\t * Order is imperative.  First we sync all writes, including the\n\t * non-committed journal writes.  Then we write the final commit and\n\t * sync the current journal segment.\n\t * There is a theoretical bug here.  Syncing the journal segment will\n\t * write a number of journal entries and the final commit.  All these\n\t * are written in a single operation.  If the device layer writes the\n\t * data back-to-front, the commit will precede the other journal\n\t * entries, leaving a race window.\n\t * Two fixes are possible.  Preferred is to fix the device layer to\n\t * ensure writes happen front-to-back.  Alternatively we can insert\n\t * another logfs_sync_area() super->s_devops->sync() combo before\n\t * writing the commit.\n\t */\n\t/*\n\t * On another subject, super->s_devops->sync is usually not necessary.\n\t * Unless called from sys_sync or friends, a barrier would suffice.\n\t */\n\tsuper->s_devops->sync(sb);\n\terr = logfs_write_je(sb, logfs_write_commit);\n\tif (err)\n\t\tgoto again;\n\tlog_journal(\"Write commit to %llx\\n\",\n\t\t\tbe64_to_cpu(super->s_je_array[super->s_no_je - 1]));\n\tlogfs_sync_area(area);\n\tBUG_ON(area->a_used_bytes != area->a_written_bytes);\n\tsuper->s_devops->sync(sb);\n\n\tmutex_unlock(&super->s_journal_mutex);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_get_wblocks",
          "args": [
            "sb",
            "NULL",
            "WF_LOCK"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_get_wblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "247-260",
          "snippet": "void logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nvoid logfs_get_wblocks(struct super_block *sb, struct page *page, int lock)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\n\tif (page)\n\t\tprelock_page(sb, page, lock);\n\n\tif (lock) {\n\t\tmutex_lock(&super->s_write_mutex);\n\t\tlogfs_gc_pass(sb);\n\t\t/* FIXME: We also have to check for shadowed space\n\t\t * and mempool fill grade */\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_sync_fs(struct super_block *sb, int wait)\n{\n\tlogfs_get_wblocks(sb, NULL, WF_LOCK);\n\tlogfs_write_anchor(sb);\n\tlogfs_put_wblocks(sb, NULL, WF_LOCK);\n\treturn 0;\n}"
  },
  {
    "function_name": "logfs_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "367-378",
    "snippet": "static void logfs_init_once(void *_li)\n{\n\tstruct logfs_inode *li = _li;\n\tint i;\n\n\tli->li_flags = 0;\n\tli->li_used_bytes = 0;\n\tli->li_refcount = 1;\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = 0;\n\tinode_init_once(&li->vfs_inode);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&li->vfs_inode"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_init_once(void *_li)\n{\n\tstruct logfs_inode *li = _li;\n\tint i;\n\n\tli->li_flags = 0;\n\tli->li_used_bytes = 0;\n\tli->li_refcount = 1;\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = 0;\n\tinode_init_once(&li->vfs_inode);\n}"
  },
  {
    "function_name": "logfs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "342-365",
    "snippet": "struct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode_setops",
          "args": [
            "inode"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "dir",
            "mode"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_set_ino_generation",
          "args": [
            "sb",
            "inode"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_set_ino_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "322-340",
          "snippet": "static void logfs_set_ino_generation(struct super_block *sb,\n\t\tstruct inode *inode)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ino;\n\n\tmutex_lock(&super->s_journal_mutex);\n\tino = logfs_seek_hole(super->s_master_inode, super->s_last_ino + 1);\n\tsuper->s_last_ino = ino;\n\tsuper->s_inos_till_wrap--;\n\tif (super->s_inos_till_wrap < 0) {\n\t\tsuper->s_last_ino = LOGFS_RESERVED_INOS;\n\t\tsuper->s_generation++;\n\t\tsuper->s_inos_till_wrap = INOS_PER_WRAP;\n\t}\n\tinode->i_ino = ino;\n\tinode->i_generation = super->s_generation;\n\tmutex_unlock(&super->s_journal_mutex);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [
            "#define INOS_PER_WRAP (0x10000)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\n#define INOS_PER_WRAP (0x10000)\n\nstatic void logfs_set_ino_generation(struct super_block *sb,\n\t\tstruct inode *inode)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ino;\n\n\tmutex_lock(&super->s_journal_mutex);\n\tino = logfs_seek_hole(super->s_master_inode, super->s_last_ino + 1);\n\tsuper->s_last_ino = ino;\n\tsuper->s_inos_till_wrap--;\n\tif (super->s_inos_till_wrap < 0) {\n\t\tsuper->s_last_ino = LOGFS_RESERVED_INOS;\n\t\tsuper->s_generation++;\n\t\tsuper->s_inos_till_wrap = INOS_PER_WRAP;\n\t}\n\tinode->i_ino = ino;\n\tinode->i_generation = super->s_generation;\n\tmutex_unlock(&super->s_journal_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_init_inode",
          "args": [
            "sb",
            "inode"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "202-224",
          "snippet": "static void logfs_init_inode(struct super_block *sb, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tli->li_flags\t= 0;\n\tli->li_height\t= 0;\n\tli->li_used_bytes = 0;\n\tli->li_block\t= NULL;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tinode->i_size\t= 0;\n\tinode->i_blocks\t= 0;\n\tinode->i_ctime\t= CURRENT_TIME;\n\tinode->i_mtime\t= CURRENT_TIME;\n\tli->li_refcount = 1;\n\tINIT_LIST_HEAD(&li->li_freeing_list);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = 0;\n\n\treturn;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_init_inode(struct super_block *sb, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tli->li_flags\t= 0;\n\tli->li_height\t= 0;\n\tli->li_used_bytes = 0;\n\tli->li_block\t= NULL;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tinode->i_size\t= 0;\n\tinode->i_blocks\t= 0;\n\tinode->i_ctime\t= CURRENT_TIME;\n\tinode->i_mtime\t= CURRENT_TIME;\n\tli->li_refcount = 1;\n\tINIT_LIST_HEAD(&li->li_freeing_list);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = 0;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct super_block *sb = dir->i_sb;\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlogfs_init_inode(sb, inode);\n\n\t/* inherit parent flags */\n\tlogfs_inode(inode)->li_flags |=\n\t\tlogfs_inode(dir)->li_flags & LOGFS_FL_INHERITED;\n\n\tinode->i_mode = mode;\n\tlogfs_set_ino_generation(sb, inode);\n\n\tinode_init_owner(inode, dir, mode);\n\tlogfs_inode_setops(inode);\n\tinsert_inode_hash(inode);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "logfs_set_ino_generation",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "322-340",
    "snippet": "static void logfs_set_ino_generation(struct super_block *sb,\n\t\tstruct inode *inode)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ino;\n\n\tmutex_lock(&super->s_journal_mutex);\n\tino = logfs_seek_hole(super->s_master_inode, super->s_last_ino + 1);\n\tsuper->s_last_ino = ino;\n\tsuper->s_inos_till_wrap--;\n\tif (super->s_inos_till_wrap < 0) {\n\t\tsuper->s_last_ino = LOGFS_RESERVED_INOS;\n\t\tsuper->s_generation++;\n\t\tsuper->s_inos_till_wrap = INOS_PER_WRAP;\n\t}\n\tinode->i_ino = ino;\n\tinode->i_generation = super->s_generation;\n\tmutex_unlock(&super->s_journal_mutex);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [
      "#define INOS_PER_WRAP (0x10000)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&super->s_journal_mutex"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_seek_hole",
          "args": [
            "super->s_master_inode",
            "super->s_last_ino + 1"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_seek_hole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "887-914",
          "snippet": "u64 logfs_seek_hole(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS) {\n\t\tbix = seek_holedata_direct(inode, bix, 0);\n\t\tif (bix < I0_BLOCKS)\n\t\t\treturn bix;\n\t}\n\n\tif (!li->li_data[INDIRECT_INDEX])\n\t\treturn bix;\n\telse if (li->li_data[INDIRECT_INDEX] & LOGFS_FULLY_POPULATED)\n\t\tbix = maxbix(li->li_height);\n\telse if (bix >= maxbix(li->li_height))\n\t\treturn bix;\n\telse {\n\t\tbix = seek_holedata_loop(inode, bix, 0);\n\t\tif (bix < maxbix(li->li_height))\n\t\t\treturn bix;\n\t\t/* Should not happen anymore.  But if some port writes semi-\n\t\t * corrupt images (as this one used to) we might run into it.\n\t\t */\n\t\tWARN_ON_ONCE(bix == maxbix(li->li_height));\n\t}\n\n\treturn bix;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nu64 logfs_seek_hole(struct inode *inode, u64 bix)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (bix < I0_BLOCKS) {\n\t\tbix = seek_holedata_direct(inode, bix, 0);\n\t\tif (bix < I0_BLOCKS)\n\t\t\treturn bix;\n\t}\n\n\tif (!li->li_data[INDIRECT_INDEX])\n\t\treturn bix;\n\telse if (li->li_data[INDIRECT_INDEX] & LOGFS_FULLY_POPULATED)\n\t\tbix = maxbix(li->li_height);\n\telse if (bix >= maxbix(li->li_height))\n\t\treturn bix;\n\telse {\n\t\tbix = seek_holedata_loop(inode, bix, 0);\n\t\tif (bix < maxbix(li->li_height))\n\t\t\treturn bix;\n\t\t/* Should not happen anymore.  But if some port writes semi-\n\t\t * corrupt images (as this one used to) we might run into it.\n\t\t */\n\t\tWARN_ON_ONCE(bix == maxbix(li->li_height));\n\t}\n\n\treturn bix;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&super->s_journal_mutex"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\n#define INOS_PER_WRAP (0x10000)\n\nstatic void logfs_set_ino_generation(struct super_block *sb,\n\t\tstruct inode *inode)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tu64 ino;\n\n\tmutex_lock(&super->s_journal_mutex);\n\tino = logfs_seek_hole(super->s_master_inode, super->s_last_ino + 1);\n\tsuper->s_last_ino = ino;\n\tsuper->s_inos_till_wrap--;\n\tif (super->s_inos_till_wrap < 0) {\n\t\tsuper->s_last_ino = LOGFS_RESERVED_INOS;\n\t\tsuper->s_generation++;\n\t\tsuper->s_inos_till_wrap = INOS_PER_WRAP;\n\t}\n\tinode->i_ino = ino;\n\tinode->i_generation = super->s_generation;\n\tmutex_unlock(&super->s_journal_mutex);\n}"
  },
  {
    "function_name": "logfs_drop_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "311-320",
    "snippet": "static int logfs_drop_inode(struct inode *inode)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_move(&li->li_freeing_list, &super->s_freeing_list);\n\tspin_unlock(&logfs_inode_lock);\n\treturn generic_drop_inode(inode);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(logfs_inode_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_drop_inode",
          "args": [
            "inode"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&logfs_inode_lock"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&li->li_freeing_list",
            "&super->s_freeing_list"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&logfs_inode_lock"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "inode->i_sb"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic DEFINE_SPINLOCK(logfs_inode_lock);\n\nstatic int logfs_drop_inode(struct inode *inode)\n{\n\tstruct logfs_super *super = logfs_super(inode->i_sb);\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_move(&li->li_freeing_list, &super->s_freeing_list);\n\tspin_unlock(&logfs_inode_lock);\n\treturn generic_drop_inode(inode);\n}"
  },
  {
    "function_name": "logfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "296-308",
    "snippet": "static int logfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\tlong flags = WF_LOCK;\n\n\t/* Can only happen if creat() failed.  Safe to skip. */\n\tif (logfs_inode(inode)->li_flags & LOGFS_IF_STILLBORN)\n\t\treturn 0;\n\n\tret = __logfs_write_inode(inode, NULL, flags);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LOGFS_BUG_ON",
          "args": [
            "ret",
            "inode->i_sb"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__logfs_write_inode",
          "args": [
            "inode",
            "NULL",
            "flags"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "2132-2141",
          "snippet": "int __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint __logfs_write_inode(struct inode *inode, struct page *page, long flags)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tint ret;\n\n\tlogfs_get_wblocks(sb, page, flags & WF_LOCK);\n\tret = do_write_inode(inode);\n\tlogfs_put_wblocks(sb, page, flags & WF_LOCK);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic int logfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint ret;\n\tlong flags = WF_LOCK;\n\n\t/* Can only happen if creat() failed.  Safe to skip. */\n\tif (logfs_inode(inode)->li_flags & LOGFS_IF_STILLBORN)\n\t\treturn 0;\n\n\tret = __logfs_write_inode(inode, NULL, flags);\n\tLOGFS_BUG_ON(ret, inode->i_sb);\n\treturn ret;\n}"
  },
  {
    "function_name": "logfs_read_meta_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "278-294",
    "snippet": "struct inode *logfs_read_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tinode = logfs_new_meta_inode(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tlogfs_inode_setops(inode);\n\treturn inode;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_inode_setops",
          "args": [
            "inode"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_inode",
          "args": [
            "inode"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1951-1976",
          "snippet": "int logfs_read_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *master_inode = super->s_master_inode;\n\tstruct page *page;\n\tstruct logfs_disk_inode *di;\n\tu64 ino = inode->i_ino;\n\n\tif (ino << sb->s_blocksize_bits > i_size_read(master_inode))\n\t\treturn -ENODATA;\n\tif (!logfs_exist_block(master_inode, ino))\n\t\treturn -ENODATA;\n\n\tpage = read_cache_page(master_inode->i_mapping, ino,\n\t\t\t(filler_t *)logfs_readpage, NULL);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tdi = kmap_atomic(page);\n\tlogfs_disk_to_inode(di, inode);\n\tkunmap_atomic(di);\n\tmove_page_to_inode(inode, page);\n\tpage_cache_release(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_read_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *master_inode = super->s_master_inode;\n\tstruct page *page;\n\tstruct logfs_disk_inode *di;\n\tu64 ino = inode->i_ino;\n\n\tif (ino << sb->s_blocksize_bits > i_size_read(master_inode))\n\t\treturn -ENODATA;\n\tif (!logfs_exist_block(master_inode, ino))\n\t\treturn -ENODATA;\n\n\tpage = read_cache_page(master_inode->i_mapping, ino,\n\t\t\t(filler_t *)logfs_readpage, NULL);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tdi = kmap_atomic(page);\n\tlogfs_disk_to_inode(di, inode);\n\tkunmap_atomic(di);\n\tmove_page_to_inode(inode, page);\n\tpage_cache_release(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_new_meta_inode",
          "args": [
            "sb",
            "ino"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_new_meta_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "262-276",
          "snippet": "struct inode *logfs_new_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_ino = ino;\n\tinode->i_data.a_ops = &logfs_reg_aops;\n\tmapping_set_gfp_mask(&inode->i_data, GFP_NOFS);\n\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_ino = ino;\n\tinode->i_data.a_ops = &logfs_reg_aops;\n\tmapping_set_gfp_mask(&inode->i_data, GFP_NOFS);\n\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_read_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\tint err;\n\n\tinode = logfs_new_meta_inode(sb, ino);\n\tif (IS_ERR(inode))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err) {\n\t\tiput(inode);\n\t\treturn ERR_PTR(err);\n\t}\n\tlogfs_inode_setops(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "logfs_new_meta_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "262-276",
    "snippet": "struct inode *logfs_new_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_ino = ino;\n\tinode->i_data.a_ops = &logfs_reg_aops;\n\tmapping_set_gfp_mask(&inode->i_data, GFP_NOFS);\n\n\treturn inode;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mapping_set_gfp_mask",
          "args": [
            "&inode->i_data",
            "GFP_NOFS"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "sb"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_new_meta_inode(struct super_block *sb, u64 ino)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinode->i_mode = S_IFREG;\n\tinode->i_ino = ino;\n\tinode->i_data.a_ops = &logfs_reg_aops;\n\tmapping_set_gfp_mask(&inode->i_data, GFP_NOFS);\n\n\treturn inode;\n}"
  },
  {
    "function_name": "logfs_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "226-235",
    "snippet": "static struct inode *logfs_alloc_inode(struct super_block *sb)\n{\n\tstruct logfs_inode *li;\n\n\tli = kmem_cache_alloc(logfs_inode_cache, GFP_NOFS);\n\tif (!li)\n\t\treturn NULL;\n\tlogfs_init_inode(sb, &li->vfs_inode);\n\treturn &li->vfs_inode;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *logfs_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logfs_init_inode",
          "args": [
            "sb",
            "&li->vfs_inode"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_init_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "202-224",
          "snippet": "static void logfs_init_inode(struct super_block *sb, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tli->li_flags\t= 0;\n\tli->li_height\t= 0;\n\tli->li_used_bytes = 0;\n\tli->li_block\t= NULL;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tinode->i_size\t= 0;\n\tinode->i_blocks\t= 0;\n\tinode->i_ctime\t= CURRENT_TIME;\n\tinode->i_mtime\t= CURRENT_TIME;\n\tli->li_refcount = 1;\n\tINIT_LIST_HEAD(&li->li_freeing_list);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = 0;\n\n\treturn;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_init_inode(struct super_block *sb, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tli->li_flags\t= 0;\n\tli->li_height\t= 0;\n\tli->li_used_bytes = 0;\n\tli->li_block\t= NULL;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tinode->i_size\t= 0;\n\tinode->i_blocks\t= 0;\n\tinode->i_ctime\t= CURRENT_TIME;\n\tinode->i_mtime\t= CURRENT_TIME;\n\tli->li_refcount = 1;\n\tINIT_LIST_HEAD(&li->li_freeing_list);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = 0;\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "logfs_inode_cache",
            "GFP_NOFS"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct kmem_cache *logfs_inode_cache;\n\nstatic struct inode *logfs_alloc_inode(struct super_block *sb)\n{\n\tstruct logfs_inode *li;\n\n\tli = kmem_cache_alloc(logfs_inode_cache, GFP_NOFS);\n\tif (!li)\n\t\treturn NULL;\n\tlogfs_init_inode(sb, &li->vfs_inode);\n\treturn &li->vfs_inode;\n}"
  },
  {
    "function_name": "logfs_init_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "202-224",
    "snippet": "static void logfs_init_inode(struct super_block *sb, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tli->li_flags\t= 0;\n\tli->li_height\t= 0;\n\tli->li_used_bytes = 0;\n\tli->li_block\t= NULL;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tinode->i_size\t= 0;\n\tinode->i_blocks\t= 0;\n\tinode->i_ctime\t= CURRENT_TIME;\n\tinode->i_mtime\t= CURRENT_TIME;\n\tli->li_refcount = 1;\n\tINIT_LIST_HEAD(&li->li_freeing_list);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = 0;\n\n\treturn;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&li->li_freeing_list"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "0"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_init_inode(struct super_block *sb, struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tint i;\n\n\tli->li_flags\t= 0;\n\tli->li_height\t= 0;\n\tli->li_used_bytes = 0;\n\tli->li_block\t= NULL;\n\ti_uid_write(inode, 0);\n\ti_gid_write(inode, 0);\n\tinode->i_size\t= 0;\n\tinode->i_blocks\t= 0;\n\tinode->i_ctime\t= CURRENT_TIME;\n\tinode->i_mtime\t= CURRENT_TIME;\n\tli->li_refcount = 1;\n\tINIT_LIST_HEAD(&li->li_freeing_list);\n\n\tfor (i = 0; i < LOGFS_EMBEDDED_FIELDS; i++)\n\t\tli->li_data[i] = 0;\n\n\treturn;\n}"
  },
  {
    "function_name": "logfs_safe_iput",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "187-200",
    "snippet": "void logfs_safe_iput(struct inode *inode, int is_cached)\n{\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\treturn;\n\tif (inode->i_ino == LOGFS_INO_SEGFILE)\n\t\treturn;\n\n\tif (is_cached) {\n\t\tlogfs_destroy_inode(inode);\n\t\treturn;\n\t}\n\n\tiput(inode);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_destroy_inode",
          "args": [
            "inode"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "166-185",
          "snippet": "static void logfs_destroy_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (inode->i_ino < LOGFS_RESERVED_INOS) {\n\t\t/*\n\t\t * The reserved inodes are never destroyed unless we are in\n\t\t * unmont path.\n\t\t */\n\t\t__logfs_destroy_meta_inode(inode);\n\t\treturn;\n\t}\n\n\tBUG_ON(list_empty(&li->li_freeing_list));\n\tspin_lock(&logfs_inode_lock);\n\tli->li_refcount--;\n\tif (li->li_refcount == 0)\n\t\t__logfs_destroy_inode(inode);\n\tspin_unlock(&logfs_inode_lock);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(logfs_inode_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic DEFINE_SPINLOCK(logfs_inode_lock);\n\nstatic void logfs_destroy_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (inode->i_ino < LOGFS_RESERVED_INOS) {\n\t\t/*\n\t\t * The reserved inodes are never destroyed unless we are in\n\t\t * unmont path.\n\t\t */\n\t\t__logfs_destroy_meta_inode(inode);\n\t\treturn;\n\t}\n\n\tBUG_ON(list_empty(&li->li_freeing_list));\n\tspin_lock(&logfs_inode_lock);\n\tli->li_refcount--;\n\tif (li->li_refcount == 0)\n\t\t__logfs_destroy_inode(inode);\n\tspin_unlock(&logfs_inode_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nvoid logfs_safe_iput(struct inode *inode, int is_cached)\n{\n\tif (inode->i_ino == LOGFS_INO_MASTER)\n\t\treturn;\n\tif (inode->i_ino == LOGFS_INO_SEGFILE)\n\t\treturn;\n\n\tif (is_cached) {\n\t\tlogfs_destroy_inode(inode);\n\t\treturn;\n\t}\n\n\tiput(inode);\n}"
  },
  {
    "function_name": "logfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "166-185",
    "snippet": "static void logfs_destroy_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (inode->i_ino < LOGFS_RESERVED_INOS) {\n\t\t/*\n\t\t * The reserved inodes are never destroyed unless we are in\n\t\t * unmont path.\n\t\t */\n\t\t__logfs_destroy_meta_inode(inode);\n\t\treturn;\n\t}\n\n\tBUG_ON(list_empty(&li->li_freeing_list));\n\tspin_lock(&logfs_inode_lock);\n\tli->li_refcount--;\n\tif (li->li_refcount == 0)\n\t\t__logfs_destroy_inode(inode);\n\tspin_unlock(&logfs_inode_lock);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(logfs_inode_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&logfs_inode_lock"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_destroy_inode",
          "args": [
            "inode"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_destroy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "150-157",
          "snippet": "static void __logfs_destroy_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tBUG_ON(li->li_block);\n\tlist_del(&li->li_freeing_list);\n\tcall_rcu(&inode->i_rcu, logfs_i_callback);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void __logfs_destroy_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tBUG_ON(li->li_block);\n\tlist_del(&li->li_freeing_list);\n\tcall_rcu(&inode->i_rcu, logfs_i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&logfs_inode_lock"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "list_empty(&li->li_freeing_list)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&li->li_freeing_list"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__logfs_destroy_meta_inode",
          "args": [
            "inode"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_destroy_meta_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "159-164",
          "snippet": "static void __logfs_destroy_meta_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tBUG_ON(li->li_block);\n\tcall_rcu(&inode->i_rcu, logfs_i_callback);\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void __logfs_destroy_meta_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tBUG_ON(li->li_block);\n\tcall_rcu(&inode->i_rcu, logfs_i_callback);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic DEFINE_SPINLOCK(logfs_inode_lock);\n\nstatic void logfs_destroy_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tif (inode->i_ino < LOGFS_RESERVED_INOS) {\n\t\t/*\n\t\t * The reserved inodes are never destroyed unless we are in\n\t\t * unmont path.\n\t\t */\n\t\t__logfs_destroy_meta_inode(inode);\n\t\treturn;\n\t}\n\n\tBUG_ON(list_empty(&li->li_freeing_list));\n\tspin_lock(&logfs_inode_lock);\n\tli->li_refcount--;\n\tif (li->li_refcount == 0)\n\t\t__logfs_destroy_inode(inode);\n\tspin_unlock(&logfs_inode_lock);\n}"
  },
  {
    "function_name": "__logfs_destroy_meta_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "159-164",
    "snippet": "static void __logfs_destroy_meta_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tBUG_ON(li->li_block);\n\tcall_rcu(&inode->i_rcu, logfs_i_callback);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "logfs_i_callback"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "li->li_block"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void __logfs_destroy_meta_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\tBUG_ON(li->li_block);\n\tcall_rcu(&inode->i_rcu, logfs_i_callback);\n}"
  },
  {
    "function_name": "__logfs_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "150-157",
    "snippet": "static void __logfs_destroy_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tBUG_ON(li->li_block);\n\tlist_del(&li->li_freeing_list);\n\tcall_rcu(&inode->i_rcu, logfs_i_callback);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "logfs_i_callback"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&li->li_freeing_list"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "li->li_block"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void __logfs_destroy_inode(struct inode *inode)\n{\n\tstruct logfs_inode *li = logfs_inode(inode);\n\n\tBUG_ON(li->li_block);\n\tlist_del(&li->li_freeing_list);\n\tcall_rcu(&inode->i_rcu, logfs_i_callback);\n}"
  },
  {
    "function_name": "logfs_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "144-148",
    "snippet": "static void logfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(logfs_inode_cache, logfs_inode(inode));\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *logfs_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "logfs_inode_cache",
            "logfs_inode(inode)"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logfs_inode",
          "args": [
            "inode"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct kmem_cache *logfs_inode_cache;\n\nstatic void logfs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(logfs_inode_cache, logfs_inode(inode));\n}"
  },
  {
    "function_name": "logfs_safe_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "120-142",
    "snippet": "struct inode *logfs_safe_iget(struct super_block *sb, ino_t ino, int *is_cached)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_inode *li;\n\n\tif (ino == LOGFS_INO_MASTER)\n\t\treturn super->s_master_inode;\n\tif (ino == LOGFS_INO_SEGFILE)\n\t\treturn super->s_segfile_inode;\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_for_each_entry(li, &super->s_freeing_list, li_freeing_list)\n\t\tif (li->vfs_inode.i_ino == ino) {\n\t\t\tli->li_refcount++;\n\t\t\tspin_unlock(&logfs_inode_lock);\n\t\t\t*is_cached = 1;\n\t\t\treturn &li->vfs_inode;\n\t\t}\n\tspin_unlock(&logfs_inode_lock);\n\n\t*is_cached = 0;\n\treturn __logfs_iget(sb, ino);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(logfs_inode_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "81-107",
          "snippet": "static struct inode *__logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct inode *inode = iget_locked(sb, ino);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err || inode->i_nlink == 0) {\n\t\t/* inode->i_nlink == 0 can be true when called from\n\t\t * block validator */\n\t\t/* set i_nlink to 0 to prevent caching */\n\t\tclear_nlink(inode);\n\t\tlogfs_inode(inode)->li_flags |= LOGFS_IF_ZOMBIE;\n\t\tiget_failed(inode);\n\t\tif (!err)\n\t\t\terr = -ENOENT;\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlogfs_inode_setops(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct inode *__logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct inode *inode = iget_locked(sb, ino);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err || inode->i_nlink == 0) {\n\t\t/* inode->i_nlink == 0 can be true when called from\n\t\t * block validator */\n\t\t/* set i_nlink to 0 to prevent caching */\n\t\tclear_nlink(inode);\n\t\tlogfs_inode(inode)->li_flags |= LOGFS_IF_ZOMBIE;\n\t\tiget_failed(inode);\n\t\tif (!err)\n\t\t\terr = -ENOENT;\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlogfs_inode_setops(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&logfs_inode_lock"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "li",
            "&super->s_freeing_list",
            "li_freeing_list"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&logfs_inode_lock"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_super",
          "args": [
            "sb"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/logfs.h",
          "lines": "628-631",
          "snippet": "static inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"logfs_abi.h\"",
            "#include <linux/mtd/mtd.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mempool.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/btree.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"logfs_abi.h\"\n#include <linux/mtd/mtd.h>\n#include <linux/pagemap.h>\n#include <linux/mempool.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/crc32.h>\n#include <linux/btree.h>\n\nstatic inline struct logfs_super *logfs_super(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic DEFINE_SPINLOCK(logfs_inode_lock);\n\nstruct inode *logfs_safe_iget(struct super_block *sb, ino_t ino, int *is_cached)\n{\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct logfs_inode *li;\n\n\tif (ino == LOGFS_INO_MASTER)\n\t\treturn super->s_master_inode;\n\tif (ino == LOGFS_INO_SEGFILE)\n\t\treturn super->s_segfile_inode;\n\n\tspin_lock(&logfs_inode_lock);\n\tlist_for_each_entry(li, &super->s_freeing_list, li_freeing_list)\n\t\tif (li->vfs_inode.i_ino == ino) {\n\t\t\tli->li_refcount++;\n\t\t\tspin_unlock(&logfs_inode_lock);\n\t\t\t*is_cached = 1;\n\t\t\treturn &li->vfs_inode;\n\t\t}\n\tspin_unlock(&logfs_inode_lock);\n\n\t*is_cached = 0;\n\treturn __logfs_iget(sb, ino);\n}"
  },
  {
    "function_name": "logfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "109-114",
    "snippet": "struct inode *logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tBUG_ON(ino == LOGFS_INO_MASTER);\n\tBUG_ON(ino == LOGFS_INO_SEGFILE);\n\treturn __logfs_iget(sb, ino);\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__logfs_iget",
          "args": [
            "sb",
            "ino"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "__logfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "81-107",
          "snippet": "static struct inode *__logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct inode *inode = iget_locked(sb, ino);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err || inode->i_nlink == 0) {\n\t\t/* inode->i_nlink == 0 can be true when called from\n\t\t * block validator */\n\t\t/* set i_nlink to 0 to prevent caching */\n\t\tclear_nlink(inode);\n\t\tlogfs_inode(inode)->li_flags |= LOGFS_IF_ZOMBIE;\n\t\tiget_failed(inode);\n\t\tif (!err)\n\t\t\terr = -ENOENT;\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlogfs_inode_setops(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct inode *__logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct inode *inode = iget_locked(sb, ino);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err || inode->i_nlink == 0) {\n\t\t/* inode->i_nlink == 0 can be true when called from\n\t\t * block validator */\n\t\t/* set i_nlink to 0 to prevent caching */\n\t\tclear_nlink(inode);\n\t\tlogfs_inode(inode)->li_flags |= LOGFS_IF_ZOMBIE;\n\t\tiget_failed(inode);\n\t\tif (!err)\n\t\t\terr = -ENOENT;\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlogfs_inode_setops(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ino == LOGFS_INO_SEGFILE"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ino == LOGFS_INO_MASTER"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstruct inode *logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tBUG_ON(ino == LOGFS_INO_MASTER);\n\tBUG_ON(ino == LOGFS_INO_SEGFILE);\n\treturn __logfs_iget(sb, ino);\n}"
  },
  {
    "function_name": "__logfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "81-107",
    "snippet": "static struct inode *__logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct inode *inode = iget_locked(sb, ino);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err || inode->i_nlink == 0) {\n\t\t/* inode->i_nlink == 0 can be true when called from\n\t\t * block validator */\n\t\t/* set i_nlink to 0 to prevent caching */\n\t\tclear_nlink(inode);\n\t\tlogfs_inode(inode)->li_flags |= LOGFS_IF_ZOMBIE;\n\t\tiget_failed(inode);\n\t\tif (!err)\n\t\t\terr = -ENOENT;\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlogfs_inode_setops(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_inode_setops",
          "args": [
            "inode"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_inode_setops",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
          "lines": "53-79",
          "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include <linux/backing-dev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "inode"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "logfs_read_inode",
          "args": [
            "inode"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "logfs_read_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/readwrite.c",
          "lines": "1951-1976",
          "snippet": "int logfs_read_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *master_inode = super->s_master_inode;\n\tstruct page *page;\n\tstruct logfs_disk_inode *di;\n\tu64 ino = inode->i_ino;\n\n\tif (ino << sb->s_blocksize_bits > i_size_read(master_inode))\n\t\treturn -ENODATA;\n\tif (!logfs_exist_block(master_inode, ino))\n\t\treturn -ENODATA;\n\n\tpage = read_cache_page(master_inode->i_mapping, ino,\n\t\t\t(filler_t *)logfs_readpage, NULL);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tdi = kmap_atomic(page);\n\tlogfs_disk_to_inode(di, inode);\n\tkunmap_atomic(di);\n\tmove_page_to_inode(inode, page);\n\tpage_cache_release(page);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include \"logfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/sched.h>\n#include \"logfs.h\"\n\nint logfs_read_inode(struct inode *inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct logfs_super *super = logfs_super(sb);\n\tstruct inode *master_inode = super->s_master_inode;\n\tstruct page *page;\n\tstruct logfs_disk_inode *di;\n\tu64 ino = inode->i_ino;\n\n\tif (ino << sb->s_blocksize_bits > i_size_read(master_inode))\n\t\treturn -ENODATA;\n\tif (!logfs_exist_block(master_inode, ino))\n\t\treturn -ENODATA;\n\n\tpage = read_cache_page(master_inode->i_mapping, ino,\n\t\t\t(filler_t *)logfs_readpage, NULL);\n\tif (IS_ERR(page))\n\t\treturn PTR_ERR(page);\n\n\tdi = kmap_atomic(page);\n\tlogfs_disk_to_inode(di, inode);\n\tkunmap_atomic(di);\n\tmove_page_to_inode(inode, page);\n\tpage_cache_release(page);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic struct inode *__logfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct inode *inode = iget_locked(sb, ino);\n\tint err;\n\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\terr = logfs_read_inode(inode);\n\tif (err || inode->i_nlink == 0) {\n\t\t/* inode->i_nlink == 0 can be true when called from\n\t\t * block validator */\n\t\t/* set i_nlink to 0 to prevent caching */\n\t\tclear_nlink(inode);\n\t\tlogfs_inode(inode)->li_flags |= LOGFS_IF_ZOMBIE;\n\t\tiget_failed(inode);\n\t\tif (!err)\n\t\t\terr = -ENOENT;\n\t\treturn ERR_PTR(err);\n\t}\n\n\tlogfs_inode_setops(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "logfs_inode_setops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/logfs/inode.c",
    "lines": "53-79",
    "snippet": "static void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include <linux/backing-dev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include \"logfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "inode->i_rdev"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/backing-dev.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include \"logfs.h\"\n\nstatic void logfs_inode_setops(struct inode *inode)\n{\n\tswitch (inode->i_mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &logfs_dir_iops;\n\t\tinode->i_fop = &logfs_dir_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &logfs_reg_iops;\n\t\tinode->i_fop = &logfs_reg_fops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFLNK:\n\t\tinode->i_op = &logfs_symlink_iops;\n\t\tinode->i_mapping->a_ops = &logfs_reg_aops;\n\t\tbreak;\n\tcase S_IFSOCK:\t/* fall through */\n\tcase S_IFBLK:\t/* fall through */\n\tcase S_IFCHR:\t/* fall through */\n\tcase S_IFIFO:\n\t\tinit_special_inode(inode, inode->i_mode, inode->i_rdev);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n}"
  }
]