[
  {
    "function_name": "exit_minix_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "681-685",
    "snippet": "static void __exit exit_minix_fs(void)\n{\n        unregister_filesystem(&minix_fs_type);\n\tdestroy_inodecache();\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type minix_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"minix\",\n\t.mount\t\t= minix_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "101-109",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(minix_inode_cachep);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * minix_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct kmem_cache * minix_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(minix_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&minix_fs_type"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct file_system_type minix_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"minix\",\n\t.mount\t\t= minix_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_minix_fs(void)\n{\n        unregister_filesystem(&minix_fs_type);\n\tdestroy_inodecache();\n}"
  },
  {
    "function_name": "init_minix_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "666-679",
    "snippet": "static int __init init_minix_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&minix_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type minix_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"minix\",\n\t.mount\t\t= minix_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_inodecache",
          "args": [],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "101-109",
          "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(minix_inode_cachep);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * minix_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct kmem_cache * minix_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(minix_inode_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&minix_fs_type"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_inodecache",
          "args": [],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "init_inodecache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "89-99",
          "snippet": "static int __init init_inodecache(void)\n{\n\tminix_inode_cachep = kmem_cache_create(\"minix_inode_cache\",\n\t\t\t\t\t     sizeof(struct minix_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (minix_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache * minix_inode_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct kmem_cache * minix_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tminix_inode_cachep = kmem_cache_create(\"minix_inode_cache\",\n\t\t\t\t\t     sizeof(struct minix_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (minix_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct file_system_type minix_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"minix\",\n\t.mount\t\t= minix_mount,\n\t.kill_sb\t= kill_block_super,\n\t.fs_flags\t= FS_REQUIRES_DEV,\n};\n\nstatic int __init init_minix_fs(void)\n{\n\tint err = init_inodecache();\n\tif (err)\n\t\tgoto out1;\n\terr = register_filesystem(&minix_fs_type);\n\tif (err)\n\t\tgoto out;\n\treturn 0;\nout:\n\tdestroy_inodecache();\nout1:\n\treturn err;\n}"
  },
  {
    "function_name": "minix_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "651-655",
    "snippet": "static struct dentry *minix_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, minix_fill_super);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int minix_remount (struct super_block * sb, int * flags, char * data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "minix_fill_super"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_remount (struct super_block * sb, int * flags, char * data);\n\nstatic struct dentry *minix_mount(struct file_system_type *fs_type,\n\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, minix_fill_super);\n}"
  },
  {
    "function_name": "minix_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "641-649",
    "snippet": "void minix_truncate(struct inode * inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tV1_minix_truncate(inode);\n\telse\n\t\tV2_minix_truncate(inode);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "V2_minix_truncate",
          "args": [
            "inode"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/itree_v2.c",
          "lines": "68-71",
          "snippet": "void V2_minix_truncate(struct inode * inode)\n{\n\ttruncate(inode);\n}",
          "includes": [
            "#include \"itree_common.c\"",
            "#include \"minix.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"itree_common.c\"\n#include \"minix.h\"\n#include <linux/buffer_head.h>\n\nvoid V2_minix_truncate(struct inode * inode)\n{\n\ttruncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "V1_minix_truncate",
          "args": [
            "inode"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "V1_minix_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/itree_v1.c",
          "lines": "59-62",
          "snippet": "void V1_minix_truncate(struct inode * inode)\n{\n\ttruncate(inode);\n}",
          "includes": [
            "#include \"itree_common.c\"",
            "#include \"minix.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"itree_common.c\"\n#include \"minix.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nvoid V1_minix_truncate(struct inode * inode)\n{\n\ttruncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_VERSION",
          "args": [
            "inode"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nvoid minix_truncate(struct inode * inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tV1_minix_truncate(inode);\n\telse\n\t\tV2_minix_truncate(inode);\n}"
  },
  {
    "function_name": "minix_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "626-636",
    "snippet": "int minix_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tif (INODE_VERSION(dentry->d_inode) == MINIX_V1)\n\t\tstat->blocks = (BLOCK_SIZE / 512) * V1_minix_blocks(stat->size, sb);\n\telse\n\t\tstat->blocks = (sb->s_blocksize / 512) * V2_minix_blocks(stat->size, sb);\n\tstat->blksize = sb->s_blocksize;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "V2_minix_blocks",
          "args": [
            "stat->size",
            "sb"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/itree_v2.c",
          "lines": "73-76",
          "snippet": "unsigned V2_minix_blocks(loff_t size, struct super_block *sb)\n{\n\treturn nblocks(size, sb);\n}",
          "includes": [
            "#include \"itree_common.c\"",
            "#include \"minix.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"itree_common.c\"\n#include \"minix.h\"\n#include <linux/buffer_head.h>\n\nunsigned V2_minix_blocks(loff_t size, struct super_block *sb)\n{\n\treturn nblocks(size, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "V1_minix_blocks",
          "args": [
            "stat->size",
            "sb"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "V1_minix_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/itree_v1.c",
          "lines": "64-67",
          "snippet": "unsigned V1_minix_blocks(loff_t size, struct super_block *sb)\n{\n\treturn nblocks(size, sb);\n}",
          "includes": [
            "#include \"itree_common.c\"",
            "#include \"minix.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"itree_common.c\"\n#include \"minix.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nunsigned V1_minix_blocks(loff_t size, struct super_block *sb)\n{\n\treturn nblocks(size, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_VERSION",
          "args": [
            "dentry->d_inode"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_fillattr",
          "args": [
            "dentry->d_inode",
            "stat"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "generic_fillattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/stat.c",
          "lines": "21-36",
          "snippet": "void generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/file.h>",
            "#include <linux/errno.h>",
            "#include <linux/mm.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/highuid.h>\n#include <linux/file.h>\n#include <linux/errno.h>\n#include <linux/mm.h>\n#include <linux/export.h>\n\nvoid generic_fillattr(struct inode *inode, struct kstat *stat)\n{\n\tstat->dev = inode->i_sb->s_dev;\n\tstat->ino = inode->i_ino;\n\tstat->mode = inode->i_mode;\n\tstat->nlink = inode->i_nlink;\n\tstat->uid = inode->i_uid;\n\tstat->gid = inode->i_gid;\n\tstat->rdev = inode->i_rdev;\n\tstat->size = i_size_read(inode);\n\tstat->atime = inode->i_atime;\n\tstat->mtime = inode->i_mtime;\n\tstat->ctime = inode->i_ctime;\n\tstat->blksize = (1 << inode->i_blkbits);\n\tstat->blocks = inode->i_blocks;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nint minix_getattr(struct vfsmount *mnt, struct dentry *dentry, struct kstat *stat)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tgeneric_fillattr(dentry->d_inode, stat);\n\tif (INODE_VERSION(dentry->d_inode) == MINIX_V1)\n\t\tstat->blocks = (BLOCK_SIZE / 512) * V1_minix_blocks(stat->size, sb);\n\telse\n\t\tstat->blocks = (sb->s_blocksize / 512) * V2_minix_blocks(stat->size, sb);\n\tstat->blksize = sb->s_blocksize;\n\treturn 0;\n}"
  },
  {
    "function_name": "minix_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "603-624",
    "snippet": "static int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"IO error syncing minix inode [%s:%08lx]\\n\"",
            "inode->i_sb->s_id",
            "inode->i_ino"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "V2_minix_update_inode",
          "args": [
            "inode"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "577-601",
          "snippet": "static struct buffer_head * V2_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_mtime = inode->i_mtime.tv_sec;\n\traw_inode->i_atime = inode->i_atime.tv_sec;\n\traw_inode->i_ctime = inode->i_ctime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 10; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i2_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct buffer_head * V2_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_mtime = inode->i_mtime.tv_sec;\n\traw_inode->i_atime = inode->i_atime.tv_sec;\n\traw_inode->i_ctime = inode->i_ctime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 10; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i2_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "V1_minix_update_inode",
          "args": [
            "inode"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "V1_minix_update_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "550-572",
          "snippet": "static struct buffer_head * V1_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_time = inode->i_mtime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 9; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i1_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct buffer_head * V1_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_time = inode->i_mtime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 9; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i1_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_VERSION",
          "args": [
            "inode"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err = 0;\n\tstruct buffer_head *bh;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tbh = V1_minix_update_inode(inode);\n\telse\n\t\tbh = V2_minix_update_inode(inode);\n\tif (!bh)\n\t\treturn -EIO;\n\tif (wbc->sync_mode == WB_SYNC_ALL && buffer_dirty(bh)) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh)) {\n\t\t\tprintk(\"IO error syncing minix inode [%s:%08lx]\\n\",\n\t\t\t\tinode->i_sb->s_id, inode->i_ino);\n\t\t\terr = -EIO;\n\t\t}\n\t}\n\tbrelse (bh);\n\treturn err;\n}"
  },
  {
    "function_name": "V2_minix_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "577-601",
    "snippet": "static struct buffer_head * V2_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_mtime = inode->i_mtime.tv_sec;\n\traw_inode->i_atime = inode->i_atime.tv_sec;\n\traw_inode->i_ctime = inode->i_ctime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 10; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i2_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowgid",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowuid",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_V2_raw_inode",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&bh"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "minix_V2_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "129-153",
          "snippet": "struct minix2_inode *\nminix_V2_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix2_inode *p;\n\tint minix2_inodes_per_block = sb->s_blocksize / sizeof(struct minix2_inode);\n\n\t*bh = NULL;\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / minix2_inodes_per_block;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % minix2_inodes_per_block;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstruct minix2_inode *\nminix_V2_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix2_inode *p;\n\tint minix2_inodes_per_block = sb->s_blocksize / sizeof(struct minix2_inode);\n\n\t*bh = NULL;\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / minix2_inodes_per_block;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % minix2_inodes_per_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_i",
          "args": [
            "inode"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "496-526",
          "snippet": "static struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct buffer_head * V2_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_mtime = inode->i_mtime.tv_sec;\n\traw_inode->i_atime = inode->i_atime.tv_sec;\n\traw_inode->i_ctime = inode->i_ctime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 10; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i2_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}"
  },
  {
    "function_name": "V1_minix_update_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "550-572",
    "snippet": "static struct buffer_head * V1_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_time = inode->i_mtime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 9; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i1_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_encode_dev",
          "args": [
            "inode->i_rdev"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "inode->i_mode"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "inode->i_mode"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowgid",
          "args": [
            "i_gid_read(inode)"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_read",
          "args": [
            "inode"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_high2lowuid",
          "args": [
            "i_uid_read(inode)"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_read",
          "args": [
            "inode"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_V1_raw_inode",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&bh"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "minix_V1_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "105-127",
          "snippet": "struct minix_inode *\nminix_V1_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix_inode *p;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / MINIX_INODES_PER_BLOCK;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % MINIX_INODES_PER_BLOCK;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstruct minix_inode *\nminix_V1_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix_inode *p;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / MINIX_INODES_PER_BLOCK;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % MINIX_INODES_PER_BLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_i",
          "args": [
            "inode"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "496-526",
          "snippet": "static struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct buffer_head * V1_minix_update_inode(struct inode * inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode)\n\t\treturn NULL;\n\traw_inode->i_mode = inode->i_mode;\n\traw_inode->i_uid = fs_high2lowuid(i_uid_read(inode));\n\traw_inode->i_gid = fs_high2lowgid(i_gid_read(inode));\n\traw_inode->i_nlinks = inode->i_nlink;\n\traw_inode->i_size = inode->i_size;\n\traw_inode->i_time = inode->i_mtime.tv_sec;\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode))\n\t\traw_inode->i_zone[0] = old_encode_dev(inode->i_rdev);\n\telse for (i = 0; i < 9; i++)\n\t\traw_inode->i_zone[i] = minix_inode->u.i1_data[i];\n\tmark_buffer_dirty(bh);\n\treturn bh;\n}"
  },
  {
    "function_name": "minix_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "531-545",
    "snippet": "struct inode *minix_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_iget(inode);\n\telse\n\t\treturn V2_minix_iget(inode);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "V2_minix_iget",
          "args": [
            "inode"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "496-526",
          "snippet": "static struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "V1_minix_iget",
          "args": [
            "inode"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "V1_minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "463-491",
          "snippet": "static struct inode *V1_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = raw_inode->i_time;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 9; i++)\n\t\tminix_inode->u.i1_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct inode *V1_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = raw_inode->i_time;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 9; i++)\n\t\tminix_inode->u.i1_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_VERSION",
          "args": [
            "inode"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstruct inode *minix_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_iget(inode);\n\telse\n\t\treturn V2_minix_iget(inode);\n}"
  },
  {
    "function_name": "V2_minix_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "496-526",
    "snippet": "static struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_set_inode",
          "args": [
            "inode",
            "old_decode_dev(raw_inode->i_zone[0])"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "minix_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "443-458",
          "snippet": "void minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};",
            "static const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};\nstatic const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};\n\nvoid minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "raw_inode->i_zone[0]"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "raw_inode->i_nlinks"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "raw_inode->i_gid"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "raw_inode->i_uid"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_V2_raw_inode",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&bh"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "minix_V2_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "129-153",
          "snippet": "struct minix2_inode *\nminix_V2_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix2_inode *p;\n\tint minix2_inodes_per_block = sb->s_blocksize / sizeof(struct minix2_inode);\n\n\t*bh = NULL;\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / minix2_inodes_per_block;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % minix2_inodes_per_block;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstruct minix2_inode *\nminix_V2_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix2_inode *p;\n\tint minix2_inodes_per_block = sb->s_blocksize / sizeof(struct minix2_inode);\n\n\t*bh = NULL;\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / minix2_inodes_per_block;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % minix2_inodes_per_block;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_i",
          "args": [
            "inode"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "496-526",
          "snippet": "static struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "V1_minix_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "463-491",
    "snippet": "static struct inode *V1_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = raw_inode->i_time;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 9; i++)\n\t\tminix_inode->u.i1_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_set_inode",
          "args": [
            "inode",
            "old_decode_dev(raw_inode->i_zone[0])"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "minix_set_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "443-458",
          "snippet": "void minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};",
            "static const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};\nstatic const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};\n\nvoid minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "raw_inode->i_zone[0]"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "raw_inode->i_nlinks"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "raw_inode->i_gid"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "raw_inode->i_uid"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_V1_raw_inode",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "&bh"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "minix_V1_raw_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "105-127",
          "snippet": "struct minix_inode *\nminix_V1_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix_inode *p;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / MINIX_INODES_PER_BLOCK;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % MINIX_INODES_PER_BLOCK;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstruct minix_inode *\nminix_V1_raw_inode(struct super_block *sb, ino_t ino, struct buffer_head **bh)\n{\n\tint block;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tstruct minix_inode *p;\n\n\tif (!ino || ino > sbi->s_ninodes) {\n\t\tprintk(\"Bad inode number on dev %s: %ld is out of range\\n\",\n\t\t       sb->s_id, (long)ino);\n\t\treturn NULL;\n\t}\n\tino--;\n\tblock = 2 + sbi->s_imap_blocks + sbi->s_zmap_blocks +\n\t\t ino / MINIX_INODES_PER_BLOCK;\n\t*bh = sb_bread(sb, block);\n\tif (!*bh) {\n\t\tprintk(\"Unable to read inode block\\n\");\n\t\treturn NULL;\n\t}\n\tp = (void *)(*bh)->b_data;\n\treturn p + ino % MINIX_INODES_PER_BLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_i",
          "args": [
            "inode"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "496-526",
          "snippet": "static struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct inode *V1_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = inode->i_atime.tv_sec = inode->i_ctime.tv_sec = raw_inode->i_time;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 9; i++)\n\t\tminix_inode->u.i1_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
  },
  {
    "function_name": "minix_set_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "443-458",
    "snippet": "void minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};",
      "static const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "rdev"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic const struct address_space_operations minix_aops = {\n\t.readpage = minix_readpage,\n\t.writepage = minix_writepage,\n\t.write_begin = minix_write_begin,\n\t.write_end = generic_write_end,\n\t.bmap = minix_bmap\n};\nstatic const struct inode_operations minix_symlink_inode_operations = {\n\t.readlink\t= generic_readlink,\n\t.follow_link\t= page_follow_link_light,\n\t.put_link\t= page_put_link,\n\t.getattr\t= minix_getattr,\n};\n\nvoid minix_set_inode(struct inode *inode, dev_t rdev)\n{\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &minix_file_inode_operations;\n\t\tinode->i_fop = &minix_file_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &minix_dir_inode_operations;\n\t\tinode->i_fop = &minix_dir_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tinode->i_op = &minix_symlink_inode_operations;\n\t\tinode->i_mapping->a_ops = &minix_aops;\n\t} else\n\t\tinit_special_inode(inode, inode->i_mode, rdev);\n}"
  },
  {
    "function_name": "minix_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "423-426",
    "snippet": "static sector_t minix_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,minix_get_block);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "minix_get_block"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic sector_t minix_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,minix_get_block);\n}"
  },
  {
    "function_name": "minix_write_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "409-421",
    "snippet": "static int minix_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tminix_get_block);\n\tif (unlikely(ret))\n\t\tminix_write_failed(mapping, pos + len);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minix_write_failed",
          "args": [
            "mapping",
            "pos + len"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "minix_write_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "399-407",
          "snippet": "static void minix_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tminix_truncate(inode);\n\t}\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic void minix_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tminix_truncate(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_write_begin",
          "args": [
            "mapping",
            "pos",
            "len",
            "flags",
            "pagep",
            "minix_get_block"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2008-2028",
          "snippet": "int block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_begin(struct address_space *mapping, loff_t pos, unsigned len,\n\t\tunsigned flags, struct page **pagep, get_block_t *get_block)\n{\n\tpgoff_t index = pos >> PAGE_CACHE_SHIFT;\n\tstruct page *page;\n\tint status;\n\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tstatus = __block_write_begin(page, pos, len, get_block);\n\tif (unlikely(status)) {\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t}\n\n\t*pagep = page;\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_begin(struct file *file, struct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\tstruct page **pagep, void **fsdata)\n{\n\tint ret;\n\n\tret = block_write_begin(mapping, pos, len, flags, pagep,\n\t\t\t\tminix_get_block);\n\tif (unlikely(ret))\n\t\tminix_write_failed(mapping, pos + len);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "minix_write_failed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "399-407",
    "snippet": "static void minix_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tminix_truncate(inode);\n\t}\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minix_truncate",
          "args": [
            "inode"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "minix_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "641-649",
          "snippet": "void minix_truncate(struct inode * inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tV1_minix_truncate(inode);\n\telse\n\t\tV2_minix_truncate(inode);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nvoid minix_truncate(struct inode * inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tV1_minix_truncate(inode);\n\telse\n\t\tV2_minix_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_pagecache",
          "args": [
            "inode",
            "inode->i_size"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic void minix_write_failed(struct address_space *mapping, loff_t to)\n{\n\tstruct inode *inode = mapping->host;\n\n\tif (to > inode->i_size) {\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tminix_truncate(inode);\n\t}\n}"
  },
  {
    "function_name": "minix_prepare_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "394-397",
    "snippet": "int minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__block_write_begin",
          "args": [
            "page",
            "pos",
            "len",
            "minix_get_block"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "__block_write_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1882-1961",
          "snippet": "int __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint __block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\tget_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_CACHE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize, bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh=wait;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_CACHE_SIZE);\n\tBUG_ON(to > PAGE_CACHE_SIZE);\n\tBUG_ON(from > to);\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\n\tfor(bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start=block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\tbh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page,\n\t\t\t\t\t\tto, block_end,\n\t\t\t\t\t\tblock_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue; \n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t     (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++=bh;\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests - let them complete.\n\t */\n\twhile(wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nint minix_prepare_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\treturn __block_write_begin(page, pos, len, minix_get_block);\n}"
  },
  {
    "function_name": "minix_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "389-392",
    "snippet": "static int minix_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,minix_get_block);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "minix_get_block"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,minix_get_block);\n}"
  },
  {
    "function_name": "minix_writepage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "384-387",
    "snippet": "static int minix_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, minix_get_block, wbc);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_write_full_page",
          "args": [
            "page",
            "minix_get_block",
            "wbc"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "block_write_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2885-2921",
          "snippet": "int block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_write_full_page(struct page *page, get_block_t *get_block,\n\t\t\tstruct writeback_control *wbc)\n{\n\tstruct inode * const inode = page->mapping->host;\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n\tunsigned offset;\n\n\t/* Is the page fully inside i_size? */\n\tif (page->index < end_index)\n\t\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t       end_buffer_async_write);\n\n\t/* Is the page fully outside i_size? (truncate in progress) */\n\toffset = i_size & (PAGE_CACHE_SIZE-1);\n\tif (page->index >= end_index+1 || !offset) {\n\t\t/*\n\t\t * The page may have dirty, unmapped buffers.  For example,\n\t\t * they may have been added in ext3_writepage().  Make them\n\t\t * freeable here, so the page does not leak.\n\t\t */\n\t\tdo_invalidatepage(page, 0, PAGE_CACHE_SIZE);\n\t\tunlock_page(page);\n\t\treturn 0; /* don't care */\n\t}\n\n\t/*\n\t * The page straddles i_size.  It must be zeroed out on each and every\n\t * writepage invocation because it may be mmapped.  \"A file is mapped\n\t * in multiples of the page size.  For a file that is not a multiple of\n\t * the  page size, the remaining memory is zeroed when mapped, and\n\t * writes to that region are not written out to the file.\"\n\t */\n\tzero_user_segment(page, offset, PAGE_CACHE_SIZE);\n\treturn __block_write_full_page(inode, page, get_block, wbc,\n\t\t\t\t\t\t\tend_buffer_async_write);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_write_inode(struct inode *inode,\n\t\tstruct writeback_control *wbc);\n\nstatic int minix_writepage(struct page *page, struct writeback_control *wbc)\n{\n\treturn block_write_full_page(page, minix_get_block, wbc);\n}"
  },
  {
    "function_name": "minix_get_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "375-382",
    "snippet": "static int minix_get_block(struct inode *inode, sector_t block,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_get_block(inode, block, bh_result, create);\n\telse\n\t\treturn V2_minix_get_block(inode, block, bh_result, create);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "V2_minix_get_block",
          "args": [
            "inode",
            "block",
            "bh_result",
            "create"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/itree_v2.c",
          "lines": "62-66",
          "snippet": "int V2_minix_get_block(struct inode * inode, long block,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn get_block(inode, block, bh_result, create);\n}",
          "includes": [
            "#include \"itree_common.c\"",
            "#include \"minix.h\"",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"itree_common.c\"\n#include \"minix.h\"\n#include <linux/buffer_head.h>\n\nint V2_minix_get_block(struct inode * inode, long block,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn get_block(inode, block, bh_result, create);\n}"
        }
      },
      {
        "call_info": {
          "callee": "V1_minix_get_block",
          "args": [
            "inode",
            "block",
            "bh_result",
            "create"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "V1_minix_get_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/itree_v1.c",
          "lines": "53-57",
          "snippet": "int V1_minix_get_block(struct inode * inode, long block,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn get_block(inode, block, bh_result, create);\n}",
          "includes": [
            "#include \"itree_common.c\"",
            "#include \"minix.h\"",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"itree_common.c\"\n#include \"minix.h\"\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n\nint V1_minix_get_block(struct inode * inode, long block,\n\t\t\tstruct buffer_head *bh_result, int create)\n{\n\treturn get_block(inode, block, bh_result, create);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_VERSION",
          "args": [
            "inode"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_get_block(struct inode *inode, sector_t block,\n\t\t    struct buffer_head *bh_result, int create)\n{\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_get_block(inode, block, bh_result, create);\n\telse\n\t\treturn V2_minix_get_block(inode, block, bh_result, create);\n}"
  },
  {
    "function_name": "minix_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "356-373",
    "snippet": "static int minix_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tbuf->f_type = sb->s_magic;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (sbi->s_nzones - sbi->s_firstdatazone) << sbi->s_log_zone_size;\n\tbuf->f_bfree = minix_count_free_blocks(sb);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = sbi->s_ninodes;\n\tbuf->f_ffree = minix_count_free_inodes(sb);\n\tbuf->f_namelen = sbi->s_namelen;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int minix_statfs(struct dentry *dentry, struct kstatfs *buf);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_count_free_inodes",
          "args": [
            "sb"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "minix_count_free_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "266-272",
          "snippet": "unsigned long minix_count_free_inodes(struct super_block *sb)\n{\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu32 bits = sbi->s_ninodes + 1;\n\n\treturn count_free(sbi->s_imap, sb->s_blocksize, bits);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nunsigned long minix_count_free_inodes(struct super_block *sb)\n{\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu32 bits = sbi->s_ninodes + 1;\n\n\treturn count_free(sbi->s_imap, sb->s_blocksize, bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_count_free_blocks",
          "args": [
            "sb"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "minix_count_free_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "96-103",
          "snippet": "unsigned long minix_count_free_blocks(struct super_block *sb)\n{\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu32 bits = sbi->s_nzones - sbi->s_firstdatazone + 1;\n\n\treturn (count_free(sbi->s_zmap, sb->s_blocksize, bits)\n\t\t<< sbi->s_log_zone_size);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nunsigned long minix_count_free_blocks(struct super_block *sb)\n{\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu32 bits = sbi->s_nzones - sbi->s_firstdatazone + 1;\n\n\treturn (count_free(sbi->s_zmap, sb->s_blocksize, bits)\n\t\t<< sbi->s_log_zone_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "sb->s_bdev->bd_dev"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "sb"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_statfs(struct dentry *dentry, struct kstatfs *buf);\n\nstatic int minix_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *sb = dentry->d_sb;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\tu64 id = huge_encode_dev(sb->s_bdev->bd_dev);\n\tbuf->f_type = sb->s_magic;\n\tbuf->f_bsize = sb->s_blocksize;\n\tbuf->f_blocks = (sbi->s_nzones - sbi->s_firstdatazone) << sbi->s_log_zone_size;\n\tbuf->f_bfree = minix_count_free_blocks(sb);\n\tbuf->f_bavail = buf->f_bfree;\n\tbuf->f_files = sbi->s_ninodes;\n\tbuf->f_ffree = minix_count_free_inodes(sb);\n\tbuf->f_namelen = sbi->s_namelen;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "minix_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "158-354",
    "snippet": "static int minix_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head **map;\n\tstruct minix_super_block *ms;\n\tstruct minix3_super_block *m3s = NULL;\n\tunsigned long i, block;\n\tstruct inode *root_inode;\n\tstruct minix_sb_info *sbi;\n\tint ret = -EINVAL;\n\n\tsbi = kzalloc(sizeof(struct minix_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\n\tBUILD_BUG_ON(32 != sizeof (struct minix_inode));\n\tBUILD_BUG_ON(64 != sizeof(struct minix2_inode));\n\n\tif (!sb_set_blocksize(s, BLOCK_SIZE))\n\t\tgoto out_bad_hblock;\n\n\tif (!(bh = sb_bread(s, 1)))\n\t\tgoto out_bad_sb;\n\n\tms = (struct minix_super_block *) bh->b_data;\n\tsbi->s_ms = ms;\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = ms->s_state;\n\tsbi->s_ninodes = ms->s_ninodes;\n\tsbi->s_nzones = ms->s_nzones;\n\tsbi->s_imap_blocks = ms->s_imap_blocks;\n\tsbi->s_zmap_blocks = ms->s_zmap_blocks;\n\tsbi->s_firstdatazone = ms->s_firstdatazone;\n\tsbi->s_log_zone_size = ms->s_log_zone_size;\n\tsbi->s_max_size = ms->s_max_size;\n\ts->s_magic = ms->s_magic;\n\tif (s->s_magic == MINIX_SUPER_MAGIC) {\n\t\tsbi->s_version = MINIX_V1;\n\t\tsbi->s_dirsize = 16;\n\t\tsbi->s_namelen = 14;\n\t\ts->s_max_links = MINIX_LINK_MAX;\n\t} else if (s->s_magic == MINIX_SUPER_MAGIC2) {\n\t\tsbi->s_version = MINIX_V1;\n\t\tsbi->s_dirsize = 32;\n\t\tsbi->s_namelen = 30;\n\t\ts->s_max_links = MINIX_LINK_MAX;\n\t} else if (s->s_magic == MINIX2_SUPER_MAGIC) {\n\t\tsbi->s_version = MINIX_V2;\n\t\tsbi->s_nzones = ms->s_zones;\n\t\tsbi->s_dirsize = 16;\n\t\tsbi->s_namelen = 14;\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else if (s->s_magic == MINIX2_SUPER_MAGIC2) {\n\t\tsbi->s_version = MINIX_V2;\n\t\tsbi->s_nzones = ms->s_zones;\n\t\tsbi->s_dirsize = 32;\n\t\tsbi->s_namelen = 30;\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else if ( *(__u16 *)(bh->b_data + 24) == MINIX3_SUPER_MAGIC) {\n\t\tm3s = (struct minix3_super_block *) bh->b_data;\n\t\ts->s_magic = m3s->s_magic;\n\t\tsbi->s_imap_blocks = m3s->s_imap_blocks;\n\t\tsbi->s_zmap_blocks = m3s->s_zmap_blocks;\n\t\tsbi->s_firstdatazone = m3s->s_firstdatazone;\n\t\tsbi->s_log_zone_size = m3s->s_log_zone_size;\n\t\tsbi->s_max_size = m3s->s_max_size;\n\t\tsbi->s_ninodes = m3s->s_ninodes;\n\t\tsbi->s_nzones = m3s->s_zones;\n\t\tsbi->s_dirsize = 64;\n\t\tsbi->s_namelen = 60;\n\t\tsbi->s_version = MINIX_V3;\n\t\tsbi->s_mount_state = MINIX_VALID_FS;\n\t\tsb_set_blocksize(s, m3s->s_blocksize);\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else\n\t\tgoto out_no_fs;\n\n\t/*\n\t * Allocate the buffer map to keep the superblock small.\n\t */\n\tif (sbi->s_imap_blocks == 0 || sbi->s_zmap_blocks == 0)\n\t\tgoto out_illegal_sb;\n\ti = (sbi->s_imap_blocks + sbi->s_zmap_blocks) * sizeof(bh);\n\tmap = kzalloc(i, GFP_KERNEL);\n\tif (!map)\n\t\tgoto out_no_map;\n\tsbi->s_imap = &map[0];\n\tsbi->s_zmap = &map[sbi->s_imap_blocks];\n\n\tblock=2;\n\tfor (i=0 ; i < sbi->s_imap_blocks ; i++) {\n\t\tif (!(sbi->s_imap[i]=sb_bread(s, block)))\n\t\t\tgoto out_no_bitmap;\n\t\tblock++;\n\t}\n\tfor (i=0 ; i < sbi->s_zmap_blocks ; i++) {\n\t\tif (!(sbi->s_zmap[i]=sb_bread(s, block)))\n\t\t\tgoto out_no_bitmap;\n\t\tblock++;\n\t}\n\n\tminix_set_bit(0,sbi->s_imap[0]->b_data);\n\tminix_set_bit(0,sbi->s_zmap[0]->b_data);\n\n\t/* Apparently minix can create filesystems that allocate more blocks for\n\t * the bitmaps than needed.  We simply ignore that, but verify it didn't\n\t * create one with not enough blocks and bail out if so.\n\t */\n\tblock = minix_blocks_needed(sbi->s_ninodes, s->s_blocksize);\n\tif (sbi->s_imap_blocks < block) {\n\t\tprintk(\"MINIX-fs: file system does not have enough \"\n\t\t\t\t\"imap blocks allocated.  Refusing to mount.\\n\");\n\t\tgoto out_no_bitmap;\n\t}\n\n\tblock = minix_blocks_needed(\n\t\t\t(sbi->s_nzones - sbi->s_firstdatazone + 1),\n\t\t\ts->s_blocksize);\n\tif (sbi->s_zmap_blocks < block) {\n\t\tprintk(\"MINIX-fs: file system does not have enough \"\n\t\t\t\t\"zmap blocks allocated.  Refusing to mount.\\n\");\n\t\tgoto out_no_bitmap;\n\t}\n\n\t/* set up enough so that it can read an inode */\n\ts->s_op = &minix_sops;\n\troot_inode = minix_iget(s, MINIX_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tret = PTR_ERR(root_inode);\n\t\tgoto out_no_root;\n\t}\n\n\tret = -ENOMEM;\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root)\n\t\tgoto out_no_root;\n\n\tif (!(s->s_flags & MS_RDONLY)) {\n\t\tif (sbi->s_version != MINIX_V3) /* s_state is now out from V3 sb */\n\t\t\tms->s_state &= ~MINIX_VALID_FS;\n\t\tmark_buffer_dirty(bh);\n\t}\n\tif (!(sbi->s_mount_state & MINIX_VALID_FS))\n\t\tprintk(\"MINIX-fs: mounting unchecked file system, \"\n\t\t\t\"running fsck is recommended\\n\");\n\telse if (sbi->s_mount_state & MINIX_ERROR_FS)\n\t\tprintk(\"MINIX-fs: mounting file system with errors, \"\n\t\t\t\"running fsck is recommended\\n\");\n\n\treturn 0;\n\nout_no_root:\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: get root inode failed\\n\");\n\tgoto out_freemap;\n\nout_no_bitmap:\n\tprintk(\"MINIX-fs: bad superblock or unable to read bitmaps\\n\");\nout_freemap:\n\tfor (i = 0; i < sbi->s_imap_blocks; i++)\n\t\tbrelse(sbi->s_imap[i]);\n\tfor (i = 0; i < sbi->s_zmap_blocks; i++)\n\t\tbrelse(sbi->s_zmap[i]);\n\tkfree(sbi->s_imap);\n\tgoto out_release;\n\nout_no_map:\n\tret = -ENOMEM;\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: can't allocate map\\n\");\n\tgoto out_release;\n\nout_illegal_sb:\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: bad superblock\\n\");\n\tgoto out_release;\n\nout_no_fs:\n\tif (!silent)\n\t\tprintk(\"VFS: Can't find a Minix filesystem V1 | V2 | V3 \"\n\t\t       \"on device %s.\\n\", s->s_id);\nout_release:\n\tbrelse(bh);\n\tgoto out;\n\nout_bad_hblock:\n\tprintk(\"MINIX-fs: blocksize too small for device\\n\");\n\tgoto out;\n\nout_bad_sb:\n\tprintk(\"MINIX-fs: unable to read superblock\\n\");\nout:\n\ts->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int minix_remount (struct super_block * sb, int * flags, char * data);",
      "static const struct super_operations minix_sops = {\n\t.alloc_inode\t= minix_alloc_inode,\n\t.destroy_inode\t= minix_destroy_inode,\n\t.write_inode\t= minix_write_inode,\n\t.evict_inode\t= minix_evict_inode,\n\t.put_super\t= minix_put_super,\n\t.statfs\t\t= minix_statfs,\n\t.remount_fs\t= minix_remount,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"MINIX-fs: unable to read superblock\\n\""
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_imap"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root_inode"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root_inode"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root_inode"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_iget",
          "args": [
            "s",
            "MINIX_ROOT_INO"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "531-545",
          "snippet": "struct inode *minix_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_iget(inode);\n\telse\n\t\treturn V2_minix_iget(inode);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstruct inode *minix_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\treturn V1_minix_iget(inode);\n\telse\n\t\treturn V2_minix_iget(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_blocks_needed",
          "args": [
            "(sbi->s_nzones - sbi->s_firstdatazone + 1)",
            "s->s_blocksize"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "minix_blocks_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "90-93",
          "snippet": "static inline unsigned minix_blocks_needed(unsigned bits, unsigned blocksize)\n{\n\treturn DIV_ROUND_UP(bits, blocksize * 8);\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline unsigned minix_blocks_needed(unsigned bits, unsigned blocksize)\n{\n\treturn DIV_ROUND_UP(bits, blocksize * 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_set_bit",
          "args": [
            "0",
            "sbi->s_zmap[0]->b_data"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_set_bit",
          "args": [
            "0",
            "sbi->s_imap[0]->b_data"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "block"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "block"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "i",
            "GFP_KERNEL"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "s",
            "m3s->s_blocksize"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "s",
            "1"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "64 != sizeof(struct minix2_inode)"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "32 != sizeof (struct minix_inode)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct minix_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_remount (struct super_block * sb, int * flags, char * data);\nstatic const struct super_operations minix_sops = {\n\t.alloc_inode\t= minix_alloc_inode,\n\t.destroy_inode\t= minix_destroy_inode,\n\t.write_inode\t= minix_write_inode,\n\t.evict_inode\t= minix_evict_inode,\n\t.put_super\t= minix_put_super,\n\t.statfs\t\t= minix_statfs,\n\t.remount_fs\t= minix_remount,\n};\n\nstatic int minix_fill_super(struct super_block *s, void *data, int silent)\n{\n\tstruct buffer_head *bh;\n\tstruct buffer_head **map;\n\tstruct minix_super_block *ms;\n\tstruct minix3_super_block *m3s = NULL;\n\tunsigned long i, block;\n\tstruct inode *root_inode;\n\tstruct minix_sb_info *sbi;\n\tint ret = -EINVAL;\n\n\tsbi = kzalloc(sizeof(struct minix_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\ts->s_fs_info = sbi;\n\n\tBUILD_BUG_ON(32 != sizeof (struct minix_inode));\n\tBUILD_BUG_ON(64 != sizeof(struct minix2_inode));\n\n\tif (!sb_set_blocksize(s, BLOCK_SIZE))\n\t\tgoto out_bad_hblock;\n\n\tif (!(bh = sb_bread(s, 1)))\n\t\tgoto out_bad_sb;\n\n\tms = (struct minix_super_block *) bh->b_data;\n\tsbi->s_ms = ms;\n\tsbi->s_sbh = bh;\n\tsbi->s_mount_state = ms->s_state;\n\tsbi->s_ninodes = ms->s_ninodes;\n\tsbi->s_nzones = ms->s_nzones;\n\tsbi->s_imap_blocks = ms->s_imap_blocks;\n\tsbi->s_zmap_blocks = ms->s_zmap_blocks;\n\tsbi->s_firstdatazone = ms->s_firstdatazone;\n\tsbi->s_log_zone_size = ms->s_log_zone_size;\n\tsbi->s_max_size = ms->s_max_size;\n\ts->s_magic = ms->s_magic;\n\tif (s->s_magic == MINIX_SUPER_MAGIC) {\n\t\tsbi->s_version = MINIX_V1;\n\t\tsbi->s_dirsize = 16;\n\t\tsbi->s_namelen = 14;\n\t\ts->s_max_links = MINIX_LINK_MAX;\n\t} else if (s->s_magic == MINIX_SUPER_MAGIC2) {\n\t\tsbi->s_version = MINIX_V1;\n\t\tsbi->s_dirsize = 32;\n\t\tsbi->s_namelen = 30;\n\t\ts->s_max_links = MINIX_LINK_MAX;\n\t} else if (s->s_magic == MINIX2_SUPER_MAGIC) {\n\t\tsbi->s_version = MINIX_V2;\n\t\tsbi->s_nzones = ms->s_zones;\n\t\tsbi->s_dirsize = 16;\n\t\tsbi->s_namelen = 14;\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else if (s->s_magic == MINIX2_SUPER_MAGIC2) {\n\t\tsbi->s_version = MINIX_V2;\n\t\tsbi->s_nzones = ms->s_zones;\n\t\tsbi->s_dirsize = 32;\n\t\tsbi->s_namelen = 30;\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else if ( *(__u16 *)(bh->b_data + 24) == MINIX3_SUPER_MAGIC) {\n\t\tm3s = (struct minix3_super_block *) bh->b_data;\n\t\ts->s_magic = m3s->s_magic;\n\t\tsbi->s_imap_blocks = m3s->s_imap_blocks;\n\t\tsbi->s_zmap_blocks = m3s->s_zmap_blocks;\n\t\tsbi->s_firstdatazone = m3s->s_firstdatazone;\n\t\tsbi->s_log_zone_size = m3s->s_log_zone_size;\n\t\tsbi->s_max_size = m3s->s_max_size;\n\t\tsbi->s_ninodes = m3s->s_ninodes;\n\t\tsbi->s_nzones = m3s->s_zones;\n\t\tsbi->s_dirsize = 64;\n\t\tsbi->s_namelen = 60;\n\t\tsbi->s_version = MINIX_V3;\n\t\tsbi->s_mount_state = MINIX_VALID_FS;\n\t\tsb_set_blocksize(s, m3s->s_blocksize);\n\t\ts->s_max_links = MINIX2_LINK_MAX;\n\t} else\n\t\tgoto out_no_fs;\n\n\t/*\n\t * Allocate the buffer map to keep the superblock small.\n\t */\n\tif (sbi->s_imap_blocks == 0 || sbi->s_zmap_blocks == 0)\n\t\tgoto out_illegal_sb;\n\ti = (sbi->s_imap_blocks + sbi->s_zmap_blocks) * sizeof(bh);\n\tmap = kzalloc(i, GFP_KERNEL);\n\tif (!map)\n\t\tgoto out_no_map;\n\tsbi->s_imap = &map[0];\n\tsbi->s_zmap = &map[sbi->s_imap_blocks];\n\n\tblock=2;\n\tfor (i=0 ; i < sbi->s_imap_blocks ; i++) {\n\t\tif (!(sbi->s_imap[i]=sb_bread(s, block)))\n\t\t\tgoto out_no_bitmap;\n\t\tblock++;\n\t}\n\tfor (i=0 ; i < sbi->s_zmap_blocks ; i++) {\n\t\tif (!(sbi->s_zmap[i]=sb_bread(s, block)))\n\t\t\tgoto out_no_bitmap;\n\t\tblock++;\n\t}\n\n\tminix_set_bit(0,sbi->s_imap[0]->b_data);\n\tminix_set_bit(0,sbi->s_zmap[0]->b_data);\n\n\t/* Apparently minix can create filesystems that allocate more blocks for\n\t * the bitmaps than needed.  We simply ignore that, but verify it didn't\n\t * create one with not enough blocks and bail out if so.\n\t */\n\tblock = minix_blocks_needed(sbi->s_ninodes, s->s_blocksize);\n\tif (sbi->s_imap_blocks < block) {\n\t\tprintk(\"MINIX-fs: file system does not have enough \"\n\t\t\t\t\"imap blocks allocated.  Refusing to mount.\\n\");\n\t\tgoto out_no_bitmap;\n\t}\n\n\tblock = minix_blocks_needed(\n\t\t\t(sbi->s_nzones - sbi->s_firstdatazone + 1),\n\t\t\ts->s_blocksize);\n\tif (sbi->s_zmap_blocks < block) {\n\t\tprintk(\"MINIX-fs: file system does not have enough \"\n\t\t\t\t\"zmap blocks allocated.  Refusing to mount.\\n\");\n\t\tgoto out_no_bitmap;\n\t}\n\n\t/* set up enough so that it can read an inode */\n\ts->s_op = &minix_sops;\n\troot_inode = minix_iget(s, MINIX_ROOT_INO);\n\tif (IS_ERR(root_inode)) {\n\t\tret = PTR_ERR(root_inode);\n\t\tgoto out_no_root;\n\t}\n\n\tret = -ENOMEM;\n\ts->s_root = d_make_root(root_inode);\n\tif (!s->s_root)\n\t\tgoto out_no_root;\n\n\tif (!(s->s_flags & MS_RDONLY)) {\n\t\tif (sbi->s_version != MINIX_V3) /* s_state is now out from V3 sb */\n\t\t\tms->s_state &= ~MINIX_VALID_FS;\n\t\tmark_buffer_dirty(bh);\n\t}\n\tif (!(sbi->s_mount_state & MINIX_VALID_FS))\n\t\tprintk(\"MINIX-fs: mounting unchecked file system, \"\n\t\t\t\"running fsck is recommended\\n\");\n\telse if (sbi->s_mount_state & MINIX_ERROR_FS)\n\t\tprintk(\"MINIX-fs: mounting file system with errors, \"\n\t\t\t\"running fsck is recommended\\n\");\n\n\treturn 0;\n\nout_no_root:\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: get root inode failed\\n\");\n\tgoto out_freemap;\n\nout_no_bitmap:\n\tprintk(\"MINIX-fs: bad superblock or unable to read bitmaps\\n\");\nout_freemap:\n\tfor (i = 0; i < sbi->s_imap_blocks; i++)\n\t\tbrelse(sbi->s_imap[i]);\n\tfor (i = 0; i < sbi->s_zmap_blocks; i++)\n\t\tbrelse(sbi->s_zmap[i]);\n\tkfree(sbi->s_imap);\n\tgoto out_release;\n\nout_no_map:\n\tret = -ENOMEM;\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: can't allocate map\\n\");\n\tgoto out_release;\n\nout_illegal_sb:\n\tif (!silent)\n\t\tprintk(\"MINIX-fs: bad superblock\\n\");\n\tgoto out_release;\n\nout_no_fs:\n\tif (!silent)\n\t\tprintk(\"VFS: Can't find a Minix filesystem V1 | V2 | V3 \"\n\t\t       \"on device %s.\\n\", s->s_id);\nout_release:\n\tbrelse(bh);\n\tgoto out;\n\nout_bad_hblock:\n\tprintk(\"MINIX-fs: blocksize too small for device\\n\");\n\tgoto out;\n\nout_bad_sb:\n\tprintk(\"MINIX-fs: unable to read superblock\\n\");\nout:\n\ts->s_fs_info = NULL;\n\tkfree(sbi);\n\treturn ret;\n}"
  },
  {
    "function_name": "minix_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "121-156",
    "snippet": "static int minix_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct minix_super_block * ms;\n\n\tsync_filesystem(sb);\n\tms = sbi->s_ms;\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\treturn 0;\n\tif (*flags & MS_RDONLY) {\n\t\tif (ms->s_state & MINIX_VALID_FS ||\n\t\t    !(sbi->s_mount_state & MINIX_VALID_FS))\n\t\t\treturn 0;\n\t\t/* Mounting a rw partition read-only. */\n\t\tif (sbi->s_version != MINIX_V3)\n\t\t\tms->s_state = sbi->s_mount_state;\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t} else {\n\t  \t/* Mount a partition which is read-only, read-write. */\n\t\tif (sbi->s_version != MINIX_V3) {\n\t\t\tsbi->s_mount_state = ms->s_state;\n\t\t\tms->s_state &= ~MINIX_VALID_FS;\n\t\t} else {\n\t\t\tsbi->s_mount_state = MINIX_VALID_FS;\n\t\t}\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\n\t\tif (!(sbi->s_mount_state & MINIX_VALID_FS))\n\t\t\tprintk(\"MINIX-fs warning: remounting unchecked fs, \"\n\t\t\t\t\"running fsck is recommended\\n\");\n\t\telse if ((sbi->s_mount_state & MINIX_ERROR_FS))\n\t\t\tprintk(\"MINIX-fs warning: remounting fs with errors, \"\n\t\t\t\t\"running fsck is recommended\\n\");\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int minix_remount (struct super_block * sb, int * flags, char * data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"MINIX-fs warning: remounting fs with errors, \"\n\t\t\t\t\"running fsck is recommended\\n\""
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "sb"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic int minix_remount (struct super_block * sb, int * flags, char * data);\n\nstatic int minix_remount (struct super_block * sb, int * flags, char * data)\n{\n\tstruct minix_sb_info * sbi = minix_sb(sb);\n\tstruct minix_super_block * ms;\n\n\tsync_filesystem(sb);\n\tms = sbi->s_ms;\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\treturn 0;\n\tif (*flags & MS_RDONLY) {\n\t\tif (ms->s_state & MINIX_VALID_FS ||\n\t\t    !(sbi->s_mount_state & MINIX_VALID_FS))\n\t\t\treturn 0;\n\t\t/* Mounting a rw partition read-only. */\n\t\tif (sbi->s_version != MINIX_V3)\n\t\t\tms->s_state = sbi->s_mount_state;\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t} else {\n\t  \t/* Mount a partition which is read-only, read-write. */\n\t\tif (sbi->s_version != MINIX_V3) {\n\t\t\tsbi->s_mount_state = ms->s_state;\n\t\t\tms->s_state &= ~MINIX_VALID_FS;\n\t\t} else {\n\t\t\tsbi->s_mount_state = MINIX_VALID_FS;\n\t\t}\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\n\t\tif (!(sbi->s_mount_state & MINIX_VALID_FS))\n\t\t\tprintk(\"MINIX-fs warning: remounting unchecked fs, \"\n\t\t\t\t\"running fsck is recommended\\n\");\n\t\telse if ((sbi->s_mount_state & MINIX_ERROR_FS))\n\t\t\tprintk(\"MINIX-fs warning: remounting fs with errors, \"\n\t\t\t\t\"running fsck is recommended\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "101-109",
    "snippet": "static void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(minix_inode_cachep);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * minix_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "minix_inode_cachep"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct kmem_cache * minix_inode_cachep;\n\nstatic void destroy_inodecache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(minix_inode_cachep);\n}"
  },
  {
    "function_name": "init_inodecache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "89-99",
    "snippet": "static int __init init_inodecache(void)\n{\n\tminix_inode_cachep = kmem_cache_create(\"minix_inode_cache\",\n\t\t\t\t\t     sizeof(struct minix_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (minix_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * minix_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"minix_inode_cache\"",
            "sizeof(struct minix_inode_info)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD)",
            "init_once"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct kmem_cache * minix_inode_cachep;\n\nstatic int __init init_inodecache(void)\n{\n\tminix_inode_cachep = kmem_cache_create(\"minix_inode_cache\",\n\t\t\t\t\t     sizeof(struct minix_inode_info),\n\t\t\t\t\t     0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t\tSLAB_MEM_SPREAD),\n\t\t\t\t\t     init_once);\n\tif (minix_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
  },
  {
    "function_name": "init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "82-87",
    "snippet": "static void init_once(void *foo)\n{\n\tstruct minix_inode_info *ei = (struct minix_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&ei->vfs_inode"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "355-367",
          "snippet": "void inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_once(struct inode *inode)\n{\n\tmemset(inode, 0, sizeof(*inode));\n\tINIT_HLIST_NODE(&inode->i_hash);\n\tINIT_LIST_HEAD(&inode->i_devices);\n\tINIT_LIST_HEAD(&inode->i_wb_list);\n\tINIT_LIST_HEAD(&inode->i_lru);\n\taddress_space_init_once(&inode->i_data);\n\ti_size_ordered_init(inode);\n#ifdef CONFIG_FSNOTIFY\n\tINIT_HLIST_HEAD(&inode->i_fsnotify_marks);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic void init_once(void *foo)\n{\n\tstruct minix_inode_info *ei = (struct minix_inode_info *) foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}"
  },
  {
    "function_name": "minix_destroy_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "77-80",
    "snippet": "static void minix_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, minix_i_callback);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&inode->i_rcu",
            "minix_i_callback"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic void minix_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, minix_i_callback);\n}"
  },
  {
    "function_name": "minix_i_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "71-75",
    "snippet": "static void minix_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(minix_inode_cachep, minix_i(inode));\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * minix_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "minix_inode_cachep",
            "minix_i(inode)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "minix_i",
          "args": [
            "inode"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "V2_minix_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "496-526",
          "snippet": "static struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct inode *V2_minix_iget(struct inode *inode)\n{\n\tstruct buffer_head * bh;\n\tstruct minix2_inode * raw_inode;\n\tstruct minix_inode_info *minix_inode = minix_i(inode);\n\tint i;\n\n\traw_inode = minix_V2_raw_inode(inode->i_sb, inode->i_ino, &bh);\n\tif (!raw_inode) {\n\t\tiget_failed(inode);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\tinode->i_mode = raw_inode->i_mode;\n\ti_uid_write(inode, raw_inode->i_uid);\n\ti_gid_write(inode, raw_inode->i_gid);\n\tset_nlink(inode, raw_inode->i_nlinks);\n\tinode->i_size = raw_inode->i_size;\n\tinode->i_mtime.tv_sec = raw_inode->i_mtime;\n\tinode->i_atime.tv_sec = raw_inode->i_atime;\n\tinode->i_ctime.tv_sec = raw_inode->i_ctime;\n\tinode->i_mtime.tv_nsec = 0;\n\tinode->i_atime.tv_nsec = 0;\n\tinode->i_ctime.tv_nsec = 0;\n\tinode->i_blocks = 0;\n\tfor (i = 0; i < 10; i++)\n\t\tminix_inode->u.i2_data[i] = raw_inode->i_zone[i];\n\tminix_set_inode(inode, old_decode_dev(raw_inode->i_zone[0]));\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structinode",
            "i_rcu"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct kmem_cache * minix_inode_cachep;\n\nstatic void minix_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(minix_inode_cachep, minix_i(inode));\n}"
  },
  {
    "function_name": "minix_alloc_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "62-69",
    "snippet": "static struct inode *minix_alloc_inode(struct super_block *sb)\n{\n\tstruct minix_inode_info *ei;\n\tei = (struct minix_inode_info *)kmem_cache_alloc(minix_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache * minix_inode_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "minix_inode_cachep",
            "GFP_KERNEL"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic struct kmem_cache * minix_inode_cachep;\n\nstatic struct inode *minix_alloc_inode(struct super_block *sb)\n{\n\tstruct minix_inode_info *ei;\n\tei = (struct minix_inode_info *)kmem_cache_alloc(minix_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\treturn &ei->vfs_inode;\n}"
  },
  {
    "function_name": "minix_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "40-58",
    "snippet": "static void minix_put_super(struct super_block *sb)\n{\n\tint i;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tif (sbi->s_version != MINIX_V3)\t /* s_state is now out from V3 sb */\n\t\t\tsbi->s_ms->s_state = sbi->s_mount_state;\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n\tfor (i = 0; i < sbi->s_imap_blocks; i++)\n\t\tbrelse(sbi->s_imap[i]);\n\tfor (i = 0; i < sbi->s_zmap_blocks; i++)\n\t\tbrelse(sbi->s_zmap[i]);\n\tbrelse (sbi->s_sbh);\n\tkfree(sbi->s_imap);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_imap"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "sbi->s_sbh"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_sb",
          "args": [
            "sb"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "minix_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/minix.h",
          "lines": "80-83",
          "snippet": "static inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/minix_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/minix_fs.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic inline struct minix_sb_info *minix_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic void minix_put_super(struct super_block *sb)\n{\n\tint i;\n\tstruct minix_sb_info *sbi = minix_sb(sb);\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tif (sbi->s_version != MINIX_V3)\t /* s_state is now out from V3 sb */\n\t\t\tsbi->s_ms->s_state = sbi->s_mount_state;\n\t\tmark_buffer_dirty(sbi->s_sbh);\n\t}\n\tfor (i = 0; i < sbi->s_imap_blocks; i++)\n\t\tbrelse(sbi->s_imap[i]);\n\tfor (i = 0; i < sbi->s_zmap_blocks; i++)\n\t\tbrelse(sbi->s_zmap[i]);\n\tbrelse (sbi->s_sbh);\n\tkfree(sbi->s_imap);\n\tsb->s_fs_info = NULL;\n\tkfree(sbi);\n}"
  },
  {
    "function_name": "minix_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
    "lines": "27-38",
    "snippet": "static void minix_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\tminix_truncate(inode);\n\t}\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tif (!inode->i_nlink)\n\t\tminix_free_inode(inode);\n}",
    "includes": [
      "#include <linux/writeback.h>",
      "#include <linux/vfs.h>",
      "#include <linux/highuid.h>",
      "#include <linux/init.h>",
      "#include <linux/slab.h>",
      "#include <linux/buffer_head.h>",
      "#include \"minix.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "minix_free_inode",
          "args": [
            "inode"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "minix_free_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/bitmap.c",
          "lines": "182-210",
          "snippet": "void minix_free_inode(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tstruct buffer_head *bh;\n\tint k = sb->s_blocksize_bits + 3;\n\tunsigned long ino, bit;\n\n\tino = inode->i_ino;\n\tif (ino < 1 || ino > sbi->s_ninodes) {\n\t\tprintk(\"minix_free_inode: inode 0 or nonexistent inode\\n\");\n\t\treturn;\n\t}\n\tbit = ino & ((1<<k) - 1);\n\tino >>= k;\n\tif (ino >= sbi->s_imap_blocks) {\n\t\tprintk(\"minix_free_inode: nonexistent imap in superblock\\n\");\n\t\treturn;\n\t}\n\n\tminix_clear_inode(inode);\t/* clear on-disk copy */\n\n\tbh = sbi->s_imap[ino];\n\tspin_lock(&bitmap_lock);\n\tif (!minix_test_and_clear_bit(bit, bh->b_data))\n\t\tprintk(\"minix_free_inode: bit %lu already cleared\\n\", bit);\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(bitmap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n\nstatic DEFINE_SPINLOCK(bitmap_lock);\n\nvoid minix_free_inode(struct inode * inode)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct minix_sb_info *sbi = minix_sb(inode->i_sb);\n\tstruct buffer_head *bh;\n\tint k = sb->s_blocksize_bits + 3;\n\tunsigned long ino, bit;\n\n\tino = inode->i_ino;\n\tif (ino < 1 || ino > sbi->s_ninodes) {\n\t\tprintk(\"minix_free_inode: inode 0 or nonexistent inode\\n\");\n\t\treturn;\n\t}\n\tbit = ino & ((1<<k) - 1);\n\tino >>= k;\n\tif (ino >= sbi->s_imap_blocks) {\n\t\tprintk(\"minix_free_inode: nonexistent imap in superblock\\n\");\n\t\treturn;\n\t}\n\n\tminix_clear_inode(inode);\t/* clear on-disk copy */\n\n\tbh = sbi->s_imap[ino];\n\tspin_lock(&bitmap_lock);\n\tif (!minix_test_and_clear_bit(bit, bh->b_data))\n\t\tprintk(\"minix_free_inode: bit %lu already cleared\\n\", bit);\n\tspin_unlock(&bitmap_lock);\n\tmark_buffer_dirty(bh);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "invalidate_inode_buffers",
          "args": [
            "inode"
          ],
          "line": 34
        },
        "resolved": true,
        "details": {
          "function_name": "invalidate_inode_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "802-814",
          "snippet": "void invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int fsync_buffers_list(spinlock_t *lock, struct list_head *list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic int fsync_buffers_list(spinlock_t *lock, struct list_head *list);\n\nvoid invalidate_inode_buffers(struct inode *inode)\n{\n\tif (inode_has_buffers(inode)) {\n\t\tstruct address_space *mapping = &inode->i_data;\n\t\tstruct list_head *list = &mapping->private_list;\n\t\tstruct address_space *buffer_mapping = mapping->private_data;\n\n\t\tspin_lock(&buffer_mapping->private_lock);\n\t\twhile (!list_empty(list))\n\t\t\t__remove_assoc_queue(BH_ENTRY(list->next));\n\t\tspin_unlock(&buffer_mapping->private_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "minix_truncate",
          "args": [
            "inode"
          ],
          "line": 32
        },
        "resolved": true,
        "details": {
          "function_name": "minix_truncate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/minix/inode.c",
          "lines": "641-649",
          "snippet": "void minix_truncate(struct inode * inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tV1_minix_truncate(inode);\n\telse\n\t\tV2_minix_truncate(inode);\n}",
          "includes": [
            "#include <linux/writeback.h>",
            "#include <linux/vfs.h>",
            "#include <linux/highuid.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include \"minix.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nvoid minix_truncate(struct inode * inode)\n{\n\tif (!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) || S_ISLNK(inode->i_mode)))\n\t\treturn;\n\tif (INODE_VERSION(inode) == MINIX_V1)\n\t\tV1_minix_truncate(inode);\n\telse\n\t\tV2_minix_truncate(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/writeback.h>\n#include <linux/vfs.h>\n#include <linux/highuid.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include \"minix.h\"\n#include <linux/module.h>\n\nstatic void minix_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tif (!inode->i_nlink) {\n\t\tinode->i_size = 0;\n\t\tminix_truncate(inode);\n\t}\n\tinvalidate_inode_buffers(inode);\n\tclear_inode(inode);\n\tif (!inode->i_nlink)\n\t\tminix_free_inode(inode);\n}"
  }
]