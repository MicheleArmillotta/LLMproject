[
  {
    "function_name": "hfsplus_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.h",
    "lines": "33-39",
    "snippet": "static inline ssize_t hfsplus_getxattr(struct dentry *dentry,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tvoid *value,\n\t\t\t\t\tsize_t size)\n{\n\treturn __hfsplus_getxattr(dentry->d_inode, name, value, size);\n}",
    "includes": [
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hfsplus_getxattr",
          "args": [
            "dentry->d_inode",
            "name",
            "value",
            "size"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "477-561",
          "snippet": "ssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res = 0;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nssize_t __hfsplus_getxattr(struct inode *inode, const char *name,\n\t\t\t void *value, size_t size)\n{\n\tstruct hfs_find_data fd;\n\thfsplus_attr_entry *entry;\n\t__be32 xattr_record_type;\n\tu32 record_type;\n\tu16 record_length = 0;\n\tssize_t res = 0;\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!strcmp_xattr_finder_info(name))\n\t\treturn hfsplus_getxattr_finder_info(inode, value, size);\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree)\n\t\treturn -EOPNOTSUPP;\n\n\tentry = hfsplus_alloc_attr_entry();\n\tif (!entry) {\n\t\tpr_err(\"can't allocate xattr entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->attr_tree, &fd);\n\tif (res) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\tgoto failed_getxattr_init;\n\t}\n\n\tres = hfsplus_find_attr(inode->i_sb, inode->i_ino, name, &fd);\n\tif (res) {\n\t\tif (res == -ENOENT)\n\t\t\tres = -ENODATA;\n\t\telse\n\t\t\tpr_err(\"xattr searching failed\\n\");\n\t\tgoto out;\n\t}\n\n\thfs_bnode_read(fd.bnode, &xattr_record_type,\n\t\t\tfd.entryoffset, sizeof(xattr_record_type));\n\trecord_type = be32_to_cpu(xattr_record_type);\n\tif (record_type == HFSPLUS_ATTR_INLINE_DATA) {\n\t\trecord_length = hfs_bnode_read_u16(fd.bnode,\n\t\t\t\tfd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\tlength));\n\t\tif (record_length > HFSPLUS_MAX_INLINE_DATA_SIZE) {\n\t\t\tpr_err(\"invalid xattr record size\\n\");\n\t\t\tres = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t} else if (record_type == HFSPLUS_ATTR_FORK_DATA ||\n\t\t\trecord_type == HFSPLUS_ATTR_EXTENTS) {\n\t\tpr_err(\"only inline data xattr are supported\\n\");\n\t\tres = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tpr_err(\"invalid xattr record\\n\");\n\t\tres = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (size) {\n\t\thfs_bnode_read(fd.bnode, entry, fd.entryoffset,\n\t\t\t\toffsetof(struct hfsplus_attr_inline_data,\n\t\t\t\t\traw_bytes) + record_length);\n\t}\n\n\tif (size >= record_length) {\n\t\tmemcpy(value, entry->inline_data.raw_bytes, record_length);\n\t\tres = record_length;\n\t} else\n\t\tres = size ? -ERANGE : record_length;\n\nout:\n\thfs_find_exit(&fd);\n\nfailed_getxattr_init:\n\thfsplus_destroy_attr_entry(entry);\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline ssize_t hfsplus_getxattr(struct dentry *dentry,\n\t\t\t\t\tconst char *name,\n\t\t\t\t\tvoid *value,\n\t\t\t\t\tsize_t size)\n{\n\treturn __hfsplus_getxattr(dentry->d_inode, name, value, size);\n}"
  },
  {
    "function_name": "hfsplus_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.h",
    "lines": "24-28",
    "snippet": "static inline int hfsplus_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\treturn __hfsplus_setxattr(dentry->d_inode, name, value, size, flags);\n}",
    "includes": [
      "#include <linux/xattr.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hfsplus_setxattr",
          "args": [
            "dentry->d_inode",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "__hfsplus_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/hfsplus/xattr.c",
          "lines": "263-397",
          "snippet": "int __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/nls.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include \"hfsplus_fs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int hfsplus_removexattr(struct inode *inode, const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/nls.h>\n#include <linux/posix_acl_xattr.h>\n#include \"hfsplus_fs.h\"\n\nstatic int hfsplus_removexattr(struct inode *inode, const char *name);\n\nint __hfsplus_setxattr(struct inode *inode, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\tint err = 0;\n\tstruct hfs_find_data cat_fd;\n\thfsplus_cat_entry entry;\n\tu16 cat_entry_flags, cat_entry_type;\n\tu16 folder_finderinfo_len = sizeof(struct DInfo) +\n\t\t\t\t\tsizeof(struct DXInfo);\n\tu16 file_finderinfo_len = sizeof(struct FInfo) +\n\t\t\t\t\tsizeof(struct FXInfo);\n\n\tif ((!S_ISREG(inode->i_mode) &&\n\t\t\t!S_ISDIR(inode->i_mode)) ||\n\t\t\t\tHFSPLUS_IS_RSRC(inode))\n\t\treturn -EOPNOTSUPP;\n\n\tif (value == NULL)\n\t\treturn hfsplus_removexattr(inode, name);\n\n\terr = hfs_find_init(HFSPLUS_SB(inode->i_sb)->cat_tree, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"can't init xattr find struct\\n\");\n\t\treturn err;\n\t}\n\n\terr = hfsplus_find_cat(inode->i_sb, inode->i_ino, &cat_fd);\n\tif (err) {\n\t\tpr_err(\"catalog searching failed\\n\");\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!strcmp_xattr_finder_info(name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\thfs_bnode_read(cat_fd.bnode, &entry, cat_fd.entryoffset,\n\t\t\t\t\tsizeof(hfsplus_cat_entry));\n\t\tif (be16_to_cpu(entry.type) == HFSPLUS_FOLDER) {\n\t\t\tif (size == folder_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.folder.user_info, value,\n\t\t\t\t\t\tfolder_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_folder));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else if (be16_to_cpu(entry.type) == HFSPLUS_FILE) {\n\t\t\tif (size == file_finderinfo_len) {\n\t\t\t\tmemcpy(&entry.file.user_info, value,\n\t\t\t\t\t\tfile_finderinfo_len);\n\t\t\t\thfs_bnode_write(cat_fd.bnode, &entry,\n\t\t\t\t\tcat_fd.entryoffset,\n\t\t\t\t\tsizeof(struct hfsplus_cat_file));\n\t\t\t\thfsplus_mark_inode_dirty(inode,\n\t\t\t\t\t\tHFSPLUS_I_CAT_DIRTY);\n\t\t\t} else {\n\t\t\t\terr = -ERANGE;\n\t\t\t\tgoto end_setxattr;\n\t\t\t}\n\t\t} else {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\tgoto end_setxattr;\n\t}\n\n\tif (!HFSPLUS_SB(inode->i_sb)->attr_tree) {\n\t\terr = hfsplus_create_attributes_file(inode->i_sb);\n\t\tif (unlikely(err))\n\t\t\tgoto end_setxattr;\n\t}\n\n\tif (hfsplus_attr_exists(inode, name)) {\n\t\tif (flags & XATTR_CREATE) {\n\t\t\tpr_err(\"xattr exists yet\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_delete_attr(inode, name);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t} else {\n\t\tif (flags & XATTR_REPLACE) {\n\t\t\tpr_err(\"cannot replace xattr\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto end_setxattr;\n\t\t}\n\t\terr = hfsplus_create_attr(inode, name, value, size);\n\t\tif (err)\n\t\t\tgoto end_setxattr;\n\t}\n\n\tcat_entry_type = hfs_bnode_read_u16(cat_fd.bnode, cat_fd.entryoffset);\n\tif (cat_entry_type == HFSPLUS_FOLDER) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_folder, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\toffsetof(struct hfsplus_cat_folder, flags),\n\t\t\t\tcat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else if (cat_entry_type == HFSPLUS_FILE) {\n\t\tcat_entry_flags = hfs_bnode_read_u16(cat_fd.bnode,\n\t\t\t\t    cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags));\n\t\tcat_entry_flags |= HFSPLUS_XATTR_EXISTS;\n\t\tif (!strcmp_xattr_acl(name))\n\t\t\tcat_entry_flags |= HFSPLUS_ACL_EXISTS;\n\t\thfs_bnode_write_u16(cat_fd.bnode, cat_fd.entryoffset +\n\t\t\t\t    offsetof(struct hfsplus_cat_file, flags),\n\t\t\t\t    cat_entry_flags);\n\t\thfsplus_mark_inode_dirty(inode, HFSPLUS_I_CAT_DIRTY);\n\t} else {\n\t\tpr_err(\"invalid catalog entry type\\n\");\n\t\terr = -EIO;\n\t\tgoto end_setxattr;\n\t}\n\nend_setxattr:\n\thfs_find_exit(&cat_fd);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/xattr.h>\n\nstatic inline int hfsplus_setxattr(struct dentry *dentry, const char *name,\n\t\t\tconst void *value, size_t size, int flags)\n{\n\treturn __hfsplus_setxattr(dentry->d_inode, name, value, size, flags);\n}"
  }
]