[
  {
    "function_name": "dlm_user_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "1010-1014",
    "snippet": "void dlm_user_exit(void)\n{\n\tmisc_deregister(&ctl_device);\n\tmisc_deregister(&monitor_device);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&monitor_device"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&ctl_device"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nvoid dlm_user_exit(void)\n{\n\tmisc_deregister(&ctl_device);\n\tmisc_deregister(&monitor_device);\n}"
  },
  {
    "function_name": "dlm_user_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "989-1008",
    "snippet": "int __init dlm_user_init(void)\n{\n\tint error;\n\n\tatomic_set(&dlm_monitor_opened, 0);\n\n\terror = misc_register(&ctl_device);\n\tif (error) {\n\t\tlog_print(\"misc_register failed for control device\");\n\t\tgoto out;\n\t}\n\n\terror = misc_register(&monitor_device);\n\tif (error) {\n\t\tlog_print(\"misc_register failed for monitor device\");\n\t\tmisc_deregister(&ctl_device);\n\t}\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t dlm_monitor_opened;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&ctl_device"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"misc_register failed for monitor device\""
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&monitor_device"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"misc_register failed for control device\""
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&ctl_device"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&dlm_monitor_opened",
            "0"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic atomic_t dlm_monitor_opened;\n\nint __init dlm_user_init(void)\n{\n\tint error;\n\n\tatomic_set(&dlm_monitor_opened, 0);\n\n\terror = misc_register(&ctl_device);\n\tif (error) {\n\t\tlog_print(\"misc_register failed for control device\");\n\t\tgoto out;\n\t}\n\n\terror = misc_register(&monitor_device);\n\tif (error) {\n\t\tlog_print(\"misc_register failed for monitor device\");\n\t\tmisc_deregister(&ctl_device);\n\t}\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "monitor_device_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "944-949",
    "snippet": "static int monitor_device_close(struct inode *inode, struct file *file)\n{\n\tif (atomic_dec_and_test(&dlm_monitor_opened))\n\t\tdlm_stop_lockspaces();\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t dlm_monitor_opened;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_stop_lockspaces",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_stop_lockspaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "894-916",
          "snippet": "void dlm_stop_lockspaces(void)\n{\n\tstruct dlm_ls *ls;\n\tint count;\n\n restart:\n\tcount = 0;\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (!test_bit(LSFL_RUNNING, &ls->ls_flags)) {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tlog_error(ls, \"no userland control daemon, stopping lockspace\");\n\t\tdlm_ls_stop(ls);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (count)\n\t\tlog_print(\"dlm user daemon left %d lockspaces\", count);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_stop_lockspaces(void)\n{\n\tstruct dlm_ls *ls;\n\tint count;\n\n restart:\n\tcount = 0;\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (!test_bit(LSFL_RUNNING, &ls->ls_flags)) {\n\t\t\tcount++;\n\t\t\tcontinue;\n\t\t}\n\t\tspin_unlock(&lslist_lock);\n\t\tlog_error(ls, \"no userland control daemon, stopping lockspace\");\n\t\tdlm_ls_stop(ls);\n\t\tgoto restart;\n\t}\n\tspin_unlock(&lslist_lock);\n\n\tif (count)\n\t\tlog_print(\"dlm user daemon left %d lockspaces\", count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&dlm_monitor_opened"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic atomic_t dlm_monitor_opened;\n\nstatic int monitor_device_close(struct inode *inode, struct file *file)\n{\n\tif (atomic_dec_and_test(&dlm_monitor_opened))\n\t\tdlm_stop_lockspaces();\n\treturn 0;\n}"
  },
  {
    "function_name": "monitor_device_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "937-942",
    "snippet": "static int monitor_device_open(struct inode *inode, struct file *file)\n{\n\tatomic_inc(&dlm_monitor_opened);\n\tdlm_monitor_unused = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t dlm_monitor_opened;",
      "static int dlm_monitor_unused = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dlm_monitor_opened"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic atomic_t dlm_monitor_opened;\nstatic int dlm_monitor_unused = 1;\n\nstatic int monitor_device_open(struct inode *inode, struct file *file)\n{\n\tatomic_inc(&dlm_monitor_opened);\n\tdlm_monitor_unused = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "ctl_device_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "932-935",
    "snippet": "static int ctl_device_close(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int ctl_device_close(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ctl_device_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "926-930",
    "snippet": "static int ctl_device_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int ctl_device_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "dlm_user_daemon_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "906-924",
    "snippet": "int dlm_user_daemon_available(void)\n{\n\t/* dlm_controld hasn't started (or, has started, but not\n\t   properly populated configfs) */\n\n\tif (!dlm_our_nodeid())\n\t\treturn 0;\n\n\t/* This is to deal with versions of dlm_controld that don't\n\t   know about the monitor device.  We assume that if the\n\t   dlm_controld was started (above), but the monitor device\n\t   was never opened, that it's an old version.  dlm_controld\n\t   should open the monitor device before populating configfs. */\n\n\tif (dlm_monitor_unused)\n\t\treturn 1;\n\n\treturn atomic_read(&dlm_monitor_opened) ? 1 : 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t dlm_monitor_opened;",
      "static int dlm_monitor_unused = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&dlm_monitor_opened"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_our_nodeid",
          "args": [],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_our_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/config.c",
          "lines": "994-997",
          "snippet": "int dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}",
          "includes": [
            "#include \"lowcomms.h\"",
            "#include \"config.h\"",
            "#include <net/sock.h>",
            "#include <net/ipv6.h>",
            "#include <linux/dlmconstants.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/slab.h>",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dlm_comm *local_comm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lowcomms.h\"\n#include \"config.h\"\n#include <net/sock.h>\n#include <net/ipv6.h>\n#include <linux/dlmconstants.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/slab.h>\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dlm_comm *local_comm;\n\nint dlm_our_nodeid(void)\n{\n\treturn local_comm ? local_comm->nodeid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic atomic_t dlm_monitor_opened;\nstatic int dlm_monitor_unused = 1;\n\nint dlm_user_daemon_available(void)\n{\n\t/* dlm_controld hasn't started (or, has started, but not\n\t   properly populated configfs) */\n\n\tif (!dlm_our_nodeid())\n\t\treturn 0;\n\n\t/* This is to deal with versions of dlm_controld that don't\n\t   know about the monitor device.  We assume that if the\n\t   dlm_controld was started (above), but the monitor device\n\t   was never opened, that it's an old version.  dlm_controld\n\t   should open the monitor device before populating configfs. */\n\n\tif (dlm_monitor_unused)\n\t\treturn 1;\n\n\treturn atomic_read(&dlm_monitor_opened) ? 1 : 0;\n}"
  },
  {
    "function_name": "device_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "891-904",
    "snippet": "static unsigned int device_poll(struct file *file, poll_table *wait)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\n\tpoll_wait(file, &proc->wait, wait);\n\n\tspin_lock(&proc->asts_spin);\n\tif (!list_empty(&proc->asts)) {\n\t\tspin_unlock(&proc->asts_spin);\n\t\treturn POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock(&proc->asts_spin);\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&proc->asts_spin"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&proc->asts"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&proc->asts_spin"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&proc->wait",
            "wait"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic unsigned int device_poll(struct file *file, poll_table *wait)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\n\tpoll_wait(file, &proc->wait, wait);\n\n\tspin_lock(&proc->asts_spin);\n\tif (!list_empty(&proc->asts)) {\n\t\tspin_unlock(&proc->asts_spin);\n\t\treturn POLLIN | POLLRDNORM;\n\t}\n\tspin_unlock(&proc->asts_spin);\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_version_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "764-776",
    "snippet": "static int copy_version_to_user(char __user *buf, size_t count)\n{\n\tstruct dlm_device_version ver;\n\n\tmemset(&ver, 0, sizeof(struct dlm_device_version));\n\tver.version[0] = DLM_DEVICE_VERSION_MAJOR;\n\tver.version[1] = DLM_DEVICE_VERSION_MINOR;\n\tver.version[2] = DLM_DEVICE_VERSION_PATCH;\n\n\tif (copy_to_user(buf, &ver, sizeof(struct dlm_device_version)))\n\t\treturn -EFAULT;\n\treturn sizeof(struct dlm_device_version);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "&ver",
            "sizeof(struct dlm_device_version)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ver",
            "0",
            "sizeof(struct dlm_device_version)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int copy_version_to_user(char __user *buf, size_t count)\n{\n\tstruct dlm_device_version ver;\n\n\tmemset(&ver, 0, sizeof(struct dlm_device_version));\n\tver.version[0] = DLM_DEVICE_VERSION_MAJOR;\n\tver.version[1] = DLM_DEVICE_VERSION_MINOR;\n\tver.version[2] = DLM_DEVICE_VERSION_PATCH;\n\n\tif (copy_to_user(buf, &ver, sizeof(struct dlm_device_version)))\n\t\treturn -EFAULT;\n\treturn sizeof(struct dlm_device_version);\n}"
  },
  {
    "function_name": "copy_result_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "690-762",
    "snippet": "static int copy_result_to_user(struct dlm_user_args *ua, int compat,\n\t\t\t       uint32_t flags, int mode, int copy_lvb,\n\t\t\t       char __user *buf, size_t count)\n{\n#ifdef CONFIG_COMPAT\n\tstruct dlm_lock_result32 result32;\n#endif\n\tstruct dlm_lock_result result;\n\tvoid *resultptr;\n\tint error=0;\n\tint len;\n\tint struct_len;\n\n\tmemset(&result, 0, sizeof(struct dlm_lock_result));\n\tresult.version[0] = DLM_DEVICE_VERSION_MAJOR;\n\tresult.version[1] = DLM_DEVICE_VERSION_MINOR;\n\tresult.version[2] = DLM_DEVICE_VERSION_PATCH;\n\tmemcpy(&result.lksb, &ua->lksb, sizeof(struct dlm_lksb));\n\tresult.user_lksb = ua->user_lksb;\n\n\t/* FIXME: dlm1 provides for the user's bastparam/addr to not be updated\n\t   in a conversion unless the conversion is successful.  See code\n\t   in dlm_user_convert() for updating ua from ua_tmp.  OpenVMS, though,\n\t   notes that a new blocking AST address and parameter are set even if\n\t   the conversion fails, so maybe we should just do that. */\n\n\tif (flags & DLM_CB_BAST) {\n\t\tresult.user_astaddr = ua->bastaddr;\n\t\tresult.user_astparam = ua->bastparam;\n\t\tresult.bast_mode = mode;\n\t} else {\n\t\tresult.user_astaddr = ua->castaddr;\n\t\tresult.user_astparam = ua->castparam;\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tlen = sizeof(struct dlm_lock_result32);\n\telse\n#endif\n\t\tlen = sizeof(struct dlm_lock_result);\n\tstruct_len = len;\n\n\t/* copy lvb to userspace if there is one, it's been updated, and\n\t   the user buffer has space for it */\n\n\tif (copy_lvb && ua->lksb.sb_lvbptr && count >= len + DLM_USER_LVB_LEN) {\n\t\tif (copy_to_user(buf+len, ua->lksb.sb_lvbptr,\n\t\t\t\t DLM_USER_LVB_LEN)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tresult.lvb_offset = len;\n\t\tlen += DLM_USER_LVB_LEN;\n\t}\n\n\tresult.length = len;\n\tresultptr = &result;\n#ifdef CONFIG_COMPAT\n\tif (compat) {\n\t\tcompat_output(&result, &result32);\n\t\tresultptr = &result32;\n\t}\n#endif\n\n\tif (copy_to_user(buf, resultptr, struct_len))\n\t\terror = -EFAULT;\n\telse\n\t\terror = len;\n out:\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "resultptr",
            "struct_len"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_output",
          "args": [
            "&result",
            "&result32"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "compat_output",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "123-142",
          "snippet": "static void compat_output(struct dlm_lock_result *res,\n\t\t\t  struct dlm_lock_result32 *res32)\n{\n\tres32->version[0] = res->version[0];\n\tres32->version[1] = res->version[1];\n\tres32->version[2] = res->version[2];\n\n\tres32->user_astaddr = (__u32)(long)res->user_astaddr;\n\tres32->user_astparam = (__u32)(long)res->user_astparam;\n\tres32->user_lksb = (__u32)(long)res->user_lksb;\n\tres32->bast_mode = res->bast_mode;\n\n\tres32->lvb_offset = res->lvb_offset;\n\tres32->length = res->length;\n\n\tres32->lksb.sb_status = res->lksb.sb_status;\n\tres32->lksb.sb_flags = res->lksb.sb_flags;\n\tres32->lksb.sb_lkid = res->lksb.sb_lkid;\n\tres32->lksb.sb_lvbptr = (__u32)(long)res->lksb.sb_lvbptr;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic void compat_output(struct dlm_lock_result *res,\n\t\t\t  struct dlm_lock_result32 *res32)\n{\n\tres32->version[0] = res->version[0];\n\tres32->version[1] = res->version[1];\n\tres32->version[2] = res->version[2];\n\n\tres32->user_astaddr = (__u32)(long)res->user_astaddr;\n\tres32->user_astparam = (__u32)(long)res->user_astparam;\n\tres32->user_lksb = (__u32)(long)res->user_lksb;\n\tres32->bast_mode = res->bast_mode;\n\n\tres32->lvb_offset = res->lvb_offset;\n\tres32->length = res->length;\n\n\tres32->lksb.sb_status = res->lksb.sb_status;\n\tres32->lksb.sb_flags = res->lksb.sb_flags;\n\tres32->lksb.sb_lkid = res->lksb.sb_lkid;\n\tres32->lksb.sb_lvbptr = (__u32)(long)res->lksb.sb_lvbptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf+len",
            "ua->lksb.sb_lvbptr",
            "DLM_USER_LVB_LEN"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&result.lksb",
            "&ua->lksb",
            "sizeof(struct dlm_lksb)"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&result",
            "0",
            "sizeof(struct dlm_lock_result)"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int copy_result_to_user(struct dlm_user_args *ua, int compat,\n\t\t\t       uint32_t flags, int mode, int copy_lvb,\n\t\t\t       char __user *buf, size_t count)\n{\n#ifdef CONFIG_COMPAT\n\tstruct dlm_lock_result32 result32;\n#endif\n\tstruct dlm_lock_result result;\n\tvoid *resultptr;\n\tint error=0;\n\tint len;\n\tint struct_len;\n\n\tmemset(&result, 0, sizeof(struct dlm_lock_result));\n\tresult.version[0] = DLM_DEVICE_VERSION_MAJOR;\n\tresult.version[1] = DLM_DEVICE_VERSION_MINOR;\n\tresult.version[2] = DLM_DEVICE_VERSION_PATCH;\n\tmemcpy(&result.lksb, &ua->lksb, sizeof(struct dlm_lksb));\n\tresult.user_lksb = ua->user_lksb;\n\n\t/* FIXME: dlm1 provides for the user's bastparam/addr to not be updated\n\t   in a conversion unless the conversion is successful.  See code\n\t   in dlm_user_convert() for updating ua from ua_tmp.  OpenVMS, though,\n\t   notes that a new blocking AST address and parameter are set even if\n\t   the conversion fails, so maybe we should just do that. */\n\n\tif (flags & DLM_CB_BAST) {\n\t\tresult.user_astaddr = ua->bastaddr;\n\t\tresult.user_astparam = ua->bastparam;\n\t\tresult.bast_mode = mode;\n\t} else {\n\t\tresult.user_astaddr = ua->castaddr;\n\t\tresult.user_astparam = ua->castparam;\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (compat)\n\t\tlen = sizeof(struct dlm_lock_result32);\n\telse\n#endif\n\t\tlen = sizeof(struct dlm_lock_result);\n\tstruct_len = len;\n\n\t/* copy lvb to userspace if there is one, it's been updated, and\n\t   the user buffer has space for it */\n\n\tif (copy_lvb && ua->lksb.sb_lvbptr && count >= len + DLM_USER_LVB_LEN) {\n\t\tif (copy_to_user(buf+len, ua->lksb.sb_lvbptr,\n\t\t\t\t DLM_USER_LVB_LEN)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tresult.lvb_offset = len;\n\t\tlen += DLM_USER_LVB_LEN;\n\t}\n\n\tresult.length = len;\n\tresultptr = &result;\n#ifdef CONFIG_COMPAT\n\tif (compat) {\n\t\tcompat_output(&result, &result32);\n\t\tresultptr = &result32;\n\t}\n#endif\n\n\tif (copy_to_user(buf, resultptr, struct_len))\n\t\terror = -EFAULT;\n\telse\n\t\terror = len;\n out:\n\treturn error;\n}"
  },
  {
    "function_name": "device_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "661-688",
    "snippet": "static int device_close(struct inode *inode, struct file *file)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tset_bit(DLM_PROC_FLAGS_CLOSING, &proc->flags);\n\n\tdlm_clear_proc_locks(ls, proc);\n\n\t/* at this point no more lkb's should exist for this lockspace,\n\t   so there's no chance of dlm_user_add_ast() being called and\n\t   looking for lkb->ua->proc */\n\n\tkfree(proc);\n\tfile->private_data = NULL;\n\n\tdlm_put_lockspace(ls);\n\tdlm_put_lockspace(ls);  /* for the find in device_open() */\n\n\t/* FIXME: AUTOFREE: if this ls is no longer used do\n\t   device_remove_lockspace() */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "proc"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_clear_proc_locks",
          "args": [
            "ls",
            "proc"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_clear_proc_locks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6171-6212",
          "snippet": "void dlm_clear_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tdlm_lock_recovery(ls);\n\n\twhile (1) {\n\t\tlkb = del_proc_lock(ls, proc);\n\t\tif (!lkb)\n\t\t\tbreak;\n\t\tdel_timeout(lkb);\n\t\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\t\torphan_proc_lock(ls, lkb);\n\t\telse\n\t\t\tunlock_proc_lock(ls, lkb);\n\n\t\t/* this removes the reference for the proc->locks list\n\t\t   added by dlm_user_request, it may result in the lkb\n\t\t   being freed */\n\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\n\t/* in-progress unlocks */\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tmemset(&lkb->lkb_callbacks, 0,\n\t\t       sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n\tdlm_unlock_recovery(ls);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_clear_proc_locks(struct dlm_ls *ls, struct dlm_user_proc *proc)\n{\n\tstruct dlm_lkb *lkb, *safe;\n\n\tdlm_lock_recovery(ls);\n\n\twhile (1) {\n\t\tlkb = del_proc_lock(ls, proc);\n\t\tif (!lkb)\n\t\t\tbreak;\n\t\tdel_timeout(lkb);\n\t\tif (lkb->lkb_exflags & DLM_LKF_PERSISTENT)\n\t\t\torphan_proc_lock(ls, lkb);\n\t\telse\n\t\t\tunlock_proc_lock(ls, lkb);\n\n\t\t/* this removes the reference for the proc->locks list\n\t\t   added by dlm_user_request, it may result in the lkb\n\t\t   being freed */\n\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\n\t/* in-progress unlocks */\n\tlist_for_each_entry_safe(lkb, safe, &proc->unlocking, lkb_ownqueue) {\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags |= DLM_IFL_DEAD;\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tlist_for_each_entry_safe(lkb, safe, &proc->asts, lkb_cb_list) {\n\t\tmemset(&lkb->lkb_callbacks, 0,\n\t\t       sizeof(struct dlm_callback) * DLM_CALLBACKS_SIZE);\n\t\tlist_del_init(&lkb->lkb_cb_list);\n\t\tdlm_put_lkb(lkb);\n\t}\n\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n\tdlm_unlock_recovery(ls);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DLM_PROC_FLAGS_CLOSING",
            "&proc->flags"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "proc->lockspace"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_close(struct inode *inode, struct file *file)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tset_bit(DLM_PROC_FLAGS_CLOSING, &proc->flags);\n\n\tdlm_clear_proc_locks(ls, proc);\n\n\t/* at this point no more lkb's should exist for this lockspace,\n\t   so there's no chance of dlm_user_add_ast() being called and\n\t   looking for lkb->ua->proc */\n\n\tkfree(proc);\n\tfile->private_data = NULL;\n\n\tdlm_put_lockspace(ls);\n\tdlm_put_lockspace(ls);  /* for the find in device_open() */\n\n\t/* FIXME: AUTOFREE: if this ls is no longer used do\n\t   device_remove_lockspace() */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "device_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "634-659",
    "snippet": "static int device_open(struct inode *inode, struct file *file)\n{\n\tstruct dlm_user_proc *proc;\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_device(iminor(inode));\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tproc = kzalloc(sizeof(struct dlm_user_proc), GFP_NOFS);\n\tif (!proc) {\n\t\tdlm_put_lockspace(ls);\n\t\treturn -ENOMEM;\n\t}\n\n\tproc->lockspace = ls->ls_local_handle;\n\tINIT_LIST_HEAD(&proc->asts);\n\tINIT_LIST_HEAD(&proc->locks);\n\tINIT_LIST_HEAD(&proc->unlocking);\n\tspin_lock_init(&proc->asts_spin);\n\tspin_lock_init(&proc->locks_spin);\n\tinit_waitqueue_head(&proc->wait);\n\tfile->private_data = proc;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&proc->wait"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&proc->locks_spin"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&proc->asts_spin"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&proc->unlocking"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&proc->locks"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&proc->asts"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_user_proc)",
            "GFP_NOFS"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_device",
          "args": [
            "iminor(inode)"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "352-367",
          "snippet": "struct dlm_ls *dlm_find_lockspace_device(int minor)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_device.minor == minor) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_device(int minor)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_device.minor == minor) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iminor",
          "args": [
            "inode"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_open(struct inode *inode, struct file *file)\n{\n\tstruct dlm_user_proc *proc;\n\tstruct dlm_ls *ls;\n\n\tls = dlm_find_lockspace_device(iminor(inode));\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tproc = kzalloc(sizeof(struct dlm_user_proc), GFP_NOFS);\n\tif (!proc) {\n\t\tdlm_put_lockspace(ls);\n\t\treturn -ENOMEM;\n\t}\n\n\tproc->lockspace = ls->ls_local_handle;\n\tINIT_LIST_HEAD(&proc->asts);\n\tINIT_LIST_HEAD(&proc->locks);\n\tINIT_LIST_HEAD(&proc->unlocking);\n\tspin_lock_init(&proc->asts_spin);\n\tspin_lock_init(&proc->locks_spin);\n\tinit_waitqueue_head(&proc->wait);\n\tfile->private_data = proc;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "device_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "500-628",
    "snippet": "static ssize_t device_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\tstruct dlm_write_request *kbuf;\n\tint error;\n\n#ifdef CONFIG_COMPAT\n\tif (count < sizeof(struct dlm_write_request32))\n#else\n\tif (count < sizeof(struct dlm_write_request))\n#endif\n\t\treturn -EINVAL;\n\n\t/*\n\t * can't compare against COMPAT/dlm_write_request32 because\n\t * we don't yet know if is64bit is zero\n\t */\n\tif (count > sizeof(struct dlm_write_request) + DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tkbuf = kzalloc(count + 1, GFP_NOFS);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(kbuf, buf, count)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (check_version(kbuf)) {\n\t\terror = -EBADE;\n\t\tgoto out_free;\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (!kbuf->is64bit) {\n\t\tstruct dlm_write_request32 *k32buf;\n\t\tint namelen = 0;\n\n\t\tif (count > sizeof(struct dlm_write_request32))\n\t\t\tnamelen = count - sizeof(struct dlm_write_request32);\n\n\t\tk32buf = (struct dlm_write_request32 *)kbuf;\n\n\t\t/* add 1 after namelen so that the name string is terminated */\n\t\tkbuf = kzalloc(sizeof(struct dlm_write_request) + namelen + 1,\n\t\t\t       GFP_NOFS);\n\t\tif (!kbuf) {\n\t\t\tkfree(k32buf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (proc)\n\t\t\tset_bit(DLM_PROC_FLAGS_COMPAT, &proc->flags);\n\n\t\tcompat_input(kbuf, k32buf, namelen);\n\t\tkfree(k32buf);\n\t}\n#endif\n\n\t/* do we really need this? can a write happen after a close? */\n\tif ((kbuf->cmd == DLM_USER_LOCK || kbuf->cmd == DLM_USER_UNLOCK) &&\n\t    (proc && test_bit(DLM_PROC_FLAGS_CLOSING, &proc->flags))) {\n\t\terror = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\terror = -EINVAL;\n\n\tswitch (kbuf->cmd)\n\t{\n\tcase DLM_USER_LOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_lock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_UNLOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_unlock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_DEADLOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_deadlock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_CREATE_LOCKSPACE:\n\t\tif (proc) {\n\t\t\tlog_print(\"create/remove only on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_create_lockspace(&kbuf->i.lspace);\n\t\tbreak;\n\n\tcase DLM_USER_REMOVE_LOCKSPACE:\n\t\tif (proc) {\n\t\t\tlog_print(\"create/remove only on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_remove_lockspace(&kbuf->i.lspace);\n\t\tbreak;\n\n\tcase DLM_USER_PURGE:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_purge(proc, &kbuf->i.purge);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_print(\"Unknown command passed to DLM device : %d\\n\",\n\t\t\t  kbuf->cmd);\n\t}\n\n out_free:\n\tkfree(kbuf);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kbuf"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"Unknown command passed to DLM device : %d\\n\"",
            "kbuf->cmd"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "xlog_print_tic_res",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_log.c",
          "lines": "1961-2066",
          "snippet": "void\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}",
          "includes": [
            "#include \"xfs_sb.h\"",
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_log_recover.h\"",
            "#include \"xfs_log_priv.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct",
            "STATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);",
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sb.h\"\n#include \"xfs_sysfs.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_log_recover.h\"\n#include \"xfs_log_priv.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\nSTATIC void\nxlog_regrant_reserve_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC void\nxlog_ungrant_log_space(\n\tstruct xlog\t\t*log,\n\tstruct xlog_ticket\t*ticket);\nSTATIC struct;\n\nvoid\nxlog_print_tic_res(\n\tstruct xfs_mount\t*mp,\n\tstruct xlog_ticket\t*ticket)\n{\n\tuint i;\n\tuint ophdr_spc = ticket->t_res_num_ophdrs * (uint)sizeof(xlog_op_header_t);\n\n\t/* match with XLOG_REG_TYPE_* in xfs_log.h */\n\tstatic char *res_type_str[XLOG_REG_TYPE_MAX] = {\n\t    \"bformat\",\n\t    \"bchunk\",\n\t    \"efi_format\",\n\t    \"efd_format\",\n\t    \"iformat\",\n\t    \"icore\",\n\t    \"iext\",\n\t    \"ibroot\",\n\t    \"ilocal\",\n\t    \"iattr_ext\",\n\t    \"iattr_broot\",\n\t    \"iattr_local\",\n\t    \"qformat\",\n\t    \"dquot\",\n\t    \"quotaoff\",\n\t    \"LR header\",\n\t    \"unmount\",\n\t    \"commit\",\n\t    \"trans header\"\n\t};\n\tstatic char *trans_type_str[XFS_TRANS_TYPE_MAX] = {\n\t    \"SETATTR_NOT_SIZE\",\n\t    \"SETATTR_SIZE\",\n\t    \"INACTIVE\",\n\t    \"CREATE\",\n\t    \"CREATE_TRUNC\",\n\t    \"TRUNCATE_FILE\",\n\t    \"REMOVE\",\n\t    \"LINK\",\n\t    \"RENAME\",\n\t    \"MKDIR\",\n\t    \"RMDIR\",\n\t    \"SYMLINK\",\n\t    \"SET_DMATTRS\",\n\t    \"GROWFS\",\n\t    \"STRAT_WRITE\",\n\t    \"DIOSTRAT\",\n\t    \"WRITE_SYNC\",\n\t    \"WRITEID\",\n\t    \"ADDAFORK\",\n\t    \"ATTRINVAL\",\n\t    \"ATRUNCATE\",\n\t    \"ATTR_SET\",\n\t    \"ATTR_RM\",\n\t    \"ATTR_FLAG\",\n\t    \"CLEAR_AGI_BUCKET\",\n\t    \"QM_SBCHANGE\",\n\t    \"DUMMY1\",\n\t    \"DUMMY2\",\n\t    \"QM_QUOTAOFF\",\n\t    \"QM_DQALLOC\",\n\t    \"QM_SETQLIM\",\n\t    \"QM_DQCLUSTER\",\n\t    \"QM_QINOCREATE\",\n\t    \"QM_QUOTAOFF_END\",\n\t    \"SB_UNIT\",\n\t    \"FSYNC_TS\",\n\t    \"GROWFSRT_ALLOC\",\n\t    \"GROWFSRT_ZERO\",\n\t    \"GROWFSRT_FREE\",\n\t    \"SWAPEXT\"\n\t};\n\n\txfs_warn(mp,\n\t\t\"xlog_write: reservation summary:\\n\"\n\t\t\"  trans type  = %s (%u)\\n\"\n\t\t\"  unit res    = %d bytes\\n\"\n\t\t\"  current res = %d bytes\\n\"\n\t\t\"  total reg   = %u bytes (o/flow = %u bytes)\\n\"\n\t\t\"  ophdrs      = %u (ophdr space = %u bytes)\\n\"\n\t\t\"  ophdr + reg = %u bytes\\n\"\n\t\t\"  num regions = %u\",\n\t\t((ticket->t_trans_type <= 0 ||\n\t\t  ticket->t_trans_type > XFS_TRANS_TYPE_MAX) ?\n\t\t  \"bad-trans-type\" : trans_type_str[ticket->t_trans_type-1]),\n\t\tticket->t_trans_type,\n\t\tticket->t_unit_res,\n\t\tticket->t_curr_res,\n\t\tticket->t_res_arr_sum, ticket->t_res_o_flow,\n\t\tticket->t_res_num_ophdrs, ophdr_spc,\n\t\tticket->t_res_arr_sum +\n\t\tticket->t_res_o_flow + ophdr_spc,\n\t\tticket->t_res_num);\n\n\tfor (i = 0; i < ticket->t_res_num; i++) {\n\t\tuint r_type = ticket->t_res_arr[i].r_type;\n\t\txfs_warn(mp, \"region[%u]: %s - %u bytes\", i,\n\t\t\t    ((r_type <= 0 || r_type > XLOG_REG_TYPE_MAX) ?\n\t\t\t    \"bad-rtype\" : res_type_str[r_type-1]),\n\t\t\t    ticket->t_res_arr[i].r_len);\n\t}\n\n\txfs_alert_tag(mp, XFS_PTAG_LOGRES,\n\t\t\"xlog_write: reservation ran out. Need to up reservation\");\n\txfs_force_shutdown(mp, SHUTDOWN_LOG_IO_ERROR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "device_user_purge",
          "args": [
            "proc",
            "&kbuf->i.purge"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "device_user_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "379-393",
          "snippet": "static int device_user_purge(struct dlm_user_proc *proc,\n\t\t\t     struct dlm_purge_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_purge(ls, proc, params->nodeid, params->pid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_user_purge(struct dlm_user_proc *proc,\n\t\t\t     struct dlm_purge_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_purge(ls, proc, params->nodeid, params->pid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"no locking on control device\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_remove_lockspace",
          "args": [
            "&kbuf->i.lspace"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "device_remove_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "425-455",
          "snippet": "static int device_remove_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error, force = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tls = dlm_find_lockspace_device(params->minor);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (params->flags & DLM_USER_LSFLG_FORCEFREE)\n\t\tforce = 2;\n\n\tlockspace = ls->ls_local_handle;\n\tdlm_put_lockspace(ls);\n\n\t/* The final dlm_release_lockspace waits for references to go to\n\t   zero, so all processes will need to close their device for the\n\t   ls before the release will proceed.  release also calls the\n\t   device_deregister above.  Converting a positive return value\n\t   from release to zero means that userspace won't know when its\n\t   release was the final one, but it shouldn't need to know. */\n\n\terror = dlm_release_lockspace(lockspace, force);\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_remove_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error, force = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tls = dlm_find_lockspace_device(params->minor);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (params->flags & DLM_USER_LSFLG_FORCEFREE)\n\t\tforce = 2;\n\n\tlockspace = ls->ls_local_handle;\n\tdlm_put_lockspace(ls);\n\n\t/* The final dlm_release_lockspace waits for references to go to\n\t   zero, so all processes will need to close their device for the\n\t   ls before the release will proceed.  release also calls the\n\t   device_deregister above.  Converting a positive return value\n\t   from release to zero means that userspace won't know when its\n\t   release was the final one, but it shouldn't need to know. */\n\n\terror = dlm_release_lockspace(lockspace, force);\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"create/remove only on control device\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_create_lockspace",
          "args": [
            "&kbuf->i.lspace"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "device_create_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "395-423",
          "snippet": "static int device_create_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = dlm_new_lockspace(params->name, NULL, params->flags,\n\t\t\t\t  DLM_USER_LVB_LEN, NULL, NULL, NULL,\n\t\t\t\t  &lockspace);\n\tif (error)\n\t\treturn error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_device_register(ls, params->name);\n\tdlm_put_lockspace(ls);\n\n\tif (error)\n\t\tdlm_release_lockspace(lockspace, 0);\n\telse\n\t\terror = ls->ls_device.minor;\n\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_create_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = dlm_new_lockspace(params->name, NULL, params->flags,\n\t\t\t\t  DLM_USER_LVB_LEN, NULL, NULL, NULL,\n\t\t\t\t  &lockspace);\n\tif (error)\n\t\treturn error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_device_register(ls, params->name);\n\tdlm_put_lockspace(ls);\n\n\tif (error)\n\t\tdlm_release_lockspace(lockspace, 0);\n\telse\n\t\terror = ls->ls_device.minor;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"create/remove only on control device\""
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_user_deadlock",
          "args": [
            "proc",
            "&kbuf->i.lock"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "device_user_deadlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "319-333",
          "snippet": "static int device_user_deadlock(struct dlm_user_proc *proc,\n\t\t\t\tstruct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_deadlock(ls, params->flags, params->lkid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_user_deadlock(struct dlm_user_proc *proc,\n\t\t\t\tstruct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_deadlock(ls, params->flags, params->lkid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"no locking on control device\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_user_unlock",
          "args": [
            "proc",
            "&kbuf->i.lock"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "device_user_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "290-317",
          "snippet": "static int device_user_unlock(struct dlm_user_proc *proc,\n\t\t\t      struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\n\tif (params->flags & DLM_LKF_CANCEL)\n\t\terror = dlm_user_cancel(ls, ua, params->flags, params->lkid);\n\telse\n\t\terror = dlm_user_unlock(ls, ua, params->flags, params->lkid,\n\t\t\t\t\tparams->lvb);\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_user_unlock(struct dlm_user_proc *proc,\n\t\t\t      struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\n\tif (params->flags & DLM_LKF_CANCEL)\n\t\terror = dlm_user_cancel(ls, ua, params->flags, params->lkid);\n\telse\n\t\terror = dlm_user_unlock(ls, ua, params->flags, params->lkid,\n\t\t\t\t\tparams->lvb);\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"no locking on control device\""
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "device_user_lock",
          "args": [
            "proc",
            "&kbuf->i.lock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "device_user_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "236-288",
          "snippet": "static int device_user_lock(struct dlm_user_proc *proc,\n\t\t\t    struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tuint32_t lkid;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (!params->castaddr || !params->lksb) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\tua->bastparam = params->bastparam;\n\tua->bastaddr = params->bastaddr;\n\tua->xid = params->xid;\n\n\tif (params->flags & DLM_LKF_CONVERT) {\n\t\terror = dlm_user_convert(ls, ua,\n\t\t\t\t         params->mode, params->flags,\n\t\t\t\t         params->lkid, params->lvb,\n\t\t\t\t\t (unsigned long) params->timeout);\n\t} else if (params->flags & DLM_LKF_ORPHAN) {\n\t\terror = dlm_user_adopt_orphan(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t (unsigned long) params->timeout,\n\t\t\t\t\t &lkid);\n\t\tif (!error)\n\t\t\terror = lkid;\n\t} else {\n\t\terror = dlm_user_request(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t (unsigned long) params->timeout);\n\t\tif (!error)\n\t\t\terror = ua->lksb.sb_lkid;\n\t}\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_user_lock(struct dlm_user_proc *proc,\n\t\t\t    struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tuint32_t lkid;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (!params->castaddr || !params->lksb) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\tua->bastparam = params->bastparam;\n\tua->bastaddr = params->bastaddr;\n\tua->xid = params->xid;\n\n\tif (params->flags & DLM_LKF_CONVERT) {\n\t\terror = dlm_user_convert(ls, ua,\n\t\t\t\t         params->mode, params->flags,\n\t\t\t\t         params->lkid, params->lvb,\n\t\t\t\t\t (unsigned long) params->timeout);\n\t} else if (params->flags & DLM_LKF_ORPHAN) {\n\t\terror = dlm_user_adopt_orphan(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t (unsigned long) params->timeout,\n\t\t\t\t\t &lkid);\n\t\tif (!error)\n\t\t\terror = lkid;\n\t} else {\n\t\terror = dlm_user_request(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t (unsigned long) params->timeout);\n\t\tif (!error)\n\t\t\terror = ua->lksb.sb_lkid;\n\t}\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_print",
          "args": [
            "\"no locking on control device\""
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DLM_PROC_FLAGS_CLOSING",
            "&proc->flags"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "k32buf"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_input",
          "args": [
            "kbuf",
            "k32buf",
            "namelen"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "compat_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "87-121",
          "snippet": "static void compat_input(struct dlm_write_request *kb,\n\t\t\t struct dlm_write_request32 *kb32,\n\t\t\t int namelen)\n{\n\tkb->version[0] = kb32->version[0];\n\tkb->version[1] = kb32->version[1];\n\tkb->version[2] = kb32->version[2];\n\n\tkb->cmd = kb32->cmd;\n\tkb->is64bit = kb32->is64bit;\n\tif (kb->cmd == DLM_USER_CREATE_LOCKSPACE ||\n\t    kb->cmd == DLM_USER_REMOVE_LOCKSPACE) {\n\t\tkb->i.lspace.flags = kb32->i.lspace.flags;\n\t\tkb->i.lspace.minor = kb32->i.lspace.minor;\n\t\tmemcpy(kb->i.lspace.name, kb32->i.lspace.name, namelen);\n\t} else if (kb->cmd == DLM_USER_PURGE) {\n\t\tkb->i.purge.nodeid = kb32->i.purge.nodeid;\n\t\tkb->i.purge.pid = kb32->i.purge.pid;\n\t} else {\n\t\tkb->i.lock.mode = kb32->i.lock.mode;\n\t\tkb->i.lock.namelen = kb32->i.lock.namelen;\n\t\tkb->i.lock.flags = kb32->i.lock.flags;\n\t\tkb->i.lock.lkid = kb32->i.lock.lkid;\n\t\tkb->i.lock.parent = kb32->i.lock.parent;\n\t\tkb->i.lock.xid = kb32->i.lock.xid;\n\t\tkb->i.lock.timeout = kb32->i.lock.timeout;\n\t\tkb->i.lock.castparam = (void *)(long)kb32->i.lock.castparam;\n\t\tkb->i.lock.castaddr = (void *)(long)kb32->i.lock.castaddr;\n\t\tkb->i.lock.bastparam = (void *)(long)kb32->i.lock.bastparam;\n\t\tkb->i.lock.bastaddr = (void *)(long)kb32->i.lock.bastaddr;\n\t\tkb->i.lock.lksb = (void *)(long)kb32->i.lock.lksb;\n\t\tmemcpy(kb->i.lock.lvb, kb32->i.lock.lvb, DLM_USER_LVB_LEN);\n\t\tmemcpy(kb->i.lock.name, kb32->i.lock.name, namelen);\n\t}\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic void compat_input(struct dlm_write_request *kb,\n\t\t\t struct dlm_write_request32 *kb32,\n\t\t\t int namelen)\n{\n\tkb->version[0] = kb32->version[0];\n\tkb->version[1] = kb32->version[1];\n\tkb->version[2] = kb32->version[2];\n\n\tkb->cmd = kb32->cmd;\n\tkb->is64bit = kb32->is64bit;\n\tif (kb->cmd == DLM_USER_CREATE_LOCKSPACE ||\n\t    kb->cmd == DLM_USER_REMOVE_LOCKSPACE) {\n\t\tkb->i.lspace.flags = kb32->i.lspace.flags;\n\t\tkb->i.lspace.minor = kb32->i.lspace.minor;\n\t\tmemcpy(kb->i.lspace.name, kb32->i.lspace.name, namelen);\n\t} else if (kb->cmd == DLM_USER_PURGE) {\n\t\tkb->i.purge.nodeid = kb32->i.purge.nodeid;\n\t\tkb->i.purge.pid = kb32->i.purge.pid;\n\t} else {\n\t\tkb->i.lock.mode = kb32->i.lock.mode;\n\t\tkb->i.lock.namelen = kb32->i.lock.namelen;\n\t\tkb->i.lock.flags = kb32->i.lock.flags;\n\t\tkb->i.lock.lkid = kb32->i.lock.lkid;\n\t\tkb->i.lock.parent = kb32->i.lock.parent;\n\t\tkb->i.lock.xid = kb32->i.lock.xid;\n\t\tkb->i.lock.timeout = kb32->i.lock.timeout;\n\t\tkb->i.lock.castparam = (void *)(long)kb32->i.lock.castparam;\n\t\tkb->i.lock.castaddr = (void *)(long)kb32->i.lock.castaddr;\n\t\tkb->i.lock.bastparam = (void *)(long)kb32->i.lock.bastparam;\n\t\tkb->i.lock.bastaddr = (void *)(long)kb32->i.lock.bastaddr;\n\t\tkb->i.lock.lksb = (void *)(long)kb32->i.lock.lksb;\n\t\tmemcpy(kb->i.lock.lvb, kb32->i.lock.lvb, DLM_USER_LVB_LEN);\n\t\tmemcpy(kb->i.lock.name, kb32->i.lock.name, namelen);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DLM_PROC_FLAGS_COMPAT",
            "&proc->flags"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "k32buf"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_write_request) + namelen + 1",
            "GFP_NOFS"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_version",
          "args": [
            "kbuf"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "check_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "458-477",
          "snippet": "static int check_version(struct dlm_write_request *req)\n{\n\tif (req->version[0] != DLM_DEVICE_VERSION_MAJOR ||\n\t    (req->version[0] == DLM_DEVICE_VERSION_MAJOR &&\n\t     req->version[1] > DLM_DEVICE_VERSION_MINOR)) {\n\n\t\tprintk(KERN_DEBUG \"dlm: process %s (%d) version mismatch \"\n\t\t       \"user (%d.%d.%d) kernel (%d.%d.%d)\\n\",\n\t\t       current->comm,\n\t\t       task_pid_nr(current),\n\t\t       req->version[0],\n\t\t       req->version[1],\n\t\t       req->version[2],\n\t\t       DLM_DEVICE_VERSION_MAJOR,\n\t\t       DLM_DEVICE_VERSION_MINOR,\n\t\t       DLM_DEVICE_VERSION_PATCH);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int check_version(struct dlm_write_request *req)\n{\n\tif (req->version[0] != DLM_DEVICE_VERSION_MAJOR ||\n\t    (req->version[0] == DLM_DEVICE_VERSION_MAJOR &&\n\t     req->version[1] > DLM_DEVICE_VERSION_MINOR)) {\n\n\t\tprintk(KERN_DEBUG \"dlm: process %s (%d) version mismatch \"\n\t\t       \"user (%d.%d.%d) kernel (%d.%d.%d)\\n\",\n\t\t       current->comm,\n\t\t       task_pid_nr(current),\n\t\t       req->version[0],\n\t\t       req->version[1],\n\t\t       req->version[2],\n\t\t       DLM_DEVICE_VERSION_MAJOR,\n\t\t       DLM_DEVICE_VERSION_MINOR,\n\t\t       DLM_DEVICE_VERSION_PATCH);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "kbuf",
            "buf",
            "count"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "count + 1",
            "GFP_NOFS"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic ssize_t device_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct dlm_user_proc *proc = file->private_data;\n\tstruct dlm_write_request *kbuf;\n\tint error;\n\n#ifdef CONFIG_COMPAT\n\tif (count < sizeof(struct dlm_write_request32))\n#else\n\tif (count < sizeof(struct dlm_write_request))\n#endif\n\t\treturn -EINVAL;\n\n\t/*\n\t * can't compare against COMPAT/dlm_write_request32 because\n\t * we don't yet know if is64bit is zero\n\t */\n\tif (count > sizeof(struct dlm_write_request) + DLM_RESNAME_MAXLEN)\n\t\treturn -EINVAL;\n\n\tkbuf = kzalloc(count + 1, GFP_NOFS);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(kbuf, buf, count)) {\n\t\terror = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (check_version(kbuf)) {\n\t\terror = -EBADE;\n\t\tgoto out_free;\n\t}\n\n#ifdef CONFIG_COMPAT\n\tif (!kbuf->is64bit) {\n\t\tstruct dlm_write_request32 *k32buf;\n\t\tint namelen = 0;\n\n\t\tif (count > sizeof(struct dlm_write_request32))\n\t\t\tnamelen = count - sizeof(struct dlm_write_request32);\n\n\t\tk32buf = (struct dlm_write_request32 *)kbuf;\n\n\t\t/* add 1 after namelen so that the name string is terminated */\n\t\tkbuf = kzalloc(sizeof(struct dlm_write_request) + namelen + 1,\n\t\t\t       GFP_NOFS);\n\t\tif (!kbuf) {\n\t\t\tkfree(k32buf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (proc)\n\t\t\tset_bit(DLM_PROC_FLAGS_COMPAT, &proc->flags);\n\n\t\tcompat_input(kbuf, k32buf, namelen);\n\t\tkfree(k32buf);\n\t}\n#endif\n\n\t/* do we really need this? can a write happen after a close? */\n\tif ((kbuf->cmd == DLM_USER_LOCK || kbuf->cmd == DLM_USER_UNLOCK) &&\n\t    (proc && test_bit(DLM_PROC_FLAGS_CLOSING, &proc->flags))) {\n\t\terror = -EINVAL;\n\t\tgoto out_free;\n\t}\n\n\terror = -EINVAL;\n\n\tswitch (kbuf->cmd)\n\t{\n\tcase DLM_USER_LOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_lock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_UNLOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_unlock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_DEADLOCK:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_deadlock(proc, &kbuf->i.lock);\n\t\tbreak;\n\n\tcase DLM_USER_CREATE_LOCKSPACE:\n\t\tif (proc) {\n\t\t\tlog_print(\"create/remove only on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_create_lockspace(&kbuf->i.lspace);\n\t\tbreak;\n\n\tcase DLM_USER_REMOVE_LOCKSPACE:\n\t\tif (proc) {\n\t\t\tlog_print(\"create/remove only on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_remove_lockspace(&kbuf->i.lspace);\n\t\tbreak;\n\n\tcase DLM_USER_PURGE:\n\t\tif (!proc) {\n\t\t\tlog_print(\"no locking on control device\");\n\t\t\tgoto out_free;\n\t\t}\n\t\terror = device_user_purge(proc, &kbuf->i.purge);\n\t\tbreak;\n\n\tdefault:\n\t\tlog_print(\"Unknown command passed to DLM device : %d\\n\",\n\t\t\t  kbuf->cmd);\n\t}\n\n out_free:\n\tkfree(kbuf);\n\treturn error;\n}"
  },
  {
    "function_name": "check_version",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "458-477",
    "snippet": "static int check_version(struct dlm_write_request *req)\n{\n\tif (req->version[0] != DLM_DEVICE_VERSION_MAJOR ||\n\t    (req->version[0] == DLM_DEVICE_VERSION_MAJOR &&\n\t     req->version[1] > DLM_DEVICE_VERSION_MINOR)) {\n\n\t\tprintk(KERN_DEBUG \"dlm: process %s (%d) version mismatch \"\n\t\t       \"user (%d.%d.%d) kernel (%d.%d.%d)\\n\",\n\t\t       current->comm,\n\t\t       task_pid_nr(current),\n\t\t       req->version[0],\n\t\t       req->version[1],\n\t\t       req->version[2],\n\t\t       DLM_DEVICE_VERSION_MAJOR,\n\t\t       DLM_DEVICE_VERSION_MINOR,\n\t\t       DLM_DEVICE_VERSION_PATCH);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"dlm: process %s (%d) version mismatch \"\n\t\t       \"user (%d.%d.%d) kernel (%d.%d.%d)\\n\"",
            "current->comm",
            "task_pid_nr(current)",
            "req->version[0]",
            "req->version[1]",
            "req->version[2]",
            "DLM_DEVICE_VERSION_MAJOR",
            "DLM_DEVICE_VERSION_MINOR",
            "DLM_DEVICE_VERSION_PATCH"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int check_version(struct dlm_write_request *req)\n{\n\tif (req->version[0] != DLM_DEVICE_VERSION_MAJOR ||\n\t    (req->version[0] == DLM_DEVICE_VERSION_MAJOR &&\n\t     req->version[1] > DLM_DEVICE_VERSION_MINOR)) {\n\n\t\tprintk(KERN_DEBUG \"dlm: process %s (%d) version mismatch \"\n\t\t       \"user (%d.%d.%d) kernel (%d.%d.%d)\\n\",\n\t\t       current->comm,\n\t\t       task_pid_nr(current),\n\t\t       req->version[0],\n\t\t       req->version[1],\n\t\t       req->version[2],\n\t\t       DLM_DEVICE_VERSION_MAJOR,\n\t\t       DLM_DEVICE_VERSION_MINOR,\n\t\t       DLM_DEVICE_VERSION_PATCH);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "device_remove_lockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "425-455",
    "snippet": "static int device_remove_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error, force = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tls = dlm_find_lockspace_device(params->minor);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (params->flags & DLM_USER_LSFLG_FORCEFREE)\n\t\tforce = 2;\n\n\tlockspace = ls->ls_local_handle;\n\tdlm_put_lockspace(ls);\n\n\t/* The final dlm_release_lockspace waits for references to go to\n\t   zero, so all processes will need to close their device for the\n\t   ls before the release will proceed.  release also calls the\n\t   device_deregister above.  Converting a positive return value\n\t   from release to zero means that userspace won't know when its\n\t   release was the final one, but it shouldn't need to know. */\n\n\terror = dlm_release_lockspace(lockspace, force);\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_release_lockspace",
          "args": [
            "lockspace",
            "force"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_release_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "873-892",
          "snippet": "int dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct mutex\t\tls_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_device",
          "args": [
            "params->minor"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "352-367",
          "snippet": "struct dlm_ls *dlm_find_lockspace_device(int minor)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_device.minor == minor) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_device(int minor)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_device.minor == minor) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_remove_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error, force = 0;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tls = dlm_find_lockspace_device(params->minor);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (params->flags & DLM_USER_LSFLG_FORCEFREE)\n\t\tforce = 2;\n\n\tlockspace = ls->ls_local_handle;\n\tdlm_put_lockspace(ls);\n\n\t/* The final dlm_release_lockspace waits for references to go to\n\t   zero, so all processes will need to close their device for the\n\t   ls before the release will proceed.  release also calls the\n\t   device_deregister above.  Converting a positive return value\n\t   from release to zero means that userspace won't know when its\n\t   release was the final one, but it shouldn't need to know. */\n\n\terror = dlm_release_lockspace(lockspace, force);\n\tif (error > 0)\n\t\terror = 0;\n\treturn error;\n}"
  },
  {
    "function_name": "device_create_lockspace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "395-423",
    "snippet": "static int device_create_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = dlm_new_lockspace(params->name, NULL, params->flags,\n\t\t\t\t  DLM_USER_LVB_LEN, NULL, NULL, NULL,\n\t\t\t\t  &lockspace);\n\tif (error)\n\t\treturn error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_device_register(ls, params->name);\n\tdlm_put_lockspace(ls);\n\n\tif (error)\n\t\tdlm_release_lockspace(lockspace, 0);\n\telse\n\t\terror = ls->ls_device.minor;\n\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_release_lockspace",
          "args": [
            "lockspace",
            "0"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_release_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "873-892",
          "snippet": "int dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct mutex\t\tls_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_device_register",
          "args": [
            "ls",
            "params->name"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_device_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "335-361",
          "snippet": "static int dlm_device_register(struct dlm_ls *ls, char *name)\n{\n\tint error, len;\n\n\t/* The device is already registered.  This happens when the\n\t   lockspace is created multiple times from userspace. */\n\tif (ls->ls_device.name)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\tlen = strlen(name) + strlen(name_prefix) + 2;\n\tls->ls_device.name = kzalloc(len, GFP_NOFS);\n\tif (!ls->ls_device.name)\n\t\tgoto fail;\n\n\tsnprintf((char *)ls->ls_device.name, len, \"%s_%s\", name_prefix,\n\t\t name);\n\tls->ls_device.fops = &device_fops;\n\tls->ls_device.minor = MISC_DYNAMIC_MINOR;\n\n\terror = misc_register(&ls->ls_device);\n\tif (error) {\n\t\tkfree(ls->ls_device.name);\n\t}\nfail:\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char name_prefix[] = \"dlm\";",
            "static const struct file_operations device_fops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic const char name_prefix[] = \"dlm\";\nstatic const struct file_operations device_fops;\n\nstatic int dlm_device_register(struct dlm_ls *ls, char *name)\n{\n\tint error, len;\n\n\t/* The device is already registered.  This happens when the\n\t   lockspace is created multiple times from userspace. */\n\tif (ls->ls_device.name)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\tlen = strlen(name) + strlen(name_prefix) + 2;\n\tls->ls_device.name = kzalloc(len, GFP_NOFS);\n\tif (!ls->ls_device.name)\n\t\tgoto fail;\n\n\tsnprintf((char *)ls->ls_device.name, len, \"%s_%s\", name_prefix,\n\t\t name);\n\tls->ls_device.fops = &device_fops;\n\tls->ls_device.minor = MISC_DYNAMIC_MINOR;\n\n\terror = misc_register(&ls->ls_device);\n\tif (error) {\n\t\tkfree(ls->ls_device.name);\n\t}\nfail:\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "lockspace"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_new_lockspace",
          "args": [
            "params->name",
            "NULL",
            "params->flags",
            "DLM_USER_LVB_LEN",
            "NULL",
            "NULL",
            "NULL",
            "&lockspace"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "692-716",
          "snippet": "int dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct mutex\t\tls_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_create_lockspace(struct dlm_lspace_params *params)\n{\n\tdlm_lockspace_t *lockspace;\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terror = dlm_new_lockspace(params->name, NULL, params->flags,\n\t\t\t\t  DLM_USER_LVB_LEN, NULL, NULL, NULL,\n\t\t\t\t  &lockspace);\n\tif (error)\n\t\treturn error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_device_register(ls, params->name);\n\tdlm_put_lockspace(ls);\n\n\tif (error)\n\t\tdlm_release_lockspace(lockspace, 0);\n\telse\n\t\terror = ls->ls_device.minor;\n\n\treturn error;\n}"
  },
  {
    "function_name": "device_user_purge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "379-393",
    "snippet": "static int device_user_purge(struct dlm_user_proc *proc,\n\t\t\t     struct dlm_purge_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_purge(ls, proc, params->nodeid, params->pid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_user_purge",
          "args": [
            "ls",
            "proc",
            "params->nodeid",
            "params->pid"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6287-6303",
          "snippet": "int dlm_user_purge(struct dlm_ls *ls, struct dlm_user_proc *proc,\n\t\t   int nodeid, int pid)\n{\n\tint error = 0;\n\n\tif (nodeid && (nodeid != dlm_our_nodeid())) {\n\t\terror = send_purge(ls, nodeid, pid);\n\t} else {\n\t\tdlm_lock_recovery(ls);\n\t\tif (pid == current->pid)\n\t\t\tpurge_proc_locks(ls, proc);\n\t\telse\n\t\t\tdo_purge(ls, nodeid, pid);\n\t\tdlm_unlock_recovery(ls);\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\n\nint dlm_user_purge(struct dlm_ls *ls, struct dlm_user_proc *proc,\n\t\t   int nodeid, int pid)\n{\n\tint error = 0;\n\n\tif (nodeid && (nodeid != dlm_our_nodeid())) {\n\t\terror = send_purge(ls, nodeid, pid);\n\t} else {\n\t\tdlm_lock_recovery(ls);\n\t\tif (pid == current->pid)\n\t\t\tpurge_proc_locks(ls, proc);\n\t\telse\n\t\t\tdo_purge(ls, nodeid, pid);\n\t\tdlm_unlock_recovery(ls);\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "proc->lockspace"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_user_purge(struct dlm_user_proc *proc,\n\t\t\t     struct dlm_purge_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_purge(ls, proc, params->nodeid, params->pid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_device_deregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "363-377",
    "snippet": "int dlm_device_deregister(struct dlm_ls *ls)\n{\n\tint error;\n\n\t/* The device is not registered.  This happens when the lockspace\n\t   was never used from userspace, or when device_create_lockspace()\n\t   calls dlm_release_lockspace() after the register fails. */\n\tif (!ls->ls_device.name)\n\t\treturn 0;\n\n\terror = misc_deregister(&ls->ls_device);\n\tif (!error)\n\t\tkfree(ls->ls_device.name);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_device.name"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&ls->ls_device"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nint dlm_device_deregister(struct dlm_ls *ls)\n{\n\tint error;\n\n\t/* The device is not registered.  This happens when the lockspace\n\t   was never used from userspace, or when device_create_lockspace()\n\t   calls dlm_release_lockspace() after the register fails. */\n\tif (!ls->ls_device.name)\n\t\treturn 0;\n\n\terror = misc_deregister(&ls->ls_device);\n\tif (!error)\n\t\tkfree(ls->ls_device.name);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_device_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "335-361",
    "snippet": "static int dlm_device_register(struct dlm_ls *ls, char *name)\n{\n\tint error, len;\n\n\t/* The device is already registered.  This happens when the\n\t   lockspace is created multiple times from userspace. */\n\tif (ls->ls_device.name)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\tlen = strlen(name) + strlen(name_prefix) + 2;\n\tls->ls_device.name = kzalloc(len, GFP_NOFS);\n\tif (!ls->ls_device.name)\n\t\tgoto fail;\n\n\tsnprintf((char *)ls->ls_device.name, len, \"%s_%s\", name_prefix,\n\t\t name);\n\tls->ls_device.fops = &device_fops;\n\tls->ls_device.minor = MISC_DYNAMIC_MINOR;\n\n\terror = misc_register(&ls->ls_device);\n\tif (error) {\n\t\tkfree(ls->ls_device.name);\n\t}\nfail:\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char name_prefix[] = \"dlm\";",
      "static const struct file_operations device_fops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_device.name"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&ls->ls_device"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "(char *)ls->ls_device.name",
            "len",
            "\"%s_%s\"",
            "name_prefix",
            "name"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name_prefix"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic const char name_prefix[] = \"dlm\";\nstatic const struct file_operations device_fops;\n\nstatic int dlm_device_register(struct dlm_ls *ls, char *name)\n{\n\tint error, len;\n\n\t/* The device is already registered.  This happens when the\n\t   lockspace is created multiple times from userspace. */\n\tif (ls->ls_device.name)\n\t\treturn 0;\n\n\terror = -ENOMEM;\n\tlen = strlen(name) + strlen(name_prefix) + 2;\n\tls->ls_device.name = kzalloc(len, GFP_NOFS);\n\tif (!ls->ls_device.name)\n\t\tgoto fail;\n\n\tsnprintf((char *)ls->ls_device.name, len, \"%s_%s\", name_prefix,\n\t\t name);\n\tls->ls_device.fops = &device_fops;\n\tls->ls_device.minor = MISC_DYNAMIC_MINOR;\n\n\terror = misc_register(&ls->ls_device);\n\tif (error) {\n\t\tkfree(ls->ls_device.name);\n\t}\nfail:\n\treturn error;\n}"
  },
  {
    "function_name": "device_user_deadlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "319-333",
    "snippet": "static int device_user_deadlock(struct dlm_user_proc *proc,\n\t\t\t\tstruct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_deadlock(ls, params->flags, params->lkid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_user_deadlock",
          "args": [
            "ls",
            "params->flags",
            "params->lkid"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_deadlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6048-6094",
          "snippet": "int dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\t/* same as cancel_lock(), but set DEADLOCK_CANCEL after lock_rsb */\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, &args);\n\tif (error)\n\t\tgoto out_r;\n\tlkb->lkb_flags |= DLM_IFL_DEADLOCK_CANCEL;\n\n\terror = _cancel_lock(r, lkb);\n out_r:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_remove(struct dlm_rsb *r);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_remove(struct dlm_rsb *r);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_deadlock(struct dlm_ls *ls, uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_rsb *r;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\t/* same as cancel_lock(), but set DEADLOCK_CANCEL after lock_rsb */\n\n\tr = lkb->lkb_resource;\n\thold_rsb(r);\n\tlock_rsb(r);\n\n\terror = validate_unlock_args(lkb, &args);\n\tif (error)\n\t\tgoto out_r;\n\tlkb->lkb_flags |= DLM_IFL_DEADLOCK_CANCEL;\n\n\terror = _cancel_lock(r, lkb);\n out_r:\n\tunlock_rsb(r);\n\tput_rsb(r);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "proc->lockspace"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_user_deadlock(struct dlm_user_proc *proc,\n\t\t\t\tstruct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\terror = dlm_user_deadlock(ls, params->flags, params->lkid);\n\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "device_user_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "290-317",
    "snippet": "static int device_user_unlock(struct dlm_user_proc *proc,\n\t\t\t      struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\n\tif (params->flags & DLM_LKF_CANCEL)\n\t\terror = dlm_user_cancel(ls, ua, params->flags, params->lkid);\n\telse\n\t\terror = dlm_user_unlock(ls, ua, params->flags, params->lkid,\n\t\t\t\t\tparams->lvb);\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_user_unlock",
          "args": [
            "ls",
            "ua",
            "params->flags",
            "params->lkid",
            "params->lvb"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5961-6008",
          "snippet": "int dlm_user_unlock(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid, char *lvb_in)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY && (flags & DLM_LKF_FORCEUNLOCK))\n\t\terror = 0;\n\tif (error)\n\t\tgoto out_put;\n\n\tspin_lock(&ua->proc->locks_spin);\n\t/* dlm_user_add_cb() may have already taken lkb off the proc list */\n\tif (!list_empty(&lkb->lkb_ownqueue))\n\t\tlist_move(&lkb->lkb_ownqueue, &ua->proc->unlocking);\n\tspin_unlock(&ua->proc->locks_spin);\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_unlock(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid, char *lvb_in)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY && (flags & DLM_LKF_FORCEUNLOCK))\n\t\terror = 0;\n\tif (error)\n\t\tgoto out_put;\n\n\tspin_lock(&ua->proc->locks_spin);\n\t/* dlm_user_add_cb() may have already taken lkb off the proc list */\n\tif (!list_empty(&lkb->lkb_ownqueue))\n\t\tlist_move(&lkb->lkb_ownqueue, &ua->proc->unlocking);\n\tspin_unlock(&ua->proc->locks_spin);\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_user_cancel",
          "args": [
            "ls",
            "ua",
            "params->flags",
            "params->lkid"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "6010-6046",
          "snippet": "int dlm_user_cancel(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = cancel_lock(ls, lkb, &args);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_cancel(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t    uint32_t flags, uint32_t lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\tua = lkb->lkb_ua;\n\tif (ua_tmp->castparam)\n\t\tua->castparam = ua_tmp->castparam;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_unlock_args(flags, ua, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = cancel_lock(ls, lkb, &args);\n\n\tif (error == -DLM_ECANCEL)\n\t\terror = 0;\n\t/* from validate_unlock_args() */\n\tif (error == -EBUSY)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_user_args)",
            "GFP_NOFS"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "proc->lockspace"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_user_unlock(struct dlm_user_proc *proc,\n\t\t\t      struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\n\tif (params->flags & DLM_LKF_CANCEL)\n\t\terror = dlm_user_cancel(ls, ua, params->flags, params->lkid);\n\telse\n\t\terror = dlm_user_unlock(ls, ua, params->flags, params->lkid,\n\t\t\t\t\tparams->lvb);\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "device_user_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "236-288",
    "snippet": "static int device_user_lock(struct dlm_user_proc *proc,\n\t\t\t    struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tuint32_t lkid;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (!params->castaddr || !params->lksb) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\tua->bastparam = params->bastparam;\n\tua->bastaddr = params->bastaddr;\n\tua->xid = params->xid;\n\n\tif (params->flags & DLM_LKF_CONVERT) {\n\t\terror = dlm_user_convert(ls, ua,\n\t\t\t\t         params->mode, params->flags,\n\t\t\t\t         params->lkid, params->lvb,\n\t\t\t\t\t (unsigned long) params->timeout);\n\t} else if (params->flags & DLM_LKF_ORPHAN) {\n\t\terror = dlm_user_adopt_orphan(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t (unsigned long) params->timeout,\n\t\t\t\t\t &lkid);\n\t\tif (!error)\n\t\t\terror = lkid;\n\t} else {\n\t\terror = dlm_user_request(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t (unsigned long) params->timeout);\n\t\tif (!error)\n\t\t\terror = ua->lksb.sb_lkid;\n\t}\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put_lockspace",
          "args": [
            "ls"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "369-374",
          "snippet": "void dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic spinlock_t\t\tlslist_lock;\n\nvoid dlm_put_lockspace(struct dlm_ls *ls)\n{\n\tspin_lock(&lslist_lock);\n\tls->ls_count--;\n\tspin_unlock(&lslist_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_user_request",
          "args": [
            "ls",
            "ua",
            "params->mode",
            "params->flags",
            "params->name",
            "params->namelen",
            "(unsigned long) params->timeout"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5770-5833",
          "snippet": "int dlm_user_request(struct dlm_ls *ls, struct dlm_user_args *ua,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     unsigned long timeout_cs)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = create_lkb(ls, &lkb);\n\tif (error) {\n\t\tkfree(ua);\n\t\tgoto out;\n\t}\n\n\tif (flags & DLM_LKF_VALBLK) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\tkfree(ua);\n\t\t\t__put_lkb(ls, lkb);\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* After ua is attached to lkb it will be freed by dlm_free_lkb().\n\t   When DLM_IFL_USER is set, the dlm knows that this is a userspace\n\t   lock and that lkb_astparam is the dlm_user_args structure. */\n\n\terror = set_lock_args(mode, &ua->lksb, flags, namelen, timeout_cs,\n\t\t\t      fake_astfn, ua, fake_bastfn, &args);\n\tlkb->lkb_flags |= DLM_IFL_USER;\n\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out;\n\t}\n\n\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\terror = 0;\n\t\tbreak;\n\tcase -EAGAIN:\n\t\terror = 0;\n\t\t/* fall through */\n\tdefault:\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out;\n\t}\n\n\t/* add this new lkb to the per-process list of locks */\n\tspin_lock(&ua->proc->locks_spin);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_request(struct dlm_ls *ls, struct dlm_user_args *ua,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     unsigned long timeout_cs)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = create_lkb(ls, &lkb);\n\tif (error) {\n\t\tkfree(ua);\n\t\tgoto out;\n\t}\n\n\tif (flags & DLM_LKF_VALBLK) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\tkfree(ua);\n\t\t\t__put_lkb(ls, lkb);\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* After ua is attached to lkb it will be freed by dlm_free_lkb().\n\t   When DLM_IFL_USER is set, the dlm knows that this is a userspace\n\t   lock and that lkb_astparam is the dlm_user_args structure. */\n\n\terror = set_lock_args(mode, &ua->lksb, flags, namelen, timeout_cs,\n\t\t\t      fake_astfn, ua, fake_bastfn, &args);\n\tlkb->lkb_flags |= DLM_IFL_USER;\n\n\tif (error) {\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out;\n\t}\n\n\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tswitch (error) {\n\tcase 0:\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\terror = 0;\n\t\tbreak;\n\tcase -EAGAIN:\n\t\terror = 0;\n\t\t/* fall through */\n\tdefault:\n\t\t__put_lkb(ls, lkb);\n\t\tgoto out;\n\t}\n\n\t/* add this new lkb to the per-process list of locks */\n\tspin_lock(&ua->proc->locks_spin);\n\thold_lkb(lkb);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tdlm_unlock_recovery(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_user_adopt_orphan",
          "args": [
            "ls",
            "ua",
            "params->mode",
            "params->flags",
            "params->name",
            "params->namelen",
            "(unsigned long) params->timeout",
            "&lkid"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_adopt_orphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5895-5959",
          "snippet": "int dlm_user_adopt_orphan(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     unsigned long timeout_cs, uint32_t *lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_user_args *ua;\n\tint found_other_mode = 0;\n\tint found = 0;\n\tint rv = 0;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (lkb->lkb_resource->res_length != namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(lkb->lkb_resource->res_name, name, namelen))\n\t\t\tcontinue;\n\t\tif (lkb->lkb_grmode != mode) {\n\t\t\tfound_other_mode = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 1;\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags &= ~DLM_IFL_ORPHAN;\n\t\t*lkid = lkb->lkb_id;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tif (!found && found_other_mode) {\n\t\trv = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (!found) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = flags;\n\tlkb->lkb_ownpid = (int) current->pid;\n\n\tua = lkb->lkb_ua;\n\n\tua->proc = ua_tmp->proc;\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\t/*\n\t * The lkb reference from the ls_orphans list was not\n\t * removed above, and is now considered the reference\n\t * for the proc locks list.\n\t */\n\n\tspin_lock(&ua->proc->locks_spin);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tkfree(ua_tmp);\n\treturn rv;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void do_purge(struct dlm_ls *ls, int nodeid, int pid);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void do_purge(struct dlm_ls *ls, int nodeid, int pid);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_adopt_orphan(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, void *name, unsigned int namelen,\n\t\t     unsigned long timeout_cs, uint32_t *lkid)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_user_args *ua;\n\tint found_other_mode = 0;\n\tint found = 0;\n\tint rv = 0;\n\n\tmutex_lock(&ls->ls_orphans_mutex);\n\tlist_for_each_entry(lkb, &ls->ls_orphans, lkb_ownqueue) {\n\t\tif (lkb->lkb_resource->res_length != namelen)\n\t\t\tcontinue;\n\t\tif (memcmp(lkb->lkb_resource->res_name, name, namelen))\n\t\t\tcontinue;\n\t\tif (lkb->lkb_grmode != mode) {\n\t\t\tfound_other_mode = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfound = 1;\n\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\tlkb->lkb_flags &= ~DLM_IFL_ORPHAN;\n\t\t*lkid = lkb->lkb_id;\n\t\tbreak;\n\t}\n\tmutex_unlock(&ls->ls_orphans_mutex);\n\n\tif (!found && found_other_mode) {\n\t\trv = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (!found) {\n\t\trv = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tlkb->lkb_exflags = flags;\n\tlkb->lkb_ownpid = (int) current->pid;\n\n\tua = lkb->lkb_ua;\n\n\tua->proc = ua_tmp->proc;\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\t/*\n\t * The lkb reference from the ls_orphans list was not\n\t * removed above, and is now considered the reference\n\t * for the proc locks list.\n\t */\n\n\tspin_lock(&ua->proc->locks_spin);\n\tlist_add_tail(&lkb->lkb_ownqueue, &ua->proc->locks);\n\tspin_unlock(&ua->proc->locks_spin);\n out:\n\tkfree(ua_tmp);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_user_convert",
          "args": [
            "ls",
            "ua",
            "params->mode",
            "params->flags",
            "params->lkid",
            "params->lvb",
            "(unsigned long) params->timeout"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_user_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "5835-5887",
          "snippet": "int dlm_user_convert(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, uint32_t lkid, char *lvb_in,\n\t\t     unsigned long timeout_cs)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\t/* user can change the params on its lock when it converts it, or\n\t   add an lvb that didn't exist before */\n\n\tua = lkb->lkb_ua;\n\n\tif (flags & DLM_LKF_VALBLK && !ua->lksb.sb_lvbptr) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_lock_args(mode, &ua->lksb, flags, 0, timeout_cs,\n\t\t\t      fake_astfn, ua, fake_bastfn, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = convert_lock(ls, lkb, &args);\n\n\tif (error == -EINPROGRESS || error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_user_convert(struct dlm_ls *ls, struct dlm_user_args *ua_tmp,\n\t\t     int mode, uint32_t flags, uint32_t lkid, char *lvb_in,\n\t\t     unsigned long timeout_cs)\n{\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tstruct dlm_user_args *ua;\n\tint error;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\t/* user can change the params on its lock when it converts it, or\n\t   add an lvb that didn't exist before */\n\n\tua = lkb->lkb_ua;\n\n\tif (flags & DLM_LKF_VALBLK && !ua->lksb.sb_lvbptr) {\n\t\tua->lksb.sb_lvbptr = kzalloc(DLM_USER_LVB_LEN, GFP_NOFS);\n\t\tif (!ua->lksb.sb_lvbptr) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_put;\n\t\t}\n\t}\n\tif (lvb_in && ua->lksb.sb_lvbptr)\n\t\tmemcpy(ua->lksb.sb_lvbptr, lvb_in, DLM_USER_LVB_LEN);\n\n\tua->xid = ua_tmp->xid;\n\tua->castparam = ua_tmp->castparam;\n\tua->castaddr = ua_tmp->castaddr;\n\tua->bastparam = ua_tmp->bastparam;\n\tua->bastaddr = ua_tmp->bastaddr;\n\tua->user_lksb = ua_tmp->user_lksb;\n\n\terror = set_lock_args(mode, &ua->lksb, flags, 0, timeout_cs,\n\t\t\t      fake_astfn, ua, fake_bastfn, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\terror = convert_lock(ls, lkb, &args);\n\n\tif (error == -EINPROGRESS || error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tkfree(ua_tmp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct dlm_user_args)",
            "GFP_NOFS"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_find_lockspace_local",
          "args": [
            "proc->lockspace"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_find_lockspace_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "335-350",
          "snippet": "struct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct list_head\t\tlslist;",
            "static spinlock_t\t\tlslist_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct list_head\t\tlslist;\nstatic spinlock_t\t\tlslist_lock;\n\nstruct dlm_ls *dlm_find_lockspace_local(dlm_lockspace_t *lockspace)\n{\n\tstruct dlm_ls *ls;\n\n\tspin_lock(&lslist_lock);\n\tlist_for_each_entry(ls, &lslist, ls_list) {\n\t\tif (ls->ls_local_handle == lockspace) {\n\t\t\tls->ls_count++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tls = NULL;\n out:\n\tspin_unlock(&lslist_lock);\n\treturn ls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int device_user_lock(struct dlm_user_proc *proc,\n\t\t\t    struct dlm_lock_params *params)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tuint32_t lkid;\n\tint error = -ENOMEM;\n\n\tls = dlm_find_lockspace_local(proc->lockspace);\n\tif (!ls)\n\t\treturn -ENOENT;\n\n\tif (!params->castaddr || !params->lksb) {\n\t\terror = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tua = kzalloc(sizeof(struct dlm_user_args), GFP_NOFS);\n\tif (!ua)\n\t\tgoto out;\n\tua->proc = proc;\n\tua->user_lksb = params->lksb;\n\tua->castparam = params->castparam;\n\tua->castaddr = params->castaddr;\n\tua->bastparam = params->bastparam;\n\tua->bastaddr = params->bastaddr;\n\tua->xid = params->xid;\n\n\tif (params->flags & DLM_LKF_CONVERT) {\n\t\terror = dlm_user_convert(ls, ua,\n\t\t\t\t         params->mode, params->flags,\n\t\t\t\t         params->lkid, params->lvb,\n\t\t\t\t\t (unsigned long) params->timeout);\n\t} else if (params->flags & DLM_LKF_ORPHAN) {\n\t\terror = dlm_user_adopt_orphan(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t (unsigned long) params->timeout,\n\t\t\t\t\t &lkid);\n\t\tif (!error)\n\t\t\terror = lkid;\n\t} else {\n\t\terror = dlm_user_request(ls, ua,\n\t\t\t\t\t params->mode, params->flags,\n\t\t\t\t\t params->name, params->namelen,\n\t\t\t\t\t (unsigned long) params->timeout);\n\t\tif (!error)\n\t\t\terror = ua->lksb.sb_lkid;\n\t}\n out:\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
  },
  {
    "function_name": "dlm_user_add_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "175-234",
    "snippet": "void dlm_user_add_ast(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t      int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_user_proc *proc;\n\tint rv;\n\n\tif (lkb->lkb_flags & (DLM_IFL_ORPHAN | DLM_IFL_DEAD))\n\t\treturn;\n\n\tls = lkb->lkb_resource->res_ls;\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\n\t/* If ORPHAN/DEAD flag is set, it means the process is dead so an ast\n\t   can't be delivered.  For ORPHAN's, dlm_clear_proc_locks() freed\n\t   lkb->ua so we can't try to use it.  This second check is necessary\n\t   for cases where a completion ast is received for an operation that\n\t   began before clear_proc_locks did its cancel/unlock. */\n\n\tif (lkb->lkb_flags & (DLM_IFL_ORPHAN | DLM_IFL_DEAD))\n\t\tgoto out;\n\n\tDLM_ASSERT(lkb->lkb_ua, dlm_print_lkb(lkb););\n\tua = lkb->lkb_ua;\n\tproc = ua->proc;\n\n\tif ((flags & DLM_CB_BAST) && ua->bastaddr == NULL)\n\t\tgoto out;\n\n\tif ((flags & DLM_CB_CAST) && lkb_is_endoflife(mode, status))\n\t\tlkb->lkb_flags |= DLM_IFL_ENDOFLIFE;\n\n\tspin_lock(&proc->asts_spin);\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, seq);\n\tif (rv < 0) {\n\t\tspin_unlock(&proc->asts_spin);\n\t\tgoto out;\n\t}\n\n\tif (list_empty(&lkb->lkb_cb_list)) {\n\t\tkref_get(&lkb->lkb_ref);\n\t\tlist_add_tail(&lkb->lkb_cb_list, &proc->asts);\n\t\twake_up_interruptible(&proc->wait);\n\t}\n\tspin_unlock(&proc->asts_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\t/* N.B. spin_lock locks_spin, not asts_spin */\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&lkb->lkb_ownqueue)) {\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t\tdlm_put_lkb(lkb);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\t}\n out:\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ls->ls_clear_proc_locks"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&proc->locks_spin"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_put_lkb",
          "args": [
            "lkb"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "1269-1278",
          "snippet": "int dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_put_lkb(struct dlm_lkb *lkb)\n{\n\tstruct dlm_ls *ls;\n\n\tDLM_ASSERT(lkb->lkb_resource, dlm_print_lkb(lkb););\n\tDLM_ASSERT(lkb->lkb_resource->res_ls, dlm_print_lkb(lkb););\n\n\tls = lkb->lkb_resource->res_ls;\n\treturn __put_lkb(ls, lkb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&lkb->lkb_ownqueue"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "recover_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/recover.c",
          "lines": "237-246",
          "snippet": "static int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"recover.h\"",
            "#include \"member.h\"",
            "#include \"lowcomms.h\"",
            "#include \"lock.h\"",
            "#include \"rcom.h\"",
            "#include \"memory.h\"",
            "#include \"ast.h\"",
            "#include \"config.h\"",
            "#include \"dir.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recover.h\"\n#include \"member.h\"\n#include \"lowcomms.h\"\n#include \"lock.h\"\n#include \"rcom.h\"\n#include \"memory.h\"\n#include \"ast.h\"\n#include \"config.h\"\n#include \"dir.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int recover_list_empty(struct dlm_ls *ls)\n{\n\tint empty;\n\n\tspin_lock(&ls->ls_recover_list_lock);\n\tempty = list_empty(&ls->ls_recover_list);\n\tspin_unlock(&ls->ls_recover_list_lock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&proc->locks_spin"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&proc->wait"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&lkb->lkb_cb_list",
            "&proc->asts"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&lkb->lkb_ref"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_add_lkb_callback",
          "args": [
            "lkb",
            "flags",
            "mode",
            "status",
            "sbflags",
            "seq"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_add_lkb_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/ast.c",
          "lines": "53-112",
          "snippet": "int dlm_add_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t\t int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t prev_seq;\n\tint prev_mode;\n\tint i, rv;\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (lkb->lkb_callbacks[i].seq)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Suppress some redundant basts here, do more on removal.\n\t\t * Don't even add a bast if the callback just before it\n\t\t * is a bast for the same mode or a more restrictive mode.\n\t\t * (the addional > PR check is needed for PR/CW inversion)\n\t\t */\n\n\t\tif ((i > 0) && (flags & DLM_CB_BAST) &&\n\t\t    (lkb->lkb_callbacks[i-1].flags & DLM_CB_BAST)) {\n\n\t\t\tprev_seq = lkb->lkb_callbacks[i-1].seq;\n\t\t\tprev_mode = lkb->lkb_callbacks[i-1].mode;\n\n\t\t\tif ((prev_mode == mode) ||\n\t\t\t    (prev_mode > mode && prev_mode > DLM_LOCK_PR)) {\n\n\t\t\t\tlog_debug(ls, \"skip %x add bast %llu mode %d \"\n\t\t\t\t\t  \"for bast %llu mode %d\",\n\t\t\t\t\t  lkb->lkb_id,\n\t\t\t\t\t  (unsigned long long)seq,\n\t\t\t\t\t  mode,\n\t\t\t\t\t  (unsigned long long)prev_seq,\n\t\t\t\t\t  prev_mode);\n\t\t\t\trv = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlkb->lkb_callbacks[i].seq = seq;\n\t\tlkb->lkb_callbacks[i].flags = flags;\n\t\tlkb->lkb_callbacks[i].mode = mode;\n\t\tlkb->lkb_callbacks[i].sb_status = status;\n\t\tlkb->lkb_callbacks[i].sb_flags = (sbflags & 0x000000FF);\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tif (i == DLM_CALLBACKS_SIZE) {\n\t\tlog_error(ls, \"no callbacks %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id, (unsigned long long)seq,\n\t\t\t  flags, mode, status, sbflags);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t\trv = -1;\n\t\tgoto out;\n\t}\n out:\n\treturn rv;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lock.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lock.h\"\n#include \"dlm_internal.h\"\n\nint dlm_add_lkb_callback(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t\t int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls = lkb->lkb_resource->res_ls;\n\tuint64_t prev_seq;\n\tint prev_mode;\n\tint i, rv;\n\n\tfor (i = 0; i < DLM_CALLBACKS_SIZE; i++) {\n\t\tif (lkb->lkb_callbacks[i].seq)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Suppress some redundant basts here, do more on removal.\n\t\t * Don't even add a bast if the callback just before it\n\t\t * is a bast for the same mode or a more restrictive mode.\n\t\t * (the addional > PR check is needed for PR/CW inversion)\n\t\t */\n\n\t\tif ((i > 0) && (flags & DLM_CB_BAST) &&\n\t\t    (lkb->lkb_callbacks[i-1].flags & DLM_CB_BAST)) {\n\n\t\t\tprev_seq = lkb->lkb_callbacks[i-1].seq;\n\t\t\tprev_mode = lkb->lkb_callbacks[i-1].mode;\n\n\t\t\tif ((prev_mode == mode) ||\n\t\t\t    (prev_mode > mode && prev_mode > DLM_LOCK_PR)) {\n\n\t\t\t\tlog_debug(ls, \"skip %x add bast %llu mode %d \"\n\t\t\t\t\t  \"for bast %llu mode %d\",\n\t\t\t\t\t  lkb->lkb_id,\n\t\t\t\t\t  (unsigned long long)seq,\n\t\t\t\t\t  mode,\n\t\t\t\t\t  (unsigned long long)prev_seq,\n\t\t\t\t\t  prev_mode);\n\t\t\t\trv = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tlkb->lkb_callbacks[i].seq = seq;\n\t\tlkb->lkb_callbacks[i].flags = flags;\n\t\tlkb->lkb_callbacks[i].mode = mode;\n\t\tlkb->lkb_callbacks[i].sb_status = status;\n\t\tlkb->lkb_callbacks[i].sb_flags = (sbflags & 0x000000FF);\n\t\trv = 0;\n\t\tbreak;\n\t}\n\n\tif (i == DLM_CALLBACKS_SIZE) {\n\t\tlog_error(ls, \"no callbacks %x %llu flags %x mode %d sb %d %x\",\n\t\t\t  lkb->lkb_id, (unsigned long long)seq,\n\t\t\t  flags, mode, status, sbflags);\n\t\tdlm_dump_lkb_callbacks(lkb);\n\t\trv = -1;\n\t\tgoto out;\n\t}\n out:\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lkb_is_endoflife",
          "args": [
            "mode",
            "status"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "lkb_is_endoflife",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
          "lines": "156-170",
          "snippet": "static int lkb_is_endoflife(int mode, int status)\n{\n\tswitch (status) {\n\tcase -DLM_EUNLOCK:\n\t\treturn 1;\n\tcase -DLM_ECANCEL:\n\tcase -ETIMEDOUT:\n\tcase -EDEADLK:\n\tcase -EAGAIN:\n\t\tif (mode == DLM_LOCK_IV)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"lock.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/dlm_device.h>",
            "#include <linux/dlm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/signal.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/init.h>",
            "#include <linux/miscdevice.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int lkb_is_endoflife(int mode, int status)\n{\n\tswitch (status) {\n\tcase -DLM_EUNLOCK:\n\t\treturn 1;\n\tcase -DLM_ECANCEL:\n\tcase -ETIMEDOUT:\n\tcase -EDEADLK:\n\tcase -EAGAIN:\n\t\tif (mode == DLM_LOCK_IV)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DLM_ASSERT",
          "args": [
            "lkb->lkb_ua",
            "dlm_print_lkb(lkb);"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_lkb",
          "args": [
            "lkb"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_print_lkb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "162-170",
          "snippet": "void dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nvoid dlm_print_lkb(struct dlm_lkb *lkb)\n{\n\tprintk(KERN_ERR \"lkb: nodeid %d id %x remid %x exflags %x flags %x \"\n\t       \"sts %d rq %d gr %d wait_type %d wait_nodeid %d seq %llu\\n\",\n\t       lkb->lkb_nodeid, lkb->lkb_id, lkb->lkb_remid, lkb->lkb_exflags,\n\t       lkb->lkb_flags, lkb->lkb_status, lkb->lkb_rqmode,\n\t       lkb->lkb_grmode, lkb->lkb_wait_type, lkb->lkb_wait_nodeid,\n\t       (unsigned long long)lkb->lkb_recover_seq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ls->ls_clear_proc_locks"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nvoid dlm_user_add_ast(struct dlm_lkb *lkb, uint32_t flags, int mode,\n\t\t      int status, uint32_t sbflags, uint64_t seq)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_user_args *ua;\n\tstruct dlm_user_proc *proc;\n\tint rv;\n\n\tif (lkb->lkb_flags & (DLM_IFL_ORPHAN | DLM_IFL_DEAD))\n\t\treturn;\n\n\tls = lkb->lkb_resource->res_ls;\n\tmutex_lock(&ls->ls_clear_proc_locks);\n\n\t/* If ORPHAN/DEAD flag is set, it means the process is dead so an ast\n\t   can't be delivered.  For ORPHAN's, dlm_clear_proc_locks() freed\n\t   lkb->ua so we can't try to use it.  This second check is necessary\n\t   for cases where a completion ast is received for an operation that\n\t   began before clear_proc_locks did its cancel/unlock. */\n\n\tif (lkb->lkb_flags & (DLM_IFL_ORPHAN | DLM_IFL_DEAD))\n\t\tgoto out;\n\n\tDLM_ASSERT(lkb->lkb_ua, dlm_print_lkb(lkb););\n\tua = lkb->lkb_ua;\n\tproc = ua->proc;\n\n\tif ((flags & DLM_CB_BAST) && ua->bastaddr == NULL)\n\t\tgoto out;\n\n\tif ((flags & DLM_CB_CAST) && lkb_is_endoflife(mode, status))\n\t\tlkb->lkb_flags |= DLM_IFL_ENDOFLIFE;\n\n\tspin_lock(&proc->asts_spin);\n\n\trv = dlm_add_lkb_callback(lkb, flags, mode, status, sbflags, seq);\n\tif (rv < 0) {\n\t\tspin_unlock(&proc->asts_spin);\n\t\tgoto out;\n\t}\n\n\tif (list_empty(&lkb->lkb_cb_list)) {\n\t\tkref_get(&lkb->lkb_ref);\n\t\tlist_add_tail(&lkb->lkb_cb_list, &proc->asts);\n\t\twake_up_interruptible(&proc->wait);\n\t}\n\tspin_unlock(&proc->asts_spin);\n\n\tif (lkb->lkb_flags & DLM_IFL_ENDOFLIFE) {\n\t\t/* N.B. spin_lock locks_spin, not asts_spin */\n\t\tspin_lock(&proc->locks_spin);\n\t\tif (!list_empty(&lkb->lkb_ownqueue)) {\n\t\t\tlist_del_init(&lkb->lkb_ownqueue);\n\t\t\tdlm_put_lkb(lkb);\n\t\t}\n\t\tspin_unlock(&proc->locks_spin);\n\t}\n out:\n\tmutex_unlock(&ls->ls_clear_proc_locks);\n}"
  },
  {
    "function_name": "lkb_is_endoflife",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "156-170",
    "snippet": "static int lkb_is_endoflife(int mode, int status)\n{\n\tswitch (status) {\n\tcase -DLM_EUNLOCK:\n\t\treturn 1;\n\tcase -DLM_ECANCEL:\n\tcase -ETIMEDOUT:\n\tcase -EDEADLK:\n\tcase -EAGAIN:\n\t\tif (mode == DLM_LOCK_IV)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic int lkb_is_endoflife(int mode, int status)\n{\n\tswitch (status) {\n\tcase -DLM_EUNLOCK:\n\t\treturn 1;\n\tcase -DLM_ECANCEL:\n\tcase -ETIMEDOUT:\n\tcase -EDEADLK:\n\tcase -EAGAIN:\n\t\tif (mode == DLM_LOCK_IV)\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "compat_output",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "123-142",
    "snippet": "static void compat_output(struct dlm_lock_result *res,\n\t\t\t  struct dlm_lock_result32 *res32)\n{\n\tres32->version[0] = res->version[0];\n\tres32->version[1] = res->version[1];\n\tres32->version[2] = res->version[2];\n\n\tres32->user_astaddr = (__u32)(long)res->user_astaddr;\n\tres32->user_astparam = (__u32)(long)res->user_astparam;\n\tres32->user_lksb = (__u32)(long)res->user_lksb;\n\tres32->bast_mode = res->bast_mode;\n\n\tres32->lvb_offset = res->lvb_offset;\n\tres32->length = res->length;\n\n\tres32->lksb.sb_status = res->lksb.sb_status;\n\tres32->lksb.sb_flags = res->lksb.sb_flags;\n\tres32->lksb.sb_lkid = res->lksb.sb_lkid;\n\tres32->lksb.sb_lvbptr = (__u32)(long)res->lksb.sb_lvbptr;\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic void compat_output(struct dlm_lock_result *res,\n\t\t\t  struct dlm_lock_result32 *res32)\n{\n\tres32->version[0] = res->version[0];\n\tres32->version[1] = res->version[1];\n\tres32->version[2] = res->version[2];\n\n\tres32->user_astaddr = (__u32)(long)res->user_astaddr;\n\tres32->user_astparam = (__u32)(long)res->user_astparam;\n\tres32->user_lksb = (__u32)(long)res->user_lksb;\n\tres32->bast_mode = res->bast_mode;\n\n\tres32->lvb_offset = res->lvb_offset;\n\tres32->length = res->length;\n\n\tres32->lksb.sb_status = res->lksb.sb_status;\n\tres32->lksb.sb_flags = res->lksb.sb_flags;\n\tres32->lksb.sb_lkid = res->lksb.sb_lkid;\n\tres32->lksb.sb_lvbptr = (__u32)(long)res->lksb.sb_lvbptr;\n}"
  },
  {
    "function_name": "compat_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/user.c",
    "lines": "87-121",
    "snippet": "static void compat_input(struct dlm_write_request *kb,\n\t\t\t struct dlm_write_request32 *kb32,\n\t\t\t int namelen)\n{\n\tkb->version[0] = kb32->version[0];\n\tkb->version[1] = kb32->version[1];\n\tkb->version[2] = kb32->version[2];\n\n\tkb->cmd = kb32->cmd;\n\tkb->is64bit = kb32->is64bit;\n\tif (kb->cmd == DLM_USER_CREATE_LOCKSPACE ||\n\t    kb->cmd == DLM_USER_REMOVE_LOCKSPACE) {\n\t\tkb->i.lspace.flags = kb32->i.lspace.flags;\n\t\tkb->i.lspace.minor = kb32->i.lspace.minor;\n\t\tmemcpy(kb->i.lspace.name, kb32->i.lspace.name, namelen);\n\t} else if (kb->cmd == DLM_USER_PURGE) {\n\t\tkb->i.purge.nodeid = kb32->i.purge.nodeid;\n\t\tkb->i.purge.pid = kb32->i.purge.pid;\n\t} else {\n\t\tkb->i.lock.mode = kb32->i.lock.mode;\n\t\tkb->i.lock.namelen = kb32->i.lock.namelen;\n\t\tkb->i.lock.flags = kb32->i.lock.flags;\n\t\tkb->i.lock.lkid = kb32->i.lock.lkid;\n\t\tkb->i.lock.parent = kb32->i.lock.parent;\n\t\tkb->i.lock.xid = kb32->i.lock.xid;\n\t\tkb->i.lock.timeout = kb32->i.lock.timeout;\n\t\tkb->i.lock.castparam = (void *)(long)kb32->i.lock.castparam;\n\t\tkb->i.lock.castaddr = (void *)(long)kb32->i.lock.castaddr;\n\t\tkb->i.lock.bastparam = (void *)(long)kb32->i.lock.bastparam;\n\t\tkb->i.lock.bastaddr = (void *)(long)kb32->i.lock.bastaddr;\n\t\tkb->i.lock.lksb = (void *)(long)kb32->i.lock.lksb;\n\t\tmemcpy(kb->i.lock.lvb, kb32->i.lock.lvb, DLM_USER_LVB_LEN);\n\t\tmemcpy(kb->i.lock.name, kb32->i.lock.name, namelen);\n\t}\n}",
    "includes": [
      "#include \"ast.h\"",
      "#include \"user.h\"",
      "#include \"lvb_table.h\"",
      "#include \"lock.h\"",
      "#include \"lockspace.h\"",
      "#include \"dlm_internal.h\"",
      "#include <linux/slab.h>",
      "#include <linux/dlm_device.h>",
      "#include <linux/dlm.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/signal.h>",
      "#include <linux/poll.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>",
      "#include <linux/wait.h>",
      "#include <linux/init.h>",
      "#include <linux/miscdevice.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kb->i.lock.name",
            "kb32->i.lock.name",
            "namelen"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kb->i.lock.lvb",
            "kb32->i.lock.lvb",
            "DLM_USER_LVB_LEN"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "kb->i.lspace.name",
            "kb32->i.lspace.name",
            "namelen"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"lock.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/dlm_device.h>\n#include <linux/dlm.h>\n#include <linux/spinlock.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/init.h>\n#include <linux/miscdevice.h>\n\nstatic void compat_input(struct dlm_write_request *kb,\n\t\t\t struct dlm_write_request32 *kb32,\n\t\t\t int namelen)\n{\n\tkb->version[0] = kb32->version[0];\n\tkb->version[1] = kb32->version[1];\n\tkb->version[2] = kb32->version[2];\n\n\tkb->cmd = kb32->cmd;\n\tkb->is64bit = kb32->is64bit;\n\tif (kb->cmd == DLM_USER_CREATE_LOCKSPACE ||\n\t    kb->cmd == DLM_USER_REMOVE_LOCKSPACE) {\n\t\tkb->i.lspace.flags = kb32->i.lspace.flags;\n\t\tkb->i.lspace.minor = kb32->i.lspace.minor;\n\t\tmemcpy(kb->i.lspace.name, kb32->i.lspace.name, namelen);\n\t} else if (kb->cmd == DLM_USER_PURGE) {\n\t\tkb->i.purge.nodeid = kb32->i.purge.nodeid;\n\t\tkb->i.purge.pid = kb32->i.purge.pid;\n\t} else {\n\t\tkb->i.lock.mode = kb32->i.lock.mode;\n\t\tkb->i.lock.namelen = kb32->i.lock.namelen;\n\t\tkb->i.lock.flags = kb32->i.lock.flags;\n\t\tkb->i.lock.lkid = kb32->i.lock.lkid;\n\t\tkb->i.lock.parent = kb32->i.lock.parent;\n\t\tkb->i.lock.xid = kb32->i.lock.xid;\n\t\tkb->i.lock.timeout = kb32->i.lock.timeout;\n\t\tkb->i.lock.castparam = (void *)(long)kb32->i.lock.castparam;\n\t\tkb->i.lock.castaddr = (void *)(long)kb32->i.lock.castaddr;\n\t\tkb->i.lock.bastparam = (void *)(long)kb32->i.lock.bastparam;\n\t\tkb->i.lock.bastaddr = (void *)(long)kb32->i.lock.bastaddr;\n\t\tkb->i.lock.lksb = (void *)(long)kb32->i.lock.lksb;\n\t\tmemcpy(kb->i.lock.lvb, kb32->i.lock.lvb, DLM_USER_LVB_LEN);\n\t\tmemcpy(kb->i.lock.name, kb32->i.lock.name, namelen);\n\t}\n}"
  }
]