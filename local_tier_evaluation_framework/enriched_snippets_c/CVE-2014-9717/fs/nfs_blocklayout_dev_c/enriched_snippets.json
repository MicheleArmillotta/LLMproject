[
  {
    "function_name": "bl_alloc_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "307-363",
    "snippet": "struct nfs4_deviceid_node *\nbl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_deviceid_node *node = NULL;\n\tstruct pnfs_block_volume *volumes;\n\tstruct pnfs_block_dev *top;\n\tstruct xdr_stream xdr;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tint nr_volumes, ret, i;\n\t__be32 *p;\n\n\tscratch = alloc_page(gfp_mask);\n\tif (!scratch)\n\t\tgoto out;\n\n\txdr_init_decode_pages(&xdr, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&xdr, page_address(scratch), PAGE_SIZE);\n\n\tp = xdr_inline_decode(&xdr, sizeof(__be32));\n\tif (!p)\n\t\tgoto out_free_scratch;\n\tnr_volumes = be32_to_cpup(p++);\n\n\tvolumes = kcalloc(nr_volumes, sizeof(struct pnfs_block_volume),\n\t\t\t  gfp_mask);\n\tif (!volumes)\n\t\tgoto out_free_scratch;\n\n\tfor (i = 0; i < nr_volumes; i++) {\n\t\tret = nfs4_block_decode_volume(&xdr, &volumes[i]);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_volumes;\n\t}\n\n\ttop = kzalloc(sizeof(*top), gfp_mask);\n\tif (!top)\n\t\tgoto out_free_volumes;\n\n\tret = bl_parse_deviceid(server, top, volumes, nr_volumes - 1, gfp_mask);\n\tif (ret) {\n\t\tbl_free_device(top);\n\t\tkfree(top);\n\t\tgoto out_free_volumes;\n\t}\n\n\tnode = &top->node;\n\tnfs4_init_deviceid_node(node, server, &pdev->dev_id);\n\nout_free_volumes:\n\tkfree(volumes);\nout_free_scratch:\n\t__free_page(scratch);\nout:\n\treturn node;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "scratch"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "volumes"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_init_deviceid_node",
          "args": [
            "node",
            "server",
            "&pdev->dev_id"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_init_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/pnfs_dev.c",
          "lines": "247-258",
          "snippet": "void\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"internal.h\"",
            "#include \"nfs4session.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"internal.h\"\n#include \"nfs4session.h\"\n#include <linux/nfs_fs.h>\n#include <linux/export.h>\n\nvoid\nnfs4_init_deviceid_node(struct nfs4_deviceid_node *d, struct nfs_server *server,\n\t\t\tconst struct nfs4_deviceid *id)\n{\n\tINIT_HLIST_NODE(&d->node);\n\tINIT_HLIST_NODE(&d->tmpnode);\n\td->ld = server->pnfs_curr_ld;\n\td->nfs_client = server->nfs_client;\n\td->flags = 0;\n\td->deviceid = *id;\n\tatomic_set(&d->ref, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "top"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bl_free_device",
          "args": [
            "top"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "bl_free_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "29-37",
          "snippet": "void\nbl_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(d, struct pnfs_block_dev, node);\n\n\tbl_free_device(dev);\n\tkfree(dev);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nvoid\nbl_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(d, struct pnfs_block_dev, node);\n\n\tbl_free_device(dev);\n\tkfree(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bl_parse_deviceid",
          "args": [
            "server",
            "top",
            "volumes",
            "nr_volumes - 1",
            "gfp_mask"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "bl_parse_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "288-305",
          "snippet": "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*top)",
            "gfp_mask"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nfs4_block_decode_volume",
          "args": [
            "&xdr",
            "&volumes[i]"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_block_decode_volume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "39-117",
          "snippet": "static int\nnfs4_block_decode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint i;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (!p)\n\t\treturn -EIO;\n\tb->type = be32_to_cpup(p++);\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->simple.nr_sigs = be32_to_cpup(p++);\n\t\tif (!b->simple.nr_sigs) {\n\t\t\tdprintk(\"no signature\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tb->simple.len = 4 + 4;\n\t\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tp = xdr_decode_hyper(p, &b->simple.sigs[i].offset);\n\t\t\tb->simple.sigs[i].sig_len = be32_to_cpup(p++);\n\n\t\t\tp = xdr_inline_decode(xdr, b->simple.sigs[i].sig_len);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(&b->simple.sigs[i].sig, p,\n\t\t\t\tb->simple.sigs[i].sig_len);\n\n\t\t\tb->simple.len += 8 + 4 + b->simple.sigs[i].sig_len;\n\t\t}\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\tp = xdr_inline_decode(xdr, 8 + 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->slice.start);\n\t\tp = xdr_decode_hyper(p, &b->slice.len);\n\t\tb->slice.volume = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->concat.volumes_count = be32_to_cpup(p++);\n\n\t\tp = xdr_inline_decode(xdr, b->concat.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->concat.volumes_count; i++)\n\t\t\tb->concat.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->stripe.chunk_size);\n\t\tb->stripe.volumes_count = be32_to_cpup(p++);\n\n\t\tp = xdr_inline_decode(xdr, b->stripe.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->stripe.volumes_count; i++)\n\t\t\tb->stripe.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"unknown volume type!\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nnfs4_block_decode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint i;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (!p)\n\t\treturn -EIO;\n\tb->type = be32_to_cpup(p++);\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->simple.nr_sigs = be32_to_cpup(p++);\n\t\tif (!b->simple.nr_sigs) {\n\t\t\tdprintk(\"no signature\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tb->simple.len = 4 + 4;\n\t\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tp = xdr_decode_hyper(p, &b->simple.sigs[i].offset);\n\t\t\tb->simple.sigs[i].sig_len = be32_to_cpup(p++);\n\n\t\t\tp = xdr_inline_decode(xdr, b->simple.sigs[i].sig_len);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(&b->simple.sigs[i].sig, p,\n\t\t\t\tb->simple.sigs[i].sig_len);\n\n\t\t\tb->simple.len += 8 + 4 + b->simple.sigs[i].sig_len;\n\t\t}\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\tp = xdr_inline_decode(xdr, 8 + 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->slice.start);\n\t\tp = xdr_decode_hyper(p, &b->slice.len);\n\t\tb->slice.volume = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->concat.volumes_count = be32_to_cpup(p++);\n\n\t\tp = xdr_inline_decode(xdr, b->concat.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->concat.volumes_count; i++)\n\t\t\tb->concat.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->stripe.chunk_size);\n\t\tb->stripe.volumes_count = be32_to_cpup(p++);\n\n\t\tp = xdr_inline_decode(xdr, b->stripe.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->stripe.volumes_count; i++)\n\t\t\tb->stripe.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"unknown volume type!\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nr_volumes",
            "sizeof(struct pnfs_block_volume)",
            "gfp_mask"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "&xdr",
            "sizeof(__be32)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_set_scratch_buffer",
          "args": [
            "&xdr",
            "page_address(scratch)",
            "PAGE_SIZE"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "scratch"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_init_decode_pages",
          "args": [
            "&xdr",
            "&buf",
            "pdev->pages",
            "pdev->pglen"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "gfp_mask"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstruct nfs4_deviceid_node *\nbl_alloc_deviceid_node(struct nfs_server *server, struct pnfs_device *pdev,\n\t\tgfp_t gfp_mask)\n{\n\tstruct nfs4_deviceid_node *node = NULL;\n\tstruct pnfs_block_volume *volumes;\n\tstruct pnfs_block_dev *top;\n\tstruct xdr_stream xdr;\n\tstruct xdr_buf buf;\n\tstruct page *scratch;\n\tint nr_volumes, ret, i;\n\t__be32 *p;\n\n\tscratch = alloc_page(gfp_mask);\n\tif (!scratch)\n\t\tgoto out;\n\n\txdr_init_decode_pages(&xdr, &buf, pdev->pages, pdev->pglen);\n\txdr_set_scratch_buffer(&xdr, page_address(scratch), PAGE_SIZE);\n\n\tp = xdr_inline_decode(&xdr, sizeof(__be32));\n\tif (!p)\n\t\tgoto out_free_scratch;\n\tnr_volumes = be32_to_cpup(p++);\n\n\tvolumes = kcalloc(nr_volumes, sizeof(struct pnfs_block_volume),\n\t\t\t  gfp_mask);\n\tif (!volumes)\n\t\tgoto out_free_scratch;\n\n\tfor (i = 0; i < nr_volumes; i++) {\n\t\tret = nfs4_block_decode_volume(&xdr, &volumes[i]);\n\t\tif (ret < 0)\n\t\t\tgoto out_free_volumes;\n\t}\n\n\ttop = kzalloc(sizeof(*top), gfp_mask);\n\tif (!top)\n\t\tgoto out_free_volumes;\n\n\tret = bl_parse_deviceid(server, top, volumes, nr_volumes - 1, gfp_mask);\n\tif (ret) {\n\t\tbl_free_device(top);\n\t\tkfree(top);\n\t\tgoto out_free_volumes;\n\t}\n\n\tnode = &top->node;\n\tnfs4_init_deviceid_node(node, server, &pdev->dev_id);\n\nout_free_volumes:\n\tkfree(volumes);\nout_free_scratch:\n\t__free_page(scratch);\nout:\n\treturn node;\n}"
  },
  {
    "function_name": "bl_parse_deviceid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "288-305",
    "snippet": "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"unsupported volume type: %d\\n\"",
            "volumes[idx].type"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bl_parse_stripe",
          "args": [
            "server",
            "d",
            "volumes",
            "idx",
            "gfp_mask"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "bl_parse_stripe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "259-286",
          "snippet": "static int\nbl_parse_stripe(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->stripe.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), GFP_KERNEL);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->stripe.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->stripe.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->chunk_size = v->stripe.chunk_size;\n\td->map = bl_map_stripe;\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_stripe(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->stripe.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), GFP_KERNEL);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->stripe.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->stripe.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->chunk_size = v->stripe.chunk_size;\n\td->map = bl_map_stripe;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bl_parse_concat",
          "args": [
            "server",
            "d",
            "volumes",
            "idx",
            "gfp_mask"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "bl_parse_concat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "230-257",
          "snippet": "static int\nbl_parse_concat(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->concat.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), GFP_KERNEL);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->concat.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->concat.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\td->children[i].start += len;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->map = bl_map_concat;\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_concat(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->concat.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), GFP_KERNEL);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->concat.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->concat.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\td->children[i].start += len;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->map = bl_map_concat;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bl_parse_slice",
          "args": [
            "server",
            "d",
            "volumes",
            "idx",
            "gfp_mask"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "bl_parse_slice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "214-228",
          "snippet": "static int\nbl_parse_slice(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tint ret;\n\n\tret = bl_parse_deviceid(server, d, volumes, v->slice.volume, gfp_mask);\n\tif (ret)\n\t\treturn ret;\n\n\td->disk_offset = v->slice.start;\n\td->len = v->slice.len;\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_slice(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tint ret;\n\n\tret = bl_parse_deviceid(server, d, volumes, v->slice.volume, gfp_mask);\n\tif (ret)\n\t\treturn ret;\n\n\td->disk_offset = v->slice.start;\n\td->len = v->slice.len;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bl_parse_simple",
          "args": [
            "server",
            "d",
            "volumes",
            "idx",
            "gfp_mask"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "bl_parse_simple",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "187-212",
          "snippet": "static int\nbl_parse_simple(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tdev_t dev;\n\n\tdev = bl_resolve_deviceid(server, v, gfp_mask);\n\tif (!dev)\n\t\treturn -EIO;\n\n\td->bdev = blkdev_get_by_dev(dev, FMODE_READ, NULL);\n\tif (IS_ERR(d->bdev)) {\n\t\tprintk(KERN_WARNING \"pNFS: failed to open device %d:%d (%ld)\\n\",\n\t\t\tMAJOR(dev), MINOR(dev), PTR_ERR(d->bdev));\n\t\treturn PTR_ERR(d->bdev);\n\t}\n\n\n\td->len = i_size_read(d->bdev->bd_inode);\n\td->map = bl_map_simple;\n\n\tprintk(KERN_INFO \"pNFS: using block device %s\\n\",\n\t\td->bdev->bd_disk->disk_name);\n\treturn 0;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_simple(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tdev_t dev;\n\n\tdev = bl_resolve_deviceid(server, v, gfp_mask);\n\tif (!dev)\n\t\treturn -EIO;\n\n\td->bdev = blkdev_get_by_dev(dev, FMODE_READ, NULL);\n\tif (IS_ERR(d->bdev)) {\n\t\tprintk(KERN_WARNING \"pNFS: failed to open device %d:%d (%ld)\\n\",\n\t\t\tMAJOR(dev), MINOR(dev), PTR_ERR(d->bdev));\n\t\treturn PTR_ERR(d->bdev);\n\t}\n\n\n\td->len = i_size_read(d->bdev->bd_inode);\n\td->map = bl_map_simple;\n\n\tprintk(KERN_INFO \"pNFS: using block device %s\\n\",\n\t\td->bdev->bd_disk->disk_name);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}"
  },
  {
    "function_name": "bl_parse_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "259-286",
    "snippet": "static int\nbl_parse_stripe(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->stripe.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), GFP_KERNEL);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->stripe.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->stripe.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->chunk_size = v->stripe.chunk_size;\n\td->map = bl_map_stripe;\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bl_parse_deviceid",
          "args": [
            "server",
            "&d->children[i]",
            "volumes",
            "v->stripe.volumes[i]",
            "gfp_mask"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "bl_parse_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "288-305",
          "snippet": "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "v->stripe.volumes_count",
            "sizeof(struct pnfs_block_dev)",
            "GFP_KERNEL"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_stripe(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->stripe.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), GFP_KERNEL);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->stripe.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->stripe.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->chunk_size = v->stripe.chunk_size;\n\td->map = bl_map_stripe;\n\treturn 0;\n}"
  },
  {
    "function_name": "bl_parse_concat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "230-257",
    "snippet": "static int\nbl_parse_concat(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->concat.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), GFP_KERNEL);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->concat.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->concat.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\td->children[i].start += len;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->map = bl_map_concat;\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bl_parse_deviceid",
          "args": [
            "server",
            "&d->children[i]",
            "volumes",
            "v->concat.volumes[i]",
            "gfp_mask"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "bl_parse_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "288-305",
          "snippet": "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "v->concat.volumes_count",
            "sizeof(struct pnfs_block_dev)",
            "GFP_KERNEL"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_concat(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tu64 len = 0;\n\tint ret, i;\n\n\td->children = kcalloc(v->concat.volumes_count,\n\t\t\tsizeof(struct pnfs_block_dev), GFP_KERNEL);\n\tif (!d->children)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < v->concat.volumes_count; i++) {\n\t\tret = bl_parse_deviceid(server, &d->children[i],\n\t\t\t\tvolumes, v->concat.volumes[i], gfp_mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\td->nr_children++;\n\t\td->children[i].start += len;\n\t\tlen += d->children[i].len;\n\t}\n\n\td->len = len;\n\td->map = bl_map_concat;\n\treturn 0;\n}"
  },
  {
    "function_name": "bl_parse_slice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "214-228",
    "snippet": "static int\nbl_parse_slice(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tint ret;\n\n\tret = bl_parse_deviceid(server, d, volumes, v->slice.volume, gfp_mask);\n\tif (ret)\n\t\treturn ret;\n\n\td->disk_offset = v->slice.start;\n\td->len = v->slice.len;\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bl_parse_deviceid",
          "args": [
            "server",
            "d",
            "volumes",
            "v->slice.volume",
            "gfp_mask"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "bl_parse_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "288-305",
          "snippet": "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tswitch (volumes[idx].type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\treturn bl_parse_simple(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\treturn bl_parse_slice(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\treturn bl_parse_concat(server, d, volumes, idx, gfp_mask);\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\treturn bl_parse_stripe(server, d, volumes, idx, gfp_mask);\n\tdefault:\n\t\tdprintk(\"unsupported volume type: %d\\n\", volumes[idx].type);\n\t\treturn -EIO;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_slice(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tint ret;\n\n\tret = bl_parse_deviceid(server, d, volumes, v->slice.volume, gfp_mask);\n\tif (ret)\n\t\treturn ret;\n\n\td->disk_offset = v->slice.start;\n\td->len = v->slice.len;\n\treturn 0;\n}"
  },
  {
    "function_name": "bl_parse_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "187-212",
    "snippet": "static int\nbl_parse_simple(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tdev_t dev;\n\n\tdev = bl_resolve_deviceid(server, v, gfp_mask);\n\tif (!dev)\n\t\treturn -EIO;\n\n\td->bdev = blkdev_get_by_dev(dev, FMODE_READ, NULL);\n\tif (IS_ERR(d->bdev)) {\n\t\tprintk(KERN_WARNING \"pNFS: failed to open device %d:%d (%ld)\\n\",\n\t\t\tMAJOR(dev), MINOR(dev), PTR_ERR(d->bdev));\n\t\treturn PTR_ERR(d->bdev);\n\t}\n\n\n\td->len = i_size_read(d->bdev->bd_inode);\n\td->map = bl_map_simple;\n\n\tprintk(KERN_INFO \"pNFS: using block device %s\\n\",\n\t\td->bdev->bd_disk->disk_name);\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"pNFS: using block device %s\\n\"",
            "d->bdev->bd_disk->disk_name"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "d->bdev->bd_inode"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "d->bdev"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "d->bdev"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d->bdev"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blkdev_get_by_dev",
          "args": [
            "dev",
            "FMODE_READ",
            "NULL"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_get_by_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1432-1446",
          "snippet": "struct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstruct block_device *blkdev_get_by_dev(dev_t dev, fmode_t mode, void *holder)\n{\n\tstruct block_device *bdev;\n\tint err;\n\n\tbdev = bdget(dev);\n\tif (!bdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = blkdev_get(bdev, mode, holder);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\treturn bdev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bl_resolve_deviceid",
          "args": [
            "server",
            "v",
            "gfp_mask"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "bl_resolve_deviceid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/rpc_pipefs.c",
          "lines": "52-110",
          "snippet": "dev_t\nbl_resolve_deviceid(struct nfs_server *server, struct pnfs_block_volume *b,\n\t\tgfp_t gfp_mask)\n{\n\tstruct net *net = server->nfs_client->cl_net;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct bl_dev_msg *reply = &nn->bl_mount_reply;\n\tstruct bl_pipe_msg bl_pipe_msg;\n\tstruct rpc_pipe_msg *msg = &bl_pipe_msg.msg;\n\tstruct bl_msg_hdr *bl_msg;\n\tDECLARE_WAITQUEUE(wq, current);\n\tdev_t dev = 0;\n\tint rc;\n\n\tdprintk(\"%s CREATING PIPEFS MESSAGE\\n\", __func__);\n\n\tmutex_lock(&nn->bl_mutex);\n\tbl_pipe_msg.bl_wq = &nn->bl_wq;\n\n\tb->simple.len += 4;\t/* single volume */\n\tif (b->simple.len > PAGE_SIZE)\n\t\tgoto out_unlock;\n\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->len = sizeof(*bl_msg) + b->simple.len;\n\tmsg->data = kzalloc(msg->len, gfp_mask);\n\tif (!msg->data)\n\t\tgoto out_free_data;\n\n\tbl_msg = msg->data;\n\tbl_msg->type = BL_DEVICE_MOUNT,\n\tbl_msg->totallen = b->simple.len;\n\tnfs4_encode_simple(msg->data + sizeof(*bl_msg), b);\n\n\tdprintk(\"%s CALLING USERSPACE DAEMON\\n\", __func__);\n\tadd_wait_queue(&nn->bl_wq, &wq);\n\trc = rpc_queue_upcall(nn->bl_device_pipe, msg);\n\tif (rc < 0) {\n\t\tremove_wait_queue(&nn->bl_wq, &wq);\n\t\tgoto out_free_data;\n\t}\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule();\n\tremove_wait_queue(&nn->bl_wq, &wq);\n\n\tif (reply->status != BL_DEVICE_REQUEST_PROC) {\n\t\tprintk(KERN_WARNING \"%s failed to decode device: %d\\n\",\n\t\t\t__func__, reply->status);\n\t\tgoto out_free_data;\n\t}\n\n\tdev = MKDEV(reply->major, reply->minor);\nout_free_data:\n\tkfree(msg->data);\nout_unlock:\n\tmutex_unlock(&nn->bl_mutex);\n\treturn dev;\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/blkdev.h>",
            "#include <linux/genhd.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/blkdev.h>\n#include <linux/genhd.h>\n#include <linux/module.h>\n\ndev_t\nbl_resolve_deviceid(struct nfs_server *server, struct pnfs_block_volume *b,\n\t\tgfp_t gfp_mask)\n{\n\tstruct net *net = server->nfs_client->cl_net;\n\tstruct nfs_net *nn = net_generic(net, nfs_net_id);\n\tstruct bl_dev_msg *reply = &nn->bl_mount_reply;\n\tstruct bl_pipe_msg bl_pipe_msg;\n\tstruct rpc_pipe_msg *msg = &bl_pipe_msg.msg;\n\tstruct bl_msg_hdr *bl_msg;\n\tDECLARE_WAITQUEUE(wq, current);\n\tdev_t dev = 0;\n\tint rc;\n\n\tdprintk(\"%s CREATING PIPEFS MESSAGE\\n\", __func__);\n\n\tmutex_lock(&nn->bl_mutex);\n\tbl_pipe_msg.bl_wq = &nn->bl_wq;\n\n\tb->simple.len += 4;\t/* single volume */\n\tif (b->simple.len > PAGE_SIZE)\n\t\tgoto out_unlock;\n\n\tmemset(msg, 0, sizeof(*msg));\n\tmsg->len = sizeof(*bl_msg) + b->simple.len;\n\tmsg->data = kzalloc(msg->len, gfp_mask);\n\tif (!msg->data)\n\t\tgoto out_free_data;\n\n\tbl_msg = msg->data;\n\tbl_msg->type = BL_DEVICE_MOUNT,\n\tbl_msg->totallen = b->simple.len;\n\tnfs4_encode_simple(msg->data + sizeof(*bl_msg), b);\n\n\tdprintk(\"%s CALLING USERSPACE DAEMON\\n\", __func__);\n\tadd_wait_queue(&nn->bl_wq, &wq);\n\trc = rpc_queue_upcall(nn->bl_device_pipe, msg);\n\tif (rc < 0) {\n\t\tremove_wait_queue(&nn->bl_wq, &wq);\n\t\tgoto out_free_data;\n\t}\n\n\tset_current_state(TASK_UNINTERRUPTIBLE);\n\tschedule();\n\tremove_wait_queue(&nn->bl_wq, &wq);\n\n\tif (reply->status != BL_DEVICE_REQUEST_PROC) {\n\t\tprintk(KERN_WARNING \"%s failed to decode device: %d\\n\",\n\t\t\t__func__, reply->status);\n\t\tgoto out_free_data;\n\t}\n\n\tdev = MKDEV(reply->major, reply->minor);\nout_free_data:\n\tkfree(msg->data);\nout_unlock:\n\tmutex_unlock(&nn->bl_mutex);\n\treturn dev;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nbl_parse_deviceid(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask);\n\nstatic int\nbl_parse_simple(struct nfs_server *server, struct pnfs_block_dev *d,\n\t\tstruct pnfs_block_volume *volumes, int idx, gfp_t gfp_mask)\n{\n\tstruct pnfs_block_volume *v = &volumes[idx];\n\tdev_t dev;\n\n\tdev = bl_resolve_deviceid(server, v, gfp_mask);\n\tif (!dev)\n\t\treturn -EIO;\n\n\td->bdev = blkdev_get_by_dev(dev, FMODE_READ, NULL);\n\tif (IS_ERR(d->bdev)) {\n\t\tprintk(KERN_WARNING \"pNFS: failed to open device %d:%d (%ld)\\n\",\n\t\t\tMAJOR(dev), MINOR(dev), PTR_ERR(d->bdev));\n\t\treturn PTR_ERR(d->bdev);\n\t}\n\n\n\td->len = i_size_read(d->bdev->bd_inode);\n\td->map = bl_map_simple;\n\n\tprintk(KERN_INFO \"pNFS: using block device %s\\n\",\n\t\td->bdev->bd_disk->disk_name);\n\treturn 0;\n}"
  },
  {
    "function_name": "bl_map_stripe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "149-180",
    "snippet": "static bool bl_map_stripe(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tstruct pnfs_block_dev *child;\n\tu64 chunk;\n\tu32 chunk_idx;\n\tu64 disk_offset;\n\n\tchunk = div_u64(offset, dev->chunk_size);\n\tdiv_u64_rem(chunk, dev->nr_children, &chunk_idx);\n\n\tif (chunk_idx > dev->nr_children) {\n\t\tdprintk(\"%s: invalid chunk idx %d (%lld/%lld)\\n\",\n\t\t\t__func__, chunk_idx, offset, dev->chunk_size);\n\t\t/* error, should not happen */\n\t\treturn false;\n\t}\n\n\t/* truncate offset to the beginning of the stripe */\n\toffset = chunk * dev->chunk_size;\n\n\t/* disk offset of the stripe */\n\tdisk_offset = div_u64(offset, dev->nr_children);\n\n\tchild = &dev->children[chunk_idx];\n\tchild->map(child, disk_offset, map);\n\n\tmap->start += offset;\n\tmap->disk_offset += disk_offset;\n\tmap->len = dev->chunk_size;\n\treturn true;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "child->map",
          "args": [
            "child",
            "disk_offset",
            "map"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "offset",
            "dev->nr_children"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: invalid chunk idx %d (%lld/%lld)\\n\"",
            "__func__",
            "chunk_idx",
            "offset",
            "dev->chunk_size"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64_rem",
          "args": [
            "chunk",
            "dev->nr_children",
            "&chunk_idx"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "offset",
            "dev->chunk_size"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic bool bl_map_stripe(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tstruct pnfs_block_dev *child;\n\tu64 chunk;\n\tu32 chunk_idx;\n\tu64 disk_offset;\n\n\tchunk = div_u64(offset, dev->chunk_size);\n\tdiv_u64_rem(chunk, dev->nr_children, &chunk_idx);\n\n\tif (chunk_idx > dev->nr_children) {\n\t\tdprintk(\"%s: invalid chunk idx %d (%lld/%lld)\\n\",\n\t\t\t__func__, chunk_idx, offset, dev->chunk_size);\n\t\t/* error, should not happen */\n\t\treturn false;\n\t}\n\n\t/* truncate offset to the beginning of the stripe */\n\toffset = chunk * dev->chunk_size;\n\n\t/* disk offset of the stripe */\n\tdisk_offset = div_u64(offset, dev->nr_children);\n\n\tchild = &dev->children[chunk_idx];\n\tchild->map(child, disk_offset, map);\n\n\tmap->start += offset;\n\tmap->disk_offset += disk_offset;\n\tmap->len = dev->chunk_size;\n\treturn true;\n}"
  },
  {
    "function_name": "bl_map_concat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "129-147",
    "snippet": "static bool bl_map_concat(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->nr_children; i++) {\n\t\tstruct pnfs_block_dev *child = &dev->children[i];\n\n\t\tif (child->start > offset ||\n\t\t    child->start + child->len <= offset)\n\t\t\tcontinue;\n\n\t\tchild->map(child, offset - child->start, map);\n\t\treturn true;\n\t}\n\n\tdprintk(\"%s: ran off loop!\\n\", __func__);\n\treturn false;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"%s: ran off loop!\\n\"",
            "__func__"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "child->map",
          "args": [
            "child",
            "offset - child->start",
            "map"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic bool bl_map_concat(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->nr_children; i++) {\n\t\tstruct pnfs_block_dev *child = &dev->children[i];\n\n\t\tif (child->start > offset ||\n\t\t    child->start + child->len <= offset)\n\t\t\tcontinue;\n\n\t\tchild->map(child, offset - child->start, map);\n\t\treturn true;\n\t}\n\n\tdprintk(\"%s: ran off loop!\\n\", __func__);\n\treturn false;\n}"
  },
  {
    "function_name": "bl_map_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "119-127",
    "snippet": "static bool bl_map_simple(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tmap->start = dev->start;\n\tmap->len = dev->len;\n\tmap->disk_offset = dev->disk_offset;\n\tmap->bdev = dev->bdev;\n\treturn true;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic bool bl_map_simple(struct pnfs_block_dev *dev, u64 offset,\n\t\tstruct pnfs_block_dev_map *map)\n{\n\tmap->start = dev->start;\n\tmap->len = dev->len;\n\tmap->disk_offset = dev->disk_offset;\n\tmap->bdev = dev->bdev;\n\treturn true;\n}"
  },
  {
    "function_name": "nfs4_block_decode_volume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "39-117",
    "snippet": "static int\nnfs4_block_decode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint i;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (!p)\n\t\treturn -EIO;\n\tb->type = be32_to_cpup(p++);\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->simple.nr_sigs = be32_to_cpup(p++);\n\t\tif (!b->simple.nr_sigs) {\n\t\t\tdprintk(\"no signature\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tb->simple.len = 4 + 4;\n\t\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tp = xdr_decode_hyper(p, &b->simple.sigs[i].offset);\n\t\t\tb->simple.sigs[i].sig_len = be32_to_cpup(p++);\n\n\t\t\tp = xdr_inline_decode(xdr, b->simple.sigs[i].sig_len);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(&b->simple.sigs[i].sig, p,\n\t\t\t\tb->simple.sigs[i].sig_len);\n\n\t\t\tb->simple.len += 8 + 4 + b->simple.sigs[i].sig_len;\n\t\t}\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\tp = xdr_inline_decode(xdr, 8 + 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->slice.start);\n\t\tp = xdr_decode_hyper(p, &b->slice.len);\n\t\tb->slice.volume = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->concat.volumes_count = be32_to_cpup(p++);\n\n\t\tp = xdr_inline_decode(xdr, b->concat.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->concat.volumes_count; i++)\n\t\t\tb->concat.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->stripe.chunk_size);\n\t\tb->stripe.volumes_count = be32_to_cpup(p++);\n\n\t\tp = xdr_inline_decode(xdr, b->stripe.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->stripe.volumes_count; i++)\n\t\t\tb->stripe.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"unknown volume type!\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"unknown volume type!\\n\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "b->stripe.volumes_count * 4"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&b->stripe.chunk_size"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "8 + 4"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "b->concat.volumes_count * 4"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&b->slice.len"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&b->slice.start"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "8 + 8 + 4"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&b->simple.sigs[i].sig",
            "p",
            "b->simple.sigs[i].sig_len"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "b->simple.sigs[i].sig_len"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_decode_hyper",
          "args": [
            "p",
            "&b->simple.sigs[i].offset"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "8 + 4"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"no signature\\n\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic int\nnfs4_block_decode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\n{\n\t__be32 *p;\n\tint i;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (!p)\n\t\treturn -EIO;\n\tb->type = be32_to_cpup(p++);\n\n\tswitch (b->type) {\n\tcase PNFS_BLOCK_VOLUME_SIMPLE:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->simple.nr_sigs = be32_to_cpup(p++);\n\t\tif (!b->simple.nr_sigs) {\n\t\t\tdprintk(\"no signature\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tb->simple.len = 4 + 4;\n\t\tfor (i = 0; i < b->simple.nr_sigs; i++) {\n\t\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tp = xdr_decode_hyper(p, &b->simple.sigs[i].offset);\n\t\t\tb->simple.sigs[i].sig_len = be32_to_cpup(p++);\n\n\t\t\tp = xdr_inline_decode(xdr, b->simple.sigs[i].sig_len);\n\t\t\tif (!p)\n\t\t\t\treturn -EIO;\n\t\t\tmemcpy(&b->simple.sigs[i].sig, p,\n\t\t\t\tb->simple.sigs[i].sig_len);\n\n\t\t\tb->simple.len += 8 + 4 + b->simple.sigs[i].sig_len;\n\t\t}\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_SLICE:\n\t\tp = xdr_inline_decode(xdr, 8 + 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->slice.start);\n\t\tp = xdr_decode_hyper(p, &b->slice.len);\n\t\tb->slice.volume = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_CONCAT:\n\t\tp = xdr_inline_decode(xdr, 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tb->concat.volumes_count = be32_to_cpup(p++);\n\n\t\tp = xdr_inline_decode(xdr, b->concat.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->concat.volumes_count; i++)\n\t\t\tb->concat.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tcase PNFS_BLOCK_VOLUME_STRIPE:\n\t\tp = xdr_inline_decode(xdr, 8 + 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tp = xdr_decode_hyper(p, &b->stripe.chunk_size);\n\t\tb->stripe.volumes_count = be32_to_cpup(p++);\n\n\t\tp = xdr_inline_decode(xdr, b->stripe.volumes_count * 4);\n\t\tif (!p)\n\t\t\treturn -EIO;\n\t\tfor (i = 0; i < b->stripe.volumes_count; i++)\n\t\t\tb->stripe.volumes[i] = be32_to_cpup(p++);\n\t\tbreak;\n\tdefault:\n\t\tdprintk(\"unknown volume type!\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bl_free_deviceid_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "29-37",
    "snippet": "void\nbl_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(d, struct pnfs_block_dev, node);\n\n\tbl_free_device(dev);\n\tkfree(dev);\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bl_free_device",
          "args": [
            "dev"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "bl_free_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "29-37",
          "snippet": "void\nbl_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(d, struct pnfs_block_dev, node);\n\n\tbl_free_device(dev);\n\tkfree(dev);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "d",
            "structpnfs_block_dev",
            "node"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nvoid\nbl_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(d, struct pnfs_block_dev, node);\n\n\tbl_free_device(dev);\n\tkfree(dev);\n}"
  },
  {
    "function_name": "bl_free_device",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
    "lines": "14-27",
    "snippet": "static void\nbl_free_device(struct pnfs_block_dev *dev)\n{\n\tif (dev->nr_children) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dev->nr_children; i++)\n\t\t\tbl_free_device(&dev->children[i]);\n\t\tkfree(dev->children);\n\t} else {\n\t\tif (dev->bdev)\n\t\t\tblkdev_put(dev->bdev, FMODE_READ);\n\t}\n}",
    "includes": [
      "#include \"blocklayout.h\"",
      "#include <linux/nfs_xdr.h>",
      "#include <linux/nfs_fs.h>",
      "#include <linux/nfs4.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/sunrpc/svc.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blkdev_put",
          "args": [
            "dev->bdev",
            "FMODE_READ"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "blkdev_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "1519-1564",
          "snippet": "void blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(bdev_lock);\n\nvoid blkdev_put(struct block_device *bdev, fmode_t mode)\n{\n\tmutex_lock(&bdev->bd_mutex);\n\n\tif (mode & FMODE_EXCL) {\n\t\tbool bdev_free;\n\n\t\t/*\n\t\t * Release a claim on the device.  The holder fields\n\t\t * are protected with bdev_lock.  bd_mutex is to\n\t\t * synchronize disk_holder unlinking.\n\t\t */\n\t\tspin_lock(&bdev_lock);\n\n\t\tWARN_ON_ONCE(--bdev->bd_holders < 0);\n\t\tWARN_ON_ONCE(--bdev->bd_contains->bd_holders < 0);\n\n\t\t/* bd_contains might point to self, check in a separate step */\n\t\tif ((bdev_free = !bdev->bd_holders))\n\t\t\tbdev->bd_holder = NULL;\n\t\tif (!bdev->bd_contains->bd_holders)\n\t\t\tbdev->bd_contains->bd_holder = NULL;\n\n\t\tspin_unlock(&bdev_lock);\n\n\t\t/*\n\t\t * If this was the last claim, remove holder link and\n\t\t * unblock evpoll if it was a write holder.\n\t\t */\n\t\tif (bdev_free && bdev->bd_write_holder) {\n\t\t\tdisk_unblock_events(bdev->bd_disk);\n\t\t\tbdev->bd_write_holder = false;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger event checking and tell drivers to flush MEDIA_CHANGE\n\t * event.  This is to ensure detection of media removal commanded\n\t * from userland - e.g. eject(1).\n\t */\n\tdisk_flush_events(bdev->bd_disk, DISK_EVENT_MEDIA_CHANGE);\n\n\tmutex_unlock(&bdev->bd_mutex);\n\n\t__blkdev_put(bdev, mode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dev->children"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bl_free_device",
          "args": [
            "&dev->children[i]"
          ],
          "line": 21
        },
        "resolved": true,
        "details": {
          "function_name": "bl_free_deviceid_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/blocklayout/dev.c",
          "lines": "29-37",
          "snippet": "void\nbl_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(d, struct pnfs_block_dev, node);\n\n\tbl_free_device(dev);\n\tkfree(dev);\n}",
          "includes": [
            "#include \"blocklayout.h\"",
            "#include <linux/nfs_xdr.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/sunrpc/svc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nvoid\nbl_free_deviceid_node(struct nfs4_deviceid_node *d)\n{\n\tstruct pnfs_block_dev *dev =\n\t\tcontainer_of(d, struct pnfs_block_dev, node);\n\n\tbl_free_device(dev);\n\tkfree(dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blocklayout.h\"\n#include <linux/nfs_xdr.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/blkdev.h>\n#include <linux/sunrpc/svc.h>\n\nstatic void\nbl_free_device(struct pnfs_block_dev *dev)\n{\n\tif (dev->nr_children) {\n\t\tint i;\n\n\t\tfor (i = 0; i < dev->nr_children; i++)\n\t\t\tbl_free_device(&dev->children[i]);\n\t\tkfree(dev->children);\n\t} else {\n\t\tif (dev->bdev)\n\t\t\tblkdev_put(dev->bdev, FMODE_READ);\n\t}\n}"
  }
]