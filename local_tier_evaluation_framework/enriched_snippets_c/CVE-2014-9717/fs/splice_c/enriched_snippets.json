[
  {
    "function_name": "do_tee",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1976-2001",
    "snippet": "static long do_tee(struct file *in, struct file *out, size_t len,\n\t\t   unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe = get_pipe_info(in);\n\tstruct pipe_inode_info *opipe = get_pipe_info(out);\n\tint ret = -EINVAL;\n\n\t/*\n\t * Duplicate the contents of ipipe to opipe without actually\n\t * copying the data.\n\t */\n\tif (ipipe && opipe && ipipe != opipe) {\n\t\t/*\n\t\t * Keep going, unless we encounter an error. The ipipe/opipe\n\t\t * ordering doesn't really matter.\n\t\t */\n\t\tret = ipipe_prep(ipipe, flags);\n\t\tif (!ret) {\n\t\t\tret = opipe_prep(opipe, flags);\n\t\t\tif (!ret)\n\t\t\t\tret = link_pipe(ipipe, opipe, len, flags);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "link_pipe",
          "args": [
            "ipipe",
            "opipe",
            "len",
            "flags"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "link_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1895-1968",
          "snippet": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tibuf->ops->get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tibuf->ops->get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "opipe_prep",
          "args": [
            "opipe",
            "flags"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "opipe_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1740-1775",
          "snippet": "static int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipipe_prep",
          "args": [
            "ipipe",
            "flags"
          ],
          "line": 1992
        },
        "resolved": true,
        "details": {
          "function_name": "ipipe_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1702-1734",
          "snippet": "static int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "out"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "1043-1046",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_tee(struct file *in, struct file *out, size_t len,\n\t\t   unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe = get_pipe_info(in);\n\tstruct pipe_inode_info *opipe = get_pipe_info(out);\n\tint ret = -EINVAL;\n\n\t/*\n\t * Duplicate the contents of ipipe to opipe without actually\n\t * copying the data.\n\t */\n\tif (ipipe && opipe && ipipe != opipe) {\n\t\t/*\n\t\t * Keep going, unless we encounter an error. The ipipe/opipe\n\t\t * ordering doesn't really matter.\n\t\t */\n\t\tret = ipipe_prep(ipipe, flags);\n\t\tif (!ret) {\n\t\t\tret = opipe_prep(opipe, flags);\n\t\t\tif (!ret)\n\t\t\t\tret = link_pipe(ipipe, opipe, len, flags);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "link_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1895-1968",
    "snippet": "static int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tibuf->ops->get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_pipe_readers",
          "args": [
            "opipe"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "164-170",
          "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "opipe"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ibuf->ops->get",
          "args": [
            "ipipe",
            "ibuf"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "518-523",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_double_lock",
          "args": [
            "ipipe",
            "opipe"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_double_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "89-101",
          "snippet": "void pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int link_pipe(struct pipe_inode_info *ipipe,\n\t\t     struct pipe_inode_info *opipe,\n\t\t     size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, i = 0, nbuf;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If we have iterated all input buffers or ran out of\n\t\t * output room, break.\n\t\t */\n\t\tif (i >= ipipe->nrbufs || opipe->nrbufs >= opipe->buffers)\n\t\t\tbreak;\n\n\t\tibuf = ipipe->bufs + ((ipipe->curbuf + i) & (ipipe->buffers-1));\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\n\t\t/*\n\t\t * Get a reference to this pipe buffer,\n\t\t * so we can copy the contents over.\n\t\t */\n\t\tibuf->ops->get(ipipe, ibuf);\n\n\t\tobuf = opipe->bufs + nbuf;\n\t\t*obuf = *ibuf;\n\n\t\t/*\n\t\t * Don't inherit the gift flag, we need to\n\t\t * prevent multiple steals of this page.\n\t\t */\n\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\tif (obuf->len > len)\n\t\t\tobuf->len = len;\n\n\t\topipe->nrbufs++;\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t\ti++;\n\t} while (len);\n\n\t/*\n\t * return EAGAIN if we have the potential of some data in the\n\t * future, otherwise just return 0\n\t */\n\tif (!ret && ipipe->waiting_writers && (flags & SPLICE_F_NONBLOCK))\n\t\tret = -EAGAIN;\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "splice_pipe_to_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1780-1890",
    "snippet": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tibuf->ops->get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_pipe_writers",
          "args": [
            "ipipe"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "721-727",
          "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_pipe_readers",
          "args": [
            "opipe"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "164-170",
          "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "opipe"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ibuf->ops->get",
          "args": [
            "ipipe",
            "ibuf"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "518-523",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_double_lock",
          "args": [
            "ipipe",
            "opipe"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_double_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "89-101",
          "snippet": "void pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_double_lock(struct pipe_inode_info *pipe1,\n\t\t      struct pipe_inode_info *pipe2)\n{\n\tBUG_ON(pipe1 == pipe2);\n\n\tif (pipe1 < pipe2) {\n\t\tpipe_lock_nested(pipe1, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe2, I_MUTEX_CHILD);\n\t} else {\n\t\tpipe_lock_nested(pipe2, I_MUTEX_PARENT);\n\t\tpipe_lock_nested(pipe1, I_MUTEX_CHILD);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "opipe_prep",
          "args": [
            "opipe",
            "flags"
          ],
          "line": 1794
        },
        "resolved": true,
        "details": {
          "function_name": "opipe_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1740-1775",
          "snippet": "static int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ipipe_prep",
          "args": [
            "ipipe",
            "flags"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "ipipe_prep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1702-1734",
          "snippet": "static int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tibuf->ops->get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "opipe_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1740-1775",
    "snippet": "static int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 1769
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "104-117",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "518-523",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int opipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs < pipe->buffers)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (pipe->nrbufs >= pipe->buffers) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "ipipe_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1702-1734",
    "snippet": "static int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "104-117",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int ipipe_prep(struct pipe_inode_info *pipe, unsigned int flags)\n{\n\tint ret;\n\n\t/*\n\t * Check ->nrbufs without the inode lock first. This function\n\t * is speculative anyways, so missing one is ok.\n\t */\n\tif (pipe->nrbufs)\n\t\treturn 0;\n\n\tret = 0;\n\tpipe_lock(pipe);\n\n\twhile (!pipe->nrbufs) {\n\t\tif (signal_pending(current)) {\n\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\t\tif (!pipe->writers)\n\t\t\tbreak;\n\t\tif (!pipe->waiting_writers) {\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpipe_wait(pipe);\n\t}\n\n\tpipe_unlock(pipe);\n\treturn ret;\n}"
  },
  {
    "function_name": "vmsplice_to_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1573-1606",
    "snippet": "static long vmsplice_to_pipe(struct file *file, const struct iovec __user *iov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tspd.nr_pages = get_iovec_page_array(iov, nr_segs, spd.pages,\n\t\t\t\t\t    spd.partial, false,\n\t\t\t\t\t    spd.nr_pages_max);\n\tif (spd.nr_pages <= 0)\n\t\tret = spd.nr_pages;\n\telse\n\t\tret = splice_to_pipe(pipe, &spd);\n\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pipe_buf_operations user_page_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = user_page_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_shrink_spd",
          "args": [
            "&spd"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "splice_shrink_spd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "294-301",
          "snippet": "void splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nvoid splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_to_pipe",
          "args": [
            "pipe",
            "&spd"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "splice_to_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "183-264",
          "snippet": "ssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret, do_wakeup, page_nr;\n\n\tret = 0;\n\tdo_wakeup = 0;\n\tpage_nr = 0;\n\n\tpipe_lock(pipe);\n\n\tfor (;;) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe->nrbufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\t\tbuf->page = spd->pages[page_nr];\n\t\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\t\tbuf->len = spd->partial[page_nr].len;\n\t\t\tbuf->private = spd->partial[page_nr].private;\n\t\t\tbuf->ops = spd->ops;\n\t\t\tif (spd->flags & SPLICE_F_GIFT)\n\t\t\t\tbuf->flags |= PIPE_BUF_FLAG_GIFT;\n\n\t\t\tpipe->nrbufs++;\n\t\t\tpage_nr++;\n\t\t\tret += buf->len;\n\n\t\t\tif (pipe->files)\n\t\t\t\tdo_wakeup = 1;\n\n\t\t\tif (!--spd->nr_pages)\n\t\t\t\tbreak;\n\t\t\tif (pipe->nrbufs < pipe->buffers)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spd->flags & SPLICE_F_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_wakeup) {\n\t\t\tsmp_mb();\n\t\t\tif (waitqueue_active(&pipe->wait))\n\t\t\t\twake_up_interruptible_sync(&pipe->wait);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup)\n\t\twakeup_pipe_readers(pipe);\n\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret, do_wakeup, page_nr;\n\n\tret = 0;\n\tdo_wakeup = 0;\n\tpage_nr = 0;\n\n\tpipe_lock(pipe);\n\n\tfor (;;) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe->nrbufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\t\tbuf->page = spd->pages[page_nr];\n\t\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\t\tbuf->len = spd->partial[page_nr].len;\n\t\t\tbuf->private = spd->partial[page_nr].private;\n\t\t\tbuf->ops = spd->ops;\n\t\t\tif (spd->flags & SPLICE_F_GIFT)\n\t\t\t\tbuf->flags |= PIPE_BUF_FLAG_GIFT;\n\n\t\t\tpipe->nrbufs++;\n\t\t\tpage_nr++;\n\t\t\tret += buf->len;\n\n\t\t\tif (pipe->files)\n\t\t\t\tdo_wakeup = 1;\n\n\t\t\tif (!--spd->nr_pages)\n\t\t\t\tbreak;\n\t\t\tif (pipe->nrbufs < pipe->buffers)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spd->flags & SPLICE_F_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_wakeup) {\n\t\t\tsmp_mb();\n\t\t\tif (waitqueue_active(&pipe->wait))\n\t\t\t\twake_up_interruptible_sync(&pipe->wait);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup)\n\t\twakeup_pipe_readers(pipe);\n\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_iovec_page_array",
          "args": [
            "iov",
            "nr_segs",
            "spd.pages",
            "spd.partial",
            "false",
            "spd.nr_pages_max"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "get_iovec_page_array",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1422-1515",
          "snippet": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, bool aligned,\n\t\t\t\tunsigned int pipe_buffers)\n{\n\tint buffers = 0, error = 0;\n\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\n\t\terror = -EFAULT;\n\t\tif (copy_from_user(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, base, len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get this base offset and number of pages, then map\n\t\t * in the user pages.\n\t\t */\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\n\t\t/*\n\t\t * If asked for alignment, the offset must be zero and the\n\t\t * length a multiple of the PAGE_SIZE.\n\t\t */\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > pipe_buffers - buffers)\n\t\t\tnpages = pipe_buffers - buffers;\n\n\t\terror = get_user_pages_fast((unsigned long)base, npages,\n\t\t\t\t\t0, &pages[buffers]);\n\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Fill this contiguous range into the partial page map.\n\t\t */\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\n\t\t/*\n\t\t * We didn't complete this iov, stop here since it probably\n\t\t * means we have to move some of this into a pipe to\n\t\t * be able to continue.\n\t\t */\n\t\tif (len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't continue if we mapped fewer pages than we asked for,\n\t\t * or if we mapped the max number of pages that we have\n\t\t * room for.\n\t\t */\n\t\tif (error < npages || buffers == pipe_buffers)\n\t\t\tbreak;\n\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\n\tif (buffers)\n\t\treturn buffers;\n\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, bool aligned,\n\t\t\t\tunsigned int pipe_buffers)\n{\n\tint buffers = 0, error = 0;\n\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\n\t\terror = -EFAULT;\n\t\tif (copy_from_user(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, base, len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get this base offset and number of pages, then map\n\t\t * in the user pages.\n\t\t */\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\n\t\t/*\n\t\t * If asked for alignment, the offset must be zero and the\n\t\t * length a multiple of the PAGE_SIZE.\n\t\t */\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > pipe_buffers - buffers)\n\t\t\tnpages = pipe_buffers - buffers;\n\n\t\terror = get_user_pages_fast((unsigned long)base, npages,\n\t\t\t\t\t0, &pages[buffers]);\n\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Fill this contiguous range into the partial page map.\n\t\t */\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\n\t\t/*\n\t\t * We didn't complete this iov, stop here since it probably\n\t\t * means we have to move some of this into a pipe to\n\t\t * be able to continue.\n\t\t */\n\t\tif (len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't continue if we mapped fewer pages than we asked for,\n\t\t * or if we mapped the max number of pages that we have\n\t\t * room for.\n\t\t */\n\t\tif (error < npages || buffers == pipe_buffers)\n\t\t\tbreak;\n\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\n\tif (buffers)\n\t\treturn buffers;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_grow_spd",
          "args": [
            "pipe",
            "&spd"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "splice_grow_spd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "275-292",
          "snippet": "int splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = ACCESS_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nint splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = ACCESS_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "file"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "1043-1046",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic const struct pipe_buf_operations user_page_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = user_page_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long vmsplice_to_pipe(struct file *file, const struct iovec __user *iov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &user_page_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\tlong ret;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tspd.nr_pages = get_iovec_page_array(iov, nr_segs, spd.pages,\n\t\t\t\t\t    spd.partial, false,\n\t\t\t\t\t    spd.nr_pages_max);\n\tif (spd.nr_pages <= 0)\n\t\tret = spd.nr_pages;\n\telse\n\t\tret = splice_to_pipe(pipe, &spd);\n\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}"
  },
  {
    "function_name": "vmsplice_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1528-1566",
    "snippet": "static long vmsplice_to_user(struct file *file, const struct iovec __user *uiov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct splice_desc sd;\n\tlong ret;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t count;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tret = rw_copy_check_uvector(READ, uiov, nr_segs,\n\t\t\t\t    ARRAY_SIZE(iovstack), iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcount = ret;\n\tiov_iter_init(&iter, READ, iov, nr_segs, count);\n\n\tsd.len = 0;\n\tsd.total_len = count;\n\tsd.flags = flags;\n\tsd.u.data = &iter;\n\tsd.pos = 0;\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\tpipe_unlock(pipe);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__splice_from_pipe",
          "args": [
            "pipe",
            "&sd",
            "pipe_to_user"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "__splice_from_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "877-891",
          "snippet": "ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_init",
          "args": [
            "&iter",
            "READ",
            "iov",
            "nr_segs",
            "count"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_copy_check_uvector",
          "args": [
            "READ",
            "uiov",
            "nr_segs",
            "ARRAY_SIZE(iovstack)",
            "iovstack",
            "&iov"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "compat_rw_copy_check_uvector",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "546-617",
          "snippet": "ssize_t compat_rw_copy_check_uvector(int type,\n\t\tconst struct compat_iovec __user *uvector, unsigned long nr_segs,\n\t\tunsigned long fast_segs, struct iovec *fast_pointer,\n\t\tstruct iovec **ret_pointer)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec *iov = *ret_pointer = fast_pointer;\n\tssize_t ret = 0;\n\tint seg;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nr_segs > UIO_MAXIOV || nr_segs < 0)\n\t\tgoto out;\n\tif (nr_segs > fast_segs) {\n\t\tret = -ENOMEM;\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL)\n\t\t\tgoto out;\n\t}\n\t*ret_pointer = iov;\n\n\tret = -EFAULT;\n\tif (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))\n\t\tgoto out;\n\n\t/*\n\t * Single unix specification:\n\t * We should -EINVAL if an element length is not >= 0 and fitting an\n\t * ssize_t.\n\t *\n\t * In Linux, the total length is limited to MAX_RW_COUNT, there is\n\t * no overflow possibility.\n\t */\n\ttot_len = 0;\n\tret = -EINVAL;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tcompat_uptr_t buf;\n\t\tcompat_ssize_t len;\n\n\t\tif (__get_user(len, &uvector->iov_len) ||\n\t\t   __get_user(buf, &uvector->iov_base)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < 0)\t/* size_t not fitting in compat_ssize_t .. */\n\t\t\tgoto out;\n\t\tif (type >= 0 &&\n\t\t    !access_ok(vrfy_dir(type), compat_ptr(buf), len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - tot_len)\n\t\t\tlen = MAX_RW_COUNT - tot_len;\n\t\ttot_len += len;\n\t\tiov->iov_base = compat_ptr(buf);\n\t\tiov->iov_len = (compat_size_t) len;\n\t\tuvector++;\n\t\tiov++;\n\t}\n\tret = tot_len;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nssize_t compat_rw_copy_check_uvector(int type,\n\t\tconst struct compat_iovec __user *uvector, unsigned long nr_segs,\n\t\tunsigned long fast_segs, struct iovec *fast_pointer,\n\t\tstruct iovec **ret_pointer)\n{\n\tcompat_ssize_t tot_len;\n\tstruct iovec *iov = *ret_pointer = fast_pointer;\n\tssize_t ret = 0;\n\tint seg;\n\n\t/*\n\t * SuS says \"The readv() function *may* fail if the iovcnt argument\n\t * was less than or equal to 0, or greater than {IOV_MAX}.  Linux has\n\t * traditionally returned zero for zero segments, so...\n\t */\n\tif (nr_segs == 0)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (nr_segs > UIO_MAXIOV || nr_segs < 0)\n\t\tgoto out;\n\tif (nr_segs > fast_segs) {\n\t\tret = -ENOMEM;\n\t\tiov = kmalloc(nr_segs*sizeof(struct iovec), GFP_KERNEL);\n\t\tif (iov == NULL)\n\t\t\tgoto out;\n\t}\n\t*ret_pointer = iov;\n\n\tret = -EFAULT;\n\tif (!access_ok(VERIFY_READ, uvector, nr_segs*sizeof(*uvector)))\n\t\tgoto out;\n\n\t/*\n\t * Single unix specification:\n\t * We should -EINVAL if an element length is not >= 0 and fitting an\n\t * ssize_t.\n\t *\n\t * In Linux, the total length is limited to MAX_RW_COUNT, there is\n\t * no overflow possibility.\n\t */\n\ttot_len = 0;\n\tret = -EINVAL;\n\tfor (seg = 0; seg < nr_segs; seg++) {\n\t\tcompat_uptr_t buf;\n\t\tcompat_ssize_t len;\n\n\t\tif (__get_user(len, &uvector->iov_len) ||\n\t\t   __get_user(buf, &uvector->iov_base)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len < 0)\t/* size_t not fitting in compat_ssize_t .. */\n\t\t\tgoto out;\n\t\tif (type >= 0 &&\n\t\t    !access_ok(vrfy_dir(type), compat_ptr(buf), len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tif (len > MAX_RW_COUNT - tot_len)\n\t\t\tlen = MAX_RW_COUNT - tot_len;\n\t\ttot_len += len;\n\t\tiov->iov_base = compat_ptr(buf);\n\t\tiov->iov_len = (compat_size_t) len;\n\t\tuvector++;\n\t\tiov++;\n\t}\n\tret = tot_len;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "iovstack"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "file"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "1043-1046",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long vmsplice_to_user(struct file *file, const struct iovec __user *uiov,\n\t\t\t     unsigned long nr_segs, unsigned int flags)\n{\n\tstruct pipe_inode_info *pipe;\n\tstruct splice_desc sd;\n\tlong ret;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tstruct iov_iter iter;\n\tssize_t count;\n\n\tpipe = get_pipe_info(file);\n\tif (!pipe)\n\t\treturn -EBADF;\n\n\tret = rw_copy_check_uvector(READ, uiov, nr_segs,\n\t\t\t\t    ARRAY_SIZE(iovstack), iovstack, &iov);\n\tif (ret <= 0)\n\t\tgoto out;\n\n\tcount = ret;\n\tiov_iter_init(&iter, READ, iov, nr_segs, count);\n\n\tsd.len = 0;\n\tsd.total_len = count;\n\tsd.flags = flags;\n\tsd.u.data = &iter;\n\tsd.pos = 0;\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, pipe_to_user);\n\tpipe_unlock(pipe);\n\nout:\n\tif (iov != iovstack)\n\t\tkfree(iov);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pipe_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1517-1522",
    "snippet": "static int pipe_to_user(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tint n = copy_page_to_iter(buf->page, buf->offset, sd->len, sd->u.data);\n\treturn n == sd->len ? n : -EFAULT;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_page_to_iter",
          "args": [
            "buf->page",
            "buf->offset",
            "sd->len",
            "sd->u.data"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int pipe_to_user(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\tstruct splice_desc *sd)\n{\n\tint n = copy_page_to_iter(buf->page, buf->offset, sd->len, sd->u.data);\n\treturn n == sd->len ? n : -EFAULT;\n}"
  },
  {
    "function_name": "get_iovec_page_array",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1422-1515",
    "snippet": "static int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, bool aligned,\n\t\t\t\tunsigned int pipe_buffers)\n{\n\tint buffers = 0, error = 0;\n\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\n\t\terror = -EFAULT;\n\t\tif (copy_from_user(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, base, len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get this base offset and number of pages, then map\n\t\t * in the user pages.\n\t\t */\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\n\t\t/*\n\t\t * If asked for alignment, the offset must be zero and the\n\t\t * length a multiple of the PAGE_SIZE.\n\t\t */\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > pipe_buffers - buffers)\n\t\t\tnpages = pipe_buffers - buffers;\n\n\t\terror = get_user_pages_fast((unsigned long)base, npages,\n\t\t\t\t\t0, &pages[buffers]);\n\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Fill this contiguous range into the partial page map.\n\t\t */\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\n\t\t/*\n\t\t * We didn't complete this iov, stop here since it probably\n\t\t * means we have to move some of this into a pipe to\n\t\t * be able to continue.\n\t\t */\n\t\tif (len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't continue if we mapped fewer pages than we asked for,\n\t\t * or if we mapped the max number of pages that we have\n\t\t * room for.\n\t\t */\n\t\tif (error < npages || buffers == pipe_buffers)\n\t\t\tbreak;\n\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\n\tif (buffers)\n\t\treturn buffers;\n\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "len",
            "PAGE_SIZE - off"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error <= 0"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_fast",
          "args": [
            "(unsigned long)base",
            "npages",
            "0",
            "&pages[buffers]"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "base",
            "len"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!len"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&entry",
            "iov",
            "sizeof(entry)"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int get_iovec_page_array(const struct iovec __user *iov,\n\t\t\t\tunsigned int nr_vecs, struct page **pages,\n\t\t\t\tstruct partial_page *partial, bool aligned,\n\t\t\t\tunsigned int pipe_buffers)\n{\n\tint buffers = 0, error = 0;\n\n\twhile (nr_vecs) {\n\t\tunsigned long off, npages;\n\t\tstruct iovec entry;\n\t\tvoid __user *base;\n\t\tsize_t len;\n\t\tint i;\n\n\t\terror = -EFAULT;\n\t\tif (copy_from_user(&entry, iov, sizeof(entry)))\n\t\t\tbreak;\n\n\t\tbase = entry.iov_base;\n\t\tlen = entry.iov_len;\n\n\t\t/*\n\t\t * Sanity check this iovec. 0 read succeeds.\n\t\t */\n\t\terror = 0;\n\t\tif (unlikely(!len))\n\t\t\tbreak;\n\t\terror = -EFAULT;\n\t\tif (!access_ok(VERIFY_READ, base, len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Get this base offset and number of pages, then map\n\t\t * in the user pages.\n\t\t */\n\t\toff = (unsigned long) base & ~PAGE_MASK;\n\n\t\t/*\n\t\t * If asked for alignment, the offset must be zero and the\n\t\t * length a multiple of the PAGE_SIZE.\n\t\t */\n\t\terror = -EINVAL;\n\t\tif (aligned && (off || len & ~PAGE_MASK))\n\t\t\tbreak;\n\n\t\tnpages = (off + len + PAGE_SIZE - 1) >> PAGE_SHIFT;\n\t\tif (npages > pipe_buffers - buffers)\n\t\t\tnpages = pipe_buffers - buffers;\n\n\t\terror = get_user_pages_fast((unsigned long)base, npages,\n\t\t\t\t\t0, &pages[buffers]);\n\n\t\tif (unlikely(error <= 0))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Fill this contiguous range into the partial page map.\n\t\t */\n\t\tfor (i = 0; i < error; i++) {\n\t\t\tconst int plen = min_t(size_t, len, PAGE_SIZE - off);\n\n\t\t\tpartial[buffers].offset = off;\n\t\t\tpartial[buffers].len = plen;\n\n\t\t\toff = 0;\n\t\t\tlen -= plen;\n\t\t\tbuffers++;\n\t\t}\n\n\t\t/*\n\t\t * We didn't complete this iov, stop here since it probably\n\t\t * means we have to move some of this into a pipe to\n\t\t * be able to continue.\n\t\t */\n\t\tif (len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Don't continue if we mapped fewer pages than we asked for,\n\t\t * or if we mapped the max number of pages that we have\n\t\t * room for.\n\t\t */\n\t\tif (error < npages || buffers == pipe_buffers)\n\t\t\tbreak;\n\n\t\tnr_vecs--;\n\t\tiov++;\n\t}\n\n\tif (buffers)\n\t\treturn buffers;\n\n\treturn error;\n}"
  },
  {
    "function_name": "do_splice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1327-1413",
    "snippet": "static long do_splice(struct file *in, loff_t __user *off_in,\n\t\t      struct file *out, loff_t __user *off_out,\n\t\t      size_t len, unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe;\n\tstruct pipe_inode_info *opipe;\n\tloff_t offset;\n\tlong ret;\n\n\tipipe = get_pipe_info(in);\n\topipe = get_pipe_info(out);\n\n\tif (ipipe && opipe) {\n\t\tif (off_in || off_out)\n\t\t\treturn -ESPIPE;\n\n\t\tif (!(in->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\n\t\tif (!(out->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\t/* Splicing to self would be fun, but... */\n\t\tif (ipipe == opipe)\n\t\t\treturn -EINVAL;\n\n\t\treturn splice_pipe_to_pipe(ipipe, opipe, len, flags);\n\t}\n\n\tif (ipipe) {\n\t\tif (off_in)\n\t\t\treturn -ESPIPE;\n\t\tif (off_out) {\n\t\t\tif (!(out->f_mode & FMODE_PWRITE))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(&offset, off_out, sizeof(loff_t)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\toffset = out->f_pos;\n\t\t}\n\n\t\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\t\treturn -EBADF;\n\n\t\tif (unlikely(out->f_flags & O_APPEND))\n\t\t\treturn -EINVAL;\n\n\t\tret = rw_verify_area(WRITE, out, &offset, len);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\n\t\tfile_start_write(out);\n\t\tret = do_splice_from(ipipe, out, &offset, len, flags);\n\t\tfile_end_write(out);\n\n\t\tif (!off_out)\n\t\t\tout->f_pos = offset;\n\t\telse if (copy_to_user(off_out, &offset, sizeof(loff_t)))\n\t\t\tret = -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\tif (opipe) {\n\t\tif (off_out)\n\t\t\treturn -ESPIPE;\n\t\tif (off_in) {\n\t\t\tif (!(in->f_mode & FMODE_PREAD))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(&offset, off_in, sizeof(loff_t)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\toffset = in->f_pos;\n\t\t}\n\n\t\tret = do_splice_to(in, &offset, opipe, len, flags);\n\n\t\tif (!off_in)\n\t\t\tin->f_pos = offset;\n\t\telse if (copy_to_user(off_in, &offset, sizeof(loff_t)))\n\t\t\tret = -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "off_in",
            "&offset",
            "sizeof(loff_t)"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_to",
          "args": [
            "in",
            "&offset",
            "opipe",
            "len",
            "flags"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1119-1140",
          "snippet": "static long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&offset",
            "off_in",
            "sizeof(loff_t)"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "exact_copy_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2514-2534",
          "snippet": "static long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic long exact_copy_from_user(void *to, const void __user * from,\n\t\t\t\t unsigned long n)\n{\n\tchar *t = to;\n\tconst char __user *f = from;\n\tchar c;\n\n\tif (!access_ok(VERIFY_READ, from, n))\n\t\treturn n;\n\n\twhile (n) {\n\t\tif (__get_user(c, f)) {\n\t\t\tmemset(t, 0, n);\n\t\t\tbreak;\n\t\t}\n\t\t*t++ = c;\n\t\tf++;\n\t\tn--;\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "off_out",
            "&offset",
            "sizeof(loff_t)"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_end_write",
          "args": [
            "out"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_from",
          "args": [
            "ipipe",
            "out",
            "&offset",
            "len",
            "flags"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1102-1114",
          "snippet": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_start_write",
          "args": [
            "out"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "out",
            "&offset",
            "len"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "out->f_flags & O_APPEND"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(out->f_mode & FMODE_WRITE)"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_pipe_to_pipe",
          "args": [
            "ipipe",
            "opipe",
            "len",
            "flags"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "splice_pipe_to_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1780-1890",
          "snippet": "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tibuf->ops->get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags)\n{\n\tstruct pipe_buffer *ibuf, *obuf;\n\tint ret = 0, nbuf;\n\tbool input_wakeup = false;\n\n\nretry:\n\tret = ipipe_prep(ipipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = opipe_prep(opipe, flags);\n\tif (ret)\n\t\treturn ret;\n\n\t/*\n\t * Potential ABBA deadlock, work around it by ordering lock\n\t * grabbing by pipe info address. Otherwise two different processes\n\t * could deadlock (one doing tee from A -> B, the other from B -> A).\n\t */\n\tpipe_double_lock(ipipe, opipe);\n\n\tdo {\n\t\tif (!opipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!ipipe->nrbufs && !ipipe->writers)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Cannot make any progress, because either the input\n\t\t * pipe is empty or the output pipe is full.\n\t\t */\n\t\tif (!ipipe->nrbufs || opipe->nrbufs >= opipe->buffers) {\n\t\t\t/* Already processed some buffers, break */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (flags & SPLICE_F_NONBLOCK) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We raced with another reader/writer and haven't\n\t\t\t * managed to process any buffers.  A zero return\n\t\t\t * value means EOF, so retry instead.\n\t\t\t */\n\t\t\tpipe_unlock(ipipe);\n\t\t\tpipe_unlock(opipe);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tibuf = ipipe->bufs + ipipe->curbuf;\n\t\tnbuf = (opipe->curbuf + opipe->nrbufs) & (opipe->buffers - 1);\n\t\tobuf = opipe->bufs + nbuf;\n\n\t\tif (len >= ibuf->len) {\n\t\t\t/*\n\t\t\t * Simply move the whole buffer from ipipe to opipe\n\t\t\t */\n\t\t\t*obuf = *ibuf;\n\t\t\tibuf->ops = NULL;\n\t\t\topipe->nrbufs++;\n\t\t\tipipe->curbuf = (ipipe->curbuf + 1) & (ipipe->buffers - 1);\n\t\t\tipipe->nrbufs--;\n\t\t\tinput_wakeup = true;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Get a reference to this pipe buffer,\n\t\t\t * so we can copy the contents over.\n\t\t\t */\n\t\t\tibuf->ops->get(ipipe, ibuf);\n\t\t\t*obuf = *ibuf;\n\n\t\t\t/*\n\t\t\t * Don't inherit the gift flag, we need to\n\t\t\t * prevent multiple steals of this page.\n\t\t\t */\n\t\t\tobuf->flags &= ~PIPE_BUF_FLAG_GIFT;\n\n\t\t\tobuf->len = len;\n\t\t\topipe->nrbufs++;\n\t\t\tibuf->offset += obuf->len;\n\t\t\tibuf->len -= obuf->len;\n\t\t}\n\t\tret += obuf->len;\n\t\tlen -= obuf->len;\n\t} while (len);\n\n\tpipe_unlock(ipipe);\n\tpipe_unlock(opipe);\n\n\t/*\n\t * If we put data in the output pipe, wakeup any potential readers.\n\t */\n\tif (ret > 0)\n\t\twakeup_pipe_readers(opipe);\n\n\tif (input_wakeup)\n\t\twakeup_pipe_writers(ipipe);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pipe_info",
          "args": [
            "out"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "get_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "1043-1046",
          "snippet": "struct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nconst struct file_operations pipefifo_fops = {\n\t.open\t\t= fifo_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= pipe_read,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= pipe_write,\n\t.poll\t\t= pipe_poll,\n\t.unlocked_ioctl\t= pipe_ioctl,\n\t.release\t= pipe_release,\n\t.fasync\t\t= pipe_fasync,\n};\n\nstruct pipe_inode_info *get_pipe_info(struct file *file)\n{\n\treturn file->f_op == &pipefifo_fops ? file->private_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice(struct file *in, loff_t __user *off_in,\n\t\t      struct file *out, loff_t __user *off_out,\n\t\t      size_t len, unsigned int flags)\n{\n\tstruct pipe_inode_info *ipipe;\n\tstruct pipe_inode_info *opipe;\n\tloff_t offset;\n\tlong ret;\n\n\tipipe = get_pipe_info(in);\n\topipe = get_pipe_info(out);\n\n\tif (ipipe && opipe) {\n\t\tif (off_in || off_out)\n\t\t\treturn -ESPIPE;\n\n\t\tif (!(in->f_mode & FMODE_READ))\n\t\t\treturn -EBADF;\n\n\t\tif (!(out->f_mode & FMODE_WRITE))\n\t\t\treturn -EBADF;\n\n\t\t/* Splicing to self would be fun, but... */\n\t\tif (ipipe == opipe)\n\t\t\treturn -EINVAL;\n\n\t\treturn splice_pipe_to_pipe(ipipe, opipe, len, flags);\n\t}\n\n\tif (ipipe) {\n\t\tif (off_in)\n\t\t\treturn -ESPIPE;\n\t\tif (off_out) {\n\t\t\tif (!(out->f_mode & FMODE_PWRITE))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(&offset, off_out, sizeof(loff_t)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\toffset = out->f_pos;\n\t\t}\n\n\t\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\t\treturn -EBADF;\n\n\t\tif (unlikely(out->f_flags & O_APPEND))\n\t\t\treturn -EINVAL;\n\n\t\tret = rw_verify_area(WRITE, out, &offset, len);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\n\t\tfile_start_write(out);\n\t\tret = do_splice_from(ipipe, out, &offset, len, flags);\n\t\tfile_end_write(out);\n\n\t\tif (!off_out)\n\t\t\tout->f_pos = offset;\n\t\telse if (copy_to_user(off_out, &offset, sizeof(loff_t)))\n\t\t\tret = -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\tif (opipe) {\n\t\tif (off_out)\n\t\t\treturn -ESPIPE;\n\t\tif (off_in) {\n\t\t\tif (!(in->f_mode & FMODE_PREAD))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (copy_from_user(&offset, off_in, sizeof(loff_t)))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\toffset = in->f_pos;\n\t\t}\n\n\t\tret = do_splice_to(in, &offset, opipe, len, flags);\n\n\t\tif (!off_in)\n\t\t\tin->f_pos = offset;\n\t\telse if (copy_to_user(off_in, &offset, sizeof(loff_t)))\n\t\t\tret = -EFAULT;\n\n\t\treturn ret;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "do_splice_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1289-1317",
    "snippet": "long do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_direct_to_actor",
          "args": [
            "in",
            "&sd",
            "direct_splice_actor"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "splice_direct_to_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1155-1261",
          "snippet": "ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops) {\n\t\t\tbuf->ops->release(pipe, buf);\n\t\t\tbuf->ops = NULL;\n\t\t}\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops) {\n\t\t\tbuf->ops->release(pipe, buf);\n\t\t\tbuf->ops = NULL;\n\t\t}\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "WRITE",
            "out",
            "opos",
            "len"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "out->f_flags & O_APPEND"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(out->f_mode & FMODE_WRITE)"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nlong do_splice_direct(struct file *in, loff_t *ppos, struct file *out,\n\t\t      loff_t *opos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.len\t\t= len,\n\t\t.total_len\t= len,\n\t\t.flags\t\t= flags,\n\t\t.pos\t\t= *ppos,\n\t\t.u.file\t\t= out,\n\t\t.opos\t\t= opos,\n\t};\n\tlong ret;\n\n\tif (unlikely(!(out->f_mode & FMODE_WRITE)))\n\t\treturn -EBADF;\n\n\tif (unlikely(out->f_flags & O_APPEND))\n\t\treturn -EINVAL;\n\n\tret = rw_verify_area(WRITE, out, opos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = splice_direct_to_actor(in, &sd, direct_splice_actor);\n\tif (ret > 0)\n\t\t*ppos = sd.pos;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "direct_splice_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1264-1271",
    "snippet": "static int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_splice_from",
          "args": [
            "pipe",
            "file",
            "sd->opos",
            "sd->total_len",
            "sd->flags"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_from",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1102-1114",
          "snippet": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}"
  },
  {
    "function_name": "splice_direct_to_actor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1155-1261",
    "snippet": "ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops) {\n\t\t\tbuf->ops->release(pipe, buf);\n\t\t\tbuf->ops = NULL;\n\t\t}\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "buf->ops->release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "in"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actor",
          "args": [
            "pipe",
            "sd"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "direct_splice_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1264-1271",
          "snippet": "static int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int direct_splice_actor(struct pipe_inode_info *pipe,\n\t\t\t       struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\n\treturn do_splice_from(pipe, file, sd->opos, sd->total_len,\n\t\t\t      sd->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret <= 0"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_splice_to",
          "args": [
            "in",
            "&pos",
            "pipe",
            "len",
            "flags"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "do_splice_to",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1119-1140",
          "snippet": "static long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_pipe_info",
          "args": [],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_pipe_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "588-606",
          "snippet": "struct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstruct pipe_inode_info *alloc_pipe_info(void)\n{\n\tstruct pipe_inode_info *pipe;\n\n\tpipe = kzalloc(sizeof(struct pipe_inode_info), GFP_KERNEL);\n\tif (pipe) {\n\t\tpipe->bufs = kzalloc(sizeof(struct pipe_buffer) * PIPE_DEF_BUFFERS, GFP_KERNEL);\n\t\tif (pipe->bufs) {\n\t\t\tinit_waitqueue_head(&pipe->wait);\n\t\t\tpipe->r_counter = pipe->w_counter = 1;\n\t\t\tpipe->buffers = PIPE_DEF_BUFFERS;\n\t\t\tmutex_init(&pipe->mutex);\n\t\t\treturn pipe;\n\t\t}\n\t\tkfree(pipe);\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pipe"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!S_ISREG(i_mode) && !S_ISBLK(i_mode)"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "i_mode"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "i_mode"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "in"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops) {\n\t\t\tbuf->ops->release(pipe, buf);\n\t\t\tbuf->ops = NULL;\n\t\t}\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}"
  },
  {
    "function_name": "do_splice_to",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1119-1140",
    "snippet": "static long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_read",
          "args": [
            "in",
            "ppos",
            "pipe",
            "len",
            "flags"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "default_file_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "601-695",
          "snippet": "ssize_t default_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tunsigned int nr_pages;\n\tunsigned int nr_freed;\n\tsize_t offset;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct iovec *vec, __vec[PIPE_DEF_BUFFERS];\n\tssize_t res;\n\tsize_t this_len;\n\tint error;\n\tint i;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &default_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tres = -ENOMEM;\n\tvec = __vec;\n\tif (spd.nr_pages_max > PIPE_DEF_BUFFERS) {\n\t\tvec = kmalloc(spd.nr_pages_max * sizeof(struct iovec), GFP_KERNEL);\n\t\tif (!vec)\n\t\t\tgoto shrink_ret;\n\t}\n\n\toffset = *ppos & ~PAGE_CACHE_MASK;\n\tnr_pages = (len + offset + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tfor (i = 0; i < nr_pages && i < spd.nr_pages_max && len; i++) {\n\t\tstruct page *page;\n\n\t\tpage = alloc_page(GFP_USER);\n\t\terror = -ENOMEM;\n\t\tif (!page)\n\t\t\tgoto err;\n\n\t\tthis_len = min_t(size_t, len, PAGE_CACHE_SIZE - offset);\n\t\tvec[i].iov_base = (void __user *) page_address(page);\n\t\tvec[i].iov_len = this_len;\n\t\tspd.pages[i] = page;\n\t\tspd.nr_pages++;\n\t\tlen -= this_len;\n\t\toffset = 0;\n\t}\n\n\tres = kernel_readv(in, vec, spd.nr_pages, *ppos);\n\tif (res < 0) {\n\t\terror = res;\n\t\tgoto err;\n\t}\n\n\terror = 0;\n\tif (!res)\n\t\tgoto err;\n\n\tnr_freed = 0;\n\tfor (i = 0; i < spd.nr_pages; i++) {\n\t\tthis_len = min_t(size_t, vec[i].iov_len, res);\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = this_len;\n\t\tif (!this_len) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tspd.pages[i] = NULL;\n\t\t\tnr_freed++;\n\t\t}\n\t\tres -= this_len;\n\t}\n\tspd.nr_pages -= nr_freed;\n\n\tres = splice_to_pipe(pipe, &spd);\n\tif (res > 0)\n\t\t*ppos += res;\n\nshrink_ret:\n\tif (vec != __vec)\n\t\tkfree(vec);\n\tsplice_shrink_spd(&spd);\n\treturn res;\n\nerr:\n\tfor (i = 0; i < spd.nr_pages; i++)\n\t\t__free_page(spd.pages[i]);\n\n\tres = error;\n\tgoto shrink_ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct pipe_buf_operations default_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = generic_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic const struct pipe_buf_operations default_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = generic_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t default_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tunsigned int nr_pages;\n\tunsigned int nr_freed;\n\tsize_t offset;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct iovec *vec, __vec[PIPE_DEF_BUFFERS];\n\tssize_t res;\n\tsize_t this_len;\n\tint error;\n\tint i;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &default_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tres = -ENOMEM;\n\tvec = __vec;\n\tif (spd.nr_pages_max > PIPE_DEF_BUFFERS) {\n\t\tvec = kmalloc(spd.nr_pages_max * sizeof(struct iovec), GFP_KERNEL);\n\t\tif (!vec)\n\t\t\tgoto shrink_ret;\n\t}\n\n\toffset = *ppos & ~PAGE_CACHE_MASK;\n\tnr_pages = (len + offset + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tfor (i = 0; i < nr_pages && i < spd.nr_pages_max && len; i++) {\n\t\tstruct page *page;\n\n\t\tpage = alloc_page(GFP_USER);\n\t\terror = -ENOMEM;\n\t\tif (!page)\n\t\t\tgoto err;\n\n\t\tthis_len = min_t(size_t, len, PAGE_CACHE_SIZE - offset);\n\t\tvec[i].iov_base = (void __user *) page_address(page);\n\t\tvec[i].iov_len = this_len;\n\t\tspd.pages[i] = page;\n\t\tspd.nr_pages++;\n\t\tlen -= this_len;\n\t\toffset = 0;\n\t}\n\n\tres = kernel_readv(in, vec, spd.nr_pages, *ppos);\n\tif (res < 0) {\n\t\terror = res;\n\t\tgoto err;\n\t}\n\n\terror = 0;\n\tif (!res)\n\t\tgoto err;\n\n\tnr_freed = 0;\n\tfor (i = 0; i < spd.nr_pages; i++) {\n\t\tthis_len = min_t(size_t, vec[i].iov_len, res);\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = this_len;\n\t\tif (!this_len) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tspd.pages[i] = NULL;\n\t\t\tnr_freed++;\n\t\t}\n\t\tres -= this_len;\n\t}\n\tspd.nr_pages -= nr_freed;\n\n\tres = splice_to_pipe(pipe, &spd);\n\tif (res > 0)\n\t\t*ppos += res;\n\nshrink_ret:\n\tif (vec != __vec)\n\t\tkfree(vec);\n\tsplice_shrink_spd(&spd);\n\treturn res;\n\nerr:\n\tfor (i = 0; i < spd.nr_pages; i++)\n\t\t__free_page(spd.pages[i]);\n\n\tres = error;\n\tgoto shrink_ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rw_verify_area",
          "args": [
            "READ",
            "in",
            "ppos",
            "len"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "rw_verify_area",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "387-419",
          "snippet": "int rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nint rw_verify_area(int read_write, struct file *file, const loff_t *ppos, size_t count)\n{\n\tstruct inode *inode;\n\tloff_t pos;\n\tint retval = -EINVAL;\n\n\tinode = file_inode(file);\n\tif (unlikely((ssize_t) count < 0))\n\t\treturn retval;\n\tpos = *ppos;\n\tif (unlikely(pos < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t\tif (count >= -pos) /* both values are in 0..LLONG_MAX */\n\t\t\treturn -EOVERFLOW;\n\t} else if (unlikely((loff_t) (pos + count) < 0)) {\n\t\tif (!unsigned_offsets(file))\n\t\t\treturn retval;\n\t}\n\n\tif (unlikely(inode->i_flctx && mandatory_lock(inode))) {\n\t\tretval = locks_mandatory_area(\n\t\t\tread_write == READ ? FLOCK_VERIFY_READ : FLOCK_VERIFY_WRITE,\n\t\t\tinode, file, pos, count);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\tretval = security_file_permission(file,\n\t\t\t\tread_write == READ ? MAY_READ : MAY_WRITE);\n\tif (retval)\n\t\treturn retval;\n\treturn count > MAX_RW_COUNT ? MAX_RW_COUNT : count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!(in->f_mode & FMODE_READ)"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_to(struct file *in, loff_t *ppos,\n\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t unsigned int flags)\n{\n\tssize_t (*splice_read)(struct file *, loff_t *,\n\t\t\t       struct pipe_inode_info *, size_t, unsigned int);\n\tint ret;\n\n\tif (unlikely(!(in->f_mode & FMODE_READ)))\n\t\treturn -EBADF;\n\n\tret = rw_verify_area(READ, in, ppos, len);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tif (in->f_op->splice_read)\n\t\tsplice_read = in->f_op->splice_read;\n\telse\n\t\tsplice_read = default_file_splice_read;\n\n\treturn splice_read(in, ppos, pipe, len, flags);\n}"
  },
  {
    "function_name": "do_splice_from",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1102-1114",
    "snippet": "static long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_write",
          "args": [
            "pipe",
            "out",
            "ppos",
            "len",
            "flags"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "default_file_splice_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1065-1076",
          "snippet": "static ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct file *out, loff_t *ppos,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct file *out, loff_t *ppos,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic long do_splice_from(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t   loff_t *ppos, size_t len, unsigned int flags)\n{\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *,\n\t\t\t\tloff_t *, size_t, unsigned int);\n\n\tif (out->f_op->splice_write)\n\t\tsplice_write = out->f_op->splice_write;\n\telse\n\t\tsplice_write = default_file_splice_write;\n\n\treturn splice_write(pipe, out, ppos, len, flags);\n}"
  },
  {
    "function_name": "generic_splice_sendpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1091-1095",
    "snippet": "ssize_t generic_splice_sendpage(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t\tloff_t *ppos, size_t len, unsigned int flags)\n{\n\treturn splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_sendpage);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_from_pipe",
          "args": [
            "pipe",
            "out",
            "ppos",
            "len",
            "flags",
            "pipe_to_sendpage"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "908-925",
          "snippet": "ssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t generic_splice_sendpage(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t\tloff_t *ppos, size_t len, unsigned int flags)\n{\n\treturn splice_from_pipe(pipe, out, ppos, len, flags, pipe_to_sendpage);\n}"
  },
  {
    "function_name": "default_file_splice_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1065-1076",
    "snippet": "static ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct file *out, loff_t *ppos,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_from_pipe",
          "args": [
            "pipe",
            "out",
            "ppos",
            "len",
            "flags",
            "write_pipe_buf"
          ],
          "line": 1071
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "908-925",
          "snippet": "ssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic ssize_t default_file_splice_write(struct pipe_inode_info *pipe,\n\t\t\t\t\t struct file *out, loff_t *ppos,\n\t\t\t\t\t size_t len, unsigned int flags)\n{\n\tssize_t ret;\n\n\tret = splice_from_pipe(pipe, out, ppos, len, flags, write_pipe_buf);\n\tif (ret > 0)\n\t\t*ppos += ret;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "write_pipe_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "1051-1063",
    "snippet": "static int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\t  struct splice_desc *sd)\n{\n\tint ret;\n\tvoid *data;\n\tloff_t tmp = sd->pos;\n\n\tdata = kmap(buf->page);\n\tret = __kernel_write(sd->u.file, data + buf->offset, sd->len, &tmp);\n\tkunmap(buf->page);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "buf->page"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kernel_write",
          "args": [
            "sd->u.file",
            "data + buf->offset",
            "sd->len",
            "&tmp"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "__kernel_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "545-572",
          "snippet": "ssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->aio_write)\n\t\tret = do_sync_write(file, p, count, pos);\n\telse\n\t\tret = new_sync_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t __kernel_write(struct file *file, const char *buf, size_t count, loff_t *pos)\n{\n\tmm_segment_t old_fs;\n\tconst char __user *p;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tp = (__force const char __user *)buf;\n\tif (count > MAX_RW_COUNT)\n\t\tcount =  MAX_RW_COUNT;\n\tif (file->f_op->write)\n\t\tret = file->f_op->write(file, p, count, pos);\n\telse if (file->f_op->aio_write)\n\t\tret = do_sync_write(file, p, count, pos);\n\telse\n\t\tret = new_sync_write(file, p, count, pos);\n\tset_fs(old_fs);\n\tif (ret > 0) {\n\t\tfsnotify_modify(file);\n\t\tadd_wchar(current, ret);\n\t}\n\tinc_syscw(current);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "buf->page"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int write_pipe_buf(struct pipe_inode_info *pipe, struct pipe_buffer *buf,\n\t\t\t  struct splice_desc *sd)\n{\n\tint ret;\n\tvoid *data;\n\tloff_t tmp = sd->pos;\n\n\tdata = kmap(buf->page);\n\tret = __kernel_write(sd->u.file, data + buf->offset, sd->len, &tmp);\n\tkunmap(buf->page);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "iter_file_splice_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "941-1047",
    "snippet": "ssize_t\niter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\tint nbufs = pipe->buffers;\n\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\tssize_t ret;\n\n\tif (unlikely(!array))\n\t\treturn -ENOMEM;\n\n\tpipe_lock(pipe);\n\n\tsplice_from_pipe_begin(&sd);\n\twhile (sd.total_len) {\n\t\tstruct iov_iter from;\n\t\tsize_t left;\n\t\tint n, idx;\n\n\t\tret = splice_from_pipe_next(pipe, &sd);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (unlikely(nbufs < pipe->buffers)) {\n\t\t\tkfree(array);\n\t\t\tnbufs = pipe->buffers;\n\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!array) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* build the vector */\n\t\tleft = sd.total_len;\n\t\tfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + idx;\n\t\t\tsize_t this_len = buf->len;\n\n\t\t\tif (this_len > left)\n\t\t\t\tthis_len = left;\n\n\t\t\tif (idx == pipe->buffers - 1)\n\t\t\t\tidx = -1;\n\n\t\t\tret = buf->ops->confirm(pipe, buf);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == -ENODATA)\n\t\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tarray[n].bv_page = buf->page;\n\t\t\tarray[n].bv_len = this_len;\n\t\t\tarray[n].bv_offset = buf->offset;\n\t\t\tleft -= this_len;\n\t\t}\n\n\t\tiov_iter_bvec(&from, ITER_BVEC | WRITE, array, n,\n\t\t\t      sd.total_len - left);\n\t\tret = vfs_iter_write(out, &from, &sd.pos);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tsd.num_spliced += ret;\n\t\tsd.total_len -= ret;\n\t\t*ppos = sd.pos;\n\n\t\t/* dismiss the fully eaten buffers, adjust the partial one */\n\t\twhile (ret) {\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\t\t\tif (ret >= buf->len) {\n\t\t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\t\t\t\tret -= buf->len;\n\t\t\t\tbuf->len = 0;\n\t\t\t\tbuf->ops = NULL;\n\t\t\t\tops->release(pipe, buf);\n\t\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\t\tpipe->nrbufs--;\n\t\t\t\tif (pipe->files)\n\t\t\t\t\tsd.need_wakeup = true;\n\t\t\t} else {\n\t\t\t\tbuf->offset += ret;\n\t\t\t\tbuf->len -= ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tkfree(array);\n\tsplice_from_pipe_end(pipe, &sd);\n\n\tpipe_unlock(pipe);\n\n\tif (sd.num_spliced)\n\t\tret = sd.num_spliced;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_end",
          "args": [
            "pipe",
            "&sd"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "858-862",
          "snippet": "static void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_iter_write",
          "args": [
            "out",
            "&from",
            "&sd.pos"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_iter_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "359-379",
          "snippet": "ssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = iov_iter_count(iter);\n\n\titer->type |= WRITE;\n\tret = file->f_op->write_iter(&kiocb, iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_iter_write(struct file *file, struct iov_iter *iter, loff_t *ppos)\n{\n\tstruct kiocb kiocb;\n\tssize_t ret;\n\n\tif (!file->f_op->write_iter)\n\t\treturn -EINVAL;\n\n\tinit_sync_kiocb(&kiocb, file);\n\tkiocb.ki_pos = *ppos;\n\tkiocb.ki_nbytes = iov_iter_count(iter);\n\n\titer->type |= WRITE;\n\tret = file->f_op->write_iter(&kiocb, iter);\n\tif (ret == -EIOCBQUEUED)\n\t\tret = wait_on_sync_kiocb(&kiocb);\n\n\tif (ret > 0)\n\t\t*ppos = kiocb.ki_pos;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_iter_bvec",
          "args": [
            "&from",
            "ITER_BVEC | WRITE",
            "array",
            "n",
            "sd.total_len - left"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->ops->confirm",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nbufs",
            "sizeof(struct bio_vec)",
            "GFP_KERNEL"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "array"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "nbufs < pipe->buffers"
          ],
          "line": 971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_next",
          "args": [
            "pipe",
            "&sd"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "807-831",
          "snippet": "static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_begin",
          "args": [
            "&sd"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "842-846",
          "snippet": "static void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!array"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "nbufs",
            "sizeof(struct bio_vec)",
            "GFP_KERNEL"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t\niter_file_splice_write(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t  loff_t *ppos, size_t len, unsigned int flags)\n{\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\tint nbufs = pipe->buffers;\n\tstruct bio_vec *array = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\tssize_t ret;\n\n\tif (unlikely(!array))\n\t\treturn -ENOMEM;\n\n\tpipe_lock(pipe);\n\n\tsplice_from_pipe_begin(&sd);\n\twhile (sd.total_len) {\n\t\tstruct iov_iter from;\n\t\tsize_t left;\n\t\tint n, idx;\n\n\t\tret = splice_from_pipe_next(pipe, &sd);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tif (unlikely(nbufs < pipe->buffers)) {\n\t\t\tkfree(array);\n\t\t\tnbufs = pipe->buffers;\n\t\t\tarray = kcalloc(nbufs, sizeof(struct bio_vec),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!array) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* build the vector */\n\t\tleft = sd.total_len;\n\t\tfor (n = 0, idx = pipe->curbuf; left && n < pipe->nrbufs; n++, idx++) {\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + idx;\n\t\t\tsize_t this_len = buf->len;\n\n\t\t\tif (this_len > left)\n\t\t\t\tthis_len = left;\n\n\t\t\tif (idx == pipe->buffers - 1)\n\t\t\t\tidx = -1;\n\n\t\t\tret = buf->ops->confirm(pipe, buf);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tif (ret == -ENODATA)\n\t\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tarray[n].bv_page = buf->page;\n\t\t\tarray[n].bv_len = this_len;\n\t\t\tarray[n].bv_offset = buf->offset;\n\t\t\tleft -= this_len;\n\t\t}\n\n\t\tiov_iter_bvec(&from, ITER_BVEC | WRITE, array, n,\n\t\t\t      sd.total_len - left);\n\t\tret = vfs_iter_write(out, &from, &sd.pos);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\n\t\tsd.num_spliced += ret;\n\t\tsd.total_len -= ret;\n\t\t*ppos = sd.pos;\n\n\t\t/* dismiss the fully eaten buffers, adjust the partial one */\n\t\twhile (ret) {\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\t\t\tif (ret >= buf->len) {\n\t\t\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\t\t\t\tret -= buf->len;\n\t\t\t\tbuf->len = 0;\n\t\t\t\tbuf->ops = NULL;\n\t\t\t\tops->release(pipe, buf);\n\t\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\t\tpipe->nrbufs--;\n\t\t\t\tif (pipe->files)\n\t\t\t\t\tsd.need_wakeup = true;\n\t\t\t} else {\n\t\t\t\tbuf->offset += ret;\n\t\t\t\tbuf->len -= ret;\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tkfree(array);\n\tsplice_from_pipe_end(pipe, &sd);\n\n\tpipe_unlock(pipe);\n\n\tif (sd.num_spliced)\n\t\tret = sd.num_spliced;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "splice_from_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "908-925",
    "snippet": "ssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__splice_from_pipe",
          "args": [
            "pipe",
            "&sd",
            "actor"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "__splice_from_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "877-891",
          "snippet": "ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_from_pipe(struct pipe_inode_info *pipe, struct file *out,\n\t\t\t loff_t *ppos, size_t len, unsigned int flags,\n\t\t\t splice_actor *actor)\n{\n\tssize_t ret;\n\tstruct splice_desc sd = {\n\t\t.total_len = len,\n\t\t.flags = flags,\n\t\t.pos = *ppos,\n\t\t.u.file = out,\n\t};\n\n\tpipe_lock(pipe);\n\tret = __splice_from_pipe(pipe, &sd, actor);\n\tpipe_unlock(pipe);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__splice_from_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "877-891",
    "snippet": "ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_from_pipe_end",
          "args": [
            "pipe",
            "sd"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "858-862",
          "snippet": "static void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_feed",
          "args": [
            "pipe",
            "sd",
            "actor"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_feed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "749-795",
          "snippet": "static int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tint ret;\n\n\twhile (pipe->nrbufs) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = buf->ops->confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tbuf->ops = NULL;\n\t\t\tops->release(pipe, buf);\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tint ret;\n\n\twhile (pipe->nrbufs) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = buf->ops->confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tbuf->ops = NULL;\n\t\t\tops->release(pipe, buf);\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_next",
          "args": [
            "pipe",
            "sd"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "807-831",
          "snippet": "static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_from_pipe_begin",
          "args": [
            "sd"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "splice_from_pipe_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "842-846",
          "snippet": "static void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t   splice_actor *actor)\n{\n\tint ret;\n\n\tsplice_from_pipe_begin(sd);\n\tdo {\n\t\tret = splice_from_pipe_next(pipe, sd);\n\t\tif (ret > 0)\n\t\t\tret = splice_from_pipe_feed(pipe, sd, actor);\n\t} while (ret > 0);\n\tsplice_from_pipe_end(pipe, sd);\n\n\treturn sd->num_spliced ? sd->num_spliced : ret;\n}"
  },
  {
    "function_name": "splice_from_pipe_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "858-862",
    "snippet": "static void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_pipe_writers",
          "args": [
            "pipe"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "721-727",
          "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void splice_from_pipe_end(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\tif (sd->need_wakeup)\n\t\twakeup_pipe_writers(pipe);\n}"
  },
  {
    "function_name": "splice_from_pipe_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "842-846",
    "snippet": "static void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void splice_from_pipe_begin(struct splice_desc *sd)\n{\n\tsd->num_spliced = 0;\n\tsd->need_wakeup = false;\n}"
  },
  {
    "function_name": "splice_from_pipe_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "807-831",
    "snippet": "static int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "104-117",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wakeup_pipe_writers",
          "args": [
            "pipe"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_writers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "721-727",
          "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)\n{\n\twhile (!pipe->nrbufs) {\n\t\tif (!pipe->writers)\n\t\t\treturn 0;\n\n\t\tif (!pipe->waiting_writers && sd->num_spliced)\n\t\t\treturn 0;\n\n\t\tif (sd->flags & SPLICE_F_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (signal_pending(current))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tif (sd->need_wakeup) {\n\t\t\twakeup_pipe_writers(pipe);\n\t\t\tsd->need_wakeup = false;\n\t\t}\n\n\t\tpipe_wait(pipe);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "splice_from_pipe_feed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "749-795",
    "snippet": "static int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tint ret;\n\n\twhile (pipe->nrbufs) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = buf->ops->confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tbuf->ops = NULL;\n\t\t\tops->release(pipe, buf);\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ops->release",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "actor",
          "args": [
            "pipe",
            "buf",
            "sd"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "splice_direct_to_actor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "1155-1261",
          "snippet": "ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops) {\n\t\t\tbuf->ops->release(pipe, buf);\n\t\t\tbuf->ops = NULL;\n\t\t}\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,\n\t\t\t       splice_direct_actor *actor)\n{\n\tstruct pipe_inode_info *pipe;\n\tlong ret, bytes;\n\tumode_t i_mode;\n\tsize_t len;\n\tint i, flags;\n\n\t/*\n\t * We require the input being a regular file, as we don't want to\n\t * randomly drop data for eg socket -> socket splicing. Use the\n\t * piped splicing for that!\n\t */\n\ti_mode = file_inode(in)->i_mode;\n\tif (unlikely(!S_ISREG(i_mode) && !S_ISBLK(i_mode)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * neither in nor out is a pipe, setup an internal pipe attached to\n\t * 'out' and transfer the wanted data from 'in' to 'out' through that\n\t */\n\tpipe = current->splice_pipe;\n\tif (unlikely(!pipe)) {\n\t\tpipe = alloc_pipe_info();\n\t\tif (!pipe)\n\t\t\treturn -ENOMEM;\n\n\t\t/*\n\t\t * We don't have an immediate reader, but we'll read the stuff\n\t\t * out of the pipe right after the splice_to_pipe(). So set\n\t\t * PIPE_READERS appropriately.\n\t\t */\n\t\tpipe->readers = 1;\n\n\t\tcurrent->splice_pipe = pipe;\n\t}\n\n\t/*\n\t * Do the splice.\n\t */\n\tret = 0;\n\tbytes = 0;\n\tlen = sd->total_len;\n\tflags = sd->flags;\n\n\t/*\n\t * Don't block on output, we have to drain the direct pipe.\n\t */\n\tsd->flags &= ~SPLICE_F_NONBLOCK;\n\n\twhile (len) {\n\t\tsize_t read_len;\n\t\tloff_t pos = sd->pos, prev_pos = pos;\n\n\t\tret = do_splice_to(in, &pos, pipe, len, flags);\n\t\tif (unlikely(ret <= 0))\n\t\t\tgoto out_release;\n\n\t\tread_len = ret;\n\t\tsd->total_len = read_len;\n\n\t\t/*\n\t\t * NOTE: nonblocking mode only applies to the input. We\n\t\t * must not do the output in nonblocking mode as then we\n\t\t * could get stuck data in the internal pipe:\n\t\t */\n\t\tret = actor(pipe, sd);\n\t\tif (unlikely(ret <= 0)) {\n\t\t\tsd->pos = prev_pos;\n\t\t\tgoto out_release;\n\t\t}\n\n\t\tbytes += ret;\n\t\tlen -= ret;\n\t\tsd->pos = pos;\n\n\t\tif (ret < read_len) {\n\t\t\tsd->pos = prev_pos + ret;\n\t\t\tgoto out_release;\n\t\t}\n\t}\n\ndone:\n\tpipe->nrbufs = pipe->curbuf = 0;\n\tfile_accessed(in);\n\treturn bytes;\n\nout_release:\n\t/*\n\t * If we did an incomplete transfer we must release\n\t * the pipe buffers in question:\n\t */\n\tfor (i = 0; i < pipe->buffers; i++) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + i;\n\n\t\tif (buf->ops) {\n\t\t\tbuf->ops->release(pipe, buf);\n\t\t\tbuf->ops = NULL;\n\t\t}\n\t}\n\n\tif (!bytes)\n\t\tbytes = ret;\n\n\tgoto done;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf->ops->confirm",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_from_pipe_feed(struct pipe_inode_info *pipe, struct splice_desc *sd,\n\t\t\t  splice_actor *actor)\n{\n\tint ret;\n\n\twhile (pipe->nrbufs) {\n\t\tstruct pipe_buffer *buf = pipe->bufs + pipe->curbuf;\n\t\tconst struct pipe_buf_operations *ops = buf->ops;\n\n\t\tsd->len = buf->len;\n\t\tif (sd->len > sd->total_len)\n\t\t\tsd->len = sd->total_len;\n\n\t\tret = buf->ops->confirm(pipe, buf);\n\t\tif (unlikely(ret)) {\n\t\t\tif (ret == -ENODATA)\n\t\t\t\tret = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = actor(pipe, buf, sd);\n\t\tif (ret <= 0)\n\t\t\treturn ret;\n\n\t\tbuf->offset += ret;\n\t\tbuf->len -= ret;\n\n\t\tsd->num_spliced += ret;\n\t\tsd->len -= ret;\n\t\tsd->pos += ret;\n\t\tsd->total_len -= ret;\n\n\t\tif (!buf->len) {\n\t\t\tbuf->ops = NULL;\n\t\t\tops->release(pipe, buf);\n\t\t\tpipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1);\n\t\t\tpipe->nrbufs--;\n\t\t\tif (pipe->files)\n\t\t\t\tsd->need_wakeup = true;\n\t\t}\n\n\t\tif (!sd->total_len)\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "wakeup_pipe_writers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "721-727",
    "snippet": "static void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_writers",
            "SIGIO",
            "POLL_OUT"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pipe->wait"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_writers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_writers, SIGIO, POLL_OUT);\n}"
  },
  {
    "function_name": "pipe_to_sendpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "702-719",
    "snippet": "static int pipe_to_sendpage(struct pipe_inode_info *pipe,\n\t\t\t    struct pipe_buffer *buf, struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tloff_t pos = sd->pos;\n\tint more;\n\n\tif (!likely(file->f_op->sendpage))\n\t\treturn -EINVAL;\n\n\tmore = (sd->flags & SPLICE_F_MORE) ? MSG_MORE : 0;\n\n\tif (sd->len < sd->total_len && pipe->nrbufs > 1)\n\t\tmore |= MSG_SENDPAGE_NOTLAST;\n\n\treturn file->f_op->sendpage(file, buf->page, buf->offset,\n\t\t\t\t    sd->len, &pos, more);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file->f_op->sendpage",
          "args": [
            "file",
            "buf->page",
            "buf->offset",
            "sd->len",
            "&pos",
            "more"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "file->f_op->sendpage"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int pipe_to_sendpage(struct pipe_inode_info *pipe,\n\t\t\t    struct pipe_buffer *buf, struct splice_desc *sd)\n{\n\tstruct file *file = sd->u.file;\n\tloff_t pos = sd->pos;\n\tint more;\n\n\tif (!likely(file->f_op->sendpage))\n\t\treturn -EINVAL;\n\n\tmore = (sd->flags & SPLICE_F_MORE) ? MSG_MORE : 0;\n\n\tif (sd->len < sd->total_len && pipe->nrbufs > 1)\n\t\tmore |= MSG_SENDPAGE_NOTLAST;\n\n\treturn file->f_op->sendpage(file, buf->page, buf->offset,\n\t\t\t\t    sd->len, &pos, more);\n}"
  },
  {
    "function_name": "default_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "601-695",
    "snippet": "ssize_t default_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tunsigned int nr_pages;\n\tunsigned int nr_freed;\n\tsize_t offset;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct iovec *vec, __vec[PIPE_DEF_BUFFERS];\n\tssize_t res;\n\tsize_t this_len;\n\tint error;\n\tint i;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &default_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tres = -ENOMEM;\n\tvec = __vec;\n\tif (spd.nr_pages_max > PIPE_DEF_BUFFERS) {\n\t\tvec = kmalloc(spd.nr_pages_max * sizeof(struct iovec), GFP_KERNEL);\n\t\tif (!vec)\n\t\t\tgoto shrink_ret;\n\t}\n\n\toffset = *ppos & ~PAGE_CACHE_MASK;\n\tnr_pages = (len + offset + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tfor (i = 0; i < nr_pages && i < spd.nr_pages_max && len; i++) {\n\t\tstruct page *page;\n\n\t\tpage = alloc_page(GFP_USER);\n\t\terror = -ENOMEM;\n\t\tif (!page)\n\t\t\tgoto err;\n\n\t\tthis_len = min_t(size_t, len, PAGE_CACHE_SIZE - offset);\n\t\tvec[i].iov_base = (void __user *) page_address(page);\n\t\tvec[i].iov_len = this_len;\n\t\tspd.pages[i] = page;\n\t\tspd.nr_pages++;\n\t\tlen -= this_len;\n\t\toffset = 0;\n\t}\n\n\tres = kernel_readv(in, vec, spd.nr_pages, *ppos);\n\tif (res < 0) {\n\t\terror = res;\n\t\tgoto err;\n\t}\n\n\terror = 0;\n\tif (!res)\n\t\tgoto err;\n\n\tnr_freed = 0;\n\tfor (i = 0; i < spd.nr_pages; i++) {\n\t\tthis_len = min_t(size_t, vec[i].iov_len, res);\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = this_len;\n\t\tif (!this_len) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tspd.pages[i] = NULL;\n\t\t\tnr_freed++;\n\t\t}\n\t\tres -= this_len;\n\t}\n\tspd.nr_pages -= nr_freed;\n\n\tres = splice_to_pipe(pipe, &spd);\n\tif (res > 0)\n\t\t*ppos += res;\n\nshrink_ret:\n\tif (vec != __vec)\n\t\tkfree(vec);\n\tsplice_shrink_spd(&spd);\n\treturn res;\n\nerr:\n\tfor (i = 0; i < spd.nr_pages; i++)\n\t\t__free_page(spd.pages[i]);\n\n\tres = error;\n\tgoto shrink_ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct pipe_buf_operations default_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = generic_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "spd.pages[i]"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_shrink_spd",
          "args": [
            "&spd"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "splice_shrink_spd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "294-301",
          "snippet": "void splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nvoid splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vec"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_to_pipe",
          "args": [
            "pipe",
            "&spd"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "splice_to_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "183-264",
          "snippet": "ssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret, do_wakeup, page_nr;\n\n\tret = 0;\n\tdo_wakeup = 0;\n\tpage_nr = 0;\n\n\tpipe_lock(pipe);\n\n\tfor (;;) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe->nrbufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\t\tbuf->page = spd->pages[page_nr];\n\t\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\t\tbuf->len = spd->partial[page_nr].len;\n\t\t\tbuf->private = spd->partial[page_nr].private;\n\t\t\tbuf->ops = spd->ops;\n\t\t\tif (spd->flags & SPLICE_F_GIFT)\n\t\t\t\tbuf->flags |= PIPE_BUF_FLAG_GIFT;\n\n\t\t\tpipe->nrbufs++;\n\t\t\tpage_nr++;\n\t\t\tret += buf->len;\n\n\t\t\tif (pipe->files)\n\t\t\t\tdo_wakeup = 1;\n\n\t\t\tif (!--spd->nr_pages)\n\t\t\t\tbreak;\n\t\t\tif (pipe->nrbufs < pipe->buffers)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spd->flags & SPLICE_F_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_wakeup) {\n\t\t\tsmp_mb();\n\t\t\tif (waitqueue_active(&pipe->wait))\n\t\t\t\twake_up_interruptible_sync(&pipe->wait);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup)\n\t\twakeup_pipe_readers(pipe);\n\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret, do_wakeup, page_nr;\n\n\tret = 0;\n\tdo_wakeup = 0;\n\tpage_nr = 0;\n\n\tpipe_lock(pipe);\n\n\tfor (;;) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe->nrbufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\t\tbuf->page = spd->pages[page_nr];\n\t\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\t\tbuf->len = spd->partial[page_nr].len;\n\t\t\tbuf->private = spd->partial[page_nr].private;\n\t\t\tbuf->ops = spd->ops;\n\t\t\tif (spd->flags & SPLICE_F_GIFT)\n\t\t\t\tbuf->flags |= PIPE_BUF_FLAG_GIFT;\n\n\t\t\tpipe->nrbufs++;\n\t\t\tpage_nr++;\n\t\t\tret += buf->len;\n\n\t\t\tif (pipe->files)\n\t\t\t\tdo_wakeup = 1;\n\n\t\t\tif (!--spd->nr_pages)\n\t\t\t\tbreak;\n\t\t\tif (pipe->nrbufs < pipe->buffers)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spd->flags & SPLICE_F_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_wakeup) {\n\t\t\tsmp_mb();\n\t\t\tif (waitqueue_active(&pipe->wait))\n\t\t\t\twake_up_interruptible_sync(&pipe->wait);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup)\n\t\twakeup_pipe_readers(pipe);\n\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "spd.pages[i]"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "vec[i].iov_len",
            "res"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_readv",
          "args": [
            "in",
            "vec",
            "spd.nr_pages",
            "*ppos"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "569-583",
          "snippet": "static ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "len",
            "PAGE_CACHE_SIZE - offset"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_USER"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_alloc_pagevec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "86-105",
          "snippet": "static void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void **dlm_alloc_pagevec(int pages)\n{\n\tvoid **vec = kmalloc(pages * sizeof(void *), GFP_KERNEL);\n\tint i;\n\n\tif (!vec)\n\t\treturn NULL;\n\n\tfor (i = 0; i < pages; i++)\n\t\tif (!(vec[i] = (void *)__get_free_page(GFP_KERNEL)))\n\t\t\tgoto out_free;\n\n\tmlog(0, \"Allocated DLM hash pagevec; %d pages (%lu expected), %lu buckets per page\\n\",\n\t     pages, (unsigned long)DLM_HASH_PAGES,\n\t     (unsigned long)DLM_BUCKETS_PER_PAGE);\n\treturn vec;\nout_free:\n\tdlm_free_pagevec(vec, i);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "spd.nr_pages_max * sizeof(struct iovec)",
            "GFP_KERNEL"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_grow_spd",
          "args": [
            "pipe",
            "&spd"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "splice_grow_spd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "275-292",
          "snippet": "int splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = ACCESS_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nint splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = ACCESS_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic const struct pipe_buf_operations default_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = generic_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t default_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tunsigned int nr_pages;\n\tunsigned int nr_freed;\n\tsize_t offset;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct iovec *vec, __vec[PIPE_DEF_BUFFERS];\n\tssize_t res;\n\tsize_t this_len;\n\tint error;\n\tint i;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &default_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tres = -ENOMEM;\n\tvec = __vec;\n\tif (spd.nr_pages_max > PIPE_DEF_BUFFERS) {\n\t\tvec = kmalloc(spd.nr_pages_max * sizeof(struct iovec), GFP_KERNEL);\n\t\tif (!vec)\n\t\t\tgoto shrink_ret;\n\t}\n\n\toffset = *ppos & ~PAGE_CACHE_MASK;\n\tnr_pages = (len + offset + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\n\tfor (i = 0; i < nr_pages && i < spd.nr_pages_max && len; i++) {\n\t\tstruct page *page;\n\n\t\tpage = alloc_page(GFP_USER);\n\t\terror = -ENOMEM;\n\t\tif (!page)\n\t\t\tgoto err;\n\n\t\tthis_len = min_t(size_t, len, PAGE_CACHE_SIZE - offset);\n\t\tvec[i].iov_base = (void __user *) page_address(page);\n\t\tvec[i].iov_len = this_len;\n\t\tspd.pages[i] = page;\n\t\tspd.nr_pages++;\n\t\tlen -= this_len;\n\t\toffset = 0;\n\t}\n\n\tres = kernel_readv(in, vec, spd.nr_pages, *ppos);\n\tif (res < 0) {\n\t\terror = res;\n\t\tgoto err;\n\t}\n\n\terror = 0;\n\tif (!res)\n\t\tgoto err;\n\n\tnr_freed = 0;\n\tfor (i = 0; i < spd.nr_pages; i++) {\n\t\tthis_len = min_t(size_t, vec[i].iov_len, res);\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = this_len;\n\t\tif (!this_len) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tspd.pages[i] = NULL;\n\t\t\tnr_freed++;\n\t\t}\n\t\tres -= this_len;\n\t}\n\tspd.nr_pages -= nr_freed;\n\n\tres = splice_to_pipe(pipe, &spd);\n\tif (res > 0)\n\t\t*ppos += res;\n\nshrink_ret:\n\tif (vec != __vec)\n\t\tkfree(vec);\n\tsplice_shrink_spd(&spd);\n\treturn res;\n\nerr:\n\tfor (i = 0; i < spd.nr_pages; i++)\n\t\t__free_page(spd.pages[i]);\n\n\tres = error;\n\tgoto shrink_ret;\n}"
  },
  {
    "function_name": "kernel_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "585-598",
    "snippet": "ssize_t kernel_write(struct file *file, const char *buf, size_t count,\n\t\t\t    loff_t pos)\n{\n\tmm_segment_t old_fs;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_write(file, (__force const char __user *)buf, count, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_write",
          "args": [
            "file",
            "(__force const char __user *)buf",
            "count",
            "&pos"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "930-939",
          "snippet": "ssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(WRITE, file, vec, vlen, pos);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_writev(struct file *file, const struct iovec __user *vec,\n\t\t   unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_WRITE))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(WRITE, file, vec, vlen, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "get_ds()"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nssize_t kernel_write(struct file *file, const char *buf, size_t count,\n\t\t\t    loff_t pos)\n{\n\tmm_segment_t old_fs;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_write(file, (__force const char __user *)buf, count, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
  },
  {
    "function_name": "kernel_readv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "569-583",
    "snippet": "static ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "old_fs"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_readv",
          "args": [
            "file",
            "(const struct iovec __user *)vec",
            "vlen",
            "&pos"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_readv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/read_write.c",
          "lines": "917-926",
          "snippet": "ssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(READ, file, vec, vlen, pos);\n}",
          "includes": [
            "#include <asm/unistd.h>",
            "#include <asm/uaccess.h>",
            "#include \"internal.h\"",
            "#include <linux/compat.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/security.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/aio.h>",
            "#include <linux/uio.h>",
            "#include <linux/file.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unistd.h>\n#include <asm/uaccess.h>\n#include \"internal.h\"\n#include <linux/compat.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/security.h>\n#include <linux/fsnotify.h>\n#include <linux/aio.h>\n#include <linux/uio.h>\n#include <linux/file.h>\n#include <linux/fcntl.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n\nssize_t vfs_readv(struct file *file, const struct iovec __user *vec,\n\t\t  unsigned long vlen, loff_t *pos)\n{\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\tif (!(file->f_mode & FMODE_CAN_READ))\n\t\treturn -EINVAL;\n\n\treturn do_readv_writev(READ, file, vec, vlen, pos);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_fs",
          "args": [
            "get_ds()"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ds",
          "args": [],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic ssize_t kernel_readv(struct file *file, const struct iovec *vec,\n\t\t\t    unsigned long vlen, loff_t offset)\n{\n\tmm_segment_t old_fs;\n\tloff_t pos = offset;\n\tssize_t res;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\t/* The cast to a user pointer is valid due to the set_fs() */\n\tres = vfs_readv(file, (const struct iovec __user *)vec, vlen, &pos);\n\tset_fs(old_fs);\n\n\treturn res;\n}"
  },
  {
    "function_name": "generic_pipe_buf_nosteal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "553-557",
    "snippet": "static int generic_pipe_buf_nosteal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int generic_pipe_buf_nosteal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "generic_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "520-542",
    "snippet": "ssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tloff_t isize, left;\n\tint ret;\n\n\tisize = i_size_read(in->f_mapping->host);\n\tif (unlikely(*ppos >= isize))\n\t\treturn 0;\n\n\tleft = isize - *ppos;\n\tif (unlikely(left < len))\n\t\tlen = left;\n\n\tret = __generic_file_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\t\tfile_accessed(in);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "file_accessed",
          "args": [
            "in"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__generic_file_splice_read",
          "args": [
            "in",
            "ppos",
            "pipe",
            "len",
            "flags"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "__generic_file_splice_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "303-504",
          "snippet": "static int\n__generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t   struct pipe_inode_info *pipe, size_t len,\n\t\t\t   unsigned int flags)\n{\n\tstruct address_space *mapping = in->f_mapping;\n\tunsigned int loff, nr_pages, req_pages;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct page *page;\n\tpgoff_t index, end_index;\n\tloff_t isize;\n\tint error, page_nr;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &page_cache_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tindex = *ppos >> PAGE_CACHE_SHIFT;\n\tloff = *ppos & ~PAGE_CACHE_MASK;\n\treq_pages = (len + loff + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tnr_pages = min(req_pages, spd.nr_pages_max);\n\n\t/*\n\t * Lookup the (hopefully) full range of pages we need.\n\t */\n\tspd.nr_pages = find_get_pages_contig(mapping, index, nr_pages, spd.pages);\n\tindex += spd.nr_pages;\n\n\t/*\n\t * If find_get_pages_contig() returned fewer pages than we needed,\n\t * readahead/allocate the rest and fill in the holes.\n\t */\n\tif (spd.nr_pages < nr_pages)\n\t\tpage_cache_sync_readahead(mapping, &in->f_ra, in,\n\t\t\t\tindex, req_pages - spd.nr_pages);\n\n\terror = 0;\n\twhile (spd.nr_pages < nr_pages) {\n\t\t/*\n\t\t * Page could be there, find_get_pages_contig() breaks on\n\t\t * the first hole.\n\t\t */\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * page didn't exist, allocate one.\n\t\t\t */\n\t\t\tpage = page_cache_alloc_cold(mapping);\n\t\t\tif (!page)\n\t\t\t\tbreak;\n\n\t\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(error)) {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tif (error == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * add_to_page_cache() locks the page, unlock it\n\t\t\t * to avoid convoluting the logic below even more.\n\t\t\t */\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tspd.pages[spd.nr_pages++] = page;\n\t\tindex++;\n\t}\n\n\t/*\n\t * Now loop over the map and see if we need to start IO on any\n\t * pages, fill in the partial map, etc.\n\t */\n\tindex = *ppos >> PAGE_CACHE_SHIFT;\n\tnr_pages = spd.nr_pages;\n\tspd.nr_pages = 0;\n\tfor (page_nr = 0; page_nr < nr_pages; page_nr++) {\n\t\tunsigned int this_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this_len is the max we'll use from this page\n\t\t */\n\t\tthis_len = min_t(unsigned long, len, PAGE_CACHE_SIZE - loff);\n\t\tpage = spd.pages[page_nr];\n\n\t\tif (PageReadahead(page))\n\t\t\tpage_cache_async_readahead(mapping, &in->f_ra, in,\n\t\t\t\t\tpage, index, req_pages - page_nr);\n\n\t\t/*\n\t\t * If the page isn't uptodate, we may need to start io on it\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\tlock_page(page);\n\n\t\t\t/*\n\t\t\t * Page was truncated, or invalidated by the\n\t\t\t * filesystem.  Redo the find/create, but this time the\n\t\t\t * page is kept locked, so there's no chance of another\n\t\t\t * race with truncate/invalidate.\n\t\t\t */\n\t\t\tif (!page->mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage = find_or_create_page(mapping, index,\n\t\t\t\t\t\tmapping_gfp_mask(mapping));\n\n\t\t\t\tif (!page) {\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpage_cache_release(spd.pages[page_nr]);\n\t\t\t\tspd.pages[page_nr] = page;\n\t\t\t}\n\t\t\t/*\n\t\t\t * page was already under io and is now done, great\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto fill_it;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * need to read in the page\n\t\t\t */\n\t\t\terror = mapping->a_ops->readpage(in, page);\n\t\t\tif (unlikely(error)) {\n\t\t\t\t/*\n\t\t\t\t * We really should re-lookup the page here,\n\t\t\t\t * but it complicates things a lot. Instead\n\t\t\t\t * lets just do what we already stored, and\n\t\t\t\t * we'll get it the next time we are called.\n\t\t\t\t */\n\t\t\t\tif (error == AOP_TRUNCATED_PAGE)\n\t\t\t\t\terror = 0;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nfill_it:\n\t\t/*\n\t\t * i_size must be checked after PageUptodate.\n\t\t */\n\t\tisize = i_size_read(mapping->host);\n\t\tend_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (unlikely(!isize || index > end_index))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if this is the last page, see if we need to shrink\n\t\t * the length and stop\n\t\t */\n\t\tif (end_index == index) {\n\t\t\tunsigned int plen;\n\n\t\t\t/*\n\t\t\t * max good bytes in this page\n\t\t\t */\n\t\t\tplen = ((isize - 1) & ~PAGE_CACHE_MASK) + 1;\n\t\t\tif (plen <= loff)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * force quit after adding this page\n\t\t\t */\n\t\t\tthis_len = min(this_len, plen - loff);\n\t\t\tlen = this_len;\n\t\t}\n\n\t\tspd.partial[page_nr].offset = loff;\n\t\tspd.partial[page_nr].len = this_len;\n\t\tlen -= this_len;\n\t\tloff = 0;\n\t\tspd.nr_pages++;\n\t\tindex++;\n\t}\n\n\t/*\n\t * Release any pages at the end, if we quit early. 'page_nr' is how far\n\t * we got, 'nr_pages' is how many pages are in the map.\n\t */\n\twhile (page_nr < nr_pages)\n\t\tpage_cache_release(spd.pages[page_nr++]);\n\tin->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\n\n\tif (spd.nr_pages)\n\t\terror = splice_to_pipe(pipe, &spd);\n\n\tsplice_shrink_spd(&spd);\n\treturn error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct pipe_buf_operations page_cache_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = page_cache_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = page_cache_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nconst struct pipe_buf_operations page_cache_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = page_cache_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = page_cache_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int\n__generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t   struct pipe_inode_info *pipe, size_t len,\n\t\t\t   unsigned int flags)\n{\n\tstruct address_space *mapping = in->f_mapping;\n\tunsigned int loff, nr_pages, req_pages;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct page *page;\n\tpgoff_t index, end_index;\n\tloff_t isize;\n\tint error, page_nr;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &page_cache_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tindex = *ppos >> PAGE_CACHE_SHIFT;\n\tloff = *ppos & ~PAGE_CACHE_MASK;\n\treq_pages = (len + loff + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tnr_pages = min(req_pages, spd.nr_pages_max);\n\n\t/*\n\t * Lookup the (hopefully) full range of pages we need.\n\t */\n\tspd.nr_pages = find_get_pages_contig(mapping, index, nr_pages, spd.pages);\n\tindex += spd.nr_pages;\n\n\t/*\n\t * If find_get_pages_contig() returned fewer pages than we needed,\n\t * readahead/allocate the rest and fill in the holes.\n\t */\n\tif (spd.nr_pages < nr_pages)\n\t\tpage_cache_sync_readahead(mapping, &in->f_ra, in,\n\t\t\t\tindex, req_pages - spd.nr_pages);\n\n\terror = 0;\n\twhile (spd.nr_pages < nr_pages) {\n\t\t/*\n\t\t * Page could be there, find_get_pages_contig() breaks on\n\t\t * the first hole.\n\t\t */\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * page didn't exist, allocate one.\n\t\t\t */\n\t\t\tpage = page_cache_alloc_cold(mapping);\n\t\t\tif (!page)\n\t\t\t\tbreak;\n\n\t\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(error)) {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tif (error == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * add_to_page_cache() locks the page, unlock it\n\t\t\t * to avoid convoluting the logic below even more.\n\t\t\t */\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tspd.pages[spd.nr_pages++] = page;\n\t\tindex++;\n\t}\n\n\t/*\n\t * Now loop over the map and see if we need to start IO on any\n\t * pages, fill in the partial map, etc.\n\t */\n\tindex = *ppos >> PAGE_CACHE_SHIFT;\n\tnr_pages = spd.nr_pages;\n\tspd.nr_pages = 0;\n\tfor (page_nr = 0; page_nr < nr_pages; page_nr++) {\n\t\tunsigned int this_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this_len is the max we'll use from this page\n\t\t */\n\t\tthis_len = min_t(unsigned long, len, PAGE_CACHE_SIZE - loff);\n\t\tpage = spd.pages[page_nr];\n\n\t\tif (PageReadahead(page))\n\t\t\tpage_cache_async_readahead(mapping, &in->f_ra, in,\n\t\t\t\t\tpage, index, req_pages - page_nr);\n\n\t\t/*\n\t\t * If the page isn't uptodate, we may need to start io on it\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\tlock_page(page);\n\n\t\t\t/*\n\t\t\t * Page was truncated, or invalidated by the\n\t\t\t * filesystem.  Redo the find/create, but this time the\n\t\t\t * page is kept locked, so there's no chance of another\n\t\t\t * race with truncate/invalidate.\n\t\t\t */\n\t\t\tif (!page->mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage = find_or_create_page(mapping, index,\n\t\t\t\t\t\tmapping_gfp_mask(mapping));\n\n\t\t\t\tif (!page) {\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpage_cache_release(spd.pages[page_nr]);\n\t\t\t\tspd.pages[page_nr] = page;\n\t\t\t}\n\t\t\t/*\n\t\t\t * page was already under io and is now done, great\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto fill_it;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * need to read in the page\n\t\t\t */\n\t\t\terror = mapping->a_ops->readpage(in, page);\n\t\t\tif (unlikely(error)) {\n\t\t\t\t/*\n\t\t\t\t * We really should re-lookup the page here,\n\t\t\t\t * but it complicates things a lot. Instead\n\t\t\t\t * lets just do what we already stored, and\n\t\t\t\t * we'll get it the next time we are called.\n\t\t\t\t */\n\t\t\t\tif (error == AOP_TRUNCATED_PAGE)\n\t\t\t\t\terror = 0;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nfill_it:\n\t\t/*\n\t\t * i_size must be checked after PageUptodate.\n\t\t */\n\t\tisize = i_size_read(mapping->host);\n\t\tend_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (unlikely(!isize || index > end_index))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if this is the last page, see if we need to shrink\n\t\t * the length and stop\n\t\t */\n\t\tif (end_index == index) {\n\t\t\tunsigned int plen;\n\n\t\t\t/*\n\t\t\t * max good bytes in this page\n\t\t\t */\n\t\t\tplen = ((isize - 1) & ~PAGE_CACHE_MASK) + 1;\n\t\t\tif (plen <= loff)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * force quit after adding this page\n\t\t\t */\n\t\t\tthis_len = min(this_len, plen - loff);\n\t\t\tlen = this_len;\n\t\t}\n\n\t\tspd.partial[page_nr].offset = loff;\n\t\tspd.partial[page_nr].len = this_len;\n\t\tlen -= this_len;\n\t\tloff = 0;\n\t\tspd.nr_pages++;\n\t\tindex++;\n\t}\n\n\t/*\n\t * Release any pages at the end, if we quit early. 'page_nr' is how far\n\t * we got, 'nr_pages' is how many pages are in the map.\n\t */\n\twhile (page_nr < nr_pages)\n\t\tpage_cache_release(spd.pages[page_nr++]);\n\tin->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\n\n\tif (spd.nr_pages)\n\t\terror = splice_to_pipe(pipe, &spd);\n\n\tsplice_shrink_spd(&spd);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "left < len"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "*ppos >= isize"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "in->f_mapping->host"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t\t struct pipe_inode_info *pipe, size_t len,\n\t\t\t\t unsigned int flags)\n{\n\tloff_t isize, left;\n\tint ret;\n\n\tisize = i_size_read(in->f_mapping->host);\n\tif (unlikely(*ppos >= isize))\n\t\treturn 0;\n\n\tleft = isize - *ppos;\n\tif (unlikely(left < len))\n\t\tlen = left;\n\n\tret = __generic_file_splice_read(in, ppos, pipe, len, flags);\n\tif (ret > 0) {\n\t\t*ppos += ret;\n\t\tfile_accessed(in);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__generic_file_splice_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "303-504",
    "snippet": "static int\n__generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t   struct pipe_inode_info *pipe, size_t len,\n\t\t\t   unsigned int flags)\n{\n\tstruct address_space *mapping = in->f_mapping;\n\tunsigned int loff, nr_pages, req_pages;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct page *page;\n\tpgoff_t index, end_index;\n\tloff_t isize;\n\tint error, page_nr;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &page_cache_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tindex = *ppos >> PAGE_CACHE_SHIFT;\n\tloff = *ppos & ~PAGE_CACHE_MASK;\n\treq_pages = (len + loff + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tnr_pages = min(req_pages, spd.nr_pages_max);\n\n\t/*\n\t * Lookup the (hopefully) full range of pages we need.\n\t */\n\tspd.nr_pages = find_get_pages_contig(mapping, index, nr_pages, spd.pages);\n\tindex += spd.nr_pages;\n\n\t/*\n\t * If find_get_pages_contig() returned fewer pages than we needed,\n\t * readahead/allocate the rest and fill in the holes.\n\t */\n\tif (spd.nr_pages < nr_pages)\n\t\tpage_cache_sync_readahead(mapping, &in->f_ra, in,\n\t\t\t\tindex, req_pages - spd.nr_pages);\n\n\terror = 0;\n\twhile (spd.nr_pages < nr_pages) {\n\t\t/*\n\t\t * Page could be there, find_get_pages_contig() breaks on\n\t\t * the first hole.\n\t\t */\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * page didn't exist, allocate one.\n\t\t\t */\n\t\t\tpage = page_cache_alloc_cold(mapping);\n\t\t\tif (!page)\n\t\t\t\tbreak;\n\n\t\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(error)) {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tif (error == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * add_to_page_cache() locks the page, unlock it\n\t\t\t * to avoid convoluting the logic below even more.\n\t\t\t */\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tspd.pages[spd.nr_pages++] = page;\n\t\tindex++;\n\t}\n\n\t/*\n\t * Now loop over the map and see if we need to start IO on any\n\t * pages, fill in the partial map, etc.\n\t */\n\tindex = *ppos >> PAGE_CACHE_SHIFT;\n\tnr_pages = spd.nr_pages;\n\tspd.nr_pages = 0;\n\tfor (page_nr = 0; page_nr < nr_pages; page_nr++) {\n\t\tunsigned int this_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this_len is the max we'll use from this page\n\t\t */\n\t\tthis_len = min_t(unsigned long, len, PAGE_CACHE_SIZE - loff);\n\t\tpage = spd.pages[page_nr];\n\n\t\tif (PageReadahead(page))\n\t\t\tpage_cache_async_readahead(mapping, &in->f_ra, in,\n\t\t\t\t\tpage, index, req_pages - page_nr);\n\n\t\t/*\n\t\t * If the page isn't uptodate, we may need to start io on it\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\tlock_page(page);\n\n\t\t\t/*\n\t\t\t * Page was truncated, or invalidated by the\n\t\t\t * filesystem.  Redo the find/create, but this time the\n\t\t\t * page is kept locked, so there's no chance of another\n\t\t\t * race with truncate/invalidate.\n\t\t\t */\n\t\t\tif (!page->mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage = find_or_create_page(mapping, index,\n\t\t\t\t\t\tmapping_gfp_mask(mapping));\n\n\t\t\t\tif (!page) {\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpage_cache_release(spd.pages[page_nr]);\n\t\t\t\tspd.pages[page_nr] = page;\n\t\t\t}\n\t\t\t/*\n\t\t\t * page was already under io and is now done, great\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto fill_it;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * need to read in the page\n\t\t\t */\n\t\t\terror = mapping->a_ops->readpage(in, page);\n\t\t\tif (unlikely(error)) {\n\t\t\t\t/*\n\t\t\t\t * We really should re-lookup the page here,\n\t\t\t\t * but it complicates things a lot. Instead\n\t\t\t\t * lets just do what we already stored, and\n\t\t\t\t * we'll get it the next time we are called.\n\t\t\t\t */\n\t\t\t\tif (error == AOP_TRUNCATED_PAGE)\n\t\t\t\t\terror = 0;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nfill_it:\n\t\t/*\n\t\t * i_size must be checked after PageUptodate.\n\t\t */\n\t\tisize = i_size_read(mapping->host);\n\t\tend_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (unlikely(!isize || index > end_index))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if this is the last page, see if we need to shrink\n\t\t * the length and stop\n\t\t */\n\t\tif (end_index == index) {\n\t\t\tunsigned int plen;\n\n\t\t\t/*\n\t\t\t * max good bytes in this page\n\t\t\t */\n\t\t\tplen = ((isize - 1) & ~PAGE_CACHE_MASK) + 1;\n\t\t\tif (plen <= loff)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * force quit after adding this page\n\t\t\t */\n\t\t\tthis_len = min(this_len, plen - loff);\n\t\t\tlen = this_len;\n\t\t}\n\n\t\tspd.partial[page_nr].offset = loff;\n\t\tspd.partial[page_nr].len = this_len;\n\t\tlen -= this_len;\n\t\tloff = 0;\n\t\tspd.nr_pages++;\n\t\tindex++;\n\t}\n\n\t/*\n\t * Release any pages at the end, if we quit early. 'page_nr' is how far\n\t * we got, 'nr_pages' is how many pages are in the map.\n\t */\n\twhile (page_nr < nr_pages)\n\t\tpage_cache_release(spd.pages[page_nr++]);\n\tin->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\n\n\tif (spd.nr_pages)\n\t\terror = splice_to_pipe(pipe, &spd);\n\n\tsplice_shrink_spd(&spd);\n\treturn error;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct pipe_buf_operations page_cache_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = page_cache_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = page_cache_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};",
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "splice_shrink_spd",
          "args": [
            "&spd"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "splice_shrink_spd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "294-301",
          "snippet": "void splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nvoid splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}"
        }
      },
      {
        "call_info": {
          "callee": "splice_to_pipe",
          "args": [
            "pipe",
            "&spd"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "splice_to_pipe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "183-264",
          "snippet": "ssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret, do_wakeup, page_nr;\n\n\tret = 0;\n\tdo_wakeup = 0;\n\tpage_nr = 0;\n\n\tpipe_lock(pipe);\n\n\tfor (;;) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe->nrbufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\t\tbuf->page = spd->pages[page_nr];\n\t\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\t\tbuf->len = spd->partial[page_nr].len;\n\t\t\tbuf->private = spd->partial[page_nr].private;\n\t\t\tbuf->ops = spd->ops;\n\t\t\tif (spd->flags & SPLICE_F_GIFT)\n\t\t\t\tbuf->flags |= PIPE_BUF_FLAG_GIFT;\n\n\t\t\tpipe->nrbufs++;\n\t\t\tpage_nr++;\n\t\t\tret += buf->len;\n\n\t\t\tif (pipe->files)\n\t\t\t\tdo_wakeup = 1;\n\n\t\t\tif (!--spd->nr_pages)\n\t\t\t\tbreak;\n\t\t\tif (pipe->nrbufs < pipe->buffers)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spd->flags & SPLICE_F_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_wakeup) {\n\t\t\tsmp_mb();\n\t\t\tif (waitqueue_active(&pipe->wait))\n\t\t\t\twake_up_interruptible_sync(&pipe->wait);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup)\n\t\twakeup_pipe_readers(pipe);\n\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret, do_wakeup, page_nr;\n\n\tret = 0;\n\tdo_wakeup = 0;\n\tpage_nr = 0;\n\n\tpipe_lock(pipe);\n\n\tfor (;;) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe->nrbufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\t\tbuf->page = spd->pages[page_nr];\n\t\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\t\tbuf->len = spd->partial[page_nr].len;\n\t\t\tbuf->private = spd->partial[page_nr].private;\n\t\t\tbuf->ops = spd->ops;\n\t\t\tif (spd->flags & SPLICE_F_GIFT)\n\t\t\t\tbuf->flags |= PIPE_BUF_FLAG_GIFT;\n\n\t\t\tpipe->nrbufs++;\n\t\t\tpage_nr++;\n\t\t\tret += buf->len;\n\n\t\t\tif (pipe->files)\n\t\t\t\tdo_wakeup = 1;\n\n\t\t\tif (!--spd->nr_pages)\n\t\t\t\tbreak;\n\t\t\tif (pipe->nrbufs < pipe->buffers)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spd->flags & SPLICE_F_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_wakeup) {\n\t\t\tsmp_mb();\n\t\t\tif (waitqueue_active(&pipe->wait))\n\t\t\t\twake_up_interruptible_sync(&pipe->wait);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup)\n\t\twakeup_pipe_readers(pipe);\n\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "spd.pages[page_nr++]"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "this_len",
            "plen - loff"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!isize || index > end_index"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "mapping->host"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping->a_ops->readpage",
          "args": [
            "in",
            "page"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "spd.pages[page_nr]"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "index",
            "mapping_gfp_mask(mapping)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mapping_gfp_mask",
          "args": [
            "mapping"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_async_readahead",
          "args": [
            "mapping",
            "&in->f_ra",
            "in",
            "page",
            "index",
            "req_pages - page_nr"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReadahead",
          "args": [
            "page"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "len",
            "PAGE_CACHE_SIZE - loff"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_to_page_cache_lru",
          "args": [
            "page",
            "mapping",
            "index",
            "GFP_KERNEL"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_alloc_cold",
          "args": [
            "mapping"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_cache_sync_readahead",
          "args": [
            "mapping",
            "&in->f_ra",
            "in",
            "index",
            "req_pages - spd.nr_pages"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_pages_contig",
          "args": [
            "mapping",
            "index",
            "nr_pages",
            "spd.pages"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "splice_grow_spd",
          "args": [
            "pipe",
            "&spd"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "splice_grow_spd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "275-292",
          "snippet": "int splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = ACCESS_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nint splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = ACCESS_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nconst struct pipe_buf_operations page_cache_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = page_cache_pipe_buf_confirm,\n\t.release = page_cache_pipe_buf_release,\n\t.steal = page_cache_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int\n__generic_file_splice_read(struct file *in, loff_t *ppos,\n\t\t\t   struct pipe_inode_info *pipe, size_t len,\n\t\t\t   unsigned int flags)\n{\n\tstruct address_space *mapping = in->f_mapping;\n\tunsigned int loff, nr_pages, req_pages;\n\tstruct page *pages[PIPE_DEF_BUFFERS];\n\tstruct partial_page partial[PIPE_DEF_BUFFERS];\n\tstruct page *page;\n\tpgoff_t index, end_index;\n\tloff_t isize;\n\tint error, page_nr;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.partial = partial,\n\t\t.nr_pages_max = PIPE_DEF_BUFFERS,\n\t\t.flags = flags,\n\t\t.ops = &page_cache_pipe_buf_ops,\n\t\t.spd_release = spd_release_page,\n\t};\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -ENOMEM;\n\n\tindex = *ppos >> PAGE_CACHE_SHIFT;\n\tloff = *ppos & ~PAGE_CACHE_MASK;\n\treq_pages = (len + loff + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n\tnr_pages = min(req_pages, spd.nr_pages_max);\n\n\t/*\n\t * Lookup the (hopefully) full range of pages we need.\n\t */\n\tspd.nr_pages = find_get_pages_contig(mapping, index, nr_pages, spd.pages);\n\tindex += spd.nr_pages;\n\n\t/*\n\t * If find_get_pages_contig() returned fewer pages than we needed,\n\t * readahead/allocate the rest and fill in the holes.\n\t */\n\tif (spd.nr_pages < nr_pages)\n\t\tpage_cache_sync_readahead(mapping, &in->f_ra, in,\n\t\t\t\tindex, req_pages - spd.nr_pages);\n\n\terror = 0;\n\twhile (spd.nr_pages < nr_pages) {\n\t\t/*\n\t\t * Page could be there, find_get_pages_contig() breaks on\n\t\t * the first hole.\n\t\t */\n\t\tpage = find_get_page(mapping, index);\n\t\tif (!page) {\n\t\t\t/*\n\t\t\t * page didn't exist, allocate one.\n\t\t\t */\n\t\t\tpage = page_cache_alloc_cold(mapping);\n\t\t\tif (!page)\n\t\t\t\tbreak;\n\n\t\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (unlikely(error)) {\n\t\t\t\tpage_cache_release(page);\n\t\t\t\tif (error == -EEXIST)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*\n\t\t\t * add_to_page_cache() locks the page, unlock it\n\t\t\t * to avoid convoluting the logic below even more.\n\t\t\t */\n\t\t\tunlock_page(page);\n\t\t}\n\n\t\tspd.pages[spd.nr_pages++] = page;\n\t\tindex++;\n\t}\n\n\t/*\n\t * Now loop over the map and see if we need to start IO on any\n\t * pages, fill in the partial map, etc.\n\t */\n\tindex = *ppos >> PAGE_CACHE_SHIFT;\n\tnr_pages = spd.nr_pages;\n\tspd.nr_pages = 0;\n\tfor (page_nr = 0; page_nr < nr_pages; page_nr++) {\n\t\tunsigned int this_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * this_len is the max we'll use from this page\n\t\t */\n\t\tthis_len = min_t(unsigned long, len, PAGE_CACHE_SIZE - loff);\n\t\tpage = spd.pages[page_nr];\n\n\t\tif (PageReadahead(page))\n\t\t\tpage_cache_async_readahead(mapping, &in->f_ra, in,\n\t\t\t\t\tpage, index, req_pages - page_nr);\n\n\t\t/*\n\t\t * If the page isn't uptodate, we may need to start io on it\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\tlock_page(page);\n\n\t\t\t/*\n\t\t\t * Page was truncated, or invalidated by the\n\t\t\t * filesystem.  Redo the find/create, but this time the\n\t\t\t * page is kept locked, so there's no chance of another\n\t\t\t * race with truncate/invalidate.\n\t\t\t */\n\t\t\tif (!page->mapping) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tpage = find_or_create_page(mapping, index,\n\t\t\t\t\t\tmapping_gfp_mask(mapping));\n\n\t\t\t\tif (!page) {\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpage_cache_release(spd.pages[page_nr]);\n\t\t\t\tspd.pages[page_nr] = page;\n\t\t\t}\n\t\t\t/*\n\t\t\t * page was already under io and is now done, great\n\t\t\t */\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tgoto fill_it;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * need to read in the page\n\t\t\t */\n\t\t\terror = mapping->a_ops->readpage(in, page);\n\t\t\tif (unlikely(error)) {\n\t\t\t\t/*\n\t\t\t\t * We really should re-lookup the page here,\n\t\t\t\t * but it complicates things a lot. Instead\n\t\t\t\t * lets just do what we already stored, and\n\t\t\t\t * we'll get it the next time we are called.\n\t\t\t\t */\n\t\t\t\tif (error == AOP_TRUNCATED_PAGE)\n\t\t\t\t\terror = 0;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\nfill_it:\n\t\t/*\n\t\t * i_size must be checked after PageUptodate.\n\t\t */\n\t\tisize = i_size_read(mapping->host);\n\t\tend_index = (isize - 1) >> PAGE_CACHE_SHIFT;\n\t\tif (unlikely(!isize || index > end_index))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * if this is the last page, see if we need to shrink\n\t\t * the length and stop\n\t\t */\n\t\tif (end_index == index) {\n\t\t\tunsigned int plen;\n\n\t\t\t/*\n\t\t\t * max good bytes in this page\n\t\t\t */\n\t\t\tplen = ((isize - 1) & ~PAGE_CACHE_MASK) + 1;\n\t\t\tif (plen <= loff)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * force quit after adding this page\n\t\t\t */\n\t\t\tthis_len = min(this_len, plen - loff);\n\t\t\tlen = this_len;\n\t\t}\n\n\t\tspd.partial[page_nr].offset = loff;\n\t\tspd.partial[page_nr].len = this_len;\n\t\tlen -= this_len;\n\t\tloff = 0;\n\t\tspd.nr_pages++;\n\t\tindex++;\n\t}\n\n\t/*\n\t * Release any pages at the end, if we quit early. 'page_nr' is how far\n\t * we got, 'nr_pages' is how many pages are in the map.\n\t */\n\twhile (page_nr < nr_pages)\n\t\tpage_cache_release(spd.pages[page_nr++]);\n\tin->f_ra.prev_pos = (loff_t)index << PAGE_CACHE_SHIFT;\n\n\tif (spd.nr_pages)\n\t\terror = splice_to_pipe(pipe, &spd);\n\n\tsplice_shrink_spd(&spd);\n\treturn error;\n}"
  },
  {
    "function_name": "splice_shrink_spd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "294-301",
    "snippet": "void splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spd->partial"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spd->pages"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nvoid splice_shrink_spd(struct splice_pipe_desc *spd)\n{\n\tif (spd->nr_pages_max <= PIPE_DEF_BUFFERS)\n\t\treturn;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n}"
  },
  {
    "function_name": "splice_grow_spd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "275-292",
    "snippet": "int splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = ACCESS_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spd->partial"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "spd->pages"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "buffers * sizeof(struct partial_page)",
            "GFP_KERNEL"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "pipe->buffers"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nint splice_grow_spd(const struct pipe_inode_info *pipe, struct splice_pipe_desc *spd)\n{\n\tunsigned int buffers = ACCESS_ONCE(pipe->buffers);\n\n\tspd->nr_pages_max = buffers;\n\tif (buffers <= PIPE_DEF_BUFFERS)\n\t\treturn 0;\n\n\tspd->pages = kmalloc(buffers * sizeof(struct page *), GFP_KERNEL);\n\tspd->partial = kmalloc(buffers * sizeof(struct partial_page), GFP_KERNEL);\n\n\tif (spd->pages && spd->partial)\n\t\treturn 0;\n\n\tkfree(spd->pages);\n\tkfree(spd->partial);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "spd_release_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "266-269",
    "snippet": "void spd_release_page(struct splice_pipe_desc *spd, unsigned int i)\n{\n\tpage_cache_release(spd->pages[i]);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "spd->pages[i]"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nvoid spd_release_page(struct splice_pipe_desc *spd, unsigned int i)\n{\n\tpage_cache_release(spd->pages[i]);\n}"
  },
  {
    "function_name": "splice_to_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "183-264",
    "snippet": "ssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret, do_wakeup, page_nr;\n\n\tret = 0;\n\tdo_wakeup = 0;\n\tpage_nr = 0;\n\n\tpipe_lock(pipe);\n\n\tfor (;;) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe->nrbufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\t\tbuf->page = spd->pages[page_nr];\n\t\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\t\tbuf->len = spd->partial[page_nr].len;\n\t\t\tbuf->private = spd->partial[page_nr].private;\n\t\t\tbuf->ops = spd->ops;\n\t\t\tif (spd->flags & SPLICE_F_GIFT)\n\t\t\t\tbuf->flags |= PIPE_BUF_FLAG_GIFT;\n\n\t\t\tpipe->nrbufs++;\n\t\t\tpage_nr++;\n\t\t\tret += buf->len;\n\n\t\t\tif (pipe->files)\n\t\t\t\tdo_wakeup = 1;\n\n\t\t\tif (!--spd->nr_pages)\n\t\t\t\tbreak;\n\t\t\tif (pipe->nrbufs < pipe->buffers)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spd->flags & SPLICE_F_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_wakeup) {\n\t\t\tsmp_mb();\n\t\t\tif (waitqueue_active(&pipe->wait))\n\t\t\t\twake_up_interruptible_sync(&pipe->wait);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup)\n\t\twakeup_pipe_readers(pipe);\n\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spd->spd_release",
          "args": [
            "spd",
            "page_nr++"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_pipe_readers",
          "args": [
            "pipe"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_pipe_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
          "lines": "164-170",
          "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/socket.h>",
            "#include <linux/gfp.h>",
            "#include <linux/security.h>",
            "#include <linux/uio.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm_inline.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/splice.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_unlock",
          "args": [
            "pipe"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "84-87",
          "snippet": "static inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_unlock(struct pipe_inode_info *pipe)\n{\n\tmutex_unlock(&pipe->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_wait",
          "args": [
            "pipe"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "pipe_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "104-117",
          "snippet": "void pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nvoid pipe_wait(struct pipe_inode_info *pipe)\n{\n\tDEFINE_WAIT(wait);\n\n\t/*\n\t * Pipes are system-local resources, so sleeping on them\n\t * is considered a noninteractive wait:\n\t */\n\tprepare_to_wait(&pipe->wait, &wait, TASK_INTERRUPTIBLE);\n\tpipe_unlock(pipe);\n\tschedule();\n\tfinish_wait(&pipe->wait, &wait);\n\tpipe_lock(pipe);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_readers",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible_sync",
          "args": [
            "&pipe->wait"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pipe->wait"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGPIPE",
            "current",
            "0"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigurg_to_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "518-523",
          "snippet": "static void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nstatic void send_sigurg_to_task(struct task_struct *p,\n\t\t\t\tstruct fown_struct *fown, int group)\n{\n\tif (sigio_perm(p, fown, SIGURG))\n\t\tdo_send_sig_info(SIGURG, SEND_SIG_PRIV, p, group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pipe_lock",
          "args": [
            "pipe"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "__pipe_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "79-82",
          "snippet": "static inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nstatic inline void __pipe_lock(struct pipe_inode_info *pipe)\n{\n\tmutex_lock_nested(&pipe->mutex, I_MUTEX_PARENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nssize_t splice_to_pipe(struct pipe_inode_info *pipe,\n\t\t       struct splice_pipe_desc *spd)\n{\n\tunsigned int spd_pages = spd->nr_pages;\n\tint ret, do_wakeup, page_nr;\n\n\tret = 0;\n\tdo_wakeup = 0;\n\tpage_nr = 0;\n\n\tpipe_lock(pipe);\n\n\tfor (;;) {\n\t\tif (!pipe->readers) {\n\t\t\tsend_sig(SIGPIPE, current, 0);\n\t\t\tif (!ret)\n\t\t\t\tret = -EPIPE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pipe->nrbufs < pipe->buffers) {\n\t\t\tint newbuf = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);\n\t\t\tstruct pipe_buffer *buf = pipe->bufs + newbuf;\n\n\t\t\tbuf->page = spd->pages[page_nr];\n\t\t\tbuf->offset = spd->partial[page_nr].offset;\n\t\t\tbuf->len = spd->partial[page_nr].len;\n\t\t\tbuf->private = spd->partial[page_nr].private;\n\t\t\tbuf->ops = spd->ops;\n\t\t\tif (spd->flags & SPLICE_F_GIFT)\n\t\t\t\tbuf->flags |= PIPE_BUF_FLAG_GIFT;\n\n\t\t\tpipe->nrbufs++;\n\t\t\tpage_nr++;\n\t\t\tret += buf->len;\n\n\t\t\tif (pipe->files)\n\t\t\t\tdo_wakeup = 1;\n\n\t\t\tif (!--spd->nr_pages)\n\t\t\t\tbreak;\n\t\t\tif (pipe->nrbufs < pipe->buffers)\n\t\t\t\tcontinue;\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (spd->flags & SPLICE_F_NONBLOCK) {\n\t\t\tif (!ret)\n\t\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\tif (!ret)\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_wakeup) {\n\t\t\tsmp_mb();\n\t\t\tif (waitqueue_active(&pipe->wait))\n\t\t\t\twake_up_interruptible_sync(&pipe->wait);\n\t\t\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n\t\t\tdo_wakeup = 0;\n\t\t}\n\n\t\tpipe->waiting_writers++;\n\t\tpipe_wait(pipe);\n\t\tpipe->waiting_writers--;\n\t}\n\n\tpipe_unlock(pipe);\n\n\tif (do_wakeup)\n\t\twakeup_pipe_readers(pipe);\n\n\twhile (page_nr < spd_pages)\n\t\tspd->spd_release(spd, page_nr++);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "wakeup_pipe_readers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "164-170",
    "snippet": "static void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_fasync",
          "args": [
            "&pipe->fasync_readers",
            "SIGIO",
            "POLL_IN"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "kill_fasync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fcntl.c",
          "lines": "723-733",
          "snippet": "void kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/poll.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/security.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/capability.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <asm/siginfo.h>\n#include <asm/poll.h>\n#include <linux/shmem_fs.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/security.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/dnotify.h>\n#include <linux/capability.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/syscalls.h>\n\nvoid kill_fasync(struct fasync_struct **fp, int sig, int band)\n{\n\t/* First a quick test without locking: usually\n\t * the list is empty.\n\t */\n\tif (*fp) {\n\t\trcu_read_lock();\n\t\tkill_fasync_rcu(rcu_dereference(*fp), sig, band);\n\t\trcu_read_unlock();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_interruptible",
          "args": [
            "&pipe->wait"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&pipe->wait"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic void wakeup_pipe_readers(struct pipe_inode_info *pipe)\n{\n\tsmp_mb();\n\tif (waitqueue_active(&pipe->wait))\n\t\twake_up_interruptible(&pipe->wait);\n\tkill_fasync(&pipe->fasync_readers, SIGIO, POLL_IN);\n}"
  },
  {
    "function_name": "user_page_pipe_buf_steal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "146-154",
    "snippet": "static int user_page_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tif (!(buf->flags & PIPE_BUF_FLAG_GIFT))\n\t\treturn 1;\n\n\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\treturn generic_pipe_buf_steal(pipe, buf);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_pipe_buf_steal",
          "args": [
            "pipe",
            "buf"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "generic_pipe_buf_steal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pipe.c",
          "lines": "147-163",
          "snippet": "int generic_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * A reference of one is golden, that means that the owner of this\n\t * page is the only one holding a reference to it. lock the page\n\t * and return OK.\n\t */\n\tif (page_count(page) == 1) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/audit.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/uio.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/audit.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/uio.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n\nint generic_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\n\t/*\n\t * A reference of one is golden, that means that the owner of this\n\t * page is the only one holding a reference to it. lock the page\n\t * and return OK.\n\t */\n\tif (page_count(page) == 1) {\n\t\tlock_page(page);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int user_page_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tif (!(buf->flags & PIPE_BUF_FLAG_GIFT))\n\t\treturn 1;\n\n\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\treturn generic_pipe_buf_steal(pipe, buf);\n}"
  },
  {
    "function_name": "page_cache_pipe_buf_confirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "100-136",
    "snippet": "static int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tint err;\n\n\tif (!PageUptodate(page)) {\n\t\tlock_page(page);\n\n\t\t/*\n\t\t * Page got truncated/unhashed. This will cause a 0-byte\n\t\t * splice, if this is the first page.\n\t\t */\n\t\tif (!page->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Uh oh, read-error from disk.\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Page is ok afterall, we are done.\n\t\t */\n\t\tunlock_page(page);\n\t}\n\n\treturn 0;\nerror:\n\tunlock_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int page_cache_pipe_buf_confirm(struct pipe_inode_info *pipe,\n\t\t\t\t       struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tint err;\n\n\tif (!PageUptodate(page)) {\n\t\tlock_page(page);\n\n\t\t/*\n\t\t * Page got truncated/unhashed. This will cause a 0-byte\n\t\t * splice, if this is the first page.\n\t\t */\n\t\tif (!page->mapping) {\n\t\t\terr = -ENODATA;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Uh oh, read-error from disk.\n\t\t */\n\t\tif (!PageUptodate(page)) {\n\t\t\terr = -EIO;\n\t\t\tgoto error;\n\t\t}\n\n\t\t/*\n\t\t * Page is ok afterall, we are done.\n\t\t */\n\t\tunlock_page(page);\n\t}\n\n\treturn 0;\nerror:\n\tunlock_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "page_cache_pipe_buf_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "89-94",
    "snippet": "static void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tpage_cache_release(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "buf->page"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic void page_cache_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t\tstruct pipe_buffer *buf)\n{\n\tpage_cache_release(buf->page);\n\tbuf->flags &= ~PIPE_BUF_FLAG_LRU;\n}"
  },
  {
    "function_name": "page_cache_pipe_buf_steal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/splice.c",
    "lines": "44-87",
    "snippet": "static int page_cache_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t     struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tstruct address_space *mapping;\n\n\tlock_page(page);\n\n\tmapping = page_mapping(page);\n\tif (mapping) {\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\t/*\n\t\t * At least for ext2 with nobh option, we need to wait on\n\t\t * writeback completing on this page, since we'll remove it\n\t\t * from the pagecache.  Otherwise truncate wont wait on the\n\t\t * page, allowing the disk blocks to be reused by someone else\n\t\t * before we actually wrote our data to them. fs corruption\n\t\t * ensues.\n\t\t */\n\t\twait_on_page_writeback(page);\n\n\t\tif (page_has_private(page) &&\n\t\t    !try_to_release_page(page, GFP_KERNEL))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If we succeeded in removing the mapping, set LRU flag\n\t\t * and return good.\n\t\t */\n\t\tif (remove_mapping(mapping, page)) {\n\t\t\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Raced with truncate or failed to remove page from current\n\t * address space, unlock and return failure.\n\t */\nout_unlock:\n\tunlock_page(page);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/aio.h>",
      "#include <linux/compat.h>",
      "#include <linux/socket.h>",
      "#include <linux/gfp.h>",
      "#include <linux/security.h>",
      "#include <linux/uio.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/export.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm_inline.h>",
      "#include <linux/memcontrol.h>",
      "#include <linux/splice.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_mapping",
          "args": [
            "mapping",
            "page"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_release_page",
          "args": [
            "page",
            "GFP_KERNEL"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_has_private",
          "args": [
            "page"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!PageUptodate(page)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_mapping",
          "args": [
            "page"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/socket.h>\n#include <linux/gfp.h>\n#include <linux/security.h>\n#include <linux/uio.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mm_inline.h>\n#include <linux/memcontrol.h>\n#include <linux/splice.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n\nstatic int splice_pipe_to_pipe(struct pipe_inode_info *ipipe,\n\t\t\t       struct pipe_inode_info *opipe,\n\t\t\t       size_t len, unsigned int flags);\n\nstatic int page_cache_pipe_buf_steal(struct pipe_inode_info *pipe,\n\t\t\t\t     struct pipe_buffer *buf)\n{\n\tstruct page *page = buf->page;\n\tstruct address_space *mapping;\n\n\tlock_page(page);\n\n\tmapping = page_mapping(page);\n\tif (mapping) {\n\t\tWARN_ON(!PageUptodate(page));\n\n\t\t/*\n\t\t * At least for ext2 with nobh option, we need to wait on\n\t\t * writeback completing on this page, since we'll remove it\n\t\t * from the pagecache.  Otherwise truncate wont wait on the\n\t\t * page, allowing the disk blocks to be reused by someone else\n\t\t * before we actually wrote our data to them. fs corruption\n\t\t * ensues.\n\t\t */\n\t\twait_on_page_writeback(page);\n\n\t\tif (page_has_private(page) &&\n\t\t    !try_to_release_page(page, GFP_KERNEL))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * If we succeeded in removing the mapping, set LRU flag\n\t\t * and return good.\n\t\t */\n\t\tif (remove_mapping(mapping, page)) {\n\t\t\tbuf->flags |= PIPE_BUF_FLAG_LRU;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Raced with truncate or failed to remove page from current\n\t * address space, unlock and return failure.\n\t */\nout_unlock:\n\tunlock_page(page);\n\treturn 1;\n}"
  }
]