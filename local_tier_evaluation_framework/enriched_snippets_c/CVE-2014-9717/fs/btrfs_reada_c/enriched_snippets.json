[
  {
    "function_name": "btrfs_reada_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "987-992",
    "snippet": "void btrfs_reada_detach(void *handle)\n{\n\tstruct reada_control *rc = handle;\n\n\tkref_put(&rc->refcnt, reada_control_release);\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rc->refcnt",
            "reada_control_release"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nvoid btrfs_reada_detach(void *handle)\n{\n\tstruct reada_control *rc = handle;\n\n\tkref_put(&rc->refcnt, reada_control_release);\n}"
  },
  {
    "function_name": "btrfs_reada_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "973-984",
    "snippet": "int btrfs_reada_wait(void *handle)\n{\n\tstruct reada_control *rc = handle;\n\n\twhile (atomic_read(&rc->elems)) {\n\t\twait_event(rc->wait, atomic_read(&rc->elems) == 0);\n\t}\n\n\tkref_put(&rc->refcnt, reada_control_release);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rc->refcnt",
            "reada_control_release"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "rc->wait",
            "atomic_read(&rc->elems) == 0"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rc->elems"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rc->elems"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nint btrfs_reada_wait(void *handle)\n{\n\tstruct reada_control *rc = handle;\n\n\twhile (atomic_read(&rc->elems)) {\n\t\twait_event(rc->wait, atomic_read(&rc->elems) == 0);\n\t}\n\n\tkref_put(&rc->refcnt, reada_control_release);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_reada_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "955-971",
    "snippet": "int btrfs_reada_wait(void *handle)\n{\n\tstruct reada_control *rc = handle;\n\n\twhile (atomic_read(&rc->elems)) {\n\t\twait_event_timeout(rc->wait, atomic_read(&rc->elems) == 0,\n\t\t\t\t   5 * HZ);\n\t\tdump_devs(rc->root->fs_info,\n\t\t\t  atomic_read(&rc->elems) < 10 ? 1 : 0);\n\t}\n\n\tdump_devs(rc->root->fs_info, atomic_read(&rc->elems) < 10 ? 1 : 0);\n\n\tkref_put(&rc->refcnt, reada_control_release);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rc->refcnt",
            "reada_control_release"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_devs",
          "args": [
            "rc->root->fs_info",
            "atomic_read(&rc->elems) < 10 ? 1 : 0"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "dump_devs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "805-906",
          "snippet": "static void dump_devs(struct btrfs_fs_info *fs_info, int all)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tunsigned long index;\n\tint ret;\n\tint i;\n\tint j;\n\tint cnt;\n\n\tspin_lock(&fs_info->reada_lock);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tprintk(KERN_DEBUG \"dev %lld has %d in flight\\n\", device->devid,\n\t\t\tatomic_read(&device->reada_in_flight));\n\t\tindex = 0;\n\t\twhile (1) {\n\t\t\tstruct reada_zone *zone;\n\t\t\tret = radix_tree_gang_lookup(&device->reada_zones,\n\t\t\t\t\t\t     (void **)&zone, index, 1);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_DEBUG \"  zone %llu-%llu elems %llu locked \"\n\t\t\t\t\"%d devs\", zone->start, zone->end, zone->elems,\n\t\t\t\tzone->locked);\n\t\t\tfor (j = 0; j < zone->ndevs; ++j) {\n\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\tzone->devs[j]->devid);\n\t\t\t}\n\t\t\tif (device->reada_curr_zone == zone)\n\t\t\t\tprintk(KERN_CONT \" curr off %llu\",\n\t\t\t\t\tdevice->reada_next - zone->start);\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tindex = (zone->end >> PAGE_CACHE_SHIFT) + 1;\n\t\t}\n\t\tcnt = 0;\n\t\tindex = 0;\n\t\twhile (all) {\n\t\t\tstruct reada_extent *re = NULL;\n\n\t\t\tret = radix_tree_gang_lookup(&device->reada_extents,\n\t\t\t\t\t\t     (void **)&re, index, 1);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"  re: logical %llu size %u empty %d for %lld\",\n\t\t\t\tre->logical, fs_info->tree_root->nodesize,\n\t\t\t\tlist_empty(&re->extctl), re->scheduled_for ?\n\t\t\t\tre->scheduled_for->devid : -1);\n\n\t\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\t\tre->zones[i]->start,\n\t\t\t\t\tre->zones[i]->end);\n\t\t\t\tfor (j = 0; j < re->zones[i]->ndevs; ++j) {\n\t\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\t\tre->zones[i]->devs[j]->devid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t\t\tif (++cnt > 15)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tindex = 0;\n\tcnt = 0;\n\twhile (all) {\n\t\tstruct reada_extent *re = NULL;\n\n\t\tret = radix_tree_gang_lookup(&fs_info->reada_tree, (void **)&re,\n\t\t\t\t\t     index, 1);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (!re->scheduled_for) {\n\t\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t\t\"re: logical %llu size %u list empty %d for %lld\",\n\t\t\tre->logical, fs_info->tree_root->nodesize,\n\t\t\tlist_empty(&re->extctl),\n\t\t\tre->scheduled_for ? re->scheduled_for->devid : -1);\n\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\tre->zones[i]->start,\n\t\t\t\tre->zones[i]->end);\n\t\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\t\tre->zones[i]->start,\n\t\t\t\t\tre->zones[i]->end);\n\t\t\t\tfor (j = 0; j < re->zones[i]->ndevs; ++j) {\n\t\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\t\tre->zones[i]->devs[j]->devid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void dump_devs(struct btrfs_fs_info *fs_info, int all)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tunsigned long index;\n\tint ret;\n\tint i;\n\tint j;\n\tint cnt;\n\n\tspin_lock(&fs_info->reada_lock);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tprintk(KERN_DEBUG \"dev %lld has %d in flight\\n\", device->devid,\n\t\t\tatomic_read(&device->reada_in_flight));\n\t\tindex = 0;\n\t\twhile (1) {\n\t\t\tstruct reada_zone *zone;\n\t\t\tret = radix_tree_gang_lookup(&device->reada_zones,\n\t\t\t\t\t\t     (void **)&zone, index, 1);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_DEBUG \"  zone %llu-%llu elems %llu locked \"\n\t\t\t\t\"%d devs\", zone->start, zone->end, zone->elems,\n\t\t\t\tzone->locked);\n\t\t\tfor (j = 0; j < zone->ndevs; ++j) {\n\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\tzone->devs[j]->devid);\n\t\t\t}\n\t\t\tif (device->reada_curr_zone == zone)\n\t\t\t\tprintk(KERN_CONT \" curr off %llu\",\n\t\t\t\t\tdevice->reada_next - zone->start);\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tindex = (zone->end >> PAGE_CACHE_SHIFT) + 1;\n\t\t}\n\t\tcnt = 0;\n\t\tindex = 0;\n\t\twhile (all) {\n\t\t\tstruct reada_extent *re = NULL;\n\n\t\t\tret = radix_tree_gang_lookup(&device->reada_extents,\n\t\t\t\t\t\t     (void **)&re, index, 1);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"  re: logical %llu size %u empty %d for %lld\",\n\t\t\t\tre->logical, fs_info->tree_root->nodesize,\n\t\t\t\tlist_empty(&re->extctl), re->scheduled_for ?\n\t\t\t\tre->scheduled_for->devid : -1);\n\n\t\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\t\tre->zones[i]->start,\n\t\t\t\t\tre->zones[i]->end);\n\t\t\t\tfor (j = 0; j < re->zones[i]->ndevs; ++j) {\n\t\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\t\tre->zones[i]->devs[j]->devid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t\t\tif (++cnt > 15)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tindex = 0;\n\tcnt = 0;\n\twhile (all) {\n\t\tstruct reada_extent *re = NULL;\n\n\t\tret = radix_tree_gang_lookup(&fs_info->reada_tree, (void **)&re,\n\t\t\t\t\t     index, 1);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (!re->scheduled_for) {\n\t\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t\t\"re: logical %llu size %u list empty %d for %lld\",\n\t\t\tre->logical, fs_info->tree_root->nodesize,\n\t\t\tlist_empty(&re->extctl),\n\t\t\tre->scheduled_for ? re->scheduled_for->devid : -1);\n\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\tre->zones[i]->start,\n\t\t\t\tre->zones[i]->end);\n\t\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\t\tre->zones[i]->start,\n\t\t\t\t\tre->zones[i]->end);\n\t\t\t\tfor (j = 0; j < re->zones[i]->ndevs; ++j) {\n\t\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\t\tre->zones[i]->devs[j]->devid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rc->elems"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rc->elems"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_timeout",
          "args": [
            "rc->wait",
            "atomic_read(&rc->elems) == 0",
            "5 * HZ"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rc->elems"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rc->elems"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nint btrfs_reada_wait(void *handle)\n{\n\tstruct reada_control *rc = handle;\n\n\twhile (atomic_read(&rc->elems)) {\n\t\twait_event_timeout(rc->wait, atomic_read(&rc->elems) == 0,\n\t\t\t\t   5 * HZ);\n\t\tdump_devs(rc->root->fs_info,\n\t\t\t  atomic_read(&rc->elems) < 10 ? 1 : 0);\n\t}\n\n\tdump_devs(rc->root->fs_info, atomic_read(&rc->elems) < 10 ? 1 : 0);\n\n\tkref_put(&rc->refcnt, reada_control_release);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_reada_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "912-952",
    "snippet": "struct reada_control *btrfs_reada_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_key *key_start, struct btrfs_key *key_end)\n{\n\tstruct reada_control *rc;\n\tu64 start;\n\tu64 generation;\n\tint level;\n\tstruct extent_buffer *node;\n\tstatic struct btrfs_key max_key = {\n\t\t.objectid = (u64)-1,\n\t\t.type = (u8)-1,\n\t\t.offset = (u64)-1\n\t};\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc->root = root;\n\trc->key_start = *key_start;\n\trc->key_end = *key_end;\n\tatomic_set(&rc->elems, 0);\n\tinit_waitqueue_head(&rc->wait);\n\tkref_init(&rc->refcnt);\n\tkref_get(&rc->refcnt); /* one ref for having elements */\n\n\tnode = btrfs_root_node(root);\n\tstart = node->start;\n\tlevel = btrfs_header_level(node);\n\tgeneration = btrfs_header_generation(node);\n\tfree_extent_buffer(node);\n\n\tif (reada_add_block(rc, start, &max_key, level, generation)) {\n\t\tkfree(rc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treada_start_machine(root->fs_info);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reada_start_machine",
          "args": [
            "root->fs_info"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "reada_start_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "788-802",
          "snippet": "static void reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct reada_machine_work *rmw;\n\n\trmw = kzalloc(sizeof(*rmw), GFP_NOFS);\n\tif (!rmw) {\n\t\t/* FIXME we cannot handle this properly right now */\n\t\tBUG();\n\t}\n\tbtrfs_init_work(&rmw->work, btrfs_readahead_helper,\n\t\t\treada_start_machine_worker, NULL, NULL);\n\trmw->fs_info = fs_info;\n\n\tbtrfs_queue_work(fs_info->readahead_workers, &rmw->work);\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct reada_machine_work *rmw;\n\n\trmw = kzalloc(sizeof(*rmw), GFP_NOFS);\n\tif (!rmw) {\n\t\t/* FIXME we cannot handle this properly right now */\n\t\tBUG();\n\t}\n\tbtrfs_init_work(&rmw->work, btrfs_readahead_helper,\n\t\t\treada_start_machine_worker, NULL, NULL);\n\trmw->fs_info = fs_info;\n\n\tbtrfs_queue_work(fs_info->readahead_workers, &rmw->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rc"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reada_add_block",
          "args": [
            "rc",
            "start",
            "&max_key",
            "level",
            "generation"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "reada_add_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "556-584",
          "snippet": "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation)\n{\n\tstruct btrfs_root *root = rc->root;\n\tstruct reada_extent *re;\n\tstruct reada_extctl *rec;\n\n\tre = reada_find_extent(root, logical, top, level); /* takes one ref */\n\tif (!re)\n\t\treturn -1;\n\n\trec = kzalloc(sizeof(*rec), GFP_NOFS);\n\tif (!rec) {\n\t\treada_extent_put(root->fs_info, re);\n\t\treturn -1;\n\t}\n\n\trec->rc = rc;\n\trec->generation = generation;\n\tatomic_inc(&rc->elems);\n\n\tspin_lock(&re->lock);\n\tlist_add_tail(&rec->list, &re->extctl);\n\tspin_unlock(&re->lock);\n\n\t/* leave the ref on the extent */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);\n\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation)\n{\n\tstruct btrfs_root *root = rc->root;\n\tstruct reada_extent *re;\n\tstruct reada_extctl *rec;\n\n\tre = reada_find_extent(root, logical, top, level); /* takes one ref */\n\tif (!re)\n\t\treturn -1;\n\n\trec = kzalloc(sizeof(*rec), GFP_NOFS);\n\tif (!rec) {\n\t\treada_extent_put(root->fs_info, re);\n\t\treturn -1;\n\t}\n\n\trec->rc = rc;\n\trec->generation = generation;\n\tatomic_inc(&rc->elems);\n\n\tspin_lock(&re->lock);\n\tlist_add_tail(&rec->list, &re->extctl);\n\tspin_unlock(&re->lock);\n\n\t/* leave the ref on the extent */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "node"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "node"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "node"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_root_node",
          "args": [
            "root"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_root_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "148-170",
          "snippet": "struct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic int tree_mod_log_free_eb(struct btrfs_fs_info *fs_info,\n\t\t\t\t struct extent_buffer *eb);\nstatic noinline struct;\n\nstruct extent_buffer *btrfs_root_node(struct btrfs_root *root)\n{\n\tstruct extent_buffer *eb;\n\n\twhile (1) {\n\t\trcu_read_lock();\n\t\teb = rcu_dereference(root->node);\n\n\t\t/*\n\t\t * RCU really hurts here, we could free up the root node because\n\t\t * it was cow'ed but we may not get the new root node yet so do\n\t\t * the inc_not_zero dance and if it doesn't work then\n\t\t * synchronize_rcu and try again.\n\t\t */\n\t\tif (atomic_inc_not_zero(&eb->refs)) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tsynchronize_rcu();\n\t}\n\treturn eb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&rc->refcnt"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&rc->refcnt"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rc->wait"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&rc->elems",
            "0"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rc)",
            "GFP_NOFS"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);\n\nstruct reada_control *btrfs_reada_add(struct btrfs_root *root,\n\t\t\tstruct btrfs_key *key_start, struct btrfs_key *key_end)\n{\n\tstruct reada_control *rc;\n\tu64 start;\n\tu64 generation;\n\tint level;\n\tstruct extent_buffer *node;\n\tstatic struct btrfs_key max_key = {\n\t\t.objectid = (u64)-1,\n\t\t.type = (u8)-1,\n\t\t.offset = (u64)-1\n\t};\n\n\trc = kzalloc(sizeof(*rc), GFP_NOFS);\n\tif (!rc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trc->root = root;\n\trc->key_start = *key_start;\n\trc->key_end = *key_end;\n\tatomic_set(&rc->elems, 0);\n\tinit_waitqueue_head(&rc->wait);\n\tkref_init(&rc->refcnt);\n\tkref_get(&rc->refcnt); /* one ref for having elements */\n\n\tnode = btrfs_root_node(root);\n\tstart = node->start;\n\tlevel = btrfs_header_level(node);\n\tgeneration = btrfs_header_generation(node);\n\tfree_extent_buffer(node);\n\n\tif (reada_add_block(rc, start, &max_key, level, generation)) {\n\t\tkfree(rc);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treada_start_machine(root->fs_info);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "dump_devs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "805-906",
    "snippet": "static void dump_devs(struct btrfs_fs_info *fs_info, int all)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tunsigned long index;\n\tint ret;\n\tint i;\n\tint j;\n\tint cnt;\n\n\tspin_lock(&fs_info->reada_lock);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tprintk(KERN_DEBUG \"dev %lld has %d in flight\\n\", device->devid,\n\t\t\tatomic_read(&device->reada_in_flight));\n\t\tindex = 0;\n\t\twhile (1) {\n\t\t\tstruct reada_zone *zone;\n\t\t\tret = radix_tree_gang_lookup(&device->reada_zones,\n\t\t\t\t\t\t     (void **)&zone, index, 1);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_DEBUG \"  zone %llu-%llu elems %llu locked \"\n\t\t\t\t\"%d devs\", zone->start, zone->end, zone->elems,\n\t\t\t\tzone->locked);\n\t\t\tfor (j = 0; j < zone->ndevs; ++j) {\n\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\tzone->devs[j]->devid);\n\t\t\t}\n\t\t\tif (device->reada_curr_zone == zone)\n\t\t\t\tprintk(KERN_CONT \" curr off %llu\",\n\t\t\t\t\tdevice->reada_next - zone->start);\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tindex = (zone->end >> PAGE_CACHE_SHIFT) + 1;\n\t\t}\n\t\tcnt = 0;\n\t\tindex = 0;\n\t\twhile (all) {\n\t\t\tstruct reada_extent *re = NULL;\n\n\t\t\tret = radix_tree_gang_lookup(&device->reada_extents,\n\t\t\t\t\t\t     (void **)&re, index, 1);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"  re: logical %llu size %u empty %d for %lld\",\n\t\t\t\tre->logical, fs_info->tree_root->nodesize,\n\t\t\t\tlist_empty(&re->extctl), re->scheduled_for ?\n\t\t\t\tre->scheduled_for->devid : -1);\n\n\t\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\t\tre->zones[i]->start,\n\t\t\t\t\tre->zones[i]->end);\n\t\t\t\tfor (j = 0; j < re->zones[i]->ndevs; ++j) {\n\t\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\t\tre->zones[i]->devs[j]->devid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t\t\tif (++cnt > 15)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tindex = 0;\n\tcnt = 0;\n\twhile (all) {\n\t\tstruct reada_extent *re = NULL;\n\n\t\tret = radix_tree_gang_lookup(&fs_info->reada_tree, (void **)&re,\n\t\t\t\t\t     index, 1);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (!re->scheduled_for) {\n\t\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t\t\"re: logical %llu size %u list empty %d for %lld\",\n\t\t\tre->logical, fs_info->tree_root->nodesize,\n\t\t\tlist_empty(&re->extctl),\n\t\t\tre->scheduled_for ? re->scheduled_for->devid : -1);\n\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\tre->zones[i]->start,\n\t\t\t\tre->zones[i]->end);\n\t\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\t\tre->zones[i]->start,\n\t\t\t\t\tre->zones[i]->end);\n\t\t\t\tfor (j = 0; j < re->zones[i]->ndevs; ++j) {\n\t\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\t\tre->zones[i]->devs[j]->devid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \"\\n\""
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CONT \" %lld\"",
            "re->zones[i]->devs[j]->devid"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&re->extctl"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&fs_info->reada_tree",
            "(void **)&re",
            "index",
            "1"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&device->reada_extents",
            "(void **)&re",
            "index",
            "1"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&device->reada_zones",
            "(void **)&zone",
            "index",
            "1"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&device->reada_in_flight"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void dump_devs(struct btrfs_fs_info *fs_info, int all)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tunsigned long index;\n\tint ret;\n\tint i;\n\tint j;\n\tint cnt;\n\n\tspin_lock(&fs_info->reada_lock);\n\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\tprintk(KERN_DEBUG \"dev %lld has %d in flight\\n\", device->devid,\n\t\t\tatomic_read(&device->reada_in_flight));\n\t\tindex = 0;\n\t\twhile (1) {\n\t\t\tstruct reada_zone *zone;\n\t\t\tret = radix_tree_gang_lookup(&device->reada_zones,\n\t\t\t\t\t\t     (void **)&zone, index, 1);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_DEBUG \"  zone %llu-%llu elems %llu locked \"\n\t\t\t\t\"%d devs\", zone->start, zone->end, zone->elems,\n\t\t\t\tzone->locked);\n\t\t\tfor (j = 0; j < zone->ndevs; ++j) {\n\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\tzone->devs[j]->devid);\n\t\t\t}\n\t\t\tif (device->reada_curr_zone == zone)\n\t\t\t\tprintk(KERN_CONT \" curr off %llu\",\n\t\t\t\t\tdevice->reada_next - zone->start);\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tindex = (zone->end >> PAGE_CACHE_SHIFT) + 1;\n\t\t}\n\t\tcnt = 0;\n\t\tindex = 0;\n\t\twhile (all) {\n\t\t\tstruct reada_extent *re = NULL;\n\n\t\t\tret = radix_tree_gang_lookup(&device->reada_extents,\n\t\t\t\t\t\t     (void **)&re, index, 1);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"  re: logical %llu size %u empty %d for %lld\",\n\t\t\t\tre->logical, fs_info->tree_root->nodesize,\n\t\t\t\tlist_empty(&re->extctl), re->scheduled_for ?\n\t\t\t\tre->scheduled_for->devid : -1);\n\n\t\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\t\tre->zones[i]->start,\n\t\t\t\t\tre->zones[i]->end);\n\t\t\t\tfor (j = 0; j < re->zones[i]->ndevs; ++j) {\n\t\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\t\tre->zones[i]->devs[j]->devid);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintk(KERN_CONT \"\\n\");\n\t\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t\t\tif (++cnt > 15)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tindex = 0;\n\tcnt = 0;\n\twhile (all) {\n\t\tstruct reada_extent *re = NULL;\n\n\t\tret = radix_tree_gang_lookup(&fs_info->reada_tree, (void **)&re,\n\t\t\t\t\t     index, 1);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tif (!re->scheduled_for) {\n\t\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t\t\"re: logical %llu size %u list empty %d for %lld\",\n\t\t\tre->logical, fs_info->tree_root->nodesize,\n\t\t\tlist_empty(&re->extctl),\n\t\t\tre->scheduled_for ? re->scheduled_for->devid : -1);\n\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\tre->zones[i]->start,\n\t\t\t\tre->zones[i]->end);\n\t\t\tfor (i = 0; i < re->nzones; ++i) {\n\t\t\t\tprintk(KERN_CONT \" zone %llu-%llu devs\",\n\t\t\t\t\tre->zones[i]->start,\n\t\t\t\t\tre->zones[i]->end);\n\t\t\t\tfor (j = 0; j < re->zones[i]->ndevs; ++j) {\n\t\t\t\t\tprintk(KERN_CONT \" %lld\",\n\t\t\t\t\t\tre->zones[i]->devs[j]->devid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintk(KERN_CONT \"\\n\");\n\t\tindex = (re->logical >> PAGE_CACHE_SHIFT) + 1;\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n}"
  },
  {
    "function_name": "reada_start_machine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "788-802",
    "snippet": "static void reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct reada_machine_work *rmw;\n\n\trmw = kzalloc(sizeof(*rmw), GFP_NOFS);\n\tif (!rmw) {\n\t\t/* FIXME we cannot handle this properly right now */\n\t\tBUG();\n\t}\n\tbtrfs_init_work(&rmw->work, btrfs_readahead_helper,\n\t\t\treada_start_machine_worker, NULL, NULL);\n\trmw->fs_info = fs_info;\n\n\tbtrfs_queue_work(fs_info->readahead_workers, &rmw->work);\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_queue_work",
          "args": [
            "fs_info->readahead_workers",
            "&rmw->work"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "323-333",
          "snippet": "void btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [
            "#define WORK_HIGH_PRIO_BIT 2"
          ],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);",
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\n#define WORK_HIGH_PRIO_BIT 2\n\nstatic void normal_work_helper(struct btrfs_work *work);\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_queue_work(struct btrfs_workqueue *wq,\n\t\t      struct btrfs_work *work)\n{\n\tstruct __btrfs_workqueue *dest_wq;\n\n\tif (test_bit(WORK_HIGH_PRIO_BIT, &work->flags) && wq->high)\n\t\tdest_wq = wq->high;\n\telse\n\t\tdest_wq = wq->normal;\n\t__btrfs_queue_work(dest_wq, work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_work",
          "args": [
            "&rmw->work",
            "btrfs_readahead_helper",
            "reada_start_machine_worker",
            "NULL",
            "NULL"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "294-305",
          "snippet": "void btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void normal_work_helper(struct btrfs_work *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic void normal_work_helper(struct btrfs_work *work);\n\nvoid btrfs_init_work(struct btrfs_work *work, btrfs_work_func_t uniq_func,\n\t\t     btrfs_func_t func,\n\t\t     btrfs_func_t ordered_func,\n\t\t     btrfs_func_t ordered_free)\n{\n\twork->func = func;\n\twork->ordered_func = ordered_func;\n\twork->ordered_free = ordered_free;\n\tINIT_WORK(&work->normal_work, uniq_func);\n\tINIT_LIST_HEAD(&work->ordered_list);\n\twork->flags = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rmw)",
            "GFP_NOFS"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct reada_machine_work *rmw;\n\n\trmw = kzalloc(sizeof(*rmw), GFP_NOFS);\n\tif (!rmw) {\n\t\t/* FIXME we cannot handle this properly right now */\n\t\tBUG();\n\t}\n\tbtrfs_init_work(&rmw->work, btrfs_readahead_helper,\n\t\t\treada_start_machine_worker, NULL, NULL);\n\trmw->fs_info = fs_info;\n\n\tbtrfs_queue_work(fs_info->readahead_workers, &rmw->work);\n}"
  },
  {
    "function_name": "__reada_start_machine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "755-786",
    "snippet": "static void __reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 enqueued;\n\tu64 total = 0;\n\tint i;\n\n\tdo {\n\t\tenqueued = 0;\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\t\tif (atomic_read(&device->reada_in_flight) <\n\t\t\t    MAX_IN_FLIGHT)\n\t\t\t\tenqueued += reada_start_machine_dev(fs_info,\n\t\t\t\t\t\t\t\t    device);\n\t\t}\n\t\ttotal += enqueued;\n\t} while (enqueued && total < 10000);\n\n\tif (enqueued == 0)\n\t\treturn;\n\n\t/*\n\t * If everything is already in the cache, this is effectively single\n\t * threaded. To a) not hold the caller for too long and b) to utilize\n\t * more cores, we broke the loop above after 10000 iterations and now\n\t * enqueue to workers to finish it. This will distribute the load to\n\t * the cores.\n\t */\n\tfor (i = 0; i < 2; ++i)\n\t\treada_start_machine(fs_info);\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [
      "#define MAX_IN_FLIGHT 6"
    ],
    "globals_used": [
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reada_start_machine",
          "args": [
            "fs_info"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "reada_start_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "788-802",
          "snippet": "static void reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct reada_machine_work *rmw;\n\n\trmw = kzalloc(sizeof(*rmw), GFP_NOFS);\n\tif (!rmw) {\n\t\t/* FIXME we cannot handle this properly right now */\n\t\tBUG();\n\t}\n\tbtrfs_init_work(&rmw->work, btrfs_readahead_helper,\n\t\t\treada_start_machine_worker, NULL, NULL);\n\trmw->fs_info = fs_info;\n\n\tbtrfs_queue_work(fs_info->readahead_workers, &rmw->work);\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct reada_machine_work *rmw;\n\n\trmw = kzalloc(sizeof(*rmw), GFP_NOFS);\n\tif (!rmw) {\n\t\t/* FIXME we cannot handle this properly right now */\n\t\tBUG();\n\t}\n\tbtrfs_init_work(&rmw->work, btrfs_readahead_helper,\n\t\t\treada_start_machine_worker, NULL, NULL);\n\trmw->fs_info = fs_info;\n\n\tbtrfs_queue_work(fs_info->readahead_workers, &rmw->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reada_start_machine_dev",
          "args": [
            "fs_info",
            "device"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "reada_start_machine_dev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "654-735",
          "snippet": "static int reada_start_machine_dev(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_device *dev)\n{\n\tstruct reada_extent *re = NULL;\n\tint mirror_num = 0;\n\tstruct extent_buffer *eb = NULL;\n\tu64 logical;\n\tint ret;\n\tint i;\n\tint need_kick = 0;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (dev->reada_curr_zone == NULL) {\n\t\tret = reada_pick_zone(dev);\n\t\tif (!ret) {\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * FIXME currently we issue the reads one extent at a time. If we have\n\t * a contiguous block of extents, we could also coagulate them or use\n\t * plugging to speed things up\n\t */\n\tret = radix_tree_gang_lookup(&dev->reada_extents, (void **)&re,\n\t\t\t\t     dev->reada_next >> PAGE_CACHE_SHIFT, 1);\n\tif (ret == 0 || re->logical >= dev->reada_curr_zone->end) {\n\t\tret = reada_pick_zone(dev);\n\t\tif (!ret) {\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tre = NULL;\n\t\tret = radix_tree_gang_lookup(&dev->reada_extents, (void **)&re,\n\t\t\t\t\tdev->reada_next >> PAGE_CACHE_SHIFT, 1);\n\t}\n\tif (ret == 0) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn 0;\n\t}\n\tdev->reada_next = re->logical + fs_info->tree_root->nodesize;\n\tre->refcnt++;\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\t/*\n\t * find mirror num\n\t */\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tif (re->zones[i]->device == dev) {\n\t\t\tmirror_num = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlogical = re->logical;\n\n\tspin_lock(&re->lock);\n\tif (re->scheduled_for == NULL) {\n\t\tre->scheduled_for = dev;\n\t\tneed_kick = 1;\n\t}\n\tspin_unlock(&re->lock);\n\n\treada_extent_put(fs_info, re);\n\n\tif (!need_kick)\n\t\treturn 0;\n\n\tatomic_inc(&dev->reada_in_flight);\n\tret = reada_tree_block_flagged(fs_info->extent_root, logical,\n\t\t\tmirror_num, &eb);\n\tif (ret)\n\t\t__readahead_hook(fs_info->extent_root, NULL, logical, ret);\n\telse if (eb)\n\t\t__readahead_hook(fs_info->extent_root, eb, eb->start, ret);\n\n\tif (eb)\n\t\tfree_extent_buffer(eb);\n\n\treturn 1;\n\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic int reada_start_machine_dev(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_device *dev)\n{\n\tstruct reada_extent *re = NULL;\n\tint mirror_num = 0;\n\tstruct extent_buffer *eb = NULL;\n\tu64 logical;\n\tint ret;\n\tint i;\n\tint need_kick = 0;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (dev->reada_curr_zone == NULL) {\n\t\tret = reada_pick_zone(dev);\n\t\tif (!ret) {\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * FIXME currently we issue the reads one extent at a time. If we have\n\t * a contiguous block of extents, we could also coagulate them or use\n\t * plugging to speed things up\n\t */\n\tret = radix_tree_gang_lookup(&dev->reada_extents, (void **)&re,\n\t\t\t\t     dev->reada_next >> PAGE_CACHE_SHIFT, 1);\n\tif (ret == 0 || re->logical >= dev->reada_curr_zone->end) {\n\t\tret = reada_pick_zone(dev);\n\t\tif (!ret) {\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tre = NULL;\n\t\tret = radix_tree_gang_lookup(&dev->reada_extents, (void **)&re,\n\t\t\t\t\tdev->reada_next >> PAGE_CACHE_SHIFT, 1);\n\t}\n\tif (ret == 0) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn 0;\n\t}\n\tdev->reada_next = re->logical + fs_info->tree_root->nodesize;\n\tre->refcnt++;\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\t/*\n\t * find mirror num\n\t */\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tif (re->zones[i]->device == dev) {\n\t\t\tmirror_num = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlogical = re->logical;\n\n\tspin_lock(&re->lock);\n\tif (re->scheduled_for == NULL) {\n\t\tre->scheduled_for = dev;\n\t\tneed_kick = 1;\n\t}\n\tspin_unlock(&re->lock);\n\n\treada_extent_put(fs_info, re);\n\n\tif (!need_kick)\n\t\treturn 0;\n\n\tatomic_inc(&dev->reada_in_flight);\n\tret = reada_tree_block_flagged(fs_info->extent_root, logical,\n\t\t\tmirror_num, &eb);\n\tif (ret)\n\t\t__readahead_hook(fs_info->extent_root, NULL, logical, ret);\n\telse if (eb)\n\t\t__readahead_hook(fs_info->extent_root, eb, eb->start, ret);\n\n\tif (eb)\n\t\tfree_extent_buffer(eb);\n\n\treturn 1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&device->reada_in_flight"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "device",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define MAX_IN_FLIGHT 6\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 enqueued;\n\tu64 total = 0;\n\tint i;\n\n\tdo {\n\t\tenqueued = 0;\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\t\tif (atomic_read(&device->reada_in_flight) <\n\t\t\t    MAX_IN_FLIGHT)\n\t\t\t\tenqueued += reada_start_machine_dev(fs_info,\n\t\t\t\t\t\t\t\t    device);\n\t\t}\n\t\ttotal += enqueued;\n\t} while (enqueued && total < 10000);\n\n\tif (enqueued == 0)\n\t\treturn;\n\n\t/*\n\t * If everything is already in the cache, this is effectively single\n\t * threaded. To a) not hold the caller for too long and b) to utilize\n\t * more cores, we broke the loop above after 10000 iterations and now\n\t * enqueue to workers to finish it. This will distribute the load to\n\t * the cores.\n\t */\n\tfor (i = 0; i < 2; ++i)\n\t\treada_start_machine(fs_info);\n}"
  },
  {
    "function_name": "reada_start_machine_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "737-753",
    "snippet": "static void reada_start_machine_worker(struct btrfs_work *work)\n{\n\tstruct reada_machine_work *rmw;\n\tstruct btrfs_fs_info *fs_info;\n\tint old_ioprio;\n\n\trmw = container_of(work, struct reada_machine_work, work);\n\tfs_info = rmw->fs_info;\n\n\tkfree(rmw);\n\n\told_ioprio = IOPRIO_PRIO_VALUE(task_nice_ioclass(current),\n\t\t\t\t       task_nice_ioprio(current));\n\tset_task_ioprio(current, BTRFS_IOPRIO_READA);\n\t__reada_start_machine(fs_info);\n\tset_task_ioprio(current, old_ioprio);\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_task_ioprio",
          "args": [
            "current",
            "old_ioprio"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__reada_start_machine",
          "args": [
            "fs_info"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "__reada_start_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "755-786",
          "snippet": "static void __reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 enqueued;\n\tu64 total = 0;\n\tint i;\n\n\tdo {\n\t\tenqueued = 0;\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\t\tif (atomic_read(&device->reada_in_flight) <\n\t\t\t    MAX_IN_FLIGHT)\n\t\t\t\tenqueued += reada_start_machine_dev(fs_info,\n\t\t\t\t\t\t\t\t    device);\n\t\t}\n\t\ttotal += enqueued;\n\t} while (enqueued && total < 10000);\n\n\tif (enqueued == 0)\n\t\treturn;\n\n\t/*\n\t * If everything is already in the cache, this is effectively single\n\t * threaded. To a) not hold the caller for too long and b) to utilize\n\t * more cores, we broke the loop above after 10000 iterations and now\n\t * enqueue to workers to finish it. This will distribute the load to\n\t * the cores.\n\t */\n\tfor (i = 0; i < 2; ++i)\n\t\treada_start_machine(fs_info);\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define MAX_IN_FLIGHT 6"
          ],
          "globals_used": [
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\n#define MAX_IN_FLIGHT 6\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_device *device;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tu64 enqueued;\n\tu64 total = 0;\n\tint i;\n\n\tdo {\n\t\tenqueued = 0;\n\t\tlist_for_each_entry(device, &fs_devices->devices, dev_list) {\n\t\t\tif (atomic_read(&device->reada_in_flight) <\n\t\t\t    MAX_IN_FLIGHT)\n\t\t\t\tenqueued += reada_start_machine_dev(fs_info,\n\t\t\t\t\t\t\t\t    device);\n\t\t}\n\t\ttotal += enqueued;\n\t} while (enqueued && total < 10000);\n\n\tif (enqueued == 0)\n\t\treturn;\n\n\t/*\n\t * If everything is already in the cache, this is effectively single\n\t * threaded. To a) not hold the caller for too long and b) to utilize\n\t * more cores, we broke the loop above after 10000 iterations and now\n\t * enqueue to workers to finish it. This will distribute the load to\n\t * the cores.\n\t */\n\tfor (i = 0; i < 2; ++i)\n\t\treada_start_machine(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_ioprio",
          "args": [
            "current",
            "BTRFS_IOPRIO_READA"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IOPRIO_PRIO_VALUE",
          "args": [
            "task_nice_ioclass(current)",
            "task_nice_ioprio(current)"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice_ioprio",
          "args": [
            "current"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_nice_ioclass",
          "args": [
            "current"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rmw"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structreada_machine_work",
            "work"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_start_machine_worker(struct btrfs_work *work)\n{\n\tstruct reada_machine_work *rmw;\n\tstruct btrfs_fs_info *fs_info;\n\tint old_ioprio;\n\n\trmw = container_of(work, struct reada_machine_work, work);\n\tfs_info = rmw->fs_info;\n\n\tkfree(rmw);\n\n\told_ioprio = IOPRIO_PRIO_VALUE(task_nice_ioclass(current),\n\t\t\t\t       task_nice_ioprio(current));\n\tset_task_ioprio(current, BTRFS_IOPRIO_READA);\n\t__reada_start_machine(fs_info);\n\tset_task_ioprio(current, old_ioprio);\n}"
  },
  {
    "function_name": "reada_start_machine_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "654-735",
    "snippet": "static int reada_start_machine_dev(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_device *dev)\n{\n\tstruct reada_extent *re = NULL;\n\tint mirror_num = 0;\n\tstruct extent_buffer *eb = NULL;\n\tu64 logical;\n\tint ret;\n\tint i;\n\tint need_kick = 0;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (dev->reada_curr_zone == NULL) {\n\t\tret = reada_pick_zone(dev);\n\t\tif (!ret) {\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * FIXME currently we issue the reads one extent at a time. If we have\n\t * a contiguous block of extents, we could also coagulate them or use\n\t * plugging to speed things up\n\t */\n\tret = radix_tree_gang_lookup(&dev->reada_extents, (void **)&re,\n\t\t\t\t     dev->reada_next >> PAGE_CACHE_SHIFT, 1);\n\tif (ret == 0 || re->logical >= dev->reada_curr_zone->end) {\n\t\tret = reada_pick_zone(dev);\n\t\tif (!ret) {\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tre = NULL;\n\t\tret = radix_tree_gang_lookup(&dev->reada_extents, (void **)&re,\n\t\t\t\t\tdev->reada_next >> PAGE_CACHE_SHIFT, 1);\n\t}\n\tif (ret == 0) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn 0;\n\t}\n\tdev->reada_next = re->logical + fs_info->tree_root->nodesize;\n\tre->refcnt++;\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\t/*\n\t * find mirror num\n\t */\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tif (re->zones[i]->device == dev) {\n\t\t\tmirror_num = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlogical = re->logical;\n\n\tspin_lock(&re->lock);\n\tif (re->scheduled_for == NULL) {\n\t\tre->scheduled_for = dev;\n\t\tneed_kick = 1;\n\t}\n\tspin_unlock(&re->lock);\n\n\treada_extent_put(fs_info, re);\n\n\tif (!need_kick)\n\t\treturn 0;\n\n\tatomic_inc(&dev->reada_in_flight);\n\tret = reada_tree_block_flagged(fs_info->extent_root, logical,\n\t\t\tmirror_num, &eb);\n\tif (ret)\n\t\t__readahead_hook(fs_info->extent_root, NULL, logical, ret);\n\telse if (eb)\n\t\t__readahead_hook(fs_info->extent_root, eb, eb->start, ret);\n\n\tif (eb)\n\t\tfree_extent_buffer(eb);\n\n\treturn 1;\n\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_extent_buffer",
          "args": [
            "eb"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "free_extent_buffer_stale",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "5019-5031",
          "snippet": "void free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nvoid free_extent_buffer_stale(struct extent_buffer *eb)\n{\n\tif (!eb)\n\t\treturn;\n\n\tspin_lock(&eb->refs_lock);\n\tset_bit(EXTENT_BUFFER_STALE, &eb->bflags);\n\n\tif (atomic_read(&eb->refs) == 2 && !extent_buffer_under_io(eb) &&\n\t    test_and_clear_bit(EXTENT_BUFFER_TREE_REF, &eb->bflags))\n\t\tatomic_dec(&eb->refs);\n\trelease_extent_buffer(eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__readahead_hook",
          "args": [
            "fs_info->extent_root",
            "eb",
            "eb->start",
            "ret"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "__readahead_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "108-230",
          "snippet": "static int __readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t    u64 start, int err)\n{\n\tint level = 0;\n\tint nritems;\n\tint i;\n\tu64 bytenr;\n\tu64 generation;\n\tstruct reada_extent *re;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head list;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct btrfs_device *for_dev;\n\n\tif (eb)\n\t\tlevel = btrfs_header_level(eb);\n\n\t/* find extent */\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (!re)\n\t\treturn -1;\n\n\tspin_lock(&re->lock);\n\t/*\n\t * just take the full list from the extent. afterwards we\n\t * don't need the lock anymore\n\t */\n\tlist_replace_init(&re->extctl, &list);\n\tfor_dev = re->scheduled_for;\n\tre->scheduled_for = NULL;\n\tspin_unlock(&re->lock);\n\n\tif (err == 0) {\n\t\tnritems = level ? btrfs_header_nritems(eb) : 0;\n\t\tgeneration = btrfs_header_generation(eb);\n\t\t/*\n\t\t * FIXME: currently we just set nritems to 0 if this is a leaf,\n\t\t * effectively ignoring the content. In a next step we could\n\t\t * trigger more readahead depending from the content, e.g.\n\t\t * fetch the checksums for the extents in the leaf.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * this is the error case, the extent buffer has not been\n\t\t * read correctly. We won't access anything from it and\n\t\t * just cleanup our data structures. Effectively this will\n\t\t * cut the branch below this node from read ahead.\n\t\t */\n\t\tnritems = 0;\n\t\tgeneration = 0;\n\t}\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct reada_extctl *rec;\n\t\tu64 n_gen;\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_key next_key;\n\n\t\tbtrfs_node_key_to_cpu(eb, &key, i);\n\t\tif (i + 1 < nritems)\n\t\t\tbtrfs_node_key_to_cpu(eb, &next_key, i + 1);\n\t\telse\n\t\t\tnext_key = re->top;\n\t\tbytenr = btrfs_node_blockptr(eb, i);\n\t\tn_gen = btrfs_node_ptr_generation(eb, i);\n\n\t\tlist_for_each_entry(rec, &list, list) {\n\t\t\tstruct reada_control *rc = rec->rc;\n\n\t\t\t/*\n\t\t\t * if the generation doesn't match, just ignore this\n\t\t\t * extctl. This will probably cut off a branch from\n\t\t\t * prefetch. Alternatively one could start a new (sub-)\n\t\t\t * prefetch for this branch, starting again from root.\n\t\t\t * FIXME: move the generation check out of this loop\n\t\t\t */\n#ifdef DEBUG\n\t\t\tif (rec->generation != generation) {\n\t\t\t\tbtrfs_debug(root->fs_info,\n\t\t\t\t\t   \"generation mismatch for (%llu,%d,%llu) %llu != %llu\",\n\t\t\t\t       key.objectid, key.type, key.offset,\n\t\t\t\t       rec->generation, generation);\n\t\t\t}\n#endif\n\t\t\tif (rec->generation == generation &&\n\t\t\t    btrfs_comp_cpu_keys(&key, &rc->key_end) < 0 &&\n\t\t\t    btrfs_comp_cpu_keys(&next_key, &rc->key_start) > 0)\n\t\t\t\treada_add_block(rc, bytenr, &next_key,\n\t\t\t\t\t\tlevel - 1, n_gen);\n\t\t}\n\t}\n\t/*\n\t * free extctl records\n\t */\n\twhile (!list_empty(&list)) {\n\t\tstruct reada_control *rc;\n\t\tstruct reada_extctl *rec;\n\n\t\trec = list_first_entry(&list, struct reada_extctl, list);\n\t\tlist_del(&rec->list);\n\t\trc = rec->rc;\n\t\tkfree(rec);\n\n\t\tkref_get(&rc->refcnt);\n\t\tif (atomic_dec_and_test(&rc->elems)) {\n\t\t\tkref_put(&rc->refcnt, reada_control_release);\n\t\t\twake_up(&rc->wait);\n\t\t}\n\t\tkref_put(&rc->refcnt, reada_control_release);\n\n\t\treada_extent_put(fs_info, re);\t/* one ref for each entry */\n\t}\n\treada_extent_put(fs_info, re);\t/* our ref */\n\tif (for_dev)\n\t\tatomic_dec(&for_dev->reada_in_flight);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);\n\nstatic int __readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t    u64 start, int err)\n{\n\tint level = 0;\n\tint nritems;\n\tint i;\n\tu64 bytenr;\n\tu64 generation;\n\tstruct reada_extent *re;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head list;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct btrfs_device *for_dev;\n\n\tif (eb)\n\t\tlevel = btrfs_header_level(eb);\n\n\t/* find extent */\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (!re)\n\t\treturn -1;\n\n\tspin_lock(&re->lock);\n\t/*\n\t * just take the full list from the extent. afterwards we\n\t * don't need the lock anymore\n\t */\n\tlist_replace_init(&re->extctl, &list);\n\tfor_dev = re->scheduled_for;\n\tre->scheduled_for = NULL;\n\tspin_unlock(&re->lock);\n\n\tif (err == 0) {\n\t\tnritems = level ? btrfs_header_nritems(eb) : 0;\n\t\tgeneration = btrfs_header_generation(eb);\n\t\t/*\n\t\t * FIXME: currently we just set nritems to 0 if this is a leaf,\n\t\t * effectively ignoring the content. In a next step we could\n\t\t * trigger more readahead depending from the content, e.g.\n\t\t * fetch the checksums for the extents in the leaf.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * this is the error case, the extent buffer has not been\n\t\t * read correctly. We won't access anything from it and\n\t\t * just cleanup our data structures. Effectively this will\n\t\t * cut the branch below this node from read ahead.\n\t\t */\n\t\tnritems = 0;\n\t\tgeneration = 0;\n\t}\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct reada_extctl *rec;\n\t\tu64 n_gen;\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_key next_key;\n\n\t\tbtrfs_node_key_to_cpu(eb, &key, i);\n\t\tif (i + 1 < nritems)\n\t\t\tbtrfs_node_key_to_cpu(eb, &next_key, i + 1);\n\t\telse\n\t\t\tnext_key = re->top;\n\t\tbytenr = btrfs_node_blockptr(eb, i);\n\t\tn_gen = btrfs_node_ptr_generation(eb, i);\n\n\t\tlist_for_each_entry(rec, &list, list) {\n\t\t\tstruct reada_control *rc = rec->rc;\n\n\t\t\t/*\n\t\t\t * if the generation doesn't match, just ignore this\n\t\t\t * extctl. This will probably cut off a branch from\n\t\t\t * prefetch. Alternatively one could start a new (sub-)\n\t\t\t * prefetch for this branch, starting again from root.\n\t\t\t * FIXME: move the generation check out of this loop\n\t\t\t */\n#ifdef DEBUG\n\t\t\tif (rec->generation != generation) {\n\t\t\t\tbtrfs_debug(root->fs_info,\n\t\t\t\t\t   \"generation mismatch for (%llu,%d,%llu) %llu != %llu\",\n\t\t\t\t       key.objectid, key.type, key.offset,\n\t\t\t\t       rec->generation, generation);\n\t\t\t}\n#endif\n\t\t\tif (rec->generation == generation &&\n\t\t\t    btrfs_comp_cpu_keys(&key, &rc->key_end) < 0 &&\n\t\t\t    btrfs_comp_cpu_keys(&next_key, &rc->key_start) > 0)\n\t\t\t\treada_add_block(rc, bytenr, &next_key,\n\t\t\t\t\t\tlevel - 1, n_gen);\n\t\t}\n\t}\n\t/*\n\t * free extctl records\n\t */\n\twhile (!list_empty(&list)) {\n\t\tstruct reada_control *rc;\n\t\tstruct reada_extctl *rec;\n\n\t\trec = list_first_entry(&list, struct reada_extctl, list);\n\t\tlist_del(&rec->list);\n\t\trc = rec->rc;\n\t\tkfree(rec);\n\n\t\tkref_get(&rc->refcnt);\n\t\tif (atomic_dec_and_test(&rc->elems)) {\n\t\t\tkref_put(&rc->refcnt, reada_control_release);\n\t\t\twake_up(&rc->wait);\n\t\t}\n\t\tkref_put(&rc->refcnt, reada_control_release);\n\n\t\treada_extent_put(fs_info, re);\t/* one ref for each entry */\n\t}\n\treada_extent_put(fs_info, re);\t/* our ref */\n\tif (for_dev)\n\t\tatomic_dec(&for_dev->reada_in_flight);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reada_tree_block_flagged",
          "args": [
            "fs_info->extent_root",
            "logical",
            "mirror_num",
            "&eb"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "reada_tree_block_flagged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "1090-1120",
          "snippet": "int reada_tree_block_flagged(struct btrfs_root *root, u64 bytenr,\n\t\t\t int mirror_num, struct extent_buffer **eb)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(btree_inode)->io_tree;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn 0;\n\n\tset_bit(EXTENT_BUFFER_READAHEAD, &buf->bflags);\n\n\tret = read_extent_buffer_pages(io_tree, buf, 0, WAIT_PAGE_LOCK,\n\t\t\t\t       btree_get_extent, mirror_num);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags)) {\n\t\tfree_extent_buffer(buf);\n\t\treturn -EIO;\n\t} else if (extent_buffer_uptodate(buf)) {\n\t\t*eb = buf;\n\t} else {\n\t\tfree_extent_buffer(buf);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint reada_tree_block_flagged(struct btrfs_root *root, u64 bytenr,\n\t\t\t int mirror_num, struct extent_buffer **eb)\n{\n\tstruct extent_buffer *buf = NULL;\n\tstruct inode *btree_inode = root->fs_info->btree_inode;\n\tstruct extent_io_tree *io_tree = &BTRFS_I(btree_inode)->io_tree;\n\tint ret;\n\n\tbuf = btrfs_find_create_tree_block(root, bytenr);\n\tif (!buf)\n\t\treturn 0;\n\n\tset_bit(EXTENT_BUFFER_READAHEAD, &buf->bflags);\n\n\tret = read_extent_buffer_pages(io_tree, buf, 0, WAIT_PAGE_LOCK,\n\t\t\t\t       btree_get_extent, mirror_num);\n\tif (ret) {\n\t\tfree_extent_buffer(buf);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(EXTENT_BUFFER_CORRUPT, &buf->bflags)) {\n\t\tfree_extent_buffer(buf);\n\t\treturn -EIO;\n\t} else if (extent_buffer_uptodate(buf)) {\n\t\t*eb = buf;\n\t} else {\n\t\tfree_extent_buffer(buf);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&dev->reada_in_flight"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reada_extent_put",
          "args": [
            "fs_info",
            "re"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "reada_extent_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "494-536",
          "snippet": "static void reada_extent_put(struct btrfs_fs_info *fs_info,\n\t\t\t     struct reada_extent *re)\n{\n\tint i;\n\tunsigned long index = re->logical >> PAGE_CACHE_SHIFT;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (--re->refcnt) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn;\n\t}\n\n\tradix_tree_delete(&fs_info->reada_tree, index);\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tradix_tree_delete(&zone->device->reada_extents, index);\n\t}\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/* no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tif (re->scheduled_for)\n\t\tatomic_dec(&re->scheduled_for->reada_in_flight);\n\n\tkfree(re);\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_extent_put(struct btrfs_fs_info *fs_info,\n\t\t\t     struct reada_extent *re)\n{\n\tint i;\n\tunsigned long index = re->logical >> PAGE_CACHE_SHIFT;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (--re->refcnt) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn;\n\t}\n\n\tradix_tree_delete(&fs_info->reada_tree, index);\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tradix_tree_delete(&zone->device->reada_extents, index);\n\t}\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/* no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tif (re->scheduled_for)\n\t\tatomic_dec(&re->scheduled_for->reada_in_flight);\n\n\tkfree(re);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&re->lock"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&re->lock"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&dev->reada_extents",
            "(void **)&re",
            "dev->reada_next >> PAGE_CACHE_SHIFT",
            "1"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reada_pick_zone",
          "args": [
            "dev"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "reada_pick_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "605-652",
          "snippet": "static int reada_pick_zone(struct btrfs_device *dev)\n{\n\tstruct reada_zone *top_zone = NULL;\n\tstruct reada_zone *top_locked_zone = NULL;\n\tu64 top_elems = 0;\n\tu64 top_locked_elems = 0;\n\tunsigned long index = 0;\n\tint ret;\n\n\tif (dev->reada_curr_zone) {\n\t\treada_peer_zones_set_lock(dev->reada_curr_zone, 0);\n\t\tkref_put(&dev->reada_curr_zone->refcnt, reada_zone_release);\n\t\tdev->reada_curr_zone = NULL;\n\t}\n\t/* pick the zone with the most elements */\n\twhile (1) {\n\t\tstruct reada_zone *zone;\n\n\t\tret = radix_tree_gang_lookup(&dev->reada_zones,\n\t\t\t\t\t     (void **)&zone, index, 1);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tindex = (zone->end >> PAGE_CACHE_SHIFT) + 1;\n\t\tif (zone->locked) {\n\t\t\tif (zone->elems > top_locked_elems) {\n\t\t\t\ttop_locked_elems = zone->elems;\n\t\t\t\ttop_locked_zone = zone;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zone->elems > top_elems) {\n\t\t\t\ttop_elems = zone->elems;\n\t\t\t\ttop_zone = zone;\n\t\t\t}\n\t\t}\n\t}\n\tif (top_zone)\n\t\tdev->reada_curr_zone = top_zone;\n\telse if (top_locked_zone)\n\t\tdev->reada_curr_zone = top_locked_zone;\n\telse\n\t\treturn 0;\n\n\tdev->reada_next = dev->reada_curr_zone->start;\n\tkref_get(&dev->reada_curr_zone->refcnt);\n\treada_peer_zones_set_lock(dev->reada_curr_zone, 1);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int reada_pick_zone(struct btrfs_device *dev)\n{\n\tstruct reada_zone *top_zone = NULL;\n\tstruct reada_zone *top_locked_zone = NULL;\n\tu64 top_elems = 0;\n\tu64 top_locked_elems = 0;\n\tunsigned long index = 0;\n\tint ret;\n\n\tif (dev->reada_curr_zone) {\n\t\treada_peer_zones_set_lock(dev->reada_curr_zone, 0);\n\t\tkref_put(&dev->reada_curr_zone->refcnt, reada_zone_release);\n\t\tdev->reada_curr_zone = NULL;\n\t}\n\t/* pick the zone with the most elements */\n\twhile (1) {\n\t\tstruct reada_zone *zone;\n\n\t\tret = radix_tree_gang_lookup(&dev->reada_zones,\n\t\t\t\t\t     (void **)&zone, index, 1);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tindex = (zone->end >> PAGE_CACHE_SHIFT) + 1;\n\t\tif (zone->locked) {\n\t\t\tif (zone->elems > top_locked_elems) {\n\t\t\t\ttop_locked_elems = zone->elems;\n\t\t\t\ttop_locked_zone = zone;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zone->elems > top_elems) {\n\t\t\t\ttop_elems = zone->elems;\n\t\t\t\ttop_zone = zone;\n\t\t\t}\n\t\t}\n\t}\n\tif (top_zone)\n\t\tdev->reada_curr_zone = top_zone;\n\telse if (top_locked_zone)\n\t\tdev->reada_curr_zone = top_locked_zone;\n\telse\n\t\treturn 0;\n\n\tdev->reada_next = dev->reada_curr_zone->start;\n\tkref_get(&dev->reada_curr_zone->refcnt);\n\treada_peer_zones_set_lock(dev->reada_curr_zone, 1);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&dev->reada_extents",
            "(void **)&re",
            "dev->reada_next >> PAGE_CACHE_SHIFT",
            "1"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic int reada_start_machine_dev(struct btrfs_fs_info *fs_info,\n\t\t\t\t   struct btrfs_device *dev)\n{\n\tstruct reada_extent *re = NULL;\n\tint mirror_num = 0;\n\tstruct extent_buffer *eb = NULL;\n\tu64 logical;\n\tint ret;\n\tint i;\n\tint need_kick = 0;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (dev->reada_curr_zone == NULL) {\n\t\tret = reada_pick_zone(dev);\n\t\tif (!ret) {\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/*\n\t * FIXME currently we issue the reads one extent at a time. If we have\n\t * a contiguous block of extents, we could also coagulate them or use\n\t * plugging to speed things up\n\t */\n\tret = radix_tree_gang_lookup(&dev->reada_extents, (void **)&re,\n\t\t\t\t     dev->reada_next >> PAGE_CACHE_SHIFT, 1);\n\tif (ret == 0 || re->logical >= dev->reada_curr_zone->end) {\n\t\tret = reada_pick_zone(dev);\n\t\tif (!ret) {\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tre = NULL;\n\t\tret = radix_tree_gang_lookup(&dev->reada_extents, (void **)&re,\n\t\t\t\t\tdev->reada_next >> PAGE_CACHE_SHIFT, 1);\n\t}\n\tif (ret == 0) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn 0;\n\t}\n\tdev->reada_next = re->logical + fs_info->tree_root->nodesize;\n\tre->refcnt++;\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\t/*\n\t * find mirror num\n\t */\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tif (re->zones[i]->device == dev) {\n\t\t\tmirror_num = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tlogical = re->logical;\n\n\tspin_lock(&re->lock);\n\tif (re->scheduled_for == NULL) {\n\t\tre->scheduled_for = dev;\n\t\tneed_kick = 1;\n\t}\n\tspin_unlock(&re->lock);\n\n\treada_extent_put(fs_info, re);\n\n\tif (!need_kick)\n\t\treturn 0;\n\n\tatomic_inc(&dev->reada_in_flight);\n\tret = reada_tree_block_flagged(fs_info->extent_root, logical,\n\t\t\tmirror_num, &eb);\n\tif (ret)\n\t\t__readahead_hook(fs_info->extent_root, NULL, logical, ret);\n\telse if (eb)\n\t\t__readahead_hook(fs_info->extent_root, eb, eb->start, ret);\n\n\tif (eb)\n\t\tfree_extent_buffer(eb);\n\n\treturn 1;\n\n}"
  },
  {
    "function_name": "reada_pick_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "605-652",
    "snippet": "static int reada_pick_zone(struct btrfs_device *dev)\n{\n\tstruct reada_zone *top_zone = NULL;\n\tstruct reada_zone *top_locked_zone = NULL;\n\tu64 top_elems = 0;\n\tu64 top_locked_elems = 0;\n\tunsigned long index = 0;\n\tint ret;\n\n\tif (dev->reada_curr_zone) {\n\t\treada_peer_zones_set_lock(dev->reada_curr_zone, 0);\n\t\tkref_put(&dev->reada_curr_zone->refcnt, reada_zone_release);\n\t\tdev->reada_curr_zone = NULL;\n\t}\n\t/* pick the zone with the most elements */\n\twhile (1) {\n\t\tstruct reada_zone *zone;\n\n\t\tret = radix_tree_gang_lookup(&dev->reada_zones,\n\t\t\t\t\t     (void **)&zone, index, 1);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tindex = (zone->end >> PAGE_CACHE_SHIFT) + 1;\n\t\tif (zone->locked) {\n\t\t\tif (zone->elems > top_locked_elems) {\n\t\t\t\ttop_locked_elems = zone->elems;\n\t\t\t\ttop_locked_zone = zone;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zone->elems > top_elems) {\n\t\t\t\ttop_elems = zone->elems;\n\t\t\t\ttop_zone = zone;\n\t\t\t}\n\t\t}\n\t}\n\tif (top_zone)\n\t\tdev->reada_curr_zone = top_zone;\n\telse if (top_locked_zone)\n\t\tdev->reada_curr_zone = top_locked_zone;\n\telse\n\t\treturn 0;\n\n\tdev->reada_next = dev->reada_curr_zone->start;\n\tkref_get(&dev->reada_curr_zone->refcnt);\n\treada_peer_zones_set_lock(dev->reada_curr_zone, 1);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reada_peer_zones_set_lock",
          "args": [
            "dev->reada_curr_zone",
            "1"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "reada_peer_zones_set_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "589-600",
          "snippet": "static void reada_peer_zones_set_lock(struct reada_zone *zone, int lock)\n{\n\tint i;\n\tunsigned long index = zone->end >> PAGE_CACHE_SHIFT;\n\n\tfor (i = 0; i < zone->ndevs; ++i) {\n\t\tstruct reada_zone *peer;\n\t\tpeer = radix_tree_lookup(&zone->devs[i]->reada_zones, index);\n\t\tif (peer && peer->device != zone->device)\n\t\t\tpeer->locked = lock;\n\t}\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_peer_zones_set_lock(struct reada_zone *zone, int lock)\n{\n\tint i;\n\tunsigned long index = zone->end >> PAGE_CACHE_SHIFT;\n\n\tfor (i = 0; i < zone->ndevs; ++i) {\n\t\tstruct reada_zone *peer;\n\t\tpeer = radix_tree_lookup(&zone->devs[i]->reada_zones, index);\n\t\tif (peer && peer->device != zone->device)\n\t\t\tpeer->locked = lock;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&dev->reada_curr_zone->refcnt"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&dev->reada_zones",
            "(void **)&zone",
            "index",
            "1"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&dev->reada_curr_zone->refcnt",
            "reada_zone_release"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int reada_pick_zone(struct btrfs_device *dev)\n{\n\tstruct reada_zone *top_zone = NULL;\n\tstruct reada_zone *top_locked_zone = NULL;\n\tu64 top_elems = 0;\n\tu64 top_locked_elems = 0;\n\tunsigned long index = 0;\n\tint ret;\n\n\tif (dev->reada_curr_zone) {\n\t\treada_peer_zones_set_lock(dev->reada_curr_zone, 0);\n\t\tkref_put(&dev->reada_curr_zone->refcnt, reada_zone_release);\n\t\tdev->reada_curr_zone = NULL;\n\t}\n\t/* pick the zone with the most elements */\n\twhile (1) {\n\t\tstruct reada_zone *zone;\n\n\t\tret = radix_tree_gang_lookup(&dev->reada_zones,\n\t\t\t\t\t     (void **)&zone, index, 1);\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t\tindex = (zone->end >> PAGE_CACHE_SHIFT) + 1;\n\t\tif (zone->locked) {\n\t\t\tif (zone->elems > top_locked_elems) {\n\t\t\t\ttop_locked_elems = zone->elems;\n\t\t\t\ttop_locked_zone = zone;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zone->elems > top_elems) {\n\t\t\t\ttop_elems = zone->elems;\n\t\t\t\ttop_zone = zone;\n\t\t\t}\n\t\t}\n\t}\n\tif (top_zone)\n\t\tdev->reada_curr_zone = top_zone;\n\telse if (top_locked_zone)\n\t\tdev->reada_curr_zone = top_locked_zone;\n\telse\n\t\treturn 0;\n\n\tdev->reada_next = dev->reada_curr_zone->start;\n\tkref_get(&dev->reada_curr_zone->refcnt);\n\treada_peer_zones_set_lock(dev->reada_curr_zone, 1);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "reada_peer_zones_set_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "589-600",
    "snippet": "static void reada_peer_zones_set_lock(struct reada_zone *zone, int lock)\n{\n\tint i;\n\tunsigned long index = zone->end >> PAGE_CACHE_SHIFT;\n\n\tfor (i = 0; i < zone->ndevs; ++i) {\n\t\tstruct reada_zone *peer;\n\t\tpeer = radix_tree_lookup(&zone->devs[i]->reada_zones, index);\n\t\tif (peer && peer->device != zone->device)\n\t\t\tpeer->locked = lock;\n\t}\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&zone->devs[i]->reada_zones",
            "index"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_peer_zones_set_lock(struct reada_zone *zone, int lock)\n{\n\tint i;\n\tunsigned long index = zone->end >> PAGE_CACHE_SHIFT;\n\n\tfor (i = 0; i < zone->ndevs; ++i) {\n\t\tstruct reada_zone *peer;\n\t\tpeer = radix_tree_lookup(&zone->devs[i]->reada_zones, index);\n\t\tif (peer && peer->device != zone->device)\n\t\t\tpeer->locked = lock;\n\t}\n}"
  },
  {
    "function_name": "reada_add_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "556-584",
    "snippet": "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation)\n{\n\tstruct btrfs_root *root = rc->root;\n\tstruct reada_extent *re;\n\tstruct reada_extctl *rec;\n\n\tre = reada_find_extent(root, logical, top, level); /* takes one ref */\n\tif (!re)\n\t\treturn -1;\n\n\trec = kzalloc(sizeof(*rec), GFP_NOFS);\n\tif (!rec) {\n\t\treada_extent_put(root->fs_info, re);\n\t\treturn -1;\n\t}\n\n\trec->rc = rc;\n\trec->generation = generation;\n\tatomic_inc(&rc->elems);\n\n\tspin_lock(&re->lock);\n\tlist_add_tail(&rec->list, &re->extctl);\n\tspin_unlock(&re->lock);\n\n\t/* leave the ref on the extent */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&re->lock"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&rec->list",
            "&re->extctl"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&re->lock"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rc->elems"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reada_extent_put",
          "args": [
            "root->fs_info",
            "re"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "reada_extent_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "494-536",
          "snippet": "static void reada_extent_put(struct btrfs_fs_info *fs_info,\n\t\t\t     struct reada_extent *re)\n{\n\tint i;\n\tunsigned long index = re->logical >> PAGE_CACHE_SHIFT;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (--re->refcnt) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn;\n\t}\n\n\tradix_tree_delete(&fs_info->reada_tree, index);\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tradix_tree_delete(&zone->device->reada_extents, index);\n\t}\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/* no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tif (re->scheduled_for)\n\t\tatomic_dec(&re->scheduled_for->reada_in_flight);\n\n\tkfree(re);\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_extent_put(struct btrfs_fs_info *fs_info,\n\t\t\t     struct reada_extent *re)\n{\n\tint i;\n\tunsigned long index = re->logical >> PAGE_CACHE_SHIFT;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (--re->refcnt) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn;\n\t}\n\n\tradix_tree_delete(&fs_info->reada_tree, index);\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tradix_tree_delete(&zone->device->reada_extents, index);\n\t}\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/* no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tif (re->scheduled_for)\n\t\tatomic_dec(&re->scheduled_for->reada_in_flight);\n\n\tkfree(re);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*rec)",
            "GFP_NOFS"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reada_find_extent",
          "args": [
            "root",
            "logical",
            "top",
            "level"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "reada_find_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "318-492",
          "snippet": "static struct reada_extent *reada_find_extent(struct btrfs_root *root,\n\t\t\t\t\t      u64 logical,\n\t\t\t\t\t      struct btrfs_key *top, int level)\n{\n\tint ret;\n\tstruct reada_extent *re = NULL;\n\tstruct reada_extent *re_exist = NULL;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_device *prev_dev;\n\tu32 blocksize;\n\tu64 length;\n\tint nzones = 0;\n\tint i;\n\tunsigned long index = logical >> PAGE_CACHE_SHIFT;\n\tint dev_replace_is_ongoing;\n\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (re)\n\t\treturn re;\n\n\tre = kzalloc(sizeof(*re), GFP_NOFS);\n\tif (!re)\n\t\treturn NULL;\n\n\tblocksize = root->nodesize;\n\tre->logical = logical;\n\tre->top = *top;\n\tINIT_LIST_HEAD(&re->extctl);\n\tspin_lock_init(&re->lock);\n\tre->refcnt = 1;\n\n\t/*\n\t * map block\n\t */\n\tlength = blocksize;\n\tret = btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS, logical, &length,\n\t\t\t      &bbio, 0);\n\tif (ret || !bbio || length < blocksize)\n\t\tgoto error;\n\n\tif (bbio->num_stripes > BTRFS_MAX_MIRRORS) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t   \"readahead: more than %d copies not supported\",\n\t\t\t   BTRFS_MAX_MIRRORS);\n\t\tgoto error;\n\t}\n\n\tfor (nzones = 0; nzones < bbio->num_stripes; ++nzones) {\n\t\tstruct reada_zone *zone;\n\n\t\tdev = bbio->stripes[nzones].dev;\n\t\tzone = reada_find_zone(fs_info, dev, logical, bbio);\n\t\tif (!zone)\n\t\t\tbreak;\n\n\t\tre->zones[nzones] = zone;\n\t\tspin_lock(&zone->lock);\n\t\tif (!zone->elems)\n\t\t\tkref_get(&zone->refcnt);\n\t\t++zone->elems;\n\t\tspin_unlock(&zone->lock);\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tre->nzones = nzones;\n\tif (nzones == 0) {\n\t\t/* not a single zone found, error and out */\n\t\tgoto error;\n\t}\n\n\t/* insert extent in reada_tree + all per-device trees, all or nothing */\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_insert(&fs_info->reada_tree, index, re);\n\tif (ret == -EEXIST) {\n\t\tre_exist = radix_tree_lookup(&fs_info->reada_tree, index);\n\t\tBUG_ON(!re_exist);\n\t\tre_exist->refcnt++;\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tgoto error;\n\t}\n\tif (ret) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tgoto error;\n\t}\n\tprev_dev = NULL;\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(\n\t\t\t&fs_info->dev_replace);\n\tfor (i = 0; i < nzones; ++i) {\n\t\tdev = bbio->stripes[i].dev;\n\t\tif (dev == prev_dev) {\n\t\t\t/*\n\t\t\t * in case of DUP, just add the first zone. As both\n\t\t\t * are on the same device, there's nothing to gain\n\t\t\t * from adding both.\n\t\t\t * Also, it wouldn't work, as the tree is per device\n\t\t\t * and adding would fail with EEXIST\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->bdev) {\n\t\t\t/*\n\t\t\t * cannot read ahead on missing device, but for RAID5/6,\n\t\t\t * REQ_GET_READ_MIRRORS return 1. So don't skip missing\n\t\t\t * device for such case.\n\t\t\t */\n\t\t\tif (nzones > 1)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (dev_replace_is_ongoing &&\n\t\t    dev == fs_info->dev_replace.tgtdev) {\n\t\t\t/*\n\t\t\t * as this device is selected for reading only as\n\t\t\t * a last resort, skip it for read ahead.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tprev_dev = dev;\n\t\tret = radix_tree_insert(&dev->reada_extents, index, re);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0) {\n\t\t\t\tdev = bbio->stripes[i].dev;\n\t\t\t\tBUG_ON(dev == NULL);\n\t\t\t\t/* ignore whether the entry was inserted */\n\t\t\t\tradix_tree_delete(&dev->reada_extents, index);\n\t\t\t}\n\t\t\tBUG_ON(fs_info == NULL);\n\t\t\tradix_tree_delete(&fs_info->reada_tree, index);\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tbtrfs_put_bbio(bbio);\n\treturn re;\n\nerror:\n\twhile (nzones) {\n\t\tstruct reada_zone *zone;\n\n\t\t--nzones;\n\t\tzone = re->zones[nzones];\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/*\n\t\t\t * no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref\n\t\t\t */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tbtrfs_put_bbio(bbio);\n\tkfree(re);\n\treturn re_exist;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic struct reada_extent *reada_find_extent(struct btrfs_root *root,\n\t\t\t\t\t      u64 logical,\n\t\t\t\t\t      struct btrfs_key *top, int level)\n{\n\tint ret;\n\tstruct reada_extent *re = NULL;\n\tstruct reada_extent *re_exist = NULL;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_device *prev_dev;\n\tu32 blocksize;\n\tu64 length;\n\tint nzones = 0;\n\tint i;\n\tunsigned long index = logical >> PAGE_CACHE_SHIFT;\n\tint dev_replace_is_ongoing;\n\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (re)\n\t\treturn re;\n\n\tre = kzalloc(sizeof(*re), GFP_NOFS);\n\tif (!re)\n\t\treturn NULL;\n\n\tblocksize = root->nodesize;\n\tre->logical = logical;\n\tre->top = *top;\n\tINIT_LIST_HEAD(&re->extctl);\n\tspin_lock_init(&re->lock);\n\tre->refcnt = 1;\n\n\t/*\n\t * map block\n\t */\n\tlength = blocksize;\n\tret = btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS, logical, &length,\n\t\t\t      &bbio, 0);\n\tif (ret || !bbio || length < blocksize)\n\t\tgoto error;\n\n\tif (bbio->num_stripes > BTRFS_MAX_MIRRORS) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t   \"readahead: more than %d copies not supported\",\n\t\t\t   BTRFS_MAX_MIRRORS);\n\t\tgoto error;\n\t}\n\n\tfor (nzones = 0; nzones < bbio->num_stripes; ++nzones) {\n\t\tstruct reada_zone *zone;\n\n\t\tdev = bbio->stripes[nzones].dev;\n\t\tzone = reada_find_zone(fs_info, dev, logical, bbio);\n\t\tif (!zone)\n\t\t\tbreak;\n\n\t\tre->zones[nzones] = zone;\n\t\tspin_lock(&zone->lock);\n\t\tif (!zone->elems)\n\t\t\tkref_get(&zone->refcnt);\n\t\t++zone->elems;\n\t\tspin_unlock(&zone->lock);\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tre->nzones = nzones;\n\tif (nzones == 0) {\n\t\t/* not a single zone found, error and out */\n\t\tgoto error;\n\t}\n\n\t/* insert extent in reada_tree + all per-device trees, all or nothing */\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_insert(&fs_info->reada_tree, index, re);\n\tif (ret == -EEXIST) {\n\t\tre_exist = radix_tree_lookup(&fs_info->reada_tree, index);\n\t\tBUG_ON(!re_exist);\n\t\tre_exist->refcnt++;\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tgoto error;\n\t}\n\tif (ret) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tgoto error;\n\t}\n\tprev_dev = NULL;\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(\n\t\t\t&fs_info->dev_replace);\n\tfor (i = 0; i < nzones; ++i) {\n\t\tdev = bbio->stripes[i].dev;\n\t\tif (dev == prev_dev) {\n\t\t\t/*\n\t\t\t * in case of DUP, just add the first zone. As both\n\t\t\t * are on the same device, there's nothing to gain\n\t\t\t * from adding both.\n\t\t\t * Also, it wouldn't work, as the tree is per device\n\t\t\t * and adding would fail with EEXIST\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->bdev) {\n\t\t\t/*\n\t\t\t * cannot read ahead on missing device, but for RAID5/6,\n\t\t\t * REQ_GET_READ_MIRRORS return 1. So don't skip missing\n\t\t\t * device for such case.\n\t\t\t */\n\t\t\tif (nzones > 1)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (dev_replace_is_ongoing &&\n\t\t    dev == fs_info->dev_replace.tgtdev) {\n\t\t\t/*\n\t\t\t * as this device is selected for reading only as\n\t\t\t * a last resort, skip it for read ahead.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tprev_dev = dev;\n\t\tret = radix_tree_insert(&dev->reada_extents, index, re);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0) {\n\t\t\t\tdev = bbio->stripes[i].dev;\n\t\t\t\tBUG_ON(dev == NULL);\n\t\t\t\t/* ignore whether the entry was inserted */\n\t\t\t\tradix_tree_delete(&dev->reada_extents, index);\n\t\t\t}\n\t\t\tBUG_ON(fs_info == NULL);\n\t\t\tradix_tree_delete(&fs_info->reada_tree, index);\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tbtrfs_put_bbio(bbio);\n\treturn re;\n\nerror:\n\twhile (nzones) {\n\t\tstruct reada_zone *zone;\n\n\t\t--nzones;\n\t\tzone = re->zones[nzones];\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/*\n\t\t\t * no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref\n\t\t\t */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tbtrfs_put_bbio(bbio);\n\tkfree(re);\n\treturn re_exist;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);\n\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation)\n{\n\tstruct btrfs_root *root = rc->root;\n\tstruct reada_extent *re;\n\tstruct reada_extctl *rec;\n\n\tre = reada_find_extent(root, logical, top, level); /* takes one ref */\n\tif (!re)\n\t\treturn -1;\n\n\trec = kzalloc(sizeof(*rec), GFP_NOFS);\n\tif (!rec) {\n\t\treada_extent_put(root->fs_info, re);\n\t\treturn -1;\n\t}\n\n\trec->rc = rc;\n\trec->generation = generation;\n\tatomic_inc(&rc->elems);\n\n\tspin_lock(&re->lock);\n\tlist_add_tail(&rec->list, &re->extctl);\n\tspin_unlock(&re->lock);\n\n\t/* leave the ref on the extent */\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reada_control_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "548-554",
    "snippet": "static void reada_control_release(struct kref *kref)\n{\n\tstruct reada_control *rc = container_of(kref, struct reada_control,\n\t\t\t\t\t\trefcnt);\n\n\tkfree(rc);\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_control_release(struct kref *kref);",
      "static void reada_zone_release(struct kref *kref);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rc"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structreada_control",
            "refcnt"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_control_release(struct kref *kref);\nstatic void reada_zone_release(struct kref *kref);\n\nstatic void reada_control_release(struct kref *kref)\n{\n\tstruct reada_control *rc = container_of(kref, struct reada_control,\n\t\t\t\t\t\trefcnt);\n\n\tkfree(rc);\n}"
  },
  {
    "function_name": "reada_zone_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "538-546",
    "snippet": "static void reada_zone_release(struct kref *kref)\n{\n\tstruct reada_zone *zone = container_of(kref, struct reada_zone, refcnt);\n\n\tradix_tree_delete(&zone->device->reada_zones,\n\t\t\t  zone->end >> PAGE_CACHE_SHIFT);\n\n\tkfree(zone);\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_control_release(struct kref *kref);",
      "static void reada_zone_release(struct kref *kref);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "zone"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&zone->device->reada_zones",
            "zone->end >> PAGE_CACHE_SHIFT"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structreada_zone",
            "refcnt"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_control_release(struct kref *kref);\nstatic void reada_zone_release(struct kref *kref);\n\nstatic void reada_zone_release(struct kref *kref)\n{\n\tstruct reada_zone *zone = container_of(kref, struct reada_zone, refcnt);\n\n\tradix_tree_delete(&zone->device->reada_zones,\n\t\t\t  zone->end >> PAGE_CACHE_SHIFT);\n\n\tkfree(zone);\n}"
  },
  {
    "function_name": "reada_extent_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "494-536",
    "snippet": "static void reada_extent_put(struct btrfs_fs_info *fs_info,\n\t\t\t     struct reada_extent *re)\n{\n\tint i;\n\tunsigned long index = re->logical >> PAGE_CACHE_SHIFT;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (--re->refcnt) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn;\n\t}\n\n\tradix_tree_delete(&fs_info->reada_tree, index);\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tradix_tree_delete(&zone->device->reada_extents, index);\n\t}\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/* no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tif (re->scheduled_for)\n\t\tatomic_dec(&re->scheduled_for->reada_in_flight);\n\n\tkfree(re);\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "re"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&re->scheduled_for->reada_in_flight"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zone->refcnt",
            "reada_zone_release"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zone->refcnt",
            "reada_zone_release"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zone->refcnt"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&zone->device->reada_extents",
            "index"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&fs_info->reada_tree",
            "index"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_extent_put(struct btrfs_fs_info *fs_info,\n\t\t\t     struct reada_extent *re)\n{\n\tint i;\n\tunsigned long index = re->logical >> PAGE_CACHE_SHIFT;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (--re->refcnt) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn;\n\t}\n\n\tradix_tree_delete(&fs_info->reada_tree, index);\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tradix_tree_delete(&zone->device->reada_extents, index);\n\t}\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/* no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tif (re->scheduled_for)\n\t\tatomic_dec(&re->scheduled_for->reada_in_flight);\n\n\tkfree(re);\n}"
  },
  {
    "function_name": "reada_find_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "318-492",
    "snippet": "static struct reada_extent *reada_find_extent(struct btrfs_root *root,\n\t\t\t\t\t      u64 logical,\n\t\t\t\t\t      struct btrfs_key *top, int level)\n{\n\tint ret;\n\tstruct reada_extent *re = NULL;\n\tstruct reada_extent *re_exist = NULL;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_device *prev_dev;\n\tu32 blocksize;\n\tu64 length;\n\tint nzones = 0;\n\tint i;\n\tunsigned long index = logical >> PAGE_CACHE_SHIFT;\n\tint dev_replace_is_ongoing;\n\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (re)\n\t\treturn re;\n\n\tre = kzalloc(sizeof(*re), GFP_NOFS);\n\tif (!re)\n\t\treturn NULL;\n\n\tblocksize = root->nodesize;\n\tre->logical = logical;\n\tre->top = *top;\n\tINIT_LIST_HEAD(&re->extctl);\n\tspin_lock_init(&re->lock);\n\tre->refcnt = 1;\n\n\t/*\n\t * map block\n\t */\n\tlength = blocksize;\n\tret = btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS, logical, &length,\n\t\t\t      &bbio, 0);\n\tif (ret || !bbio || length < blocksize)\n\t\tgoto error;\n\n\tif (bbio->num_stripes > BTRFS_MAX_MIRRORS) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t   \"readahead: more than %d copies not supported\",\n\t\t\t   BTRFS_MAX_MIRRORS);\n\t\tgoto error;\n\t}\n\n\tfor (nzones = 0; nzones < bbio->num_stripes; ++nzones) {\n\t\tstruct reada_zone *zone;\n\n\t\tdev = bbio->stripes[nzones].dev;\n\t\tzone = reada_find_zone(fs_info, dev, logical, bbio);\n\t\tif (!zone)\n\t\t\tbreak;\n\n\t\tre->zones[nzones] = zone;\n\t\tspin_lock(&zone->lock);\n\t\tif (!zone->elems)\n\t\t\tkref_get(&zone->refcnt);\n\t\t++zone->elems;\n\t\tspin_unlock(&zone->lock);\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tre->nzones = nzones;\n\tif (nzones == 0) {\n\t\t/* not a single zone found, error and out */\n\t\tgoto error;\n\t}\n\n\t/* insert extent in reada_tree + all per-device trees, all or nothing */\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_insert(&fs_info->reada_tree, index, re);\n\tif (ret == -EEXIST) {\n\t\tre_exist = radix_tree_lookup(&fs_info->reada_tree, index);\n\t\tBUG_ON(!re_exist);\n\t\tre_exist->refcnt++;\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tgoto error;\n\t}\n\tif (ret) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tgoto error;\n\t}\n\tprev_dev = NULL;\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(\n\t\t\t&fs_info->dev_replace);\n\tfor (i = 0; i < nzones; ++i) {\n\t\tdev = bbio->stripes[i].dev;\n\t\tif (dev == prev_dev) {\n\t\t\t/*\n\t\t\t * in case of DUP, just add the first zone. As both\n\t\t\t * are on the same device, there's nothing to gain\n\t\t\t * from adding both.\n\t\t\t * Also, it wouldn't work, as the tree is per device\n\t\t\t * and adding would fail with EEXIST\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->bdev) {\n\t\t\t/*\n\t\t\t * cannot read ahead on missing device, but for RAID5/6,\n\t\t\t * REQ_GET_READ_MIRRORS return 1. So don't skip missing\n\t\t\t * device for such case.\n\t\t\t */\n\t\t\tif (nzones > 1)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (dev_replace_is_ongoing &&\n\t\t    dev == fs_info->dev_replace.tgtdev) {\n\t\t\t/*\n\t\t\t * as this device is selected for reading only as\n\t\t\t * a last resort, skip it for read ahead.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tprev_dev = dev;\n\t\tret = radix_tree_insert(&dev->reada_extents, index, re);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0) {\n\t\t\t\tdev = bbio->stripes[i].dev;\n\t\t\t\tBUG_ON(dev == NULL);\n\t\t\t\t/* ignore whether the entry was inserted */\n\t\t\t\tradix_tree_delete(&dev->reada_extents, index);\n\t\t\t}\n\t\t\tBUG_ON(fs_info == NULL);\n\t\t\tradix_tree_delete(&fs_info->reada_tree, index);\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tbtrfs_put_bbio(bbio);\n\treturn re;\n\nerror:\n\twhile (nzones) {\n\t\tstruct reada_zone *zone;\n\n\t\t--nzones;\n\t\tzone = re->zones[nzones];\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/*\n\t\t\t * no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref\n\t\t\t */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tbtrfs_put_bbio(bbio);\n\tkfree(re);\n\treturn re_exist;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "re"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_bbio",
          "args": [
            "bbio"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_bbio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "4933-4939",
          "snippet": "void btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_put_bbio(struct btrfs_bio *bbio)\n{\n\tif (!bbio)\n\t\treturn;\n\tif (atomic_dec_and_test(&bbio->refs))\n\t\tkfree(bbio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zone->refcnt",
            "reada_zone_release"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zone->refcnt",
            "reada_zone_release"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zone->refcnt"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_unlock",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "895-909",
          "snippet": "void btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_unlock(struct btrfs_dev_replace *dev_replace)\n{\n\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tWARN_ON(atomic_read(&dev_replace->nesting_level) < 1);\n\tWARN_ON(dev_replace->lock_owner != current->pid);\n\tatomic_dec(&dev_replace->nesting_level);\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\n\t\tdev_replace->lock_owner = 0;\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\tmutex_unlock(&dev_replace->lock);\n\t} else {\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&fs_info->reada_tree",
            "index"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fs_info == NULL"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&dev->reada_extents",
            "index"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dev == NULL"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&dev->reada_extents",
            "index",
            "re"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_is_ongoing",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_is_ongoing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "840-865",
          "snippet": "int btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\n\nint btrfs_dev_replace_is_ongoing(struct btrfs_dev_replace *dev_replace)\n{\n\tif (!dev_replace->is_valid)\n\t\treturn 0;\n\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\t/*\n\t\t * return true even if tgtdev is missing (this is\n\t\t * something that can happen if the dev_replace\n\t\t * procedure is suspended by an umount and then\n\t\t * the tgtdev is missing (or \"btrfs dev scan\") was\n\t\t * not called and the the filesystem is remounted\n\t\t * in degraded state. This does not stop the\n\t\t * dev_replace procedure. It needs to be canceled\n\t\t * manually if the cancelation is wanted.\n\t\t */\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!re_exist"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&fs_info->reada_tree",
            "index"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_lock",
          "args": [
            "&fs_info->dev_replace"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "867-893",
          "snippet": "void btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nvoid btrfs_dev_replace_lock(struct btrfs_dev_replace *dev_replace)\n{\n\t/* the beginning is just an optimization for the typical case */\n\tif (atomic_read(&dev_replace->nesting_level) == 0) {\nacquire_lock:\n\t\t/* this is not a nested case where the same thread\n\t\t * is trying to acqurire the same lock twice */\n\t\tmutex_lock(&dev_replace->lock);\n\t\tmutex_lock(&dev_replace->lock_management_lock);\n\t\tdev_replace->lock_owner = current->pid;\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_lock(&dev_replace->lock_management_lock);\n\tif (atomic_read(&dev_replace->nesting_level) > 0 &&\n\t    dev_replace->lock_owner == current->pid) {\n\t\tWARN_ON(!mutex_is_locked(&dev_replace->lock));\n\t\tatomic_inc(&dev_replace->nesting_level);\n\t\tmutex_unlock(&dev_replace->lock_management_lock);\n\t\treturn;\n\t}\n\n\tmutex_unlock(&dev_replace->lock_management_lock);\n\tgoto acquire_lock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zone->refcnt",
            "reada_zone_release"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zone->refcnt"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reada_find_zone",
          "args": [
            "fs_info",
            "dev",
            "logical",
            "bbio"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "reada_find_zone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "248-316",
          "snippet": "static struct reada_zone *reada_find_zone(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  struct btrfs_device *dev, u64 logical,\n\t\t\t\t\t  struct btrfs_bio *bbio)\n{\n\tint ret;\n\tstruct reada_zone *zone;\n\tstruct btrfs_block_group_cache *cache = NULL;\n\tu64 start;\n\tu64 end;\n\tint i;\n\n\tzone = NULL;\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_gang_lookup(&dev->reada_zones, (void **)&zone,\n\t\t\t\t     logical >> PAGE_CACHE_SHIFT, 1);\n\tif (ret == 1)\n\t\tkref_get(&zone->refcnt);\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (ret == 1) {\n\t\tif (logical >= zone->start && logical < zone->end)\n\t\t\treturn zone;\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\n\tcache = btrfs_lookup_block_group(fs_info, logical);\n\tif (!cache)\n\t\treturn NULL;\n\n\tstart = cache->key.objectid;\n\tend = start + cache->key.offset - 1;\n\tbtrfs_put_block_group(cache);\n\n\tzone = kzalloc(sizeof(*zone), GFP_NOFS);\n\tif (!zone)\n\t\treturn NULL;\n\n\tzone->start = start;\n\tzone->end = end;\n\tINIT_LIST_HEAD(&zone->list);\n\tspin_lock_init(&zone->lock);\n\tzone->locked = 0;\n\tkref_init(&zone->refcnt);\n\tzone->elems = 0;\n\tzone->device = dev; /* our device always sits at index 0 */\n\tfor (i = 0; i < bbio->num_stripes; ++i) {\n\t\t/* bounds have already been checked */\n\t\tzone->devs[i] = bbio->stripes[i].dev;\n\t}\n\tzone->ndevs = bbio->num_stripes;\n\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_insert(&dev->reada_zones,\n\t\t\t\t(unsigned long)(zone->end >> PAGE_CACHE_SHIFT),\n\t\t\t\tzone);\n\n\tif (ret == -EEXIST) {\n\t\tkfree(zone);\n\t\tret = radix_tree_gang_lookup(&dev->reada_zones, (void **)&zone,\n\t\t\t\t\t     logical >> PAGE_CACHE_SHIFT, 1);\n\t\tif (ret == 1)\n\t\t\tkref_get(&zone->refcnt);\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n\n\treturn zone;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic struct reada_zone *reada_find_zone(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  struct btrfs_device *dev, u64 logical,\n\t\t\t\t\t  struct btrfs_bio *bbio)\n{\n\tint ret;\n\tstruct reada_zone *zone;\n\tstruct btrfs_block_group_cache *cache = NULL;\n\tu64 start;\n\tu64 end;\n\tint i;\n\n\tzone = NULL;\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_gang_lookup(&dev->reada_zones, (void **)&zone,\n\t\t\t\t     logical >> PAGE_CACHE_SHIFT, 1);\n\tif (ret == 1)\n\t\tkref_get(&zone->refcnt);\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (ret == 1) {\n\t\tif (logical >= zone->start && logical < zone->end)\n\t\t\treturn zone;\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\n\tcache = btrfs_lookup_block_group(fs_info, logical);\n\tif (!cache)\n\t\treturn NULL;\n\n\tstart = cache->key.objectid;\n\tend = start + cache->key.offset - 1;\n\tbtrfs_put_block_group(cache);\n\n\tzone = kzalloc(sizeof(*zone), GFP_NOFS);\n\tif (!zone)\n\t\treturn NULL;\n\n\tzone->start = start;\n\tzone->end = end;\n\tINIT_LIST_HEAD(&zone->list);\n\tspin_lock_init(&zone->lock);\n\tzone->locked = 0;\n\tkref_init(&zone->refcnt);\n\tzone->elems = 0;\n\tzone->device = dev; /* our device always sits at index 0 */\n\tfor (i = 0; i < bbio->num_stripes; ++i) {\n\t\t/* bounds have already been checked */\n\t\tzone->devs[i] = bbio->stripes[i].dev;\n\t}\n\tzone->ndevs = bbio->num_stripes;\n\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_insert(&dev->reada_zones,\n\t\t\t\t(unsigned long)(zone->end >> PAGE_CACHE_SHIFT),\n\t\t\t\tzone);\n\n\tif (ret == -EEXIST) {\n\t\tkfree(zone);\n\t\tret = radix_tree_gang_lookup(&dev->reada_zones, (void **)&zone,\n\t\t\t\t\t     logical >> PAGE_CACHE_SHIFT, 1);\n\t\tif (ret == 1)\n\t\t\tkref_get(&zone->refcnt);\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n\n\treturn zone;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"readahead: more than %d copies not supported\"",
            "BTRFS_MAX_MIRRORS"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_error_unpin_extent_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "9705-9708",
          "snippet": "int btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_error_unpin_extent_range(struct btrfs_root *root, u64 start, u64 end)\n{\n\treturn unpin_extent_range(root, start, end, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_map_block",
          "args": [
            "fs_info",
            "REQ_GET_READ_MIRRORS",
            "logical",
            "&length",
            "&bbio",
            "0"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_map_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "5484-5490",
          "snippet": "int btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_map_block(struct btrfs_fs_info *fs_info, int rw,\n\t\t      u64 logical, u64 *length,\n\t\t      struct btrfs_bio **bbio_ret, int mirror_num)\n{\n\treturn __btrfs_map_block(fs_info, rw, logical, length, bbio_ret,\n\t\t\t\t mirror_num, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&re->lock"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&re->extctl"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*re)",
            "GFP_NOFS"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&fs_info->reada_tree",
            "index"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic struct reada_extent *reada_find_extent(struct btrfs_root *root,\n\t\t\t\t\t      u64 logical,\n\t\t\t\t\t      struct btrfs_key *top, int level)\n{\n\tint ret;\n\tstruct reada_extent *re = NULL;\n\tstruct reada_extent *re_exist = NULL;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_bio *bbio = NULL;\n\tstruct btrfs_device *dev;\n\tstruct btrfs_device *prev_dev;\n\tu32 blocksize;\n\tu64 length;\n\tint nzones = 0;\n\tint i;\n\tunsigned long index = logical >> PAGE_CACHE_SHIFT;\n\tint dev_replace_is_ongoing;\n\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (re)\n\t\treturn re;\n\n\tre = kzalloc(sizeof(*re), GFP_NOFS);\n\tif (!re)\n\t\treturn NULL;\n\n\tblocksize = root->nodesize;\n\tre->logical = logical;\n\tre->top = *top;\n\tINIT_LIST_HEAD(&re->extctl);\n\tspin_lock_init(&re->lock);\n\tre->refcnt = 1;\n\n\t/*\n\t * map block\n\t */\n\tlength = blocksize;\n\tret = btrfs_map_block(fs_info, REQ_GET_READ_MIRRORS, logical, &length,\n\t\t\t      &bbio, 0);\n\tif (ret || !bbio || length < blocksize)\n\t\tgoto error;\n\n\tif (bbio->num_stripes > BTRFS_MAX_MIRRORS) {\n\t\tbtrfs_err(root->fs_info,\n\t\t\t   \"readahead: more than %d copies not supported\",\n\t\t\t   BTRFS_MAX_MIRRORS);\n\t\tgoto error;\n\t}\n\n\tfor (nzones = 0; nzones < bbio->num_stripes; ++nzones) {\n\t\tstruct reada_zone *zone;\n\n\t\tdev = bbio->stripes[nzones].dev;\n\t\tzone = reada_find_zone(fs_info, dev, logical, bbio);\n\t\tif (!zone)\n\t\t\tbreak;\n\n\t\tre->zones[nzones] = zone;\n\t\tspin_lock(&zone->lock);\n\t\tif (!zone->elems)\n\t\t\tkref_get(&zone->refcnt);\n\t\t++zone->elems;\n\t\tspin_unlock(&zone->lock);\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tre->nzones = nzones;\n\tif (nzones == 0) {\n\t\t/* not a single zone found, error and out */\n\t\tgoto error;\n\t}\n\n\t/* insert extent in reada_tree + all per-device trees, all or nothing */\n\tbtrfs_dev_replace_lock(&fs_info->dev_replace);\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_insert(&fs_info->reada_tree, index, re);\n\tif (ret == -EEXIST) {\n\t\tre_exist = radix_tree_lookup(&fs_info->reada_tree, index);\n\t\tBUG_ON(!re_exist);\n\t\tre_exist->refcnt++;\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tgoto error;\n\t}\n\tif (ret) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\tgoto error;\n\t}\n\tprev_dev = NULL;\n\tdev_replace_is_ongoing = btrfs_dev_replace_is_ongoing(\n\t\t\t&fs_info->dev_replace);\n\tfor (i = 0; i < nzones; ++i) {\n\t\tdev = bbio->stripes[i].dev;\n\t\tif (dev == prev_dev) {\n\t\t\t/*\n\t\t\t * in case of DUP, just add the first zone. As both\n\t\t\t * are on the same device, there's nothing to gain\n\t\t\t * from adding both.\n\t\t\t * Also, it wouldn't work, as the tree is per device\n\t\t\t * and adding would fail with EEXIST\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tif (!dev->bdev) {\n\t\t\t/*\n\t\t\t * cannot read ahead on missing device, but for RAID5/6,\n\t\t\t * REQ_GET_READ_MIRRORS return 1. So don't skip missing\n\t\t\t * device for such case.\n\t\t\t */\n\t\t\tif (nzones > 1)\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (dev_replace_is_ongoing &&\n\t\t    dev == fs_info->dev_replace.tgtdev) {\n\t\t\t/*\n\t\t\t * as this device is selected for reading only as\n\t\t\t * a last resort, skip it for read ahead.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\t\tprev_dev = dev;\n\t\tret = radix_tree_insert(&dev->reada_extents, index, re);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0) {\n\t\t\t\tdev = bbio->stripes[i].dev;\n\t\t\t\tBUG_ON(dev == NULL);\n\t\t\t\t/* ignore whether the entry was inserted */\n\t\t\t\tradix_tree_delete(&dev->reada_extents, index);\n\t\t\t}\n\t\t\tBUG_ON(fs_info == NULL);\n\t\t\tradix_tree_delete(&fs_info->reada_tree, index);\n\t\t\tspin_unlock(&fs_info->reada_lock);\n\t\t\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\t\t\tgoto error;\n\t\t}\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n\tbtrfs_dev_replace_unlock(&fs_info->dev_replace);\n\n\tbtrfs_put_bbio(bbio);\n\treturn re;\n\nerror:\n\twhile (nzones) {\n\t\tstruct reada_zone *zone;\n\n\t\t--nzones;\n\t\tzone = re->zones[nzones];\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/*\n\t\t\t * no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref\n\t\t\t */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tbtrfs_put_bbio(bbio);\n\tkfree(re);\n\treturn re_exist;\n}"
  },
  {
    "function_name": "reada_find_zone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "248-316",
    "snippet": "static struct reada_zone *reada_find_zone(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  struct btrfs_device *dev, u64 logical,\n\t\t\t\t\t  struct btrfs_bio *bbio)\n{\n\tint ret;\n\tstruct reada_zone *zone;\n\tstruct btrfs_block_group_cache *cache = NULL;\n\tu64 start;\n\tu64 end;\n\tint i;\n\n\tzone = NULL;\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_gang_lookup(&dev->reada_zones, (void **)&zone,\n\t\t\t\t     logical >> PAGE_CACHE_SHIFT, 1);\n\tif (ret == 1)\n\t\tkref_get(&zone->refcnt);\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (ret == 1) {\n\t\tif (logical >= zone->start && logical < zone->end)\n\t\t\treturn zone;\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\n\tcache = btrfs_lookup_block_group(fs_info, logical);\n\tif (!cache)\n\t\treturn NULL;\n\n\tstart = cache->key.objectid;\n\tend = start + cache->key.offset - 1;\n\tbtrfs_put_block_group(cache);\n\n\tzone = kzalloc(sizeof(*zone), GFP_NOFS);\n\tif (!zone)\n\t\treturn NULL;\n\n\tzone->start = start;\n\tzone->end = end;\n\tINIT_LIST_HEAD(&zone->list);\n\tspin_lock_init(&zone->lock);\n\tzone->locked = 0;\n\tkref_init(&zone->refcnt);\n\tzone->elems = 0;\n\tzone->device = dev; /* our device always sits at index 0 */\n\tfor (i = 0; i < bbio->num_stripes; ++i) {\n\t\t/* bounds have already been checked */\n\t\tzone->devs[i] = bbio->stripes[i].dev;\n\t}\n\tzone->ndevs = bbio->num_stripes;\n\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_insert(&dev->reada_zones,\n\t\t\t\t(unsigned long)(zone->end >> PAGE_CACHE_SHIFT),\n\t\t\t\tzone);\n\n\tif (ret == -EEXIST) {\n\t\tkfree(zone);\n\t\tret = radix_tree_gang_lookup(&dev->reada_zones, (void **)&zone,\n\t\t\t\t\t     logical >> PAGE_CACHE_SHIFT, 1);\n\t\tif (ret == 1)\n\t\t\tkref_get(&zone->refcnt);\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n\n\treturn zone;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zone->refcnt"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&dev->reada_zones",
            "(void **)&zone",
            "logical >> PAGE_CACHE_SHIFT",
            "1"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "zone"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&dev->reada_zones",
            "(unsigned long)(zone->end >> PAGE_CACHE_SHIFT)",
            "zone"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_radix_tree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1078-1083",
          "snippet": "static inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void f2fs_radix_tree_insert(struct radix_tree_root *root,\n\t\t\t\tunsigned long index, void *item)\n{\n\twhile (radix_tree_insert(root, index, item))\n\t\tcond_resched();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fs_info->reada_lock"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&zone->refcnt"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&zone->lock"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&zone->list"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*zone)",
            "GFP_NOFS"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_put_block_group",
          "args": [
            "cache"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_put_block_group_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8797-8829",
          "snippet": "void btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nvoid btrfs_put_block_group_cache(struct btrfs_fs_info *info)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 last = 0;\n\n\twhile (1) {\n\t\tstruct inode *inode;\n\n\t\tblock_group = btrfs_lookup_first_block_group(info, last);\n\t\twhile (block_group) {\n\t\t\tspin_lock(&block_group->lock);\n\t\t\tif (block_group->iref)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tblock_group = next_block_group(info->tree_root,\n\t\t\t\t\t\t       block_group);\n\t\t}\n\t\tif (!block_group) {\n\t\t\tif (last == 0)\n\t\t\t\tbreak;\n\t\t\tlast = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tinode = block_group->inode;\n\t\tblock_group->iref = 0;\n\t\tblock_group->inode = NULL;\n\t\tspin_unlock(&block_group->lock);\n\t\tiput(inode);\n\t\tlast = block_group->key.objectid + block_group->key.offset;\n\t\tbtrfs_put_block_group(block_group);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_block_group",
          "args": [
            "fs_info",
            "logical"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_block_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "669-678",
          "snippet": "struct btrfs_block_group_cache *btrfs_lookup_block_group(\n\t\t\t\t\t\t struct btrfs_fs_info *info,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = block_group_cache_tree_search(info, bytenr, 1);\n\n\treturn cache;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_block_group_cache *btrfs_lookup_block_group(\n\t\t\t\t\t\t struct btrfs_fs_info *info,\n\t\t\t\t\t\t u64 bytenr)\n{\n\tstruct btrfs_block_group_cache *cache;\n\n\tcache = block_group_cache_tree_search(info, bytenr, 1);\n\n\treturn cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&zone->refcnt",
            "reada_zone_release"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&zone->refcnt"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup",
          "args": [
            "&dev->reada_zones",
            "(void **)&zone",
            "logical >> PAGE_CACHE_SHIFT",
            "1"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic struct reada_zone *reada_find_zone(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t  struct btrfs_device *dev, u64 logical,\n\t\t\t\t\t  struct btrfs_bio *bbio)\n{\n\tint ret;\n\tstruct reada_zone *zone;\n\tstruct btrfs_block_group_cache *cache = NULL;\n\tu64 start;\n\tu64 end;\n\tint i;\n\n\tzone = NULL;\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_gang_lookup(&dev->reada_zones, (void **)&zone,\n\t\t\t\t     logical >> PAGE_CACHE_SHIFT, 1);\n\tif (ret == 1)\n\t\tkref_get(&zone->refcnt);\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (ret == 1) {\n\t\tif (logical >= zone->start && logical < zone->end)\n\t\t\treturn zone;\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\n\tcache = btrfs_lookup_block_group(fs_info, logical);\n\tif (!cache)\n\t\treturn NULL;\n\n\tstart = cache->key.objectid;\n\tend = start + cache->key.offset - 1;\n\tbtrfs_put_block_group(cache);\n\n\tzone = kzalloc(sizeof(*zone), GFP_NOFS);\n\tif (!zone)\n\t\treturn NULL;\n\n\tzone->start = start;\n\tzone->end = end;\n\tINIT_LIST_HEAD(&zone->list);\n\tspin_lock_init(&zone->lock);\n\tzone->locked = 0;\n\tkref_init(&zone->refcnt);\n\tzone->elems = 0;\n\tzone->device = dev; /* our device always sits at index 0 */\n\tfor (i = 0; i < bbio->num_stripes; ++i) {\n\t\t/* bounds have already been checked */\n\t\tzone->devs[i] = bbio->stripes[i].dev;\n\t}\n\tzone->ndevs = bbio->num_stripes;\n\n\tspin_lock(&fs_info->reada_lock);\n\tret = radix_tree_insert(&dev->reada_zones,\n\t\t\t\t(unsigned long)(zone->end >> PAGE_CACHE_SHIFT),\n\t\t\t\tzone);\n\n\tif (ret == -EEXIST) {\n\t\tkfree(zone);\n\t\tret = radix_tree_gang_lookup(&dev->reada_zones, (void **)&zone,\n\t\t\t\t\t     logical >> PAGE_CACHE_SHIFT, 1);\n\t\tif (ret == 1)\n\t\t\tkref_get(&zone->refcnt);\n\t}\n\tspin_unlock(&fs_info->reada_lock);\n\n\treturn zone;\n}"
  },
  {
    "function_name": "btree_readahead_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "236-246",
    "snippet": "int btree_readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t u64 start, int err)\n{\n\tint ret;\n\n\tret = __readahead_hook(root, eb, start, err);\n\n\treada_start_machine(root->fs_info);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reada_start_machine",
          "args": [
            "root->fs_info"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "reada_start_machine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "788-802",
          "snippet": "static void reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct reada_machine_work *rmw;\n\n\trmw = kzalloc(sizeof(*rmw), GFP_NOFS);\n\tif (!rmw) {\n\t\t/* FIXME we cannot handle this properly right now */\n\t\tBUG();\n\t}\n\tbtrfs_init_work(&rmw->work, btrfs_readahead_helper,\n\t\t\treada_start_machine_worker, NULL, NULL);\n\trmw->fs_info = fs_info;\n\n\tbtrfs_queue_work(fs_info->readahead_workers, &rmw->work);\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info)\n{\n\tstruct reada_machine_work *rmw;\n\n\trmw = kzalloc(sizeof(*rmw), GFP_NOFS);\n\tif (!rmw) {\n\t\t/* FIXME we cannot handle this properly right now */\n\t\tBUG();\n\t}\n\tbtrfs_init_work(&rmw->work, btrfs_readahead_helper,\n\t\t\treada_start_machine_worker, NULL, NULL);\n\trmw->fs_info = fs_info;\n\n\tbtrfs_queue_work(fs_info->readahead_workers, &rmw->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__readahead_hook",
          "args": [
            "root",
            "eb",
            "start",
            "err"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "__readahead_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "108-230",
          "snippet": "static int __readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t    u64 start, int err)\n{\n\tint level = 0;\n\tint nritems;\n\tint i;\n\tu64 bytenr;\n\tu64 generation;\n\tstruct reada_extent *re;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head list;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct btrfs_device *for_dev;\n\n\tif (eb)\n\t\tlevel = btrfs_header_level(eb);\n\n\t/* find extent */\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (!re)\n\t\treturn -1;\n\n\tspin_lock(&re->lock);\n\t/*\n\t * just take the full list from the extent. afterwards we\n\t * don't need the lock anymore\n\t */\n\tlist_replace_init(&re->extctl, &list);\n\tfor_dev = re->scheduled_for;\n\tre->scheduled_for = NULL;\n\tspin_unlock(&re->lock);\n\n\tif (err == 0) {\n\t\tnritems = level ? btrfs_header_nritems(eb) : 0;\n\t\tgeneration = btrfs_header_generation(eb);\n\t\t/*\n\t\t * FIXME: currently we just set nritems to 0 if this is a leaf,\n\t\t * effectively ignoring the content. In a next step we could\n\t\t * trigger more readahead depending from the content, e.g.\n\t\t * fetch the checksums for the extents in the leaf.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * this is the error case, the extent buffer has not been\n\t\t * read correctly. We won't access anything from it and\n\t\t * just cleanup our data structures. Effectively this will\n\t\t * cut the branch below this node from read ahead.\n\t\t */\n\t\tnritems = 0;\n\t\tgeneration = 0;\n\t}\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct reada_extctl *rec;\n\t\tu64 n_gen;\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_key next_key;\n\n\t\tbtrfs_node_key_to_cpu(eb, &key, i);\n\t\tif (i + 1 < nritems)\n\t\t\tbtrfs_node_key_to_cpu(eb, &next_key, i + 1);\n\t\telse\n\t\t\tnext_key = re->top;\n\t\tbytenr = btrfs_node_blockptr(eb, i);\n\t\tn_gen = btrfs_node_ptr_generation(eb, i);\n\n\t\tlist_for_each_entry(rec, &list, list) {\n\t\t\tstruct reada_control *rc = rec->rc;\n\n\t\t\t/*\n\t\t\t * if the generation doesn't match, just ignore this\n\t\t\t * extctl. This will probably cut off a branch from\n\t\t\t * prefetch. Alternatively one could start a new (sub-)\n\t\t\t * prefetch for this branch, starting again from root.\n\t\t\t * FIXME: move the generation check out of this loop\n\t\t\t */\n#ifdef DEBUG\n\t\t\tif (rec->generation != generation) {\n\t\t\t\tbtrfs_debug(root->fs_info,\n\t\t\t\t\t   \"generation mismatch for (%llu,%d,%llu) %llu != %llu\",\n\t\t\t\t       key.objectid, key.type, key.offset,\n\t\t\t\t       rec->generation, generation);\n\t\t\t}\n#endif\n\t\t\tif (rec->generation == generation &&\n\t\t\t    btrfs_comp_cpu_keys(&key, &rc->key_end) < 0 &&\n\t\t\t    btrfs_comp_cpu_keys(&next_key, &rc->key_start) > 0)\n\t\t\t\treada_add_block(rc, bytenr, &next_key,\n\t\t\t\t\t\tlevel - 1, n_gen);\n\t\t}\n\t}\n\t/*\n\t * free extctl records\n\t */\n\twhile (!list_empty(&list)) {\n\t\tstruct reada_control *rc;\n\t\tstruct reada_extctl *rec;\n\n\t\trec = list_first_entry(&list, struct reada_extctl, list);\n\t\tlist_del(&rec->list);\n\t\trc = rec->rc;\n\t\tkfree(rec);\n\n\t\tkref_get(&rc->refcnt);\n\t\tif (atomic_dec_and_test(&rc->elems)) {\n\t\t\tkref_put(&rc->refcnt, reada_control_release);\n\t\t\twake_up(&rc->wait);\n\t\t}\n\t\tkref_put(&rc->refcnt, reada_control_release);\n\n\t\treada_extent_put(fs_info, re);\t/* one ref for each entry */\n\t}\n\treada_extent_put(fs_info, re);\t/* our ref */\n\tif (for_dev)\n\t\tatomic_dec(&for_dev->reada_in_flight);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);\n\nstatic int __readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t    u64 start, int err)\n{\n\tint level = 0;\n\tint nritems;\n\tint i;\n\tu64 bytenr;\n\tu64 generation;\n\tstruct reada_extent *re;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head list;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct btrfs_device *for_dev;\n\n\tif (eb)\n\t\tlevel = btrfs_header_level(eb);\n\n\t/* find extent */\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (!re)\n\t\treturn -1;\n\n\tspin_lock(&re->lock);\n\t/*\n\t * just take the full list from the extent. afterwards we\n\t * don't need the lock anymore\n\t */\n\tlist_replace_init(&re->extctl, &list);\n\tfor_dev = re->scheduled_for;\n\tre->scheduled_for = NULL;\n\tspin_unlock(&re->lock);\n\n\tif (err == 0) {\n\t\tnritems = level ? btrfs_header_nritems(eb) : 0;\n\t\tgeneration = btrfs_header_generation(eb);\n\t\t/*\n\t\t * FIXME: currently we just set nritems to 0 if this is a leaf,\n\t\t * effectively ignoring the content. In a next step we could\n\t\t * trigger more readahead depending from the content, e.g.\n\t\t * fetch the checksums for the extents in the leaf.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * this is the error case, the extent buffer has not been\n\t\t * read correctly. We won't access anything from it and\n\t\t * just cleanup our data structures. Effectively this will\n\t\t * cut the branch below this node from read ahead.\n\t\t */\n\t\tnritems = 0;\n\t\tgeneration = 0;\n\t}\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct reada_extctl *rec;\n\t\tu64 n_gen;\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_key next_key;\n\n\t\tbtrfs_node_key_to_cpu(eb, &key, i);\n\t\tif (i + 1 < nritems)\n\t\t\tbtrfs_node_key_to_cpu(eb, &next_key, i + 1);\n\t\telse\n\t\t\tnext_key = re->top;\n\t\tbytenr = btrfs_node_blockptr(eb, i);\n\t\tn_gen = btrfs_node_ptr_generation(eb, i);\n\n\t\tlist_for_each_entry(rec, &list, list) {\n\t\t\tstruct reada_control *rc = rec->rc;\n\n\t\t\t/*\n\t\t\t * if the generation doesn't match, just ignore this\n\t\t\t * extctl. This will probably cut off a branch from\n\t\t\t * prefetch. Alternatively one could start a new (sub-)\n\t\t\t * prefetch for this branch, starting again from root.\n\t\t\t * FIXME: move the generation check out of this loop\n\t\t\t */\n#ifdef DEBUG\n\t\t\tif (rec->generation != generation) {\n\t\t\t\tbtrfs_debug(root->fs_info,\n\t\t\t\t\t   \"generation mismatch for (%llu,%d,%llu) %llu != %llu\",\n\t\t\t\t       key.objectid, key.type, key.offset,\n\t\t\t\t       rec->generation, generation);\n\t\t\t}\n#endif\n\t\t\tif (rec->generation == generation &&\n\t\t\t    btrfs_comp_cpu_keys(&key, &rc->key_end) < 0 &&\n\t\t\t    btrfs_comp_cpu_keys(&next_key, &rc->key_start) > 0)\n\t\t\t\treada_add_block(rc, bytenr, &next_key,\n\t\t\t\t\t\tlevel - 1, n_gen);\n\t\t}\n\t}\n\t/*\n\t * free extctl records\n\t */\n\twhile (!list_empty(&list)) {\n\t\tstruct reada_control *rc;\n\t\tstruct reada_extctl *rec;\n\n\t\trec = list_first_entry(&list, struct reada_extctl, list);\n\t\tlist_del(&rec->list);\n\t\trc = rec->rc;\n\t\tkfree(rec);\n\n\t\tkref_get(&rc->refcnt);\n\t\tif (atomic_dec_and_test(&rc->elems)) {\n\t\t\tkref_put(&rc->refcnt, reada_control_release);\n\t\t\twake_up(&rc->wait);\n\t\t}\n\t\tkref_put(&rc->refcnt, reada_control_release);\n\n\t\treada_extent_put(fs_info, re);\t/* one ref for each entry */\n\t}\n\treada_extent_put(fs_info, re);\t/* our ref */\n\tif (for_dev)\n\t\tatomic_dec(&for_dev->reada_in_flight);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nint btree_readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t u64 start, int err)\n{\n\tint ret;\n\n\tret = __readahead_hook(root, eb, start, err);\n\n\treada_start_machine(root->fs_info);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__readahead_hook",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
    "lines": "108-230",
    "snippet": "static int __readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t    u64 start, int err)\n{\n\tint level = 0;\n\tint nritems;\n\tint i;\n\tu64 bytenr;\n\tu64 generation;\n\tstruct reada_extent *re;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head list;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct btrfs_device *for_dev;\n\n\tif (eb)\n\t\tlevel = btrfs_header_level(eb);\n\n\t/* find extent */\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (!re)\n\t\treturn -1;\n\n\tspin_lock(&re->lock);\n\t/*\n\t * just take the full list from the extent. afterwards we\n\t * don't need the lock anymore\n\t */\n\tlist_replace_init(&re->extctl, &list);\n\tfor_dev = re->scheduled_for;\n\tre->scheduled_for = NULL;\n\tspin_unlock(&re->lock);\n\n\tif (err == 0) {\n\t\tnritems = level ? btrfs_header_nritems(eb) : 0;\n\t\tgeneration = btrfs_header_generation(eb);\n\t\t/*\n\t\t * FIXME: currently we just set nritems to 0 if this is a leaf,\n\t\t * effectively ignoring the content. In a next step we could\n\t\t * trigger more readahead depending from the content, e.g.\n\t\t * fetch the checksums for the extents in the leaf.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * this is the error case, the extent buffer has not been\n\t\t * read correctly. We won't access anything from it and\n\t\t * just cleanup our data structures. Effectively this will\n\t\t * cut the branch below this node from read ahead.\n\t\t */\n\t\tnritems = 0;\n\t\tgeneration = 0;\n\t}\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct reada_extctl *rec;\n\t\tu64 n_gen;\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_key next_key;\n\n\t\tbtrfs_node_key_to_cpu(eb, &key, i);\n\t\tif (i + 1 < nritems)\n\t\t\tbtrfs_node_key_to_cpu(eb, &next_key, i + 1);\n\t\telse\n\t\t\tnext_key = re->top;\n\t\tbytenr = btrfs_node_blockptr(eb, i);\n\t\tn_gen = btrfs_node_ptr_generation(eb, i);\n\n\t\tlist_for_each_entry(rec, &list, list) {\n\t\t\tstruct reada_control *rc = rec->rc;\n\n\t\t\t/*\n\t\t\t * if the generation doesn't match, just ignore this\n\t\t\t * extctl. This will probably cut off a branch from\n\t\t\t * prefetch. Alternatively one could start a new (sub-)\n\t\t\t * prefetch for this branch, starting again from root.\n\t\t\t * FIXME: move the generation check out of this loop\n\t\t\t */\n#ifdef DEBUG\n\t\t\tif (rec->generation != generation) {\n\t\t\t\tbtrfs_debug(root->fs_info,\n\t\t\t\t\t   \"generation mismatch for (%llu,%d,%llu) %llu != %llu\",\n\t\t\t\t       key.objectid, key.type, key.offset,\n\t\t\t\t       rec->generation, generation);\n\t\t\t}\n#endif\n\t\t\tif (rec->generation == generation &&\n\t\t\t    btrfs_comp_cpu_keys(&key, &rc->key_end) < 0 &&\n\t\t\t    btrfs_comp_cpu_keys(&next_key, &rc->key_start) > 0)\n\t\t\t\treada_add_block(rc, bytenr, &next_key,\n\t\t\t\t\t\tlevel - 1, n_gen);\n\t\t}\n\t}\n\t/*\n\t * free extctl records\n\t */\n\twhile (!list_empty(&list)) {\n\t\tstruct reada_control *rc;\n\t\tstruct reada_extctl *rec;\n\n\t\trec = list_first_entry(&list, struct reada_extctl, list);\n\t\tlist_del(&rec->list);\n\t\trc = rec->rc;\n\t\tkfree(rec);\n\n\t\tkref_get(&rc->refcnt);\n\t\tif (atomic_dec_and_test(&rc->elems)) {\n\t\t\tkref_put(&rc->refcnt, reada_control_release);\n\t\t\twake_up(&rc->wait);\n\t\t}\n\t\tkref_put(&rc->refcnt, reada_control_release);\n\n\t\treada_extent_put(fs_info, re);\t/* one ref for each entry */\n\t}\n\treada_extent_put(fs_info, re);\t/* our ref */\n\tif (for_dev)\n\t\tatomic_dec(&for_dev->reada_in_flight);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"dev-replace.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"volumes.h\"",
      "#include \"ctree.h\"",
      "#include <linux/workqueue.h>",
      "#include <linux/slab.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/writeback.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/sched.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
      "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static void __reada_start_machine(struct btrfs_fs_info *fs_info);",
      "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&for_dev->reada_in_flight"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reada_extent_put",
          "args": [
            "fs_info",
            "re"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "reada_extent_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "494-536",
          "snippet": "static void reada_extent_put(struct btrfs_fs_info *fs_info,\n\t\t\t     struct reada_extent *re)\n{\n\tint i;\n\tunsigned long index = re->logical >> PAGE_CACHE_SHIFT;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (--re->refcnt) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn;\n\t}\n\n\tradix_tree_delete(&fs_info->reada_tree, index);\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tradix_tree_delete(&zone->device->reada_extents, index);\n\t}\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/* no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tif (re->scheduled_for)\n\t\tatomic_dec(&re->scheduled_for->reada_in_flight);\n\n\tkfree(re);\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\n\nstatic void reada_extent_put(struct btrfs_fs_info *fs_info,\n\t\t\t     struct reada_extent *re)\n{\n\tint i;\n\tunsigned long index = re->logical >> PAGE_CACHE_SHIFT;\n\n\tspin_lock(&fs_info->reada_lock);\n\tif (--re->refcnt) {\n\t\tspin_unlock(&fs_info->reada_lock);\n\t\treturn;\n\t}\n\n\tradix_tree_delete(&fs_info->reada_tree, index);\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tradix_tree_delete(&zone->device->reada_extents, index);\n\t}\n\n\tspin_unlock(&fs_info->reada_lock);\n\n\tfor (i = 0; i < re->nzones; ++i) {\n\t\tstruct reada_zone *zone = re->zones[i];\n\n\t\tkref_get(&zone->refcnt);\n\t\tspin_lock(&zone->lock);\n\t\t--zone->elems;\n\t\tif (zone->elems == 0) {\n\t\t\t/* no fs_info->reada_lock needed, as this can't be\n\t\t\t * the last ref */\n\t\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\t}\n\t\tspin_unlock(&zone->lock);\n\n\t\tspin_lock(&fs_info->reada_lock);\n\t\tkref_put(&zone->refcnt, reada_zone_release);\n\t\tspin_unlock(&fs_info->reada_lock);\n\t}\n\tif (re->scheduled_for)\n\t\tatomic_dec(&re->scheduled_for->reada_in_flight);\n\n\tkfree(re);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rc->refcnt",
            "reada_control_release"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&rc->wait"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&rc->refcnt",
            "reada_control_release"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&rc->elems"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&rc->refcnt"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rec"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&rec->list"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&list",
            "structreada_extctl",
            "list"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&list"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reada_add_block",
          "args": [
            "rc",
            "bytenr",
            "&next_key",
            "level - 1",
            "n_gen"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "reada_add_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/reada.c",
          "lines": "556-584",
          "snippet": "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation)\n{\n\tstruct btrfs_root *root = rc->root;\n\tstruct reada_extent *re;\n\tstruct reada_extctl *rec;\n\n\tre = reada_find_extent(root, logical, top, level); /* takes one ref */\n\tif (!re)\n\t\treturn -1;\n\n\trec = kzalloc(sizeof(*rec), GFP_NOFS);\n\tif (!rec) {\n\t\treada_extent_put(root->fs_info, re);\n\t\treturn -1;\n\t}\n\n\trec->rc = rc;\n\trec->generation = generation;\n\tatomic_inc(&rc->elems);\n\n\tspin_lock(&re->lock);\n\tlist_add_tail(&rec->list, &re->extctl);\n\tspin_unlock(&re->lock);\n\n\t/* leave the ref on the extent */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"dev-replace.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);",
            "static void reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static void __reada_start_machine(struct btrfs_fs_info *fs_info);",
            "static int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);\n\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation)\n{\n\tstruct btrfs_root *root = rc->root;\n\tstruct reada_extent *re;\n\tstruct reada_extctl *rec;\n\n\tre = reada_find_extent(root, logical, top, level); /* takes one ref */\n\tif (!re)\n\t\treturn -1;\n\n\trec = kzalloc(sizeof(*rec), GFP_NOFS);\n\tif (!rec) {\n\t\treada_extent_put(root->fs_info, re);\n\t\treturn -1;\n\t}\n\n\trec->rc = rc;\n\trec->generation = generation;\n\tatomic_inc(&rc->elems);\n\n\tspin_lock(&re->lock);\n\tlist_add_tail(&rec->list, &re->extctl);\n\tspin_unlock(&re->lock);\n\n\t/* leave the ref on the extent */\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_comp_cpu_keys",
          "args": [
            "&next_key",
            "&rc->key_start"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_comp_cpu_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "1598-1613",
          "snippet": "int btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nint btrfs_comp_cpu_keys(struct btrfs_key *k1, struct btrfs_key *k2)\n{\n\tif (k1->objectid > k2->objectid)\n\t\treturn 1;\n\tif (k1->objectid < k2->objectid)\n\t\treturn -1;\n\tif (k1->type > k2->type)\n\t\treturn 1;\n\tif (k1->type < k2->type)\n\t\treturn -1;\n\tif (k1->offset > k2->offset)\n\t\treturn 1;\n\tif (k1->offset < k2->offset)\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_debug",
          "args": [
            "root->fs_info",
            "\"generation mismatch for (%llu,%d,%llu) %llu != %llu\"",
            "key.objectid",
            "key.type",
            "key.offset",
            "rec->generation",
            "generation"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "rec",
            "&list",
            "list"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_node_ptr_generation",
          "args": [
            "eb",
            "i"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_ptr_generation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2581-2587",
          "snippet": "static inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_ptr_generation(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_generation(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_blockptr",
          "args": [
            "eb",
            "i"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_blockptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2564-2570",
          "snippet": "static inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline u64 btrfs_node_blockptr(struct extent_buffer *eb, int nr)\n{\n\tunsigned long ptr;\n\tptr = offsetof(struct btrfs_node, ptrs) +\n\t\tsizeof(struct btrfs_key_ptr) * nr;\n\treturn btrfs_key_blockptr(eb, (struct btrfs_key_ptr *)ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_node_key_to_cpu",
          "args": [
            "eb",
            "&next_key",
            "i + 1"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_node_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2747-2753",
          "snippet": "static inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_node_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t  struct btrfs_key *key, int nr)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_node_key(eb, &disk_key, nr);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_header_generation",
          "args": [
            "eb"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_nritems",
          "args": [
            "eb"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&re->lock"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_replace_init",
          "args": [
            "&re->extctl",
            "&list"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&re->lock"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&fs_info->reada_tree",
            "index"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_header_level",
          "args": [
            "eb"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"dev-replace.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic void reada_extent_put(struct btrfs_fs_info *, struct reada_extent *);\nstatic void reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic void __reada_start_machine(struct btrfs_fs_info *fs_info);\nstatic int reada_add_block(struct reada_control *rc, u64 logical,\n\t\t\t   struct btrfs_key *top, int level, u64 generation);\n\nstatic int __readahead_hook(struct btrfs_root *root, struct extent_buffer *eb,\n\t\t\t    u64 start, int err)\n{\n\tint level = 0;\n\tint nritems;\n\tint i;\n\tu64 bytenr;\n\tu64 generation;\n\tstruct reada_extent *re;\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct list_head list;\n\tunsigned long index = start >> PAGE_CACHE_SHIFT;\n\tstruct btrfs_device *for_dev;\n\n\tif (eb)\n\t\tlevel = btrfs_header_level(eb);\n\n\t/* find extent */\n\tspin_lock(&fs_info->reada_lock);\n\tre = radix_tree_lookup(&fs_info->reada_tree, index);\n\tif (re)\n\t\tre->refcnt++;\n\tspin_unlock(&fs_info->reada_lock);\n\n\tif (!re)\n\t\treturn -1;\n\n\tspin_lock(&re->lock);\n\t/*\n\t * just take the full list from the extent. afterwards we\n\t * don't need the lock anymore\n\t */\n\tlist_replace_init(&re->extctl, &list);\n\tfor_dev = re->scheduled_for;\n\tre->scheduled_for = NULL;\n\tspin_unlock(&re->lock);\n\n\tif (err == 0) {\n\t\tnritems = level ? btrfs_header_nritems(eb) : 0;\n\t\tgeneration = btrfs_header_generation(eb);\n\t\t/*\n\t\t * FIXME: currently we just set nritems to 0 if this is a leaf,\n\t\t * effectively ignoring the content. In a next step we could\n\t\t * trigger more readahead depending from the content, e.g.\n\t\t * fetch the checksums for the extents in the leaf.\n\t\t */\n\t} else {\n\t\t/*\n\t\t * this is the error case, the extent buffer has not been\n\t\t * read correctly. We won't access anything from it and\n\t\t * just cleanup our data structures. Effectively this will\n\t\t * cut the branch below this node from read ahead.\n\t\t */\n\t\tnritems = 0;\n\t\tgeneration = 0;\n\t}\n\n\tfor (i = 0; i < nritems; i++) {\n\t\tstruct reada_extctl *rec;\n\t\tu64 n_gen;\n\t\tstruct btrfs_key key;\n\t\tstruct btrfs_key next_key;\n\n\t\tbtrfs_node_key_to_cpu(eb, &key, i);\n\t\tif (i + 1 < nritems)\n\t\t\tbtrfs_node_key_to_cpu(eb, &next_key, i + 1);\n\t\telse\n\t\t\tnext_key = re->top;\n\t\tbytenr = btrfs_node_blockptr(eb, i);\n\t\tn_gen = btrfs_node_ptr_generation(eb, i);\n\n\t\tlist_for_each_entry(rec, &list, list) {\n\t\t\tstruct reada_control *rc = rec->rc;\n\n\t\t\t/*\n\t\t\t * if the generation doesn't match, just ignore this\n\t\t\t * extctl. This will probably cut off a branch from\n\t\t\t * prefetch. Alternatively one could start a new (sub-)\n\t\t\t * prefetch for this branch, starting again from root.\n\t\t\t * FIXME: move the generation check out of this loop\n\t\t\t */\n#ifdef DEBUG\n\t\t\tif (rec->generation != generation) {\n\t\t\t\tbtrfs_debug(root->fs_info,\n\t\t\t\t\t   \"generation mismatch for (%llu,%d,%llu) %llu != %llu\",\n\t\t\t\t       key.objectid, key.type, key.offset,\n\t\t\t\t       rec->generation, generation);\n\t\t\t}\n#endif\n\t\t\tif (rec->generation == generation &&\n\t\t\t    btrfs_comp_cpu_keys(&key, &rc->key_end) < 0 &&\n\t\t\t    btrfs_comp_cpu_keys(&next_key, &rc->key_start) > 0)\n\t\t\t\treada_add_block(rc, bytenr, &next_key,\n\t\t\t\t\t\tlevel - 1, n_gen);\n\t\t}\n\t}\n\t/*\n\t * free extctl records\n\t */\n\twhile (!list_empty(&list)) {\n\t\tstruct reada_control *rc;\n\t\tstruct reada_extctl *rec;\n\n\t\trec = list_first_entry(&list, struct reada_extctl, list);\n\t\tlist_del(&rec->list);\n\t\trc = rec->rc;\n\t\tkfree(rec);\n\n\t\tkref_get(&rc->refcnt);\n\t\tif (atomic_dec_and_test(&rc->elems)) {\n\t\t\tkref_put(&rc->refcnt, reada_control_release);\n\t\t\twake_up(&rc->wait);\n\t\t}\n\t\tkref_put(&rc->refcnt, reada_control_release);\n\n\t\treada_extent_put(fs_info, re);\t/* one ref for each entry */\n\t}\n\treada_extent_put(fs_info, re);\t/* our ref */\n\tif (for_dev)\n\t\tatomic_dec(&for_dev->reada_in_flight);\n\n\treturn 0;\n}"
  }
]