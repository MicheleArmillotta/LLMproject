[
  {
    "function_name": "mountstats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "309-312",
    "snippet": "static int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsstat);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mounts_open_common",
          "args": [
            "inode",
            "file",
            "show_vfsstat"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "mounts_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "231-289",
          "snippet": "static int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, &mounts_op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->ns = ns;\n\tp->root = root;\n\tp->m.poll_event = ns->event;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, &mounts_op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->ns = ns;\n\tp->root = root;\n\tp->m.poll_event = ns->event;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mountstats_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsstat);\n}"
  },
  {
    "function_name": "mountinfo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "304-307",
    "snippet": "static int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_mountinfo);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mounts_open_common",
          "args": [
            "inode",
            "file",
            "show_mountinfo"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "mounts_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "231-289",
          "snippet": "static int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, &mounts_op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->ns = ns;\n\tp->root = root;\n\tp->m.poll_event = ns->event;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, &mounts_op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->ns = ns;\n\tp->root = root;\n\tp->m.poll_event = ns->event;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mountinfo_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_mountinfo);\n}"
  },
  {
    "function_name": "mounts_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "299-302",
    "snippet": "static int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsmnt);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mounts_open_common",
          "args": [
            "inode",
            "file",
            "show_vfsmnt"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "mounts_open_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "231-289",
          "snippet": "static int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, &mounts_op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->ns = ns;\n\tp->root = root;\n\tp->m.poll_event = ns->event;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, &mounts_op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->ns = ns;\n\tp->root = root;\n\tp->m.poll_event = ns->event;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open(struct inode *inode, struct file *file)\n{\n\treturn mounts_open_common(inode, file, show_vfsmnt);\n}"
  },
  {
    "function_name": "mounts_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "291-297",
    "snippet": "static int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_mounts *p = proc_mounts(file->private_data);\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release(inode, file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "seq_release_private",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "605-612",
          "snippet": "int seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_release_private(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *seq = file->private_data;\n\n\tkfree(seq->private);\n\tseq->private = NULL;\n\treturn seq_release(inode, file);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "p->ns"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "put_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3077-3083",
          "snippet": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&p->root"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mounts",
          "args": [
            "file->private_data"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_release(struct inode *inode, struct file *file)\n{\n\tstruct proc_mounts *p = proc_mounts(file->private_data);\n\tpath_put(&p->root);\n\tput_mnt_ns(p->ns);\n\treturn seq_release(inode, file);\n}"
  },
  {
    "function_name": "mounts_open_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "231-289",
    "snippet": "static int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, &mounts_op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->ns = ns;\n\tp->root = root;\n\tp->m.poll_event = ns->event;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "put_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "3077-3083",
          "snippet": "void put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nvoid put_mnt_ns(struct mnt_namespace *ns)\n{\n\tif (!atomic_dec_and_test(&ns->count))\n\t\treturn;\n\tdrop_collected_mounts(&ns->root->mnt);\n\tfree_mnt_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&root"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&mounts_op"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "52-87",
          "snippet": "int seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_open(struct file *file, const struct seq_operations *op)\n{\n\tstruct seq_file *p = file->private_data;\n\n\tif (!p) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tfile->private_data = p;\n\t}\n\tmemset(p, 0, sizeof(*p));\n\tmutex_init(&p->lock);\n\tp->op = op;\n#ifdef CONFIG_USER_NS\n\tp->user_ns = file->f_cred->user_ns;\n#endif\n\n\t/*\n\t * Wrappers around seq_open(e.g. swaps_open) need to be\n\t * aware of this. If they set f_version themselves, they\n\t * should call seq_open first and then set f_version.\n\t */\n\tfile->f_version = 0;\n\n\t/*\n\t * seq_files support lseek() and pread().  They do not implement\n\t * write() at all, but we clear FMODE_PWRITE here for historical\n\t * reasons.\n\t *\n\t * If a client of seq_files a) implements file.write() and b) wishes to\n\t * support pwrite() then that client will need to implement its own\n\t * file.open() which calls seq_open() and then sets FMODE_PWRITE.\n\t */\n\tfile->f_mode &= ~FMODE_PWRITE;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct proc_mounts)",
            "GFP_KERNEL"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_root",
          "args": [
            "task->fs",
            "&root"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "get_fs_root_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "3021-3029",
          "snippet": "static void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void get_fs_root_rcu(struct fs_struct *fs, struct path *root)\n{\n\tunsigned seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&fs->seq);\n\t\t*root = fs->root;\n\t} while (read_seqcount_retry(&fs->seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mnt_ns",
          "args": [
            "ns"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "get_mnt_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "102-105",
          "snippet": "static inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nstatic inline void get_mnt_ns(struct mnt_namespace *ns)\n{\n\tatomic_inc(&ns->count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_proc_task",
          "args": [
            "inode"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "get_proc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/internal.h",
          "lines": "95-98",
          "snippet": "static inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/binfmts.h>",
            "#include <linux/atomic.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);",
            "extern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);",
            "extern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);",
            "extern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);",
            "extern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/binfmts.h>\n#include <linux/atomic.h>\n#include <linux/spinlock.h>\n#include <linux/proc_ns.h>\n#include <linux/proc_fs.h>\n\nextern int proc_tid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t struct pid *, struct task_struct *);\nextern int proc_tgid_stat(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern int proc_pid_status(struct seq_file *, struct pid_namespace *,\n\t\t\t   struct pid *, struct task_struct *);\nextern int proc_pid_statm(struct seq_file *, struct pid_namespace *,\n\t\t\t  struct pid *, struct task_struct *);\nextern struct inode *proc_pid_make_inode(struct super_block *, struct task_struct *);\nextern bool proc_fill_cache(struct file *, struct dir_context *, const char *, int,\n\t\t\t   instantiate_t, struct task_struct *, const void *);\n\nstatic inline struct task_struct *get_proc_task(struct inode *inode)\n{\n\treturn get_pid_task(proc_pid(inode), PIDTYPE_PID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int mounts_open_common(struct inode *inode, struct file *file,\n\t\t\t      int (*show)(struct seq_file *, struct vfsmount *))\n{\n\tstruct task_struct *task = get_proc_task(inode);\n\tstruct nsproxy *nsp;\n\tstruct mnt_namespace *ns = NULL;\n\tstruct path root;\n\tstruct proc_mounts *p;\n\tint ret = -EINVAL;\n\n\tif (!task)\n\t\tgoto err;\n\n\ttask_lock(task);\n\tnsp = task->nsproxy;\n\tif (!nsp || !nsp->mnt_ns) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tgoto err;\n\t}\n\tns = nsp->mnt_ns;\n\tget_mnt_ns(ns);\n\tif (!task->fs) {\n\t\ttask_unlock(task);\n\t\tput_task_struct(task);\n\t\tret = -ENOENT;\n\t\tgoto err_put_ns;\n\t}\n\tget_fs_root(task->fs, &root);\n\ttask_unlock(task);\n\tput_task_struct(task);\n\n\tret = -ENOMEM;\n\tp = kmalloc(sizeof(struct proc_mounts), GFP_KERNEL);\n\tif (!p)\n\t\tgoto err_put_path;\n\n\tfile->private_data = &p->m;\n\tret = seq_open(file, &mounts_op);\n\tif (ret)\n\t\tgoto err_free;\n\n\tp->ns = ns;\n\tp->root = root;\n\tp->m.poll_event = ns->event;\n\tp->show = show;\n\tp->cached_event = ~0ULL;\n\n\treturn 0;\n\n err_free:\n\tkfree(p);\n err_put_path:\n\tpath_put(&root);\n err_put_ns:\n\tput_mnt_ns(ns);\n err:\n\treturn ret;\n}"
  },
  {
    "function_name": "show_vfsstat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "187-229",
    "snippet": "static int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = real_mount(mnt);\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\tint err = 0;\n\n\t/* device */\n\tif (sb->s_op->show_devname) {\n\t\tseq_puts(m, \"device \");\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t} else {\n\t\tif (r->mnt_devname) {\n\t\t\tseq_puts(m, \"device \");\n\t\t\tmangle(m, r->mnt_devname);\n\t\t} else\n\t\t\tseq_puts(m, \"no device\");\n\t}\n\n\t/* mount point */\n\tseq_puts(m, \" mounted on \");\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\n\t/* file system type */\n\tseq_puts(m, \"with fstype \");\n\tshow_type(m, sb);\n\n\t/* optional statistics */\n\tif (sb->s_op->show_stats) {\n\t\tseq_putc(m, ' ');\n\t\tif (!err)\n\t\t\terr = sb->s_op->show_stats(m, mnt_path.dentry);\n\t}\n\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_stats",
          "args": [
            "m",
            "mnt_path.dentry"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_type",
          "args": [
            "m",
            "sb"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "show_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "84-91",
          "snippet": "static void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"with fstype \""
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path_root",
          "args": [
            "m",
            "&mnt_path",
            "&p->root",
            "\" \\t\\n\\\\\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "493-518",
          "snippet": "int seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "r->mnt_devname"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "79-82",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_devname",
          "args": [
            "m",
            "mnt_path.dentry"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mounts",
          "args": [
            "m"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_vfsstat(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = real_mount(mnt);\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\tint err = 0;\n\n\t/* device */\n\tif (sb->s_op->show_devname) {\n\t\tseq_puts(m, \"device \");\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t} else {\n\t\tif (r->mnt_devname) {\n\t\t\tseq_puts(m, \"device \");\n\t\t\tmangle(m, r->mnt_devname);\n\t\t} else\n\t\t\tseq_puts(m, \"no device\");\n\t}\n\n\t/* mount point */\n\tseq_puts(m, \" mounted on \");\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\n\t/* file system type */\n\tseq_puts(m, \"with fstype \");\n\tshow_type(m, sb);\n\n\t/* optional statistics */\n\tif (sb->s_op->show_stats) {\n\t\tseq_putc(m, ' ');\n\t\tif (!err)\n\t\t\terr = sb->s_op->show_stats(m, mnt_path.dentry);\n\t}\n\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "show_mountinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "127-185",
    "snippet": "static int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = real_mount(mnt);\n\tstruct super_block *sb = mnt->mnt_sb;\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tint err = 0;\n\n\tseq_printf(m, \"%i %i %u:%u \", r->mnt_id, r->mnt_parent->mnt_id,\n\t\t   MAJOR(sb->s_dev), MINOR(sb->s_dev));\n\tif (sb->s_op->show_path)\n\t\terr = sb->s_op->show_path(m, mnt->mnt_root);\n\telse\n\t\tseq_dentry(m, mnt->mnt_root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\n\tseq_puts(m, mnt->mnt_flags & MNT_READONLY ? \" ro\" : \" rw\");\n\tshow_mnt_opts(m, mnt);\n\n\t/* Tagged fields (\"foo:X\" or \"bar\") */\n\tif (IS_MNT_SHARED(r))\n\t\tseq_printf(m, \" shared:%i\", r->mnt_group_id);\n\tif (IS_MNT_SLAVE(r)) {\n\t\tint master = r->mnt_master->mnt_group_id;\n\t\tint dom = get_dominating_id(r, &p->root);\n\t\tseq_printf(m, \" master:%i\", master);\n\t\tif (dom && dom != master)\n\t\t\tseq_printf(m, \" propagate_from:%i\", dom);\n\t}\n\tif (IS_MNT_UNBINDABLE(r))\n\t\tseq_puts(m, \" unbindable\");\n\n\t/* Filesystem specific data */\n\tseq_puts(m, \" - \");\n\tshow_type(m, sb);\n\tseq_putc(m, ' ');\n\tif (sb->s_op->show_devname)\n\t\terr = sb->s_op->show_devname(m, mnt->mnt_root);\n\telse\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\tif (err)\n\t\tgoto out;\n\tseq_puts(m, sb->s_flags & MS_RDONLY ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt->mnt_root);\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_options",
          "args": [
            "m",
            "mnt->mnt_root"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_sb_opts",
          "args": [
            "m",
            "sb"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "show_sb_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "41-58",
          "snippet": "static int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ MS_SYNCHRONOUS, \",sync\" },\n\t\t{ MS_DIRSYNC, \",dirsync\" },\n\t\t{ MS_MANDLOCK, \",mand\" },\n\t\t{ MS_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ MS_SYNCHRONOUS, \",sync\" },\n\t\t{ MS_DIRSYNC, \",dirsync\" },\n\t\t{ MS_MANDLOCK, \",mand\" },\n\t\t{ MS_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "sb->s_flags & MS_RDONLY ? \" ro\" : \" rw\""
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "r->mnt_devname ? r->mnt_devname : \"none\""
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "79-82",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_devname",
          "args": [
            "m",
            "mnt->mnt_root"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_type",
          "args": [
            "m",
            "sb"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "show_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "84-91",
          "snippet": "static void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_UNBINDABLE",
          "args": [
            "r"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" propagate_from:%i\"",
            "dom"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_dominating_id",
          "args": [
            "r",
            "&p->root"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_MNT_SLAVE",
          "args": [
            "r"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_MNT_SHARED",
          "args": [
            "r"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_mnt_opts",
          "args": [
            "m",
            "mnt"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "show_mnt_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "60-77",
          "snippet": "static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path_root",
          "args": [
            "m",
            "&mnt_path",
            "&p->root",
            "\" \\t\\n\\\\\""
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "493-518",
          "snippet": "int seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_dentry",
          "args": [
            "m",
            "mnt->mnt_root",
            "\" \\t\\n\\\\\""
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "seq_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "523-540",
          "snippet": "int seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_dentry(struct seq_file *m, struct dentry *dentry, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -1;\n\n\tif (size) {\n\t\tchar *p = dentry_path(dentry, buf, size);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_path",
          "args": [
            "m",
            "mnt->mnt_root"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "sb->s_dev"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "sb->s_dev"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mounts",
          "args": [
            "m"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_mountinfo(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = real_mount(mnt);\n\tstruct super_block *sb = mnt->mnt_sb;\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tint err = 0;\n\n\tseq_printf(m, \"%i %i %u:%u \", r->mnt_id, r->mnt_parent->mnt_id,\n\t\t   MAJOR(sb->s_dev), MINOR(sb->s_dev));\n\tif (sb->s_op->show_path)\n\t\terr = sb->s_op->show_path(m, mnt->mnt_root);\n\telse\n\t\tseq_dentry(m, mnt->mnt_root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\n\tseq_puts(m, mnt->mnt_flags & MNT_READONLY ? \" ro\" : \" rw\");\n\tshow_mnt_opts(m, mnt);\n\n\t/* Tagged fields (\"foo:X\" or \"bar\") */\n\tif (IS_MNT_SHARED(r))\n\t\tseq_printf(m, \" shared:%i\", r->mnt_group_id);\n\tif (IS_MNT_SLAVE(r)) {\n\t\tint master = r->mnt_master->mnt_group_id;\n\t\tint dom = get_dominating_id(r, &p->root);\n\t\tseq_printf(m, \" master:%i\", master);\n\t\tif (dom && dom != master)\n\t\t\tseq_printf(m, \" propagate_from:%i\", dom);\n\t}\n\tif (IS_MNT_UNBINDABLE(r))\n\t\tseq_puts(m, \" unbindable\");\n\n\t/* Filesystem specific data */\n\tseq_puts(m, \" - \");\n\tshow_type(m, sb);\n\tseq_putc(m, ' ');\n\tif (sb->s_op->show_devname)\n\t\terr = sb->s_op->show_devname(m, mnt->mnt_root);\n\telse\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\tif (err)\n\t\tgoto out;\n\tseq_puts(m, sb->s_flags & MS_RDONLY ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt->mnt_root);\n\tseq_putc(m, '\\n');\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "show_vfsmnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "93-125",
    "snippet": "static int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = real_mount(mnt);\n\tint err = 0;\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\n\tif (sb->s_op->show_devname) {\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\t}\n\tseq_putc(m, ' ');\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\tshow_type(m, sb);\n\tseq_puts(m, __mnt_is_readonly(mnt) ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tshow_mnt_opts(m, mnt);\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt_path.dentry);\n\tseq_puts(m, \" 0 0\\n\");\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" 0 0\\n\""
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_options",
          "args": [
            "m",
            "mnt_path.dentry"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_mnt_opts",
          "args": [
            "m",
            "mnt"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "show_mnt_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "60-77",
          "snippet": "static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_sb_opts",
          "args": [
            "m",
            "sb"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "show_sb_opts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "41-58",
          "snippet": "static int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ MS_SYNCHRONOUS, \",sync\" },\n\t\t{ MS_DIRSYNC, \",dirsync\" },\n\t\t{ MS_MANDLOCK, \",mand\" },\n\t\t{ MS_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ MS_SYNCHRONOUS, \",sync\" },\n\t\t{ MS_DIRSYNC, \",dirsync\" },\n\t\t{ MS_MANDLOCK, \",mand\" },\n\t\t{ MS_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mnt_is_readonly",
          "args": [
            "mnt"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "__mnt_is_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "274-281",
          "snippet": "int __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nint __mnt_is_readonly(struct vfsmount *mnt)\n{\n\tif (mnt->mnt_flags & MNT_READONLY)\n\t\treturn 1;\n\tif (mnt->mnt_sb->s_flags & MS_RDONLY)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_type",
          "args": [
            "m",
            "sb"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "show_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "84-91",
          "snippet": "static void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "' '"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_path_root",
          "args": [
            "m",
            "&mnt_path",
            "&p->root",
            "\" \\t\\n\\\\\""
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "seq_path_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "493-518",
          "snippet": "int seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_path_root(struct seq_file *m, const struct path *path,\n\t\t  const struct path *root, const char *esc)\n{\n\tchar *buf;\n\tsize_t size = seq_get_buf(m, &buf);\n\tint res = -ENAMETOOLONG;\n\n\tif (size) {\n\t\tchar *p;\n\n\t\tp = __d_path(path, root, buf, size);\n\t\tif (!p)\n\t\t\treturn SEQ_SKIP;\n\t\tres = PTR_ERR(p);\n\t\tif (!IS_ERR(p)) {\n\t\t\tchar *end = mangle_path(buf, p, esc);\n\t\t\tif (end)\n\t\t\t\tres = end - buf;\n\t\t\telse\n\t\t\t\tres = -ENAMETOOLONG;\n\t\t}\n\t}\n\tseq_commit(m, res);\n\n\treturn res < 0 && res != -ENAMETOOLONG ? res : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "r->mnt_devname ? r->mnt_devname : \"none\""
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "79-82",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb->s_op->show_devname",
          "args": [
            "m",
            "mnt_path.dentry"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "real_mount",
          "args": [
            "mnt"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "real_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mount.h",
          "lines": "72-75",
          "snippet": "static inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/ns_common.h>",
            "#include <linux/poll.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool legitimize_mnt(struct vfsmount *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/ns_common.h>\n#include <linux/poll.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n\nextern bool legitimize_mnt(struct vfsmount *, unsigned);\n\nstatic inline struct mount *real_mount(struct vfsmount *mnt)\n{\n\treturn container_of(mnt, struct mount, mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_mounts",
          "args": [
            "m"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_vfsmnt(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstruct proc_mounts *p = proc_mounts(m);\n\tstruct mount *r = real_mount(mnt);\n\tint err = 0;\n\tstruct path mnt_path = { .dentry = mnt->mnt_root, .mnt = mnt };\n\tstruct super_block *sb = mnt_path.dentry->d_sb;\n\n\tif (sb->s_op->show_devname) {\n\t\terr = sb->s_op->show_devname(m, mnt_path.dentry);\n\t\tif (err)\n\t\t\tgoto out;\n\t} else {\n\t\tmangle(m, r->mnt_devname ? r->mnt_devname : \"none\");\n\t}\n\tseq_putc(m, ' ');\n\t/* mountpoints outside of chroot jail will give SEQ_SKIP on this */\n\terr = seq_path_root(m, &mnt_path, &p->root, \" \\t\\n\\\\\");\n\tif (err)\n\t\tgoto out;\n\tseq_putc(m, ' ');\n\tshow_type(m, sb);\n\tseq_puts(m, __mnt_is_readonly(mnt) ? \" ro\" : \" rw\");\n\terr = show_sb_opts(m, sb);\n\tif (err)\n\t\tgoto out;\n\tshow_mnt_opts(m, mnt);\n\tif (sb->s_op->show_options)\n\t\terr = sb->s_op->show_options(m, mnt_path.dentry);\n\tseq_puts(m, \" 0 0\\n\");\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "show_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "84-91",
    "snippet": "static void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mangle",
          "args": [
            "m",
            "sb->s_subtype"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "mangle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
          "lines": "79-82",
          "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
            "#include <linux/fs_struct.h>",
            "#include <linux/security.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'.'"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "648-655",
          "snippet": "int seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_putc(struct seq_file *m, char c)\n{\n\tif (m->count < m->size) {\n\t\tm->buf[m->count++] = c;\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_type(struct seq_file *m, struct super_block *sb)\n{\n\tmangle(m, sb->s_type->name);\n\tif (sb->s_subtype && sb->s_subtype[0]) {\n\t\tseq_putc(m, '.');\n\t\tmangle(m, sb->s_subtype);\n\t}\n}"
  },
  {
    "function_name": "mangle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "79-82",
    "snippet": "static inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "s",
            "\" \\t\\n\\\\\""
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "seq_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "374-397",
          "snippet": "int seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic inline void mangle(struct seq_file *m, const char *s)\n{\n\tseq_escape(m, s, \" \\t\\n\\\\\");\n}"
  },
  {
    "function_name": "show_mnt_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "60-77",
    "snippet": "static void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "fs_infop->str"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic void show_mnt_opts(struct seq_file *m, struct vfsmount *mnt)\n{\n\tstatic const struct proc_fs_info mnt_info[] = {\n\t\t{ MNT_NOSUID, \",nosuid\" },\n\t\t{ MNT_NODEV, \",nodev\" },\n\t\t{ MNT_NOEXEC, \",noexec\" },\n\t\t{ MNT_NOATIME, \",noatime\" },\n\t\t{ MNT_NODIRATIME, \",nodiratime\" },\n\t\t{ MNT_RELATIME, \",relatime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = mnt_info; fs_infop->flag; fs_infop++) {\n\t\tif (mnt->mnt_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n}"
  },
  {
    "function_name": "show_sb_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "41-58",
    "snippet": "static int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ MS_SYNCHRONOUS, \",sync\" },\n\t\t{ MS_DIRSYNC, \",dirsync\" },\n\t\t{ MS_MANDLOCK, \",mand\" },\n\t\t{ MS_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_sb_show_options",
          "args": [
            "m",
            "sb"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "fs_infop->str"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic int show_sb_opts(struct seq_file *m, struct super_block *sb)\n{\n\tstatic const struct proc_fs_info fs_info[] = {\n\t\t{ MS_SYNCHRONOUS, \",sync\" },\n\t\t{ MS_DIRSYNC, \",dirsync\" },\n\t\t{ MS_MANDLOCK, \",mand\" },\n\t\t{ MS_LAZYTIME, \",lazytime\" },\n\t\t{ 0, NULL }\n\t};\n\tconst struct proc_fs_info *fs_infop;\n\n\tfor (fs_infop = fs_info; fs_infop->flag; fs_infop++) {\n\t\tif (sb->s_flags & fs_infop->flag)\n\t\t\tseq_puts(m, fs_infop->str);\n\t}\n\n\treturn security_sb_show_options(m, sb);\n}"
  },
  {
    "function_name": "mounts_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc_namespace.c",
    "lines": "18-34",
    "snippet": "static unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = proc_mounts(file->private_data);\n\tstruct mnt_namespace *ns = p->ns;\n\tunsigned res = POLLIN | POLLRDNORM;\n\tint event;\n\n\tpoll_wait(file, &p->ns->poll, wait);\n\n\tevent = ACCESS_ONCE(ns->event);\n\tif (p->m.poll_event != event) {\n\t\tp->m.poll_event = event;\n\t\tres |= POLLERR | POLLPRI;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include \"pnode.h\"",
      "#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */",
      "#include <linux/fs_struct.h>",
      "#include <linux/security.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/mnt_namespace.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "ns->event"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&p->ns->poll",
            "wait"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_mounts",
          "args": [
            "file->private_data"
          ],
          "line": 20
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include \"proc/internal.h\" /* only for get_proc_task() in ->open() */\n#include <linux/fs_struct.h>\n#include <linux/security.h>\n#include <linux/nsproxy.h>\n#include <linux/mnt_namespace.h>\n\nstatic unsigned mounts_poll(struct file *file, poll_table *wait)\n{\n\tstruct proc_mounts *p = proc_mounts(file->private_data);\n\tstruct mnt_namespace *ns = p->ns;\n\tunsigned res = POLLIN | POLLRDNORM;\n\tint event;\n\n\tpoll_wait(file, &p->ns->poll, wait);\n\n\tevent = ACCESS_ONCE(ns->event);\n\tif (p->m.poll_event != event) {\n\t\tp->m.poll_event = event;\n\t\tres |= POLLERR | POLLPRI;\n\t}\n\n\treturn res;\n}"
  }
]