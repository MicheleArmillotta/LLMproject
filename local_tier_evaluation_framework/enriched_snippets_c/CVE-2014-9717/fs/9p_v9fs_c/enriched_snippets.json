[
  {
    "function_name": "exit_v9fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "672-677",
    "snippet": "static void __exit exit_v9fs(void)\n{\n\tv9fs_sysfs_cleanup();\n\tv9fs_cache_unregister();\n\tunregister_filesystem(&v9fs_fs_type);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&v9fs_fs_type"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_cache_unregister",
          "args": [],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "620-626",
          "snippet": "static void v9fs_cache_unregister(void)\n{\n\tv9fs_destroy_inode_cache();\n#ifdef CONFIG_9P_FSCACHE\n\tfscache_unregister_netfs(&v9fs_cache_netfs);\n#endif\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void v9fs_cache_unregister(void)\n{\n\tv9fs_destroy_inode_cache();\n#ifdef CONFIG_9P_FSCACHE\n\tfscache_unregister_netfs(&v9fs_cache_netfs);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_sysfs_cleanup",
          "args": [],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_sysfs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "559-563",
          "snippet": "static void v9fs_sysfs_cleanup(void)\n{\n\tsysfs_remove_group(v9fs_kobj, &v9fs_attr_group);\n\tkobject_put(v9fs_kobj);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *v9fs_kobj;",
            "static struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct kobject *v9fs_kobj;\nstatic struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};\n\nstatic void v9fs_sysfs_cleanup(void)\n{\n\tsysfs_remove_group(v9fs_kobj, &v9fs_attr_group);\n\tkobject_put(v9fs_kobj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void __exit exit_v9fs(void)\n{\n\tv9fs_sysfs_cleanup();\n\tv9fs_cache_unregister();\n\tunregister_filesystem(&v9fs_fs_type);\n}"
  },
  {
    "function_name": "init_v9fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "633-665",
    "snippet": "static int __init init_v9fs(void)\n{\n\tint err;\n\tpr_info(\"Installing v9fs 9p2000 file system support\\n\");\n\t/* TODO: Setup list of registered trasnport modules */\n\n\terr = v9fs_cache_register();\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register v9fs for caching\\n\");\n\t\treturn err;\n\t}\n\n\terr = v9fs_sysfs_init();\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register with sysfs\\n\");\n\t\tgoto out_cache;\n\t}\n\terr = register_filesystem(&v9fs_fs_type);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register filesystem\\n\");\n\t\tgoto out_sysfs_cleanup;\n\t}\n\n\treturn 0;\n\nout_sysfs_cleanup:\n\tv9fs_sysfs_cleanup();\n\nout_cache:\n\tv9fs_cache_unregister();\n\n\treturn err;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_cache_unregister",
          "args": [],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "620-626",
          "snippet": "static void v9fs_cache_unregister(void)\n{\n\tv9fs_destroy_inode_cache();\n#ifdef CONFIG_9P_FSCACHE\n\tfscache_unregister_netfs(&v9fs_cache_netfs);\n#endif\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void v9fs_cache_unregister(void)\n{\n\tv9fs_destroy_inode_cache();\n#ifdef CONFIG_9P_FSCACHE\n\tfscache_unregister_netfs(&v9fs_cache_netfs);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_sysfs_cleanup",
          "args": [],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_sysfs_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "559-563",
          "snippet": "static void v9fs_sysfs_cleanup(void)\n{\n\tsysfs_remove_group(v9fs_kobj, &v9fs_attr_group);\n\tkobject_put(v9fs_kobj);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *v9fs_kobj;",
            "static struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct kobject *v9fs_kobj;\nstatic struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};\n\nstatic void v9fs_sysfs_cleanup(void)\n{\n\tsysfs_remove_group(v9fs_kobj, &v9fs_attr_group);\n\tkobject_put(v9fs_kobj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to register filesystem\\n\""
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&v9fs_fs_type"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to register with sysfs\\n\""
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_sysfs_init",
          "args": [],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_sysfs_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "540-552",
          "snippet": "static int __init v9fs_sysfs_init(void)\n{\n\tv9fs_kobj = kobject_create_and_add(\"9p\", fs_kobj);\n\tif (!v9fs_kobj)\n\t\treturn -ENOMEM;\n\n\tif (sysfs_create_group(v9fs_kobj, &v9fs_attr_group)) {\n\t\tkobject_put(v9fs_kobj);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kobject *v9fs_kobj;",
            "static struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct kobject *v9fs_kobj;\nstatic struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};\n\nstatic int __init v9fs_sysfs_init(void)\n{\n\tv9fs_kobj = kobject_create_and_add(\"9p\", fs_kobj);\n\tif (!v9fs_kobj)\n\t\treturn -ENOMEM;\n\n\tif (sysfs_create_group(v9fs_kobj, &v9fs_attr_group)) {\n\t\tkobject_put(v9fs_kobj);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to register v9fs for caching\\n\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_cache_register",
          "args": [],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "606-618",
          "snippet": "static int v9fs_cache_register(void)\n{\n\tint ret;\n\tret = v9fs_init_inode_cache();\n\tif (ret < 0)\n\t\treturn ret;\n#ifdef CONFIG_9P_FSCACHE\n\tret = fscache_register_netfs(&v9fs_cache_netfs);\n\tif (ret < 0)\n\t\tv9fs_destroy_inode_cache();\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_cache_register(void)\n{\n\tint ret;\n\tret = v9fs_init_inode_cache();\n\tif (ret < 0)\n\t\treturn ret;\n#ifdef CONFIG_9P_FSCACHE\n\tret = fscache_register_netfs(&v9fs_cache_netfs);\n\tif (ret < 0)\n\t\tv9fs_destroy_inode_cache();\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Installing v9fs 9p2000 file system support\\n\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int __init init_v9fs(void)\n{\n\tint err;\n\tpr_info(\"Installing v9fs 9p2000 file system support\\n\");\n\t/* TODO: Setup list of registered trasnport modules */\n\n\terr = v9fs_cache_register();\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register v9fs for caching\\n\");\n\t\treturn err;\n\t}\n\n\terr = v9fs_sysfs_init();\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register with sysfs\\n\");\n\t\tgoto out_cache;\n\t}\n\terr = register_filesystem(&v9fs_fs_type);\n\tif (err < 0) {\n\t\tpr_err(\"Failed to register filesystem\\n\");\n\t\tgoto out_sysfs_cleanup;\n\t}\n\n\treturn 0;\n\nout_sysfs_cleanup:\n\tv9fs_sysfs_cleanup();\n\nout_cache:\n\tv9fs_cache_unregister();\n\n\treturn err;\n}"
  },
  {
    "function_name": "v9fs_cache_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "620-626",
    "snippet": "static void v9fs_cache_unregister(void)\n{\n\tv9fs_destroy_inode_cache();\n#ifdef CONFIG_9P_FSCACHE\n\tfscache_unregister_netfs(&v9fs_cache_netfs);\n#endif\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscache_unregister_netfs",
          "args": [
            "&v9fs_cache_netfs"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_unregister_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "88-103",
          "snippet": "void __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid __fscache_unregister_netfs(struct fscache_netfs *netfs)\n{\n\t_enter(\"{%s.%u}\", netfs->name, netfs->version);\n\n\tdown_write(&fscache_addremove_sem);\n\n\tlist_del(&netfs->link);\n\tfscache_relinquish_cookie(netfs->primary_index, 0);\n\n\tup_write(&fscache_addremove_sem);\n\n\tpr_notice(\"Netfs '%s' unregistered from caching\\n\",\n\t\t  netfs->name);\n\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_destroy_inode_cache",
          "args": [],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_destroy_inode_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "596-604",
          "snippet": "static void v9fs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(v9fs_inode_cache);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *v9fs_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct kmem_cache *v9fs_inode_cache;\n\nstatic void v9fs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(v9fs_inode_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void v9fs_cache_unregister(void)\n{\n\tv9fs_destroy_inode_cache();\n#ifdef CONFIG_9P_FSCACHE\n\tfscache_unregister_netfs(&v9fs_cache_netfs);\n#endif\n}"
  },
  {
    "function_name": "v9fs_cache_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "606-618",
    "snippet": "static int v9fs_cache_register(void)\n{\n\tint ret;\n\tret = v9fs_init_inode_cache();\n\tif (ret < 0)\n\t\treturn ret;\n#ifdef CONFIG_9P_FSCACHE\n\tret = fscache_register_netfs(&v9fs_cache_netfs);\n\tif (ret < 0)\n\t\tv9fs_destroy_inode_cache();\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "v9fs_destroy_inode_cache",
          "args": [],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_destroy_inode_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "596-604",
          "snippet": "static void v9fs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(v9fs_inode_cache);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *v9fs_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct kmem_cache *v9fs_inode_cache;\n\nstatic void v9fs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(v9fs_inode_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscache_register_netfs",
          "args": [
            "&v9fs_cache_netfs"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "__fscache_register_netfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/netfs.c",
          "lines": "22-81",
          "snippet": "int __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fscache_netfs_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(fscache_netfs_list);\n\nint __fscache_register_netfs(struct fscache_netfs *netfs)\n{\n\tstruct fscache_netfs *ptr;\n\tint ret;\n\n\t_enter(\"{%s}\", netfs->name);\n\n\tINIT_LIST_HEAD(&netfs->link);\n\n\t/* allocate a cookie for the primary index */\n\tnetfs->primary_index =\n\t\tkmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);\n\n\tif (!netfs->primary_index) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/* initialise the primary index cookie */\n\tatomic_set(&netfs->primary_index->usage, 1);\n\tatomic_set(&netfs->primary_index->n_children, 0);\n\tatomic_set(&netfs->primary_index->n_active, 1);\n\n\tnetfs->primary_index->def\t\t= &fscache_fsdef_netfs_def;\n\tnetfs->primary_index->parent\t\t= &fscache_fsdef_index;\n\tnetfs->primary_index->netfs_data\t= netfs;\n\tnetfs->primary_index->flags\t\t= 1 << FSCACHE_COOKIE_ENABLED;\n\n\tatomic_inc(&netfs->primary_index->parent->usage);\n\tatomic_inc(&netfs->primary_index->parent->n_children);\n\n\tspin_lock_init(&netfs->primary_index->lock);\n\tINIT_HLIST_HEAD(&netfs->primary_index->backing_objects);\n\n\t/* check the netfs type is not already present */\n\tdown_write(&fscache_addremove_sem);\n\n\tret = -EEXIST;\n\tlist_for_each_entry(ptr, &fscache_netfs_list, link) {\n\t\tif (strcmp(ptr->name, netfs->name) == 0)\n\t\t\tgoto already_registered;\n\t}\n\n\tlist_add(&netfs->link, &fscache_netfs_list);\n\tret = 0;\n\n\tpr_notice(\"Netfs '%s' registered for caching\\n\", netfs->name);\n\nalready_registered:\n\tup_write(&fscache_addremove_sem);\n\n\tif (ret < 0) {\n\t\tnetfs->primary_index->parent = NULL;\n\t\t__fscache_cookie_put(netfs->primary_index);\n\t\tnetfs->primary_index = NULL;\n\t}\n\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_init_inode_cache",
          "args": [],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_init_inode_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "579-590",
          "snippet": "static int v9fs_init_inode_cache(void)\n{\n\tv9fs_inode_cache = kmem_cache_create(\"v9fs_inode_cache\",\n\t\t\t\t\t  sizeof(struct v9fs_inode),\n\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t      SLAB_MEM_SPREAD),\n\t\t\t\t\t  v9fs_inode_init_once);\n\tif (!v9fs_inode_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *v9fs_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct kmem_cache *v9fs_inode_cache;\n\nstatic int v9fs_init_inode_cache(void)\n{\n\tv9fs_inode_cache = kmem_cache_create(\"v9fs_inode_cache\",\n\t\t\t\t\t  sizeof(struct v9fs_inode),\n\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t      SLAB_MEM_SPREAD),\n\t\t\t\t\t  v9fs_inode_init_once);\n\tif (!v9fs_inode_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int v9fs_cache_register(void)\n{\n\tint ret;\n\tret = v9fs_init_inode_cache();\n\tif (ret < 0)\n\t\treturn ret;\n#ifdef CONFIG_9P_FSCACHE\n\tret = fscache_register_netfs(&v9fs_cache_netfs);\n\tif (ret < 0)\n\t\tv9fs_destroy_inode_cache();\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "v9fs_destroy_inode_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "596-604",
    "snippet": "static void v9fs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(v9fs_inode_cache);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *v9fs_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "v9fs_inode_cache"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_barrier",
          "args": [],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct kmem_cache *v9fs_inode_cache;\n\nstatic void v9fs_destroy_inode_cache(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tkmem_cache_destroy(v9fs_inode_cache);\n}"
  },
  {
    "function_name": "v9fs_init_inode_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "579-590",
    "snippet": "static int v9fs_init_inode_cache(void)\n{\n\tv9fs_inode_cache = kmem_cache_create(\"v9fs_inode_cache\",\n\t\t\t\t\t  sizeof(struct v9fs_inode),\n\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t      SLAB_MEM_SPREAD),\n\t\t\t\t\t  v9fs_inode_init_once);\n\tif (!v9fs_inode_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *v9fs_inode_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"v9fs_inode_cache\"",
            "sizeof(struct v9fs_inode)",
            "0",
            "(SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t      SLAB_MEM_SPREAD)",
            "v9fs_inode_init_once"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstruct kmem_cache *v9fs_inode_cache;\n\nstatic int v9fs_init_inode_cache(void)\n{\n\tv9fs_inode_cache = kmem_cache_create(\"v9fs_inode_cache\",\n\t\t\t\t\t  sizeof(struct v9fs_inode),\n\t\t\t\t\t  0, (SLAB_RECLAIM_ACCOUNT|\n\t\t\t\t\t      SLAB_MEM_SPREAD),\n\t\t\t\t\t  v9fs_inode_init_once);\n\tif (!v9fs_inode_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "v9fs_inode_init_once",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "565-573",
    "snippet": "static void v9fs_inode_init_once(void *foo)\n{\n\tstruct v9fs_inode *v9inode = (struct v9fs_inode *)foo;\n#ifdef CONFIG_9P_FSCACHE\n\tv9inode->fscache = NULL;\n#endif\n\tmemset(&v9inode->qid, 0, sizeof(v9inode->qid));\n\tinode_init_once(&v9inode->vfs_inode);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_init_once",
          "args": [
            "&v9inode->vfs_inode"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_inode_init_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "565-573",
          "snippet": "static void v9fs_inode_init_once(void *foo)\n{\n\tstruct v9fs_inode *v9inode = (struct v9fs_inode *)foo;\n#ifdef CONFIG_9P_FSCACHE\n\tv9inode->fscache = NULL;\n#endif\n\tmemset(&v9inode->qid, 0, sizeof(v9inode->qid));\n\tinode_init_once(&v9inode->vfs_inode);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&v9inode->qid",
            "0",
            "sizeof(v9inode->qid)"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic void v9fs_inode_init_once(void *foo)\n{\n\tstruct v9fs_inode *v9inode = (struct v9fs_inode *)foo;\n#ifdef CONFIG_9P_FSCACHE\n\tv9inode->fscache = NULL;\n#endif\n\tmemset(&v9inode->qid, 0, sizeof(v9inode->qid));\n\tinode_init_once(&v9inode->vfs_inode);\n}"
  },
  {
    "function_name": "v9fs_sysfs_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "559-563",
    "snippet": "static void v9fs_sysfs_cleanup(void)\n{\n\tsysfs_remove_group(v9fs_kobj, &v9fs_attr_group);\n\tkobject_put(v9fs_kobj);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *v9fs_kobj;",
      "static struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "v9fs_kobj"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_remove_group",
          "args": [
            "v9fs_kobj",
            "&v9fs_attr_group"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_remove_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "243-252",
          "snippet": "void sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nvoid sysfs_remove_groups(struct kobject *kobj,\n\t\t\t const struct attribute_group **groups)\n{\n\tint i;\n\n\tif (!groups)\n\t\treturn;\n\tfor (i = 0; groups[i]; i++)\n\t\tsysfs_remove_group(kobj, groups[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct kobject *v9fs_kobj;\nstatic struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};\n\nstatic void v9fs_sysfs_cleanup(void)\n{\n\tsysfs_remove_group(v9fs_kobj, &v9fs_attr_group);\n\tkobject_put(v9fs_kobj);\n}"
  },
  {
    "function_name": "v9fs_sysfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "540-552",
    "snippet": "static int __init v9fs_sysfs_init(void)\n{\n\tv9fs_kobj = kobject_create_and_add(\"9p\", fs_kobj);\n\tif (!v9fs_kobj)\n\t\treturn -ENOMEM;\n\n\tif (sysfs_create_group(v9fs_kobj, &v9fs_attr_group)) {\n\t\tkobject_put(v9fs_kobj);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kobject *v9fs_kobj;",
      "static struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kobject_put",
          "args": [
            "v9fs_kobj"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "v9fs_kobj",
            "&v9fs_attr_group"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "sysfs_create_groups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sysfs/group.c",
          "lines": "155-173",
          "snippet": "int sysfs_create_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\tint error = 0;\n\tint i;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = sysfs_create_group(kobj, groups[i]);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tsysfs_remove_group(kobj, groups[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include <linux/err.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/module.h>",
            "#include <linux/kobject.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include <linux/err.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/module.h>\n#include <linux/kobject.h>\n\nint sysfs_create_groups(struct kobject *kobj,\n\t\t\tconst struct attribute_group **groups)\n{\n\tint error = 0;\n\tint i;\n\n\tif (!groups)\n\t\treturn 0;\n\n\tfor (i = 0; groups[i]; i++) {\n\t\terror = sysfs_create_group(kobj, groups[i]);\n\t\tif (error) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tsysfs_remove_group(kobj, groups[i]);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"9p\"",
            "fs_kobj"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic struct kobject *v9fs_kobj;\nstatic struct attribute_group v9fs_attr_group = {\n\t.attrs = v9fs_attrs,\n};\n\nstatic int __init v9fs_sysfs_init(void)\n{\n\tv9fs_kobj = kobject_create_and_add(\"9p\", fs_kobj);\n\tif (!v9fs_kobj)\n\t\treturn -ENOMEM;\n\n\tif (sysfs_create_group(v9fs_kobj, &v9fs_attr_group)) {\n\t\tkobject_put(v9fs_kobj);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "caches_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "496-519",
    "snippet": "static ssize_t caches_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\tssize_t n = 0, count = 0, limit = PAGE_SIZE;\n\tstruct v9fs_session_info *v9ses;\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_for_each_entry(v9ses, &v9fs_sessionlist, slist) {\n\t\tif (v9ses->cachetag) {\n\t\t\tn = snprintf(buf, limit, \"%s\\n\", v9ses->cachetag);\n\t\t\tif (n < 0) {\n\t\t\t\tcount = n;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcount += n;\n\t\t\tlimit -= n;\n\t\t}\n\t}\n\n\tspin_unlock(&v9fs_sessionlist_lock);\n\treturn count;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(v9fs_sessionlist_lock);",
      "static LIST_HEAD(v9fs_sessionlist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&v9fs_sessionlist_lock"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "limit",
            "\"%s\\n\"",
            "v9ses->cachetag"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "v9ses",
            "&v9fs_sessionlist",
            "slist"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&v9fs_sessionlist_lock"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(v9fs_sessionlist_lock);\nstatic LIST_HEAD(v9fs_sessionlist);\n\nstatic ssize_t caches_show(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\tssize_t n = 0, count = 0, limit = PAGE_SIZE;\n\tstruct v9fs_session_info *v9ses;\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_for_each_entry(v9ses, &v9fs_sessionlist, slist) {\n\t\tif (v9ses->cachetag) {\n\t\t\tn = snprintf(buf, limit, \"%s\\n\", v9ses->cachetag);\n\t\t\tif (n < 0) {\n\t\t\t\tcount = n;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcount += n;\n\t\t\tlimit -= n;\n\t\t}\n\t}\n\n\tspin_unlock(&v9fs_sessionlist_lock);\n\treturn count;\n}"
  },
  {
    "function_name": "v9fs_session_begin_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "479-483",
    "snippet": "void v9fs_session_begin_cancel(struct v9fs_session_info *v9ses)\n{\n\tp9_debug(P9_DEBUG_ERROR, \"begin cancel session %p\\n\", v9ses);\n\tp9_client_begin_disconnect(v9ses->clnt);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_begin_disconnect",
          "args": [
            "v9ses->clnt"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"begin cancel session %p\\n\"",
            "v9ses"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_session_begin_cancel(struct v9fs_session_info *v9ses)\n{\n\tp9_debug(P9_DEBUG_ERROR, \"begin cancel session %p\\n\", v9ses);\n\tp9_client_begin_disconnect(v9ses->clnt);\n}"
  },
  {
    "function_name": "v9fs_session_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "467-470",
    "snippet": "void v9fs_session_cancel(struct v9fs_session_info *v9ses) {\n\tp9_debug(P9_DEBUG_ERROR, \"cancel session %p\\n\", v9ses);\n\tp9_client_disconnect(v9ses->clnt);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "p9_client_disconnect",
          "args": [
            "v9ses->clnt"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"cancel session %p\\n\"",
            "v9ses"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_session_cancel(struct v9fs_session_info *v9ses) {\n\tp9_debug(P9_DEBUG_ERROR, \"cancel session %p\\n\", v9ses);\n\tp9_client_disconnect(v9ses->clnt);\n}"
  },
  {
    "function_name": "v9fs_session_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "437-458",
    "snippet": "void v9fs_session_close(struct v9fs_session_info *v9ses)\n{\n\tif (v9ses->clnt) {\n\t\tp9_client_destroy(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t}\n\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->fscache) {\n\t\tv9fs_cache_session_put_cookie(v9ses);\n\t\tkfree(v9ses->cachetag);\n\t}\n#endif\n\tkfree(v9ses->uname);\n\tkfree(v9ses->aname);\n\n\tbdi_destroy(&v9ses->bdi);\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_del(&v9ses->slist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(v9fs_sessionlist_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&v9fs_sessionlist_lock"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&v9ses->slist"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&v9fs_sessionlist_lock"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&v9ses->bdi"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses->aname"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses->uname"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses->cachetag"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_cache_session_put_cookie",
          "args": [
            "v9ses"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_session_put_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "98-104",
          "snippet": "void v9fs_cache_session_put_cookie(struct v9fs_session_info *v9ses)\n{\n\tp9_debug(P9_DEBUG_FSC, \"session %p put cookie %p\\n\",\n\t\t v9ses, v9ses->fscache);\n\tfscache_relinquish_cookie(v9ses->fscache, 0);\n\tv9ses->fscache = NULL;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nvoid v9fs_cache_session_put_cookie(struct v9fs_session_info *v9ses)\n{\n\tp9_debug(P9_DEBUG_FSC, \"session %p put cookie %p\\n\",\n\t\t v9ses, v9ses->fscache);\n\tfscache_relinquish_cookie(v9ses->fscache, 0);\n\tv9ses->fscache = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_client_destroy",
          "args": [
            "v9ses->clnt"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(v9fs_sessionlist_lock);\n\nvoid v9fs_session_close(struct v9fs_session_info *v9ses)\n{\n\tif (v9ses->clnt) {\n\t\tp9_client_destroy(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t}\n\n#ifdef CONFIG_9P_FSCACHE\n\tif (v9ses->fscache) {\n\t\tv9fs_cache_session_put_cookie(v9ses);\n\t\tkfree(v9ses->cachetag);\n\t}\n#endif\n\tkfree(v9ses->uname);\n\tkfree(v9ses->aname);\n\n\tbdi_destroy(&v9ses->bdi);\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_del(&v9ses->slist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n}"
  },
  {
    "function_name": "v9fs_session_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "320-429",
    "snippet": "struct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,\n\t\t  const char *dev_name, char *data)\n{\n\tint retval = -EINVAL;\n\tstruct p9_fid *fid;\n\tint rc;\n\n\tv9ses->uname = kstrdup(V9FS_DEFUSER, GFP_KERNEL);\n\tif (!v9ses->uname)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tv9ses->aname = kstrdup(V9FS_DEFANAME, GFP_KERNEL);\n\tif (!v9ses->aname) {\n\t\tkfree(v9ses->uname);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinit_rwsem(&v9ses->rename_sem);\n\n\trc = bdi_setup_and_register(&v9ses->bdi, \"9p\");\n\tif (rc) {\n\t\tkfree(v9ses->aname);\n\t\tkfree(v9ses->uname);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_add(&v9ses->slist, &v9fs_sessionlist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n\n\tv9ses->uid = INVALID_UID;\n\tv9ses->dfltuid = V9FS_DEFUID;\n\tv9ses->dfltgid = V9FS_DEFGID;\n\n\tv9ses->clnt = p9_client_create(dev_name, data);\n\tif (IS_ERR(v9ses->clnt)) {\n\t\tretval = PTR_ERR(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t\tp9_debug(P9_DEBUG_ERROR, \"problem initializing 9p client\\n\");\n\t\tgoto error;\n\t}\n\n\tv9ses->flags = V9FS_ACCESS_USER;\n\n\tif (p9_is_proto_dotl(v9ses->clnt)) {\n\t\tv9ses->flags = V9FS_ACCESS_CLIENT;\n\t\tv9ses->flags |= V9FS_PROTO_2000L;\n\t} else if (p9_is_proto_dotu(v9ses->clnt)) {\n\t\tv9ses->flags |= V9FS_PROTO_2000U;\n\t}\n\n\trc = v9fs_parse_options(v9ses, data);\n\tif (rc < 0) {\n\t\tretval = rc;\n\t\tgoto error;\n\t}\n\n\tv9ses->maxdata = v9ses->clnt->msize - P9_IOHDRSZ;\n\n\tif (!v9fs_proto_dotl(v9ses) &&\n\t    ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t/*\n\t\t * We support ACCESS_CLIENT only for dotl.\n\t\t * Fall back to ACCESS_USER\n\t\t */\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t}\n\t/*FIXME !! */\n\t/* for legacy mode, fall back to V9FS_ACCESS_ANY */\n\tif (!(v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses)) &&\n\t\t((v9ses->flags&V9FS_ACCESS_MASK) == V9FS_ACCESS_USER)) {\n\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\tv9ses->uid = INVALID_UID;\n\t}\n\tif (!v9fs_proto_dotl(v9ses) ||\n\t\t!((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t/*\n\t\t * We support ACL checks on clinet only if the protocol is\n\t\t * 9P2000.L and access is V9FS_ACCESS_CLIENT.\n\t\t */\n\t\tv9ses->flags &= ~V9FS_ACL_MASK;\n\t}\n\n\tfid = p9_client_attach(v9ses->clnt, NULL, v9ses->uname, INVALID_UID,\n\t\t\t\t\t\t\tv9ses->aname);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\tfid = NULL;\n\t\tp9_debug(P9_DEBUG_ERROR, \"cannot attach\\n\");\n\t\tgoto error;\n\t}\n\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_SINGLE)\n\t\tfid->uid = v9ses->uid;\n\telse\n\t\tfid->uid = INVALID_UID;\n\n#ifdef CONFIG_9P_FSCACHE\n\t/* register the session for caching */\n\tv9fs_cache_session_get_cookie(v9ses);\n#endif\n\n\treturn fid;\n\nerror:\n\tbdi_destroy(&v9ses->bdi);\n\treturn ERR_PTR(retval);\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(v9fs_sessionlist_lock);",
      "static LIST_HEAD(v9fs_sessionlist);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_destroy",
          "args": [
            "&v9ses->bdi"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bdi_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "372-376",
          "snippet": "static void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic void fuse_bdi_destroy(struct fuse_conn *fc)\n{\n\tif (fc->bdi_initialized)\n\t\tbdi_destroy(&fc->bdi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_cache_session_get_cookie",
          "args": [
            "v9ses"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_cache_session_get_cookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/cache.c",
          "lines": "85-96",
          "snippet": "void v9fs_cache_session_get_cookie(struct v9fs_session_info *v9ses)\n{\n\t/* If no cache session tag was specified, we generate a random one. */\n\tif (!v9ses->cachetag)\n\t\tv9fs_random_cachetag(v9ses);\n\n\tv9ses->fscache = fscache_acquire_cookie(v9fs_cache_netfs.primary_index,\n\t\t\t\t\t\t&v9fs_cache_session_index_def,\n\t\t\t\t\t\tv9ses, true);\n\tp9_debug(P9_DEBUG_FSC, \"session %p get cookie %p\\n\",\n\t\t v9ses, v9ses->fscache);\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/9p.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/stat.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/jiffies.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct fscache_netfs v9fs_cache_netfs = {\n\t.name \t\t= \"9p\",\n\t.version \t= 0,\n};",
            "const struct fscache_cookie_def v9fs_cache_session_index_def = {\n\t.name\t\t= \"9P.session\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_INDEX,\n\t.get_key\t= v9fs_cache_session_get_key,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs.h\"\n#include <net/9p/9p.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/jiffies.h>\n\nstruct fscache_netfs v9fs_cache_netfs = {\n\t.name \t\t= \"9p\",\n\t.version \t= 0,\n};\nconst struct fscache_cookie_def v9fs_cache_session_index_def = {\n\t.name\t\t= \"9P.session\",\n\t.type\t\t= FSCACHE_COOKIE_TYPE_INDEX,\n\t.get_key\t= v9fs_cache_session_get_key,\n};\n\nvoid v9fs_cache_session_get_cookie(struct v9fs_session_info *v9ses)\n{\n\t/* If no cache session tag was specified, we generate a random one. */\n\tif (!v9ses->cachetag)\n\t\tv9fs_random_cachetag(v9ses);\n\n\tv9ses->fscache = fscache_acquire_cookie(v9fs_cache_netfs.primary_index,\n\t\t\t\t\t\t&v9fs_cache_session_index_def,\n\t\t\t\t\t\tv9ses, true);\n\tp9_debug(P9_DEBUG_FSC, \"session %p get cookie %p\\n\",\n\t\t v9ses, v9ses->fscache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"cannot attach\\n\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "fid"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "fid"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_attach",
          "args": [
            "v9ses->clnt",
            "NULL",
            "v9ses->uname",
            "INVALID_UID",
            "v9ses->aname"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotl",
          "args": [
            "v9ses"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "187-190",
          "snippet": "static inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotl(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000L;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_proto_dotu",
          "args": [
            "v9ses"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_proto_dotu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.h",
          "lines": "182-185",
          "snippet": "static inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}",
          "includes": [
            "#include <linux/backing-dev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/backing-dev.h>\n\nstatic inline int v9fs_proto_dotu(struct v9fs_session_info *v9ses)\n{\n\treturn v9ses->flags & V9FS_PROTO_2000U;\n}"
        }
      },
      {
        "call_info": {
          "callee": "v9fs_parse_options",
          "args": [
            "v9ses",
            "data"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "113-310",
          "snippet": "static int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)\n{\n\tchar *options, *tmp_options;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint option = 0;\n\tchar *s, *e;\n\tint ret = 0;\n\n\t/* setup defaults */\n\tv9ses->afid = ~0;\n\tv9ses->debug = 0;\n\tv9ses->cache = CACHE_NONE;\n#ifdef CONFIG_9P_FSCACHE\n\tv9ses->cachetag = NULL;\n#endif\n\n\tif (!opts)\n\t\treturn 0;\n\n\ttmp_options = kstrdup(opts, GFP_KERNEL);\n\tif (!tmp_options) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_option_alloc;\n\t}\n\toptions = tmp_options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, r;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_debug:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->debug = option;\n#ifdef CONFIG_NET_9P_DEBUG\n\t\t\tp9_debug_level = option;\n#endif\n\t\t\tbreak;\n\n\t\tcase Opt_dfltuid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(v9ses->dfltuid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"uid field, but not a uid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_dfltgid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(v9ses->dfltgid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"gid field, but not a gid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_afid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->afid = option;\n\t\t\tbreak;\n\t\tcase Opt_uname:\n\t\t\tkfree(v9ses->uname);\n\t\t\tv9ses->uname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->uname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_remotename:\n\t\t\tkfree(v9ses->aname);\n\t\t\tv9ses->aname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->aname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_nodevmap:\n\t\t\tv9ses->nodev = 1;\n\t\t\tbreak;\n\t\tcase Opt_cache_loose:\n\t\t\tv9ses->cache = CACHE_LOOSE;\n\t\t\tbreak;\n\t\tcase Opt_fscache:\n\t\t\tv9ses->cache = CACHE_FSCACHE;\n\t\t\tbreak;\n\t\tcase Opt_mmap:\n\t\t\tv9ses->cache = CACHE_MMAP;\n\t\t\tbreak;\n\t\tcase Opt_cachetag:\n#ifdef CONFIG_9P_FSCACHE\n\t\t\tv9ses->cachetag = match_strdup(&args[0]);\n#endif\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of cache arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tret = get_cache_mode(s);\n\t\t\tif (ret == -EINVAL) {\n\t\t\t\tkfree(s);\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->cache = ret;\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_access:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of access arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\t\tif (strcmp(s, \"user\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t\t\telse if (strcmp(s, \"any\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\t\telse if (strcmp(s, \"client\") == 0) {\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_CLIENT;\n\t\t\t} else {\n\t\t\t\tuid_t uid;\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_SINGLE;\n\t\t\t\tuid = simple_strtoul(s, &e, 10);\n\t\t\t\tif (*e != '\\0') {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Unknown access argument %s\\n\",\n\t\t\t\t\t\ts);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tgoto free_and_return;\n\t\t\t\t}\n\t\t\t\tv9ses->uid = make_kuid(current_user_ns(), uid);\n\t\t\t\tif (!uid_valid(v9ses->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Uknown uid %s\\n\", s);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tgoto free_and_return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_posixacl:\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\t\t\tv9ses->flags |= V9FS_POSIX_ACL;\n#else\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"Not defined CONFIG_9P_FS_POSIX_ACL. Ignoring posixacl option\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\nfree_and_return:\n\tkfree(tmp_options);\nfail_option_alloc:\n\treturn ret;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_debug, \"debug=%x\"},\n\t{Opt_dfltuid, \"dfltuid=%u\"},\n\t{Opt_dfltgid, \"dfltgid=%u\"},\n\t{Opt_afid, \"afid=%u\"},\n\t{Opt_uname, \"uname=%s\"},\n\t{Opt_remotename, \"aname=%s\"},\n\t{Opt_nodevmap, \"nodevmap\"},\n\t{Opt_cache, \"cache=%s\"},\n\t{Opt_cache_loose, \"loose\"},\n\t{Opt_fscache, \"fscache\"},\n\t{Opt_mmap, \"mmap\"},\n\t{Opt_cachetag, \"cachetag=%s\"},\n\t{Opt_access, \"access=%s\"},\n\t{Opt_posixacl, \"posixacl\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_debug, \"debug=%x\"},\n\t{Opt_dfltuid, \"dfltuid=%u\"},\n\t{Opt_dfltgid, \"dfltgid=%u\"},\n\t{Opt_afid, \"afid=%u\"},\n\t{Opt_uname, \"uname=%s\"},\n\t{Opt_remotename, \"aname=%s\"},\n\t{Opt_nodevmap, \"nodevmap\"},\n\t{Opt_cache, \"cache=%s\"},\n\t{Opt_cache_loose, \"loose\"},\n\t{Opt_fscache, \"fscache\"},\n\t{Opt_mmap, \"mmap\"},\n\t{Opt_cachetag, \"cachetag=%s\"},\n\t{Opt_access, \"access=%s\"},\n\t{Opt_posixacl, \"posixacl\"},\n\t{Opt_err, NULL}\n};\n\nstatic int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)\n{\n\tchar *options, *tmp_options;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint option = 0;\n\tchar *s, *e;\n\tint ret = 0;\n\n\t/* setup defaults */\n\tv9ses->afid = ~0;\n\tv9ses->debug = 0;\n\tv9ses->cache = CACHE_NONE;\n#ifdef CONFIG_9P_FSCACHE\n\tv9ses->cachetag = NULL;\n#endif\n\n\tif (!opts)\n\t\treturn 0;\n\n\ttmp_options = kstrdup(opts, GFP_KERNEL);\n\tif (!tmp_options) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_option_alloc;\n\t}\n\toptions = tmp_options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, r;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_debug:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->debug = option;\n#ifdef CONFIG_NET_9P_DEBUG\n\t\t\tp9_debug_level = option;\n#endif\n\t\t\tbreak;\n\n\t\tcase Opt_dfltuid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(v9ses->dfltuid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"uid field, but not a uid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_dfltgid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(v9ses->dfltgid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"gid field, but not a gid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_afid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->afid = option;\n\t\t\tbreak;\n\t\tcase Opt_uname:\n\t\t\tkfree(v9ses->uname);\n\t\t\tv9ses->uname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->uname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_remotename:\n\t\t\tkfree(v9ses->aname);\n\t\t\tv9ses->aname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->aname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_nodevmap:\n\t\t\tv9ses->nodev = 1;\n\t\t\tbreak;\n\t\tcase Opt_cache_loose:\n\t\t\tv9ses->cache = CACHE_LOOSE;\n\t\t\tbreak;\n\t\tcase Opt_fscache:\n\t\t\tv9ses->cache = CACHE_FSCACHE;\n\t\t\tbreak;\n\t\tcase Opt_mmap:\n\t\t\tv9ses->cache = CACHE_MMAP;\n\t\t\tbreak;\n\t\tcase Opt_cachetag:\n#ifdef CONFIG_9P_FSCACHE\n\t\t\tv9ses->cachetag = match_strdup(&args[0]);\n#endif\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of cache arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tret = get_cache_mode(s);\n\t\t\tif (ret == -EINVAL) {\n\t\t\t\tkfree(s);\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->cache = ret;\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_access:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of access arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\t\tif (strcmp(s, \"user\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t\t\telse if (strcmp(s, \"any\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\t\telse if (strcmp(s, \"client\") == 0) {\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_CLIENT;\n\t\t\t} else {\n\t\t\t\tuid_t uid;\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_SINGLE;\n\t\t\t\tuid = simple_strtoul(s, &e, 10);\n\t\t\t\tif (*e != '\\0') {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Unknown access argument %s\\n\",\n\t\t\t\t\t\ts);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tgoto free_and_return;\n\t\t\t\t}\n\t\t\t\tv9ses->uid = make_kuid(current_user_ns(), uid);\n\t\t\t\tif (!uid_valid(v9ses->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Uknown uid %s\\n\", s);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tgoto free_and_return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_posixacl:\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\t\t\tv9ses->flags |= V9FS_POSIX_ACL;\n#else\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"Not defined CONFIG_9P_FS_POSIX_ACL. Ignoring posixacl option\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\nfree_and_return:\n\tkfree(tmp_options);\nfail_option_alloc:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_is_proto_dotu",
          "args": [
            "v9ses->clnt"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_is_proto_dotl",
          "args": [
            "v9ses->clnt"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"problem initializing 9p client\\n\""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "v9ses->clnt"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "v9ses->clnt"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_client_create",
          "args": [
            "dev_name",
            "data"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&v9fs_sessionlist_lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&v9ses->slist",
            "&v9fs_sessionlist"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&v9fs_sessionlist_lock"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses->uname"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses->aname"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdi_setup_and_register",
          "args": [
            "&v9ses->bdi",
            "\"9p\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&v9ses->rename_sem"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses->uname"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "V9FS_DEFANAME",
            "GFP_KERNEL"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "V9FS_DEFUSER",
            "GFP_KERNEL"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic DEFINE_SPINLOCK(v9fs_sessionlist_lock);\nstatic LIST_HEAD(v9fs_sessionlist);\n\nstruct p9_fid *v9fs_session_init(struct v9fs_session_info *v9ses,\n\t\t  const char *dev_name, char *data)\n{\n\tint retval = -EINVAL;\n\tstruct p9_fid *fid;\n\tint rc;\n\n\tv9ses->uname = kstrdup(V9FS_DEFUSER, GFP_KERNEL);\n\tif (!v9ses->uname)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tv9ses->aname = kstrdup(V9FS_DEFANAME, GFP_KERNEL);\n\tif (!v9ses->aname) {\n\t\tkfree(v9ses->uname);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tinit_rwsem(&v9ses->rename_sem);\n\n\trc = bdi_setup_and_register(&v9ses->bdi, \"9p\");\n\tif (rc) {\n\t\tkfree(v9ses->aname);\n\t\tkfree(v9ses->uname);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tspin_lock(&v9fs_sessionlist_lock);\n\tlist_add(&v9ses->slist, &v9fs_sessionlist);\n\tspin_unlock(&v9fs_sessionlist_lock);\n\n\tv9ses->uid = INVALID_UID;\n\tv9ses->dfltuid = V9FS_DEFUID;\n\tv9ses->dfltgid = V9FS_DEFGID;\n\n\tv9ses->clnt = p9_client_create(dev_name, data);\n\tif (IS_ERR(v9ses->clnt)) {\n\t\tretval = PTR_ERR(v9ses->clnt);\n\t\tv9ses->clnt = NULL;\n\t\tp9_debug(P9_DEBUG_ERROR, \"problem initializing 9p client\\n\");\n\t\tgoto error;\n\t}\n\n\tv9ses->flags = V9FS_ACCESS_USER;\n\n\tif (p9_is_proto_dotl(v9ses->clnt)) {\n\t\tv9ses->flags = V9FS_ACCESS_CLIENT;\n\t\tv9ses->flags |= V9FS_PROTO_2000L;\n\t} else if (p9_is_proto_dotu(v9ses->clnt)) {\n\t\tv9ses->flags |= V9FS_PROTO_2000U;\n\t}\n\n\trc = v9fs_parse_options(v9ses, data);\n\tif (rc < 0) {\n\t\tretval = rc;\n\t\tgoto error;\n\t}\n\n\tv9ses->maxdata = v9ses->clnt->msize - P9_IOHDRSZ;\n\n\tif (!v9fs_proto_dotl(v9ses) &&\n\t    ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t/*\n\t\t * We support ACCESS_CLIENT only for dotl.\n\t\t * Fall back to ACCESS_USER\n\t\t */\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t}\n\t/*FIXME !! */\n\t/* for legacy mode, fall back to V9FS_ACCESS_ANY */\n\tif (!(v9fs_proto_dotu(v9ses) || v9fs_proto_dotl(v9ses)) &&\n\t\t((v9ses->flags&V9FS_ACCESS_MASK) == V9FS_ACCESS_USER)) {\n\n\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\tv9ses->uid = INVALID_UID;\n\t}\n\tif (!v9fs_proto_dotl(v9ses) ||\n\t\t!((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_CLIENT)) {\n\t\t/*\n\t\t * We support ACL checks on clinet only if the protocol is\n\t\t * 9P2000.L and access is V9FS_ACCESS_CLIENT.\n\t\t */\n\t\tv9ses->flags &= ~V9FS_ACL_MASK;\n\t}\n\n\tfid = p9_client_attach(v9ses->clnt, NULL, v9ses->uname, INVALID_UID,\n\t\t\t\t\t\t\tv9ses->aname);\n\tif (IS_ERR(fid)) {\n\t\tretval = PTR_ERR(fid);\n\t\tfid = NULL;\n\t\tp9_debug(P9_DEBUG_ERROR, \"cannot attach\\n\");\n\t\tgoto error;\n\t}\n\n\tif ((v9ses->flags & V9FS_ACCESS_MASK) == V9FS_ACCESS_SINGLE)\n\t\tfid->uid = v9ses->uid;\n\telse\n\t\tfid->uid = INVALID_UID;\n\n#ifdef CONFIG_9P_FSCACHE\n\t/* register the session for caching */\n\tv9fs_cache_session_get_cookie(v9ses);\n#endif\n\n\treturn fid;\n\nerror:\n\tbdi_destroy(&v9ses->bdi);\n\treturn ERR_PTR(retval);\n}"
  },
  {
    "function_name": "v9fs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "113-310",
    "snippet": "static int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)\n{\n\tchar *options, *tmp_options;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint option = 0;\n\tchar *s, *e;\n\tint ret = 0;\n\n\t/* setup defaults */\n\tv9ses->afid = ~0;\n\tv9ses->debug = 0;\n\tv9ses->cache = CACHE_NONE;\n#ifdef CONFIG_9P_FSCACHE\n\tv9ses->cachetag = NULL;\n#endif\n\n\tif (!opts)\n\t\treturn 0;\n\n\ttmp_options = kstrdup(opts, GFP_KERNEL);\n\tif (!tmp_options) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_option_alloc;\n\t}\n\toptions = tmp_options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, r;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_debug:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->debug = option;\n#ifdef CONFIG_NET_9P_DEBUG\n\t\t\tp9_debug_level = option;\n#endif\n\t\t\tbreak;\n\n\t\tcase Opt_dfltuid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(v9ses->dfltuid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"uid field, but not a uid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_dfltgid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(v9ses->dfltgid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"gid field, but not a gid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_afid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->afid = option;\n\t\t\tbreak;\n\t\tcase Opt_uname:\n\t\t\tkfree(v9ses->uname);\n\t\t\tv9ses->uname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->uname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_remotename:\n\t\t\tkfree(v9ses->aname);\n\t\t\tv9ses->aname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->aname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_nodevmap:\n\t\t\tv9ses->nodev = 1;\n\t\t\tbreak;\n\t\tcase Opt_cache_loose:\n\t\t\tv9ses->cache = CACHE_LOOSE;\n\t\t\tbreak;\n\t\tcase Opt_fscache:\n\t\t\tv9ses->cache = CACHE_FSCACHE;\n\t\t\tbreak;\n\t\tcase Opt_mmap:\n\t\t\tv9ses->cache = CACHE_MMAP;\n\t\t\tbreak;\n\t\tcase Opt_cachetag:\n#ifdef CONFIG_9P_FSCACHE\n\t\t\tv9ses->cachetag = match_strdup(&args[0]);\n#endif\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of cache arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tret = get_cache_mode(s);\n\t\t\tif (ret == -EINVAL) {\n\t\t\t\tkfree(s);\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->cache = ret;\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_access:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of access arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\t\tif (strcmp(s, \"user\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t\t\telse if (strcmp(s, \"any\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\t\telse if (strcmp(s, \"client\") == 0) {\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_CLIENT;\n\t\t\t} else {\n\t\t\t\tuid_t uid;\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_SINGLE;\n\t\t\t\tuid = simple_strtoul(s, &e, 10);\n\t\t\t\tif (*e != '\\0') {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Unknown access argument %s\\n\",\n\t\t\t\t\t\ts);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tgoto free_and_return;\n\t\t\t\t}\n\t\t\t\tv9ses->uid = make_kuid(current_user_ns(), uid);\n\t\t\t\tif (!uid_valid(v9ses->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Uknown uid %s\\n\", s);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tgoto free_and_return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_posixacl:\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\t\t\tv9ses->flags |= V9FS_POSIX_ACL;\n#else\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"Not defined CONFIG_9P_FS_POSIX_ACL. Ignoring posixacl option\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\nfree_and_return:\n\tkfree(tmp_options);\nfail_option_alloc:\n\treturn ret;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_debug, \"debug=%x\"},\n\t{Opt_dfltuid, \"dfltuid=%u\"},\n\t{Opt_dfltgid, \"dfltgid=%u\"},\n\t{Opt_afid, \"afid=%u\"},\n\t{Opt_uname, \"uname=%s\"},\n\t{Opt_remotename, \"aname=%s\"},\n\t{Opt_nodevmap, \"nodevmap\"},\n\t{Opt_cache, \"cache=%s\"},\n\t{Opt_cache_loose, \"loose\"},\n\t{Opt_fscache, \"fscache\"},\n\t{Opt_mmap, \"mmap\"},\n\t{Opt_cachetag, \"cachetag=%s\"},\n\t{Opt_access, \"access=%s\"},\n\t{Opt_posixacl, \"posixacl\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tmp_options"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"Not defined CONFIG_9P_FS_POSIX_ACL. Ignoring posixacl option\\n\""
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Uknown uid %s\\n\"",
            "s"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "v9ses->uid"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "uid"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unknown access argument %s\\n\"",
            "s"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "s",
            "&e",
            "10"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"client\""
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"problem allocating copy of access arg\\n\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cache_mode",
          "args": [
            "s"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "get_cache_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
          "lines": "85-104",
          "snippet": "static int get_cache_mode(char *s)\n{\n\tint version = -EINVAL;\n\n\tif (!strcmp(s, \"loose\")) {\n\t\tversion = CACHE_LOOSE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: loose\\n\");\n\t} else if (!strcmp(s, \"fscache\")) {\n\t\tversion = CACHE_FSCACHE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: fscache\\n\");\n\t} else if (!strcmp(s, \"mmap\")) {\n\t\tversion = CACHE_MMAP;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: mmap\\n\");\n\t} else if (!strcmp(s, \"none\")) {\n\t\tversion = CACHE_NONE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: none\\n\");\n\t} else\n\t\tpr_info(\"Unknown Cache mode %s\\n\", s);\n\treturn version;\n}",
          "includes": [
            "#include \"cache.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/transport.h>",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/slab.h>",
            "#include <linux/idr.h>",
            "#include <linux/parser.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int get_cache_mode(char *s)\n{\n\tint version = -EINVAL;\n\n\tif (!strcmp(s, \"loose\")) {\n\t\tversion = CACHE_LOOSE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: loose\\n\");\n\t} else if (!strcmp(s, \"fscache\")) {\n\t\tversion = CACHE_FSCACHE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: fscache\\n\");\n\t} else if (!strcmp(s, \"mmap\")) {\n\t\tversion = CACHE_MMAP;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: mmap\\n\");\n\t} else if (!strcmp(s, \"none\")) {\n\t\tversion = CACHE_NONE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: none\\n\");\n\t} else\n\t\tpr_info(\"Unknown Cache mode %s\\n\", s);\n\treturn version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"problem allocating copy of cache arg\\n\""
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses->aname"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "v9ses->uname"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"integer field, but no integer?\\n\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"gid field, but not a gid?\\n\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "v9ses->dfltgid"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"integer field, but no integer?\\n\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"uid field, but not a uid?\\n\""
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"integer field, but no integer?\\n\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_ERROR",
            "\"integer field, but no integer?\\n\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "opts",
            "GFP_KERNEL"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_debug, \"debug=%x\"},\n\t{Opt_dfltuid, \"dfltuid=%u\"},\n\t{Opt_dfltgid, \"dfltgid=%u\"},\n\t{Opt_afid, \"afid=%u\"},\n\t{Opt_uname, \"uname=%s\"},\n\t{Opt_remotename, \"aname=%s\"},\n\t{Opt_nodevmap, \"nodevmap\"},\n\t{Opt_cache, \"cache=%s\"},\n\t{Opt_cache_loose, \"loose\"},\n\t{Opt_fscache, \"fscache\"},\n\t{Opt_mmap, \"mmap\"},\n\t{Opt_cachetag, \"cachetag=%s\"},\n\t{Opt_access, \"access=%s\"},\n\t{Opt_posixacl, \"posixacl\"},\n\t{Opt_err, NULL}\n};\n\nstatic int v9fs_parse_options(struct v9fs_session_info *v9ses, char *opts)\n{\n\tchar *options, *tmp_options;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p;\n\tint option = 0;\n\tchar *s, *e;\n\tint ret = 0;\n\n\t/* setup defaults */\n\tv9ses->afid = ~0;\n\tv9ses->debug = 0;\n\tv9ses->cache = CACHE_NONE;\n#ifdef CONFIG_9P_FSCACHE\n\tv9ses->cachetag = NULL;\n#endif\n\n\tif (!opts)\n\t\treturn 0;\n\n\ttmp_options = kstrdup(opts, GFP_KERNEL);\n\tif (!tmp_options) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_option_alloc;\n\t}\n\toptions = tmp_options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token, r;\n\t\tif (!*p)\n\t\t\tcontinue;\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_debug:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->debug = option;\n#ifdef CONFIG_NET_9P_DEBUG\n\t\t\tp9_debug_level = option;\n#endif\n\t\t\tbreak;\n\n\t\tcase Opt_dfltuid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltuid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(v9ses->dfltuid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"uid field, but not a uid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_dfltgid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->dfltgid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(v9ses->dfltgid)) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"gid field, but not a gid?\\n\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_afid:\n\t\t\tr = match_int(&args[0], &option);\n\t\t\tif (r < 0) {\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"integer field, but no integer?\\n\");\n\t\t\t\tret = r;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tv9ses->afid = option;\n\t\t\tbreak;\n\t\tcase Opt_uname:\n\t\t\tkfree(v9ses->uname);\n\t\t\tv9ses->uname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->uname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_remotename:\n\t\t\tkfree(v9ses->aname);\n\t\t\tv9ses->aname = match_strdup(&args[0]);\n\t\t\tif (!v9ses->aname) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_nodevmap:\n\t\t\tv9ses->nodev = 1;\n\t\t\tbreak;\n\t\tcase Opt_cache_loose:\n\t\t\tv9ses->cache = CACHE_LOOSE;\n\t\t\tbreak;\n\t\tcase Opt_fscache:\n\t\t\tv9ses->cache = CACHE_FSCACHE;\n\t\t\tbreak;\n\t\tcase Opt_mmap:\n\t\t\tv9ses->cache = CACHE_MMAP;\n\t\t\tbreak;\n\t\tcase Opt_cachetag:\n#ifdef CONFIG_9P_FSCACHE\n\t\t\tv9ses->cachetag = match_strdup(&args[0]);\n#endif\n\t\t\tbreak;\n\t\tcase Opt_cache:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of cache arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\t\t\tret = get_cache_mode(s);\n\t\t\tif (ret == -EINVAL) {\n\t\t\t\tkfree(s);\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->cache = ret;\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_access:\n\t\t\ts = match_strdup(&args[0]);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t\t \"problem allocating copy of access arg\\n\");\n\t\t\t\tgoto free_and_return;\n\t\t\t}\n\n\t\t\tv9ses->flags &= ~V9FS_ACCESS_MASK;\n\t\t\tif (strcmp(s, \"user\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_USER;\n\t\t\telse if (strcmp(s, \"any\") == 0)\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_ANY;\n\t\t\telse if (strcmp(s, \"client\") == 0) {\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_CLIENT;\n\t\t\t} else {\n\t\t\t\tuid_t uid;\n\t\t\t\tv9ses->flags |= V9FS_ACCESS_SINGLE;\n\t\t\t\tuid = simple_strtoul(s, &e, 10);\n\t\t\t\tif (*e != '\\0') {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Unknown access argument %s\\n\",\n\t\t\t\t\t\ts);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tgoto free_and_return;\n\t\t\t\t}\n\t\t\t\tv9ses->uid = make_kuid(current_user_ns(), uid);\n\t\t\t\tif (!uid_valid(v9ses->uid)) {\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tpr_info(\"Uknown uid %s\\n\", s);\n\t\t\t\t\tkfree(s);\n\t\t\t\t\tgoto free_and_return;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tkfree(s);\n\t\t\tbreak;\n\n\t\tcase Opt_posixacl:\n#ifdef CONFIG_9P_FS_POSIX_ACL\n\t\t\tv9ses->flags |= V9FS_POSIX_ACL;\n#else\n\t\t\tp9_debug(P9_DEBUG_ERROR,\n\t\t\t\t \"Not defined CONFIG_9P_FS_POSIX_ACL. Ignoring posixacl option\\n\");\n#endif\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t}\n\nfree_and_return:\n\tkfree(tmp_options);\nfail_option_alloc:\n\treturn ret;\n}"
  },
  {
    "function_name": "get_cache_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/v9fs.c",
    "lines": "85-104",
    "snippet": "static int get_cache_mode(char *s)\n{\n\tint version = -EINVAL;\n\n\tif (!strcmp(s, \"loose\")) {\n\t\tversion = CACHE_LOOSE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: loose\\n\");\n\t} else if (!strcmp(s, \"fscache\")) {\n\t\tversion = CACHE_FSCACHE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: fscache\\n\");\n\t} else if (!strcmp(s, \"mmap\")) {\n\t\tversion = CACHE_MMAP;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: mmap\\n\");\n\t} else if (!strcmp(s, \"none\")) {\n\t\tversion = CACHE_NONE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: none\\n\");\n\t} else\n\t\tpr_info(\"Unknown Cache mode %s\\n\", s);\n\treturn version;\n}",
    "includes": [
      "#include \"cache.h\"",
      "#include \"v9fs_vfs.h\"",
      "#include \"v9fs.h\"",
      "#include <net/9p/transport.h>",
      "#include <net/9p/client.h>",
      "#include <net/9p/9p.h>",
      "#include <linux/slab.h>",
      "#include <linux/idr.h>",
      "#include <linux/parser.h>",
      "#include <linux/sched.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Unknown Cache mode %s\\n\"",
            "s"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_9P",
            "\"Cache mode: none\\n\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s",
            "\"none\""
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_prefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "667-675",
          "snippet": "static const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic const char *\nstrcmp_prefix(const char *a, const char *a_prefix)\n{\n\twhile (*a_prefix && *a == *a_prefix) {\n\t\ta++;\n\t\ta_prefix++;\n\t}\n\treturn *a_prefix ? NULL : a;\n}"
        }
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_9P",
            "\"Cache mode: mmap\\n\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_9P",
            "\"Cache mode: fscache\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "p9_debug",
          "args": [
            "P9_DEBUG_9P",
            "\"Cache mode: loose\\n\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cache.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/transport.h>\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/slab.h>\n#include <linux/idr.h>\n#include <linux/parser.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nstatic int get_cache_mode(char *s)\n{\n\tint version = -EINVAL;\n\n\tif (!strcmp(s, \"loose\")) {\n\t\tversion = CACHE_LOOSE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: loose\\n\");\n\t} else if (!strcmp(s, \"fscache\")) {\n\t\tversion = CACHE_FSCACHE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: fscache\\n\");\n\t} else if (!strcmp(s, \"mmap\")) {\n\t\tversion = CACHE_MMAP;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: mmap\\n\");\n\t} else if (!strcmp(s, \"none\")) {\n\t\tversion = CACHE_NONE;\n\t\tp9_debug(P9_DEBUG_9P, \"Cache mode: none\\n\");\n\t} else\n\t\tpr_info(\"Unknown Cache mode %s\\n\", s);\n\treturn version;\n}"
  }
]